// Programa...: BlEstF
// Autor......: Robert Koch
// Data.......: 29/10/2023
// Descricao..: Interface para solicitar bloqueio/desbloqueio de lotes com FullWMS
//
// Historico de alteracoes:
//

// Se a funcao chamadora quiser me passar itens a processar, deve estar neste mesmo formato.
#XTranslate .BFWIdOper     => 1
#XTranslate .BFWAlmox      => 2
#XTranslate .BFWProduto    => 3
#XTranslate .BFWLote       => 4
#XTranslate .BFWEndereco   => 5
#XTranslate .BFWQuantidade => 6
#XTranslate .BFWOperacao   => 7
#XTranslate .BFWResultado  => 8
#XTranslate .BFWObs        => 9
#XTranslate .BFWStatusFull => 10
#XTranslate .BFWQtColunbas => 10
// 1 - Almoxarifado
// 2 - Codigo produto
// 3 - Lote
// 4 - Endereco (do FullWMS)
// 5 - Quantidade
// 6 - Operacao: [B]loquear ou [L]iberar
// 7 - Para retorno da funcao: .T.=executou com exito; .F.=nao executou
// 8 - Para retorno da funcao: Observacoes/Descritivo de possiveis erros.
// 9 - Retorno do campo 'status' do FullWMS

// --------------------------------------------------------------------------
User Function BlEstF (_oParmSolBloq as json)
	local _lContinua  := .T.
	local _nLock      := 0
	local _lTelaParaSelecao := .F.
	local _aAreaAnt   := U_ML_SRArea ()
	private _oListaSolBloq := JsonObject():New()
	private _sLinkSrv := ''
	
	if cEmpAnt + cFilAnt != '0101'
		u_help ("Esta rotina nao se aplica a esta empresa/filial.",, .t.)
		_lContinua = .F.
	endif

	if _lContinua
		_sLinkSrv = U_LkServer ('FULLWMS_AX01')
		if empty (_sLinkSrv)
			u_help ("Linked server para o FullWMS nao definido. Impossivel continuar.",, .t.)
			_lContinua = .F.
		endif
	endif

	// Inicialmente vou usar controle de semaforo, pois preciso ter identificadores
	// unicos, bem como quero ficar aguardando o retorno do FullWMS. Depois veremos
	// como se comporta...
	if _lContinua
		_nLock := U_Semaforo ("ZBH" + cEmpAnt + cFilAnt)
		if _nLock == 0
			u_help ("Nao foi possivel obter acesso exclusivo a esta rotina nesta empresa/filial.")
			_lContinua = .F.
		endif
	endif

	// Se nao recebi uma array com itens, abro tela para o usuario selecionar.
	if _lContinua
		_lTelaParaSelecao = .F.
		if valtype (_oParmSolBloq) != 'U'
			if valtype (_oParmSolBloq) != 'J'
				u_help ("Parametro com itens a bloquear/desbloquear deve ser do tipo JSON",, .t.)
				_lContinua = .F.
			endif
		else
			_lTelaParaSelecao = .T.
		endif

		if _lTelaParaSelecao
			if aviso ("Bloqueio/desbloqueio", "Selecione o que deseja fazer", {"Bloquear", "Desbloquear"}, 3, "Selecione acao") == 1
				//_lContinua = _Bloq ()
				u_help ("falta fazer!",, .t.)
			else
				//_lContinua = _Desbloq ()
				u_help ("falta fazer!",, .t.)
			endif
		else
			_lContinua = _Executa (_oParmSolBloq)
		endif
	endif

	// Libera semaforo
	U_Semaforo (_nLock)

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Processa a array de itens
static function _Executa (_oListaSolBloq as json)
	local _lContinua := .T.
//	local _nItem     := 0
	local _oSQL      := NIL
	local _aSldFull  := {}
	local _sIdOper   := ''
	local _nSolBloq  := 0
	local _oSolBloq  := NIL
	local _sErros := ''

	U_Log2 ('debug', '[' + procname () + ']' + _oListaSolBloq:toJson ())

	// Validacoes antes de enviar ao FullWMS.
	_sErros = ''

	// Vou partir de um primeiro ID e apenas incrementar para todos os itens.
	// Como estou trabalhando com semaforo, nao deve ocorrer situacao de outra
	// sessao usando os mesmos IDs.
	_sIdOper = _GeraID ()
	
	sb1 -> (dbsetorder (1))
	for _nSolBloq = 1 to len (_oListaSolBloq)

		// Ateh prova em contrario, todas as solicitacoes podem ser enviadas.
		_oListaSolBloq [_nSolBloq]['PodeEnviar'] = .T.

		// Preenche um ID para cada solicitacao
		_oListaSolBloq [_nSolBloq]['IdOper'] = _sIdOper
		_sIdOper = soma1 (_sIdOper)

		// Instancia uma solicitacao da lista, para analisar seus dados.
		_oSolBloq := _oListaSolBloq [_nSolBloq]
		U_Log2 ('debug', '[' + procname () + ']Analisando: ' + _oSolBloq:toJson ())

		if _oSolBloq ['Almox'] != '01'
			_oSolBloq ['PodeEnviar'] = .F.
			_oSolBloq ['Obs'] += 'Esta rotina gera bloqueio apenas para o almoxarifado 01."
		endif
		if ! sb1 -> (dbseek (xfilial ("SB1") + _oSolBloq ['Produto'], .f.))
			_oSolBloq ['PodeEnviar'] = .F.
			_oSolBloq ['Obs'] += 'Cadastro do produto nao localizado!'
		endif
		if sb1 -> b1_rastro != 'L'
			_oSolBloq ['PodeEnviar'] = .F.
			_oSolBloq ['Obs'] += 'Produto nao usa controle de lotes no Protheus.'
		endif
		if sb1 -> b1_vafullw != 'S'
			_oSolBloq ['PodeEnviar'] = .F.
			_oSolBloq ['Obs'] += "Produto nao eh controlado pelo FullWMS."
		endif
		if empty (_oSolBloq ['Lote'])
			_oSolBloq ['PodeEnviar'] = .F.
			_oSolBloq ['Obs'] += "Lote deve ser informado."
		endif
		if empty (_oSolBloq ['Endereco'])
			_oSolBloq ['PodeEnviar'] = .F.
			_oSolBloq ['Obs'] += "Endereco (do FullWMS) deve ser informado."
		endif

		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "select QTD, SITUACAO_LOTE"
		_oSQL:_sQuery += " FROM openquery (" + _sLinkSrv + ","
		_oSQL:_sQuery += " 'select QTD, SITUACAO_LOTE"
		_oSQL:_sQuery +=    " from v_alianca_estoques"
		_oSQL:_sQuery +=   " where empr_codemp       = 1"
		_oSQL:_sQuery +=     " and item_cod_item_log = ''" + alltrim (_oSolBloq ['Produto']) + "''"
		_oSQL:_sQuery +=     " and lote              = ''" + alltrim (_oSolBloq ['Lote']) + "''"
		_oSQL:_sQuery +=     " and endereco          = ''" + alltrim (_oSolBloq ['Endereco'])  + "''"
		_oSQL:_sQuery += " ')"
	//	_oSQL:Log ('[' + procname () + ']')
		_aSldFull := aclone (_oSQL:Qry2Array (.f., .f.))
	//	U_Log2 ('debug', _aSldFull)
		if len (_aSldFull) == 0
			_oSolBloq ['PodeEnviar'] = .F.
			_oSolBloq ['Obs'] += "Lote '" + alltrim (_oSolBloq ['Lote']) + "' / endereco '" + alltrim (_oSolBloq ['Endereco']) + "' nao localizado no FullWMS."
		endif
		if _aSldFull [1, 1] != _oSolBloq ['Quantidade']
			_oSolBloq ['PodeEnviar'] = .F.
			_oSolBloq ['Obs'] += "Saldo do endereco no FullWMS = " + cvaltochar (_aSldFull [1, 1]) + ". Voce deve informar a mesma quantidade, pois o FullWMS nao faz bloqueio parcial de enderecos."
		endif
		if _oSolBloq ['Operacao'] == 'B' .and. left (_aSldFull [1, 2], 1) == 'B'
			_oSolBloq ['PodeEnviar'] = .F.
			_oSolBloq ['Obs'] += "Endereco ja se encontra bloqueado no FullWMS."
		endif
		if _oSolBloq ['Operacao'] == 'L' .and. left (_aSldFull [1, 2], 1) == 'L'
			_oSolBloq ['PodeEnviar'] = .F.
			_oSolBloq ['Obs'] += "Endereco ja se encontra liberado no FullWMS."
		endif

		if ! _oSolBloq ['PodeEnviar']
			_sErros += "Linha " + cvaltochar (_nSolBloq) + " produto " + alltrim (_oSolBloq ['Produto']) + ": " + _oSolBloq ['Obs'] + '; '
		endif

		// DURANTE O DESENVOLVIMENTO, PARA AJUDAR NO DEBUG
		IF ! _oSolBloq ['PodeEnviar']
			_oSQL:Log ('[' + procname () + ']')
			U_Log2 ('debug', _aSldFull)
		ENDIF
	next

	U_Log2 ('debug', '[' + procname () + ']Apos analise:' + _oListaSolBloq:toJson ())

	// Qualquer item com aviso de erro invalida todos os demais.
	if ! empty (_sErros)
		u_help (_sErros,, .t.)
		_lContinua = .F.
	endif

	// Gravacao dos dados para posterior disponibilizacao para o FullWMS
	if _lContinua
		for _nSolBloq = 1 to len (_oListaSolBloq)

			// Instancia uma solicitacao da lista, para analisar seus dados.
			_oSolBloq := _oListaSolBloq [_nSolBloq]

			reclock ("ZBH", .T.)
			zbh -> zbh_filial = xfilial ("ZBH")
			zbh -> zbh_idOper = _oSolBloq ['IdOper']  // Manter aqui consistencia com a view v_wms_bloqueios.
			zbh -> zbh_produt = _oSolBloq ['Produto']
			zbh -> zbh_lote   = _oSolBloq ['Lote']
			zbh -> zbh_posf   = _oSolBloq ['Endereco']
			zbh -> zbh_quant  = _oSolBloq ['Quantidade']
			zbh -> zbh_oper   = _oSolBloq ['Operacao']
			msunlock ()
			U_Log2 ('debug', '[' + procname () + ']ZBH_IdOper ' + zbh -> zbh_idOper + ' criado para item ' + zbh -> zbh_produt)
		next
	endif

	// Aguarda em loop por um retorno do FullWMS
	if _lContinua
		_Aguarda (_oListaSolBloq)
	endif

return _lContinua


// --------------------------------------------------------------------------
// Gera identificador unico para cada registro. Isso por que vai ser usado
// como chava na v_wms_blqueios e tb_wms_bloqueios (interface com o FullWMS).
static function _GeraID ()
	local _oSQL := NIL
	local _sRet := ''

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT MAX (ZBH_IDOPER)"
	_oSQL:_sQuery +=   " FROM " + RetSQLName ("ZBH")
	_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
	// NAO QUERO a filial ---> _oSQL:_sQuery +=    " AND ZBH_FILIAL = '" + xfilial ("ZBH") + "'"
	//_oSQL:Log ()
	_sRet = _oSQL:RetQry ()
	if empty (_sRet)
		_sRet = strzero (1, tamsx3 ("ZBH_IDOPER")[1])
	else
		_sRet = soma1 (_sRet)
	endif
return _sRet


// --------------------------------------------------------------------------
// Aguarda pelo retorno do FullWMS.
static function _Aguarda (_oListaSolBloq as json)
	local _sHrIni    := ''
	local _sTempo    := ''
	local _sMaxTempo := '00:01:30'
	local _oSQL      := NIL
	local _sListaIDs := ''
	local _aRetFull  := {}
	local _nRetFull  := 0
	local _nSolBloq  := 0
	local _lTodosComRetorno := .F.

	// Gera lista dos IDs a verificar. Manter conformidade com a view v_wms_bloqueios
	// e com a tabela tb_wms_bloqueios.
	_sListaIDs = ''
	for _nSolBloq = 1 to len (_oListaSolBloq)
		_sListaIDs += "'" + _oListaSolBloq [_nSolBloq]['IdOper'] + "'" + iif (_nSolBloq < len (_oListaSolBloq), ',', '')

		// Inicialmente todos os itens serao considerados 'com erro' ateh
		// conseguir retorno do FullWMS.
		_oListaSolBloq [_nSolBloq]['Resultado'] = .F.
	next

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT bloqueio_id, status, descr_erro"
	_oSQL:_sQuery +=  " FROM tb_wms_bloqueios"
	_oSQL:_sQuery += " WHERE bloqueio_id in (" + _sListaIDs + ")"
	_oSQL:Log ('[' + procname () + ']')

	_sHrIni = time ()
	do while .t.
		_sTempo = ElapTime (_sHrIni, time ())
		U_Log2 ('debug', '[' + procname () + ']Aguardando retorno do FullWMS  ' + ElapTime (_sTempo, _sMaxTempo))
		MsgRun ("Aguardando retorno do FullWMS", ElapTime (_sTempo, _sMaxTempo), {|| allwaystrue ()})
		
		// Como o FullSinc roda (por configuracao nossa) a cada 1 minuto, nao
		// adianta bombardear o banco verificando a cada pouco.
		sleep (10000)

		// Verifica retornos do FulLWMS e vai preenchendo na array original de bloqueios.
		// Poderia ler um a um via SQL, mas acho que ler todos em uma consulta unica
		// vai dar melhor performance no final.
		_aRetFull = aclone (_oSQL:Qry2Array (.f., .f.))
		U_Log2 ('debug', _aRetFull)
		for _nRetFull = 1 to len (_aRetFull)
			U_Log2 ('debug', '[' + procname () + ']Lendo retorno ' + cvaltochar (_nRetFull) + ' do Full')
			for _nSolBloq = 1 to len (_oListaSolBloq)
				U_Log2 ('debug', '[' + procname () + ']   Comparando com a solicitacao ' + cvaltochar (_nSolBloq))
				if _oListaSolBloq [_nSolBloq]['IdOper'] == _aRetFull [_nRetFull, 1]
					U_Log2 ('debug', '[' + procname () + ']   Encontrei')
					_oListaSolBloq [_nSolBloq]['StatusFull'] = alltrim (_aRetFull [_nRetFull, 2])
					if alltrim (_aRetFull [_nRetFull, 2]) == '1'
						_oListaSolBloq [_nSolBloq]['Resultado'] = .t.
					elseif alltrim (_aRetFull [_nRetFull, 2]) == '9'
						_oListaSolBloq [_nSolBloq]['Resultado'] = .f.
						_oListaSolBloq [_nSolBloq]['Obs'] = alltrim (_aRetFull [_nRetFull, 3])
					endif
					exit
				endif
			next
		next

		// Se todos os itens tiveram retorno, posso cair fora do loop.
		_lTodosComRetorno = .T.
		for _nSolBloq = 1 to len (_oListaSolBloq)
			if empty (_oListaSolBloq [_nSolBloq]['StatusFull'])
				U_Log2 ('debug', '[' + procname () + ']Ainda tenho a solicitacao ' + cvaltochar (_nSolBloq) + ' sem retorno do Full')
				_lTodosComRetorno = .F.
				exit
			endif
		next
		if _lTodosComRetorno
			exit
		endif

		if _sTempo >= _sMaxTempo
			u_help ("Sem retorno do FullWMS em tempo habil. Cancelando operacao.",, .t.)
			exit
		endif
	enddo

	// E agora, o que fazer se nao tive retorno do Full para todos os itens?
return
