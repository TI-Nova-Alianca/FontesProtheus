// Programa...: BlEstF
// Autor......: Robert Koch
// Data.......: 29/10/2023
// Descricao..: Interface para solicitar bloqueio/desbloqueio de lotes com FullWMS
//
// Historico de alteracoes:
//

// --------------------------------------------------------------------------
User Function BlEstF (_aBloq)
	local _lContinua := .T.
	local _nLock     := 0
	local _aAreaAnt  := U_ML_SRArea ()
	
	if cEmpAnt + cFilAnt != '0101'
		u_help ("Esta rotina nao se aplica a esta empresa/filial.",, .t.)
		_lContinua = .F.
	endif

	// Inicialmente vou usar controle de semaforo, pois preciso ter identificadores
	// unicos, bem como quero ficar aguardando o retorno do FullWMS. Depois veremos
	// como se comporta...
	if _lContinua
		_nLock := U_Semaforo ("ZBH" + cEmpAnt + cFilAnt)
		if _nLock == 0
			u_help ("Nao foi possivel obter acesso exclusivo a esta rotina nesta empresa/filial.")
			_lContinua = .F.
		endif
	endif

	// Se nao recebi uma array com itens, abro tela para o usuario selecionar.
	if _lContinua
		if valtype (_aBloq) == 'A'
			_lContinua = _Executa (_aBloq)
		else
			if aviso ("Selecione o que deseja fazer", {"Bloquear", "Desbloquear"}, 3, "Selecione acao") == 1
				_lContinua = _Bloq ()
			else
				_lContinua = _Desbloq ()
			endif
		endif
	endif

	// Libera semaforo
	U_Semaforo (_nLock)

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Processa a array de itens
// Formato de cada linha da array:
// 1 - Almoxarifado
// 2 - Codigo produto
// 3 - Lote
// 4 - Endereco (do FullWMS)
// 5 - Quantidade
// 6 - Operacao: [B]loquear ou [L]iberar
static function _Executa (_aBloq)
	local _lContinua := .T.
	local _nItem     := 0
	local _oSQL      := NIL
	local _sLinkSrv  := ''
	local _aSldFull  := {}
	local _sIdOper   := ''

	// Validacoes 'basicas'
	sb1 -> (dbsetorder (1))
	_nItem = 1
	do while _lContinua .and. _nItem <= len (_aBloq)
		if _aBloq [_nItem, 1] != '01'
			u_help ("Item " + cvaltochar (_nItem) + " (produto '" + alltrim (_aBloq [_nItem, 2]) +"'): Esta rotina gera bloqueio apenas para o almoxarifado 01.",, .t.)
			_lContinua = .F.
			exit
		endif
		if ! sb1 -> (dbseek (xfilial ("SB1") + _aBloq [_nItem, 2], .f.))
			u_help ("Item " + cvaltochar (_nItem) + " (produto '" + alltrim (_aBloq [_nItem, 2]) +"'): Cadastro do produto nao localizado!",, .t.)
			_lContinua = .F.
			exit
		endif
		if sb1 -> b1_rastro != 'L'
			u_help ("Item " + cvaltochar (_nItem) + " (produto '" + alltrim (_aBloq [_nItem, 2]) +"'): Produto nao usa controle de lotes.",, .t.)
			_lContinua = .F.
			exit
		endif
		if sb1 -> b1_vafullw != 'S'
			u_help ("Item " + cvaltochar (_nItem) + " (produto '" + alltrim (_aBloq [_nItem, 2]) +"'): Produto nao eh controlado pelo FullWMS.",, .t.)
			_lContinua = .F.
			exit
		endif
		if empty (_aBloq [_nItem, 3])
			u_help ("Item " + cvaltochar (_nItem) + " (produto '" + alltrim (_aBloq [_nItem, 2]) +"'): Lote deve ser informado.",, .t.)
			_lContinua = .F.
			exit
		endif
		if empty (_aBloq [_nItem, 4])
			u_help ("Item " + cvaltochar (_nItem) + " (produto '" + alltrim (_aBloq [_nItem, 2]) +"'): Endereco (no FullWMS) deve ser informado.",, .t.)
			_lContinua = .F.
			exit
		endif
		_nItem ++
	enddo

	if _lContinua
		_sLinkSrv = U_LkServer ('FULLWMS_AX01')
		if empty (_sLinkSrv)
			u_help ("Linked server para o FullWMS nao definido. Impossivel continuar.",, .t.)
			_lContinua = .F.
		endif
	endif

	// Se passou nas validacoes basicas, verifico estoque no FullWMS.
	_nItem = 1
	do while _lContinua .and. _nItem <= len (_aBloq)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "select QTD, SITUACAO_LOTE"
		_oSQL:_sQuery += " FROM openquery (" + _sLinkSrv + ","
		_oSQL:_sQuery += " 'select QTD, SITUACAO_LOTE"
		_oSQL:_sQuery +=    " from v_alianca_estoques"
		_oSQL:_sQuery +=   " where empr_codemp       = 1"
		_oSQL:_sQuery +=     " and item_cod_item_log = ''" + alltrim (_aBloq [_nItem, 2]) + "''"
		_oSQL:_sQuery +=     " and lote              = ''" + alltrim (_aBloq [_nItem, 3]) + "''"
		_oSQL:_sQuery +=     " and endereco          = ''" + alltrim (_aBloq [_nItem, 4])  + "''"
		_oSQL:_sQuery += " ')"
		_oSQL:Log ('[' + procname () + ']')
		_aSldFull := aclone (_oSQL:Qry2Array (.f., .f.))
		U_Log2 ('debug', _aSldFull)
		if len (_aSldFull) == 0
			u_help ("Item " + cvaltochar (_nItem) + " (produto '" + alltrim (_aBloq [_nItem, 2]) +"'): Lote '" + alltrim (_aBloq [_nItem, 3]) + "' / endereco '" + alltrim (_aBloq [_nItem, 4]) + "' nao localizado no FullWMS.", _oSQL:_sQuery, .t.)
			_lContinua = .F.
			exit
		endif
		if _aSldFull [1, 1] != _aBloq [_nItem, 5]
			u_help ("Item " + cvaltochar (_nItem) + " (produto '" + alltrim (_aBloq [_nItem, 2]) +"'): Saldo do endereco no FullWMS = " + cvaltochar (_aSldFull [1, 1]) + ". Voce deve informar a mesma quantidade, pois o FullWMS nao faz bloqueio parcial de enderecos.", _oSQL:_sQuery, .t.)
			_lContinua = .F.
			exit
		endif
		if _aBloq [_nItem, 6] == 'B' .and. left (_aSldFull [1, 2], 1) == 'B'
			u_help ("Item " + cvaltochar (_nItem) + " (produto '" + alltrim (_aBloq [_nItem, 2]) +"'): Endereco ja se encontra bloqueado no FullWMS.",_oSQL:_sQuery, .t.)
			_lContinua = .F.
			exit
		endif
		if _aBloq [_nItem, 6] == 'L' .and. left (_aSldFull [1, 2], 1) == 'L'
			u_help ("Item " + cvaltochar (_nItem) + " (produto '" + alltrim (_aBloq [_nItem, 2]) +"'): Endereco ja se encontra liberado no FullWMS.",_oSQL:_sQuery, .t.)
			_lContinua = .F.
			exit
		endif
		_nItem ++
	enddo

	// Gravacao dos dados para posterior disponibilizacao para o FullWMS
	if _lContinua
		_sIdOper = _GeraID ()
		for _nItem = 1 to len (_aBloq)
			reclock ("ZBH", .T.)
			zbh -> zbh_filial = xfilial ("ZBH")
			zbh -> zbh_idOper = _sIdOper
			zbh -> zbh_produt = _aBloq [_nItem, 2]
			zbh -> zbh_lote   = _aBloq [_nItem, 3]
			zbh -> zbh_posf   = _aBloq [_nItem, 4]
			zbh -> zbh_quant  = _aBloq [_nItem, 5]
			zbh -> zbh_oper   = _aBloq [_nItem, 6]
			msunlock ()
			U_Log2 ('debug', '[' + procname () + ']ZBH_IdOper ' + zbh -> zbh_idOper + ' criado para item ' + zbh -> zbh_produt)
		next
	endif

return _lContinua


// --------------------------------------------------------------------------
// Gera identificador unico para cada registro. Isso por que vai ser usado
// como chava na v_wms_blqueios e tb_wms_bloqueios (interface com o FullWMS).
static function _GeraID ()
	local _oSQL := NIL
	local _sRet := ''

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT MAX (ZBH_IDOPER)"
	_oSQL:_sQuery +=   " FROM " + RetSQLName ("ZBH")
	_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=    " AND ZBH_FILIAL = '" + xfilial ("ZBH") + "'"
	//_oSQL:Log ()
	_sRet = _oSQL:RetQry ()
	if empty (_sRet)
		_sRet = strzero (1, tamsx3 ("ZBH_IDOPER")[1])
	endif
	_sRet = soma1 (_oSQL:RetQry ())
return _sRet
