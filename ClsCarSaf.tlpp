// Programa:  ClsCarSaf
// Autor:     Robert Koch
// Data:      09/10/2022 (inicio)
// Descricao: Declaracao de classe de representacao de carga recebida na safra de uva.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa carga recebida durante safra de uva.
// #PalavasChave      #carga #safra
// #TabelasPrincipais #SZD #SZE
// #Modulos           #COOP

// Historico de alteracoes:
//

#Include "Protheus.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsCarSaf ()
return


// ==========================================================================
CLASS ClsCarSaf

	// Declaracao das propriedades da Classe
	public  data aIntegGrau  // Registros referentes a esta carga na tabela ZZA (integracao com leitor de grau)
	public  data Carga       // ZE_CARGA
	public  data CXouGranel  // Indica se recebe em caixas ou a granel (tombador)
	public  data Compart1    // ZE_CargaC1 - Carga compartilhada com outro fornecedor
	public  data Compart2    // ZE_CargaC2 - Carga compartilhada com outro fornecedor (atualmente, no maximo 2)
	public  data Contranota  // ZE_NFGER
	public  data Filial      // ZE_FILIAL
	public  data Fornece     // ze_assoc
	public  data Loja        // ze_lojasso
	public  data PesoBruto   // ZE_PESOBRU
	public  data PesoTara    // ZE_PESOTAR
	public  data RegSZE      // recno() da tabela SZE.
	public  data Safra       // ZE_SAFRA
	public  data Segregada   // ZE_SEGREG
	public  data SerieCtrn   // ze_serie
	public  data UltMsg      // Ultima mensagem gerada

	// Declaracao dos Metodos da classe
	public METHOD New ()
	public METHOD AtuAgenda ()
	public METHOD GeraAtrib ()
	public METHOD GrvEvt ()
	public METHOD Log ()
	public METHOD StatusZZA ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor da classe pelo R_E_C_N_O_ da tabela SZE.
METHOD New (_nNumReg) Class ClsCarSaf
	local _aAreaAnt := U_ML_SRArea ()

	
	// Se receber valor numerico, eh por que se trata do numero de registro do SZE.
	if valtype (_nNumReg) == "N" .and. _nNumReg > 0
		SZE -> (dbgoto (_nNumReg))
		::GeraAtrib ("SZE")
	else
		// Alimenta atributos com valores default de uma carga nova (vazia).
		::GeraAtrib ("")
	endif

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Instanciada carga F' + ::Filial + '/' + ::Safra + '/' + ::Carga + ' de ' + ::Fornece + '/' + ::Loja)
	U_ML_SRArea (_aAreaAnt)
Return ::self


// --------------------------------------------------------------------------
// Altera o status do agendamento relacionado a esta carga na agenda do NaWeb.
METHOD AtuAgenda (_sStatPara) Class ClsCarSaf
	local _lRetWSNA  := .F.
	local _oWSNaWeb  := NIL
	local _sXMLCarg  := ''
	local _lContinua := .T.
	local _sZZAAtual := ''

	// Lista de status passados pela Daiana em 26/10/22:
	// Dis Disponível
	// AGE Agendado
	// RES Reservado
	// INS Inspecionado
	// AUT Autorizada entrada
	// LIB Liberada
	// EMP Em processamento
	// CON Concluido processamento
	// REJ Rejeitada
	// REI Reinspecionar
	// SEG Segregada
	// CNF Concluida NF

	// Analisa situacao do arquivo de integracao com medidor de grau
	_sZZAAtual = ::StatusZZA ()

	// Define o que vai enviar para o NaWeb
	_sStatPara = ''
	if _lContinua
		do case
		case ::Segregada
			_sStatPara = 'SEG'  // Segregada
		case ! empty (::Contranota)
			_sStatPara = 'CNF'  // Concluida NF
		case _sZZAAtual == '3'
			_sStatPara = 'CON'  // Processamento concluido
		case _sZZAAtual == '2'
			_sStatPara = 'EMP'  // Em processamento
		case ::PesoBruto > 0
			_sStatPara = 'LIB'  // Liberada (para ir ate o tombador e descarregar)
		otherwise
			u_help ("Situacao nao prevista. Nao sei o que enviar para o NaWeb para definir o status da carga " + ::Carga,, .T.)
			_lContinua = .F.
		endcase
	endif

	if _lContinua
		_sXMLCarg := '<?xml version="1.0" encoding="utf-8"?>'
		_sXMLCarg += '<SDT_Cargas>'
		_sXMLCarg +=    '<Itens>'
		_sXMLCarg +=    '<Filial>'   + ::Filial   + '</Filial>'
		_sXMLCarg +=    '<Safra>'    + ::Safra    + '</Safra>'
		_sXMLCarg +=    '<Carga>'    + ::Carga    + '</Carga>'
		_sXMLCarg +=    '<Situacao>' + _sStatPara + '</Situacao>'
		_sXMLCarg +=    '</Itens>'
		_sXMLCarg += '</SDT_Cargas>'

		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sXMLCarg)
		
		_oWSNaWeb := WSPrcStatusAgendaSafraWS():New()
		_oWSNaWeb:cEntrada := _sXMLCarg
		_oWSNaWeb:Execute()
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retorno do NaWeb: ' + CVALTOCHAR (_oWSNaWeb:cSaida))

		if cvaltochar (_oWSNaWeb:cSaida) == 'OK'
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Alteracao da carga foi aceita pelo NaWeb')
			_lRetWSNA = .T.

			// Grava evento para posterior rastreamento
			::GrvEvt ('SZE004', "Enviado novo status (" + _sStatPara + ") para o NaWeb.")
		else
			::UltMsg += "Alteracao da carga '" + ::Carga + "' nao foi aceita pelo NaWeb: " + cvaltochar (_oWSNaWeb:cSaida)
			u_help (::UltMsg,, .t.)
			_lRetWSNA = .F.

			// Grava evento para posterior rastreamento
			::GrvEvt ('SZE004', "ERRO ao enviado novo status (" + _sStatPara + ") para o NaWeb: " + ::UltMsg)
		endif
	endif
return _lRetWSNA


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sOrigem) Class ClsCarSaf
	local _aAreaAnt := U_ML_SRArea ()
	local _oSQL     := NIL

	// Defaults
	::aIntegGrau   = {}
	::Carga      = ''
	::Contranota = ''
	::Compart1   = ''
	::Compart2   = ''
	::CXouGranel = ''
	::Filial     = ''
	::Fornece    = ''
	::Loja       = ''
	::PesoBruto  = 0
	::PesoTara   = 0
	::RegSZE     = 0
	::Safra      = ''
	::Segregada  = .F.
	::UltMsg     = ''

	do case
	case _sOrigem == 'M'  // Variaveis M->
		::Filial     = xfilial ("SZE")
		::Safra      = m->safra
		::Carga      = m->carga
		::Compart1   = m->ze_cargaC1
		::Compart2   = m->ze_cargaC2
		::Contranota = m->ze_nfger
		::Fornece    = m->ze_assoc
		::Loja       = m->ze_lojasso
		::PesoBruto  = m->ze_pesobru
		::PesoTara   = m->ze_pesotar
		::Segregada  = (m->ze_segreg == 'S')

	case _sOrigem == "SZE"
		::Carga      = sze -> ze_carga
		::Filial     = sze -> ze_filial
		::Compart1   = sze -> ze_cargaC1
		::Compart2   = sze -> ze_cargaC2
		::Contranota = sze -> ze_nfger
		::Fornece    = sze -> ze_assoc
		::Loja       = sze -> ze_lojasso
		::PesoBruto  = sze -> ze_pesobru
		::PesoTara   = sze -> ze_pesotar
		::RegSZE     = sze -> (recno ())
		::Safra      = sze -> ze_safra
		::Segregada  = (sze -> ze_segreg == 'S')

	otherwise
		if ! empty (_sOrigem)  // Se origem vazia, eh por que estou apenas instanciando um objeto vazio.
			::UltMsg += "Impossivel gerar atributos. Origem '" + _sOrigem + "' desconhecida."
			u_help (::UltMsg,, .t.)
		endif
	endcase

	::CxOuGranel = iif (::Filial == '03', 'C', 'G')  // Somente Livramento ainda recebe em caixas

	// Alimenta array de informacoes da tabela de integracao com medidor de grau.
	if ! empty (::Filial) .and. ! empty (::Safra) .and. ! empty (::Carga)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT ZZA_PRODUT, ZZA_STATUS, ZZA_GRAU"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZZA") + " ZZA"
		_oSQL:_sQuery += " WHERE ZZA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_FILIAL = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_SAFRA  = '" + ::Safra + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_CARGA  = '" + ::Carga + "'"
		_oSQL:_sQuery += " ORDER BY ZZA.ZZA_PRODUT"  // zza_produt = zf_item
		//_oSQL:_sQuery +=   " AND ZZA.ZZA_PRODUT = '01'"  // Tenho intencao de comecar a gravar apenas 1 item por carga, independentemente de haver mais de uma variedade.
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		::aIntegGrau := aclone (_oSQL:Qry2Array (.F., .F.))
//		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']aIntegGrau:')
//		U_Log2 ('debug', ::aIntegGrau)
	endif

	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Grava evento padrao do sistema.
METHOD GrvEvt (_sCodEvt, _sTxtEvt) Class ClsCarSaf
	local _oEvento := NIL

	_oEvento := ClsEvent():new ()
	_oEvento:CodEven   = _sCodEvt
	_oEvento:Texto    := 'Safra ' + ::Safra + ' Carga ' + ::Carga + ' ' + _sTxtEvt
	_oEvento:Recno     = ::RegSZE
	_oEvento:Alias     = 'SZE'
	_oEvento:CodAlias  = ::Safra + ::Carga
	_oEvento:NFEntrada = ::Contranota
	_oEvento:SerieEntr = ::SerieCtrn
	_oEvento:Fornece   = ::Fornece
	_oEvento:LojaFor   = ::Loja
	_oEvento:Grava ()
return


// --------------------------------------------------------------------------
// Grava dados da carga em arquivo de log, para ajudar em rastreio de problemas.
METHOD Log () Class ClsCarSaf
	local _sLogCar := ''
	_sLogCar += 'Filial: ' + ::Filial + ' Safra: ' + ::Safra + ' Carga: ' + ::Carga + chr (13) + chr (10)
	_sLogCar += 'Fornecedor: ' + ::Fornece + '/' + ::Loja + ' - ' + ::Carga + chr (13) + chr (10)
	U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']--------------------------')
	U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Exportando dados do objeto')
	U_Log2 ('info', _sLogCar)
	U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']--------------------------')
return _sLogCar


// --------------------------------------------------------------------------
// Faz uma analise da integracao com o grau (pode ter mais de um item na carga)
// e procura definir o status do ZZA 'como um todo' para a carga.
METHOD StatusZZA () Class ClsCarSaf
	local _sRetStZZA := ''

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Avaliando carga recebida em ' + ::CXouGranel + ' com registros assim:')
	U_Log2 ('debug', ::aIntegGrau)
	
	// Quando a carga eh recebida em caixas, vale o 'menor' status por
	// que provavelmente cada variedade vai ser processada separadamente.
	if ::CXouGranel == 'C'
		if ascan (::aIntegGrau, {|_aVal| _aVal [2] == 'C'}) > 0
			_sRetStZZA = 'C'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '0'}) > 0
			_sRetStZZA = '0'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '1'}) > 0
			_sRetStZZA = '1'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '2'}) > 0
			_sRetStZZA = '2'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '3'}) > 0
			_sRetStZZA = '3'
		endif

	// Quando a carga eh recebida a granel, vale o 'maior' status por
	// que todas as variedades serao processadas junto. O programa do
	// grau vai dar o retorno em apenas um dos registros.
	elseif ::CXouGranel == 'G'
		if ascan (::aIntegGrau, {|_aVal| _aVal [2] == 'C'}) > 0
			_sRetStZZA = 'C'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '3'}) > 0
			_sRetStZZA = '3'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '2'}) > 0
			_sRetStZZA = '2'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '1'}) > 0
			_sRetStZZA = '1'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '0'}) > 0
			_sRetStZZA = '0'
		endif
		
	else
		u_help ("Conteudo desconhecido (" + ::CXouGranel + ") na analise do status da medicao de grau.")
	endif

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retornando statusZZA = ' + _sRetStZZA + ' para a carga ' + ::Carga)
return _sRetStZZA
