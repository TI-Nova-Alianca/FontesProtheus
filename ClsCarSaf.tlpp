// Programa:  ClsCarSaf
// Autor:     Robert Koch
// Data:      09/10/2022 (inicio)
// Descricao: Declaracao de classe de representacao de carga recebida na safra de uva.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa carga recebida durante safra de uva.
// #PalavasChave      #carga #safra
// #TabelasPrincipais #SZD #SZE
// #Modulos           #COOP

// Historico de alteracoes:
//

#Include "Protheus.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsCarSaf ()
return


// ==========================================================================
CLASS ClsCarSaf

	// Declaracao das propriedades da Classe
	public  data aIntegGrau  // Registros referentes a esta carga na tabela ZZA (integracao com leitor de grau)
	public  data Carga       // ZE_CARGA
	public  data CXouGranel  // Indica se recebe em caixas ou a granel (tombador)
	public  data Compart1    // ZE_CargaC1 - Carga compartilhada com outro fornecedor
	public  data Compart2    // ZE_CargaC2 - Carga compartilhada com outro fornecedor (atualmente, no maximo 2)
	public  data Contranota  // ZE_NFGER
	public  data Filial      // ZE_FILIAL
	public  data Fornece     // ze_assoc
	public  data PortImpTk   // Porta / caminho para impressao do ticket
	public  data Loja        // ze_lojasso
	public  data PesoBruto   // ZE_PESOBRU
	public  data PesoTara    // ZE_PESOTAR
	public  data RegSZE      // recno() da tabela SZE.
	public  data Safra       // ZE_SAFRA
	public  data Segregada   // ZE_SEGREG
	public  data SerieCtrn   // ze_serie
	public  data UltMsg      // Ultima mensagem gerada

	// Declaracao dos Metodos da classe
	public METHOD New ()
	public METHOD AtuAgenda ()
	public METHOD DefImprTk ()  // Define porta para impressao do ticket
	public METHOD GeraAtrib ()
	public METHOD EnderEstq ()  // Enderecar (ou estornar) estoque
	public METHOD GrvEvt ()
	public METHOD ImprimeTk ()  // Gera impressao do ticket
	public METHOD Log ()
	public METHOD StatusZZA ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor da classe pelo R_E_C_N_O_ da tabela SZE.
METHOD New (_nNumReg) Class ClsCarSaf
	local _aAreaAnt := U_ML_SRArea ()

	// Como o metodo GeraAtrib eh chamado de varios lugares depois que o objeto
	// jah foi instanciado, achei que seria desnecessario ler novamente algumas
	// coisas que apenas degradariam a performance, entao jah vou deixar setadas
	// aqui. Havendo necessidades especificas, poderao ser alteradas depois.
	::DefImprTk ()

	// Se receber valor numerico, eh por que se trata do numero de registro do SZE.
	if valtype (_nNumReg) == "N" .and. _nNumReg > 0
		SZE -> (dbgoto (_nNumReg))
		::GeraAtrib ("SZE")
	else
		// Alimenta atributos com valores default de uma carga nova (vazia).
		::GeraAtrib ("")
	endif

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Instanciada carga p/ Filial ' + ::Filial + ' Safra ' + ::Safra + ' Carga ' + ::Carga + ' de ' + ::Fornece + '/' + ::Loja)
	U_ML_SRArea (_aAreaAnt)
Return ::self


// --------------------------------------------------------------------------
// Altera o status do agendamento relacionado a esta carga na agenda do NaWeb.
METHOD AtuAgenda (_sStatPara) Class ClsCarSaf
	local _lRetWSNA  := .F.
	local _oWSNaWeb  := NIL
	local _sXMLCarg  := ''
	local _lContinua := .T.
	local _sZZAAtual := ''

	// Lista de status passados pela Daiana em 26/10/22:
	// Dis Disponível
	// AGE Agendado
	// RES Reservado
	// INS Inspecionado
	// AUT Autorizada entrada
	// LIB Liberada
	// EMP Em processamento
	// CON Concluido processamento
	// REJ Rejeitada
	// REI Reinspecionar
	// SEG Segregada
	// CNF Concluida NF

	// Analisa situacao do arquivo de integracao com medidor de grau
	_sZZAAtual = ::StatusZZA ()

	// Define o que vai enviar para o NaWeb
	_sStatPara = ''
	if _lContinua
		do case
		case ::Segregada
			_sStatPara = 'SEG'  // Segregada
		case ! empty (::Contranota)
			_sStatPara = 'CNF'  // Concluida NF
		case _sZZAAtual == '3'
			_sStatPara = 'CON'  // Processamento concluido
		case _sZZAAtual == '2'  // Muito provavelmente o NaWeb vai ver isso bem antes que o Protheus
			_sStatPara = 'EMP'  // Em processamento
		case ::PesoBruto > 0
			_sStatPara = 'LIB'  // Liberada (para ir ate o tombador e descarregar)
		otherwise
			u_help ("Situacao nao prevista. Nao sei o que enviar para o NaWeb para definir o status da carga " + ::Carga,, .T.)
			U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + ']_sZZAAtual: ' + cvaltochar (_sZZAAtual))
			u_logObj (::Self)
			_lContinua = .F.
		endcase
	endif

	if _lContinua
		_sXMLCarg := '<?xml version="1.0" encoding="utf-8"?>'
		_sXMLCarg += '<SDT_Cargas>'
		_sXMLCarg +=    '<Itens>'
		_sXMLCarg +=    '<Filial>'   + ::Filial   + '</Filial>'
		_sXMLCarg +=    '<Safra>'    + ::Safra    + '</Safra>'
		_sXMLCarg +=    '<Carga>'    + ::Carga    + '</Carga>'
		_sXMLCarg +=    '<Situacao>' + _sStatPara + '</Situacao>'
		_sXMLCarg +=    '</Itens>'
		_sXMLCarg += '</SDT_Cargas>'

		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sXMLCarg)
		
		_oWSNaWeb := WSPrcStatusAgendaSafraWS():New()
		_oWSNaWeb:cEntrada := _sXMLCarg
		_oWSNaWeb:Execute()
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retorno do NaWeb: ' + CVALTOCHAR (_oWSNaWeb:cSaida))

		if cvaltochar (_oWSNaWeb:cSaida) == 'OK'
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Alteracao da carga foi aceita pelo NaWeb')
			_lRetWSNA = .T.

			// Grava evento para posterior rastreamento
			::GrvEvt ('SZE004', "Enviado novo status (" + _sStatPara + ") para o NaWeb.")
		else
			::UltMsg += "Alteracao da carga '" + ::Carga + "' nao foi aceita pelo NaWeb: " + cvaltochar (_oWSNaWeb:cSaida)
			u_help (::UltMsg,, .t.)
			_lRetWSNA = .F.

			// Grava evento para posterior rastreamento
			::GrvEvt ('SZE004', "ERRO ao enviar novo status (" + _sStatPara + ") para o NaWeb: " + ::UltMsg)
		endif
	endif
return _lRetWSNA


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD DefImprTk (_sFilial, _sCamFixo) Class ClsCarSaf
	//local _sIdImpr := ''

	_sFilial = iif (empty (_sFilial), ::Filial, _sFilial)

	if ! empty (_sCamFixo)
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Recebi um caminho fixo para impressora: ' + _sCamFixo)
		::PortImpTk = _sCamFixo
	else
		// Se for base teste, evita enviar para a impressora padrao para nao causar confusao com a safra normal.
		if U_AmbTeste()
			::PortImpTk := '\\192.168.1.3\siga\ticket.txt'
			U_Log2 ('aviso', '[' + GetClassName (::Self) + '.' + procname () + ']Ambiente de TESTE. Vou redirecionar o ticket para ' + ::PortImpTk)
		else
			::PortImpTk = GetMV ("VA_ITKSAFR")
			U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']::PortImTk = ' + ::PortImpTk + ' (lido do parametro VA_ITKSAFR)')
		endif
	endif
return


// --------------------------------------------------------------------------
// Faz o enderecamento (ou estorno)dos lotes de uva no estoque
METHOD EnderEstq (_sQueFazer) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _aAmbAnt   := U_SalvaAmb ()
	local _oSQL      := NIL
	local _aRegSDA   := {}
	local _nRegSDA   := 0
	local _aAutoSDA  := {}
	local _aAutoSDB  := {}
	local _aLinhaSDB := {}
	local _sFiltrSDA := ''
	local _lContinua := .T.

	// Se for estorno, filtra a tabela e chama tela padrao do sistema.
	// O usuario deverah clicar no botao 'estornar'.
	if _sQueFazer == 'E'  // Estornar
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Chamando tela estorno enderecamento docto ' + ::Contranota)
		oGetD := NIL
		nOpcA := 0
		aHeader := NIL
		aCols := NIL
		N := 1
		aRotina := NIL
	//	u_logobj (::Self)
		_sFiltrSDA := "da_filial='"      + ::Filial     + "'"
		_sFiltrSDA += ".and.da_doc='"    + ::Contranota + "'"
		_sFiltrSDA += ".and.da_serie='"  + ::SerieCtrn  + "'"
		_sFiltrSDA += ".and.da_clifor='" + ::Fornece    + "'"
		_sFiltrSDA += ".and.da_loja='"   + ::Loja       + "'"
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sFiltrSDA)
 		dbselectarea ("SDA")
		set filter to &(_sFiltrSDA)
		MATA265 ()
		dbselectarea ("SDA")
		set filter to

	elseif _sQueFazer == 'I'  // Incluir

		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Iniciando enderecamento docto ' + ::Contranota)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT SDA.R_E_C_N_O_"
		
		// Posso estar reenderecando uma nota. Nesse caso, preciso gerar o
		// campo DB_ITEM maior que 0001.
		_oSQL:_sQuery +=      " ,ISNULL ((SELECT MAX (DB_ITEM)
		_oSQL:_sQuery +=                  " FROM " + RetSQLName ("SDB") + " SDB "
		_oSQL:_sQuery +=                 " WHERE SDB.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=                   " AND SDB.DB_FILIAL = SDA.DA_FILIAL"
		_oSQL:_sQuery +=                  " AND SDB.DB_PRODUTO = SDA.DA_PRODUTO"
		_oSQL:_sQuery +=                  " AND SDB.DB_DOC = SDA.DA_DOC"
		_oSQL:_sQuery +=                  " AND SDB.DB_SERIE = SDA.DA_SERIE"
		_oSQL:_sQuery +=                  " AND SDB.DB_CLIFOR = SDA.DA_CLIFOR"
		_oSQL:_sQuery +=                  " AND SDB.DB_LOJA = SDA.DA_LOJA"
		_oSQL:_sQuery +=                  " AND SDB.DB_LOTECTL = SDA.DA_LOTECTL"
		_oSQL:_sQuery +=                  " AND SDB.DB_NUMSEQ = SDA.DA_NUMSEQ"
		_oSQL:_sQuery +=                  " AND SDB.DB_ORIGEM = SDA.DA_ORIGEM), '0000')"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD1") + " SD1, "
		_oSQL:_sQuery +=             RetSQLName ("SDA") + " SDA "
		_oSQL:_sQuery += " WHERE SD1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SD1.D1_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_DOC     = '" + ::Contranota + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_SERIE   = '" + ::SerieCtrn + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_FORNECE = '" + ::Fornece + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_LOJA    = '" + ::Loja + "'"
		_oSQL:_sQuery +=   " AND SDA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SDA.DA_FILIAL  = SD1.D1_FILIAL"
		_oSQL:_sQuery +=   " AND SDA.DA_DOC     = SD1.D1_DOC"
		_oSQL:_sQuery +=   " AND SDA.DA_SERIE   = SD1.D1_SERIE"
		_oSQL:_sQuery +=   " AND SDA.DA_CLIFOR  = SD1.D1_FORNECE"
		_oSQL:_sQuery +=   " AND SDA.DA_LOJA    = SD1.D1_LOJA"
		_oSQL:_sQuery +=   " AND SDA.DA_ORIGEM  = 'SD1'"
		_oSQL:_sQuery +=   " AND SDA.DA_NUMSEQ  = SD1.D1_NUMSEQ"
		_oSQL:_sQuery +=   " AND SDA.DA_PRODUTO = SD1.D1_COD"
		_oSQL:_sQuery +=   " AND SDA.DA_SALDO   > 0"
		_oSQL:Log ()
		_aRegSDA = _oSQL:Qry2Array (.F., .F.)
		if len (_aRegSDA) == 0
			u_help ("Nenhum produto com saldo a enderecar para esta carga/contranota.")
		endif
		for _nRegSDA = 1 to len (_aRegSDA)
			sda -> (dbgoto (_aRegSDA [_nRegSDA, 1]))
			_aAutoSDA = {}
			aadd (_aAutoSDA, {"DA_PRODUTO", sda -> da_produto, nil})
			aadd (_aAutoSDA, {"DA_LOCAL"  , SDA -> DA_LOCAL    , nil})
			aadd (_aAutoSDA, {"DA_NUMSEQ" , SDA -> DA_NUMSEQ   , nil})
			aadd (_aAutoSDA, {"DA_DOC"    , SDA -> DA_DOC      , nil})
			aadd (_aAutoSDA, {"DA_SERIE"  , SDA -> DA_SERIE    , nil})

			_aAutoSDB = {}
			_aLinhaSDB = {}
		//	aadd (_aLinhaSDB, {"DB_ITEM", '0001', nil})
			aadd (_aLinhaSDB, {"DB_ITEM", Soma1 (_aRegSDA [_nRegSDA, 2]), nil})
			if ::Filial == '01'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T01PCP03       ', nil})
			elseif ::Filial == '03'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T03 PCP AX 03  ', nil})
			elseif ::Filial == '07'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T07 PCP 03     ', nil})
			elseif ::Filial == '09'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T09 PCP AX 03  ', nil})
			endif
			aadd (_aLinhaSDB, {"DB_QUANT"  , SDA->DA_QTDORI   , nil})
			aadd (_aLinhaSDB, {"DB_DATA"   , dDATABASE        , nil})
			U_Log2 ('info', 'Enderecando docto ' + sda -> da_doc + ' / produto ' + sda -> da_produto)
			_aLinhaSDB = aclone (U_OrdAuto (_aLinhaSDB))
			aadd (_aAutoSDB, aclone (_aLinhaSDB))
			lMsErroAuto := .F.
			MSExecAuto({|x,y,z| mata265(x,y,z)}, _aAutoSDA, _aAutoSDB, 3)
			If lMsErroAuto
				u_log2 ('erro', 'lMsErroAuto')
				if ! empty (NomeAutoLog ())
					u_log2 ('erro', memoread (NomeAutoLog ()))
					MostraErro()
				else
					u_help ("Nao foi possivel ler o arquivo de log de erros da rotina de enderecamento de uva no estoque.",, .t.)
				endif
			endif
		next
	else
		u_help ('Sem tratamento para acao ' + _sQueFazer,, .t.)
	endif

	U_SalvaAmb (_aAmbAnt)
	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sOrigem) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _lContinua := .T.

	// Defaults
	::aIntegGrau   = {}
	::Carga      = ''
	::Contranota = ''
	::Compart1   = ''
	::Compart2   = ''
	::CXouGranel = ''
	::Filial     = ''
	::Fornece    = ''
	::Loja       = ''
	::PesoBruto  = 0
	::PesoTara   = 0
	::RegSZE     = 0
	::Safra      = ''
	::Segregada  = .F.
	::SerieCtrn  = ''
	::UltMsg     = ''

	do case
	case _sOrigem == 'M'  // Variaveis M->
		::Filial     = xfilial ("SZE")
		::Safra      = m->safra
		::Carga      = m->carga
		::Compart1   = m->ze_cargaC1
		::Compart2   = m->ze_cargaC2
		::Contranota = m->ze_nfger
		::Fornece    = m->ze_assoc
		::Loja       = m->ze_lojasso
		::PesoBruto  = m->ze_pesobru
		::PesoTara   = m->ze_pesotar
		::Segregada  = (m->ze_segreg == 'S')
		::SerieCtrn  = m->ze_serie

	case _sOrigem == "SZE"
		::Carga      = sze -> ze_carga
		::Filial     = sze -> ze_filial
		::Compart1   = sze -> ze_cargaC1
		::Compart2   = sze -> ze_cargaC2
		::Contranota = sze -> ze_nfger
		::Fornece    = sze -> ze_assoc
		::Loja       = sze -> ze_lojasso
		::PesoBruto  = sze -> ze_pesobru
		::PesoTara   = sze -> ze_pesotar
		::RegSZE     = sze -> (recno ())
		::Safra      = sze -> ze_safra
		::Segregada  = (sze -> ze_segreg == 'S')
		::SerieCtrn  = sze -> ze_serie

	otherwise
		if ! empty (_sOrigem)  // Se origem vazia, eh por que estou apenas instanciando um objeto vazio.
			::UltMsg += "Impossivel gerar atributos. Origem '" + _sOrigem + "' desconhecida."
			u_help (::UltMsg,, .t.)
		endif
		_lContinua = .F.
	endcase

	if _lContinua
		::CxOuGranel = iif (::Filial == '03', 'C', 'G')  // Somente Livramento ainda recebe em caixas
	endif

	// Alimenta array de informacoes da tabela de integracao com medidor de grau.
	if _lContinua .and. ! empty (::Filial) .and. ! empty (::Safra) .and. ! empty (::Carga)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT ZZA_PRODUT, ZZA_STATUS, ZZA_GRAU"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZZA") + " ZZA"
		_oSQL:_sQuery += " WHERE ZZA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_FILIAL = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_SAFRA  = '" + ::Safra + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_CARGA  = '" + ::Carga + "'"
		_oSQL:_sQuery += " ORDER BY ZZA.ZZA_PRODUT"  // zza_produt = zf_item
		//_oSQL:_sQuery +=   " AND ZZA.ZZA_PRODUT = '01'"  // Tenho intencao de comecar a gravar apenas 1 item por carga, independentemente de haver mais de uma variedade.
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		::aIntegGrau := aclone (_oSQL:Qry2Array (.F., .F.))
//		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']aIntegGrau:')
//		U_Log2 ('debug', ::aIntegGrau)
	endif

	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Grava evento padrao do sistema.
METHOD GrvEvt (_sCodEvt, _sTxtEvt) Class ClsCarSaf
	local _oEvento := NIL

	_oEvento := ClsEvent():new ()
	_oEvento:CodEven   = _sCodEvt
	_oEvento:Texto    := 'Safra ' + ::Safra + ' Carga ' + ::Carga + ' ' + _sTxtEvt
	_oEvento:Recno     = ::RegSZE
	_oEvento:Alias     = 'SZE'
	_oEvento:CodAlias  = ::Safra + ::Carga
	_oEvento:NFEntrada = ::Contranota
	_oEvento:SerieEntr = ::SerieCtrn
	_oEvento:Fornece   = ::Fornece
	_oEvento:LojaFor   = ::Loja
	_oEvento:Grava ()
return


// --------------------------------------------------------------------------
// Gera (re)impressao do ticket da carga.
METHOD ImprimeTk (_nQualTk) Class ClsCarSaf
	
	// Se nao especificado qual ticket (1a. ou 2a. pesagem), verifica se quais dados jah tem.
	if empty (_nQualTk)
		_nQualTk = iif (::PesoTara != 0, 2, 1)
	endif

	U_VA_RusTk (_nQualTk, ::PortImpTk, iif (_nQualTk == 1, 1, 2), {}, 'bematech', .t.)

return


// --------------------------------------------------------------------------
// Grava dados da carga em arquivo de log, para ajudar em rastreio de problemas.
METHOD Log () Class ClsCarSaf
	local _sLogCar := ''
	_sLogCar += 'Filial: ' + ::Filial + ' Safra: ' + ::Safra + ' Carga: ' + ::Carga + chr (13) + chr (10)
	_sLogCar += 'Fornecedor: ' + ::Fornece + '/' + ::Loja + ' - ' + ::Carga + chr (13) + chr (10)
	U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']--------------------------')
	U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Exportando dados do objeto')
	U_Log2 ('info', _sLogCar)
	U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']--------------------------')
return _sLogCar


// --------------------------------------------------------------------------
// Faz uma analise da integracao com o grau (pode ter mais de um item na carga)
// e procura definir o status do ZZA 'como um todo' para a carga.
METHOD StatusZZA () Class ClsCarSaf
	local _sRetStZZA := ''

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Avaliando carga recebida em ' + ::CXouGranel + ' com registros assim:')
	U_Log2 ('debug', ::aIntegGrau)
	
	// Quando a carga eh recebida em caixas, vale o 'menor' status por
	// que provavelmente cada variedade vai ser processada separadamente.
	if ::CXouGranel == 'C'
		if ascan (::aIntegGrau, {|_aVal| _aVal [2] == 'C'}) > 0
			_sRetStZZA = 'C'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '0'}) > 0
			_sRetStZZA = '0'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '1'}) > 0
			_sRetStZZA = '1'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '2'}) > 0
			_sRetStZZA = '2'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '3'}) > 0
			_sRetStZZA = '3'
		endif

	// Quando a carga eh recebida a granel, vale o 'maior' status por
	// que todas as variedades serao processadas junto. O programa do
	// grau vai dar o retorno em apenas um dos registros.
	elseif ::CXouGranel == 'G'
		if ascan (::aIntegGrau, {|_aVal| _aVal [2] == 'C'}) > 0
			_sRetStZZA = 'C'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '3'}) > 0
			_sRetStZZA = '3'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '2'}) > 0
			_sRetStZZA = '2'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '1'}) > 0
			_sRetStZZA = '1'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '0'}) > 0
			_sRetStZZA = '0'
		endif
		
	else
		u_help ("Conteudo desconhecido (" + ::CXouGranel + ") na analise do status da medicao de grau.")
	endif

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retornando statusZZA = ' + _sRetStZZA + ' para a carga ' + ::Carga)
return _sRetStZZA
