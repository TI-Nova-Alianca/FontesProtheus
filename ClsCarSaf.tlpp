// Programa:  ClsCarSaf
// Autor:     Robert Koch
// Data:      09/10/2022 (inicio)
// Descricao: Declaracao de classe de representacao de carga recebida na safra de uva.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa carga recebida durante safra de uva.
// #PalavasChave      #carga #safra
// #TabelasPrincipais #SZD #SZE
// #Modulos           #COOP

// Historico de alteracoes:
// 17/01/2023 - Robert - Quando producao propria, gera apenas 1 via do ticket 2a.pesagem.
// 20/01/2023 - Robert - Comecado a gravar arrays de itens (ItItem, ItProduto, ...)
// 23/01/2023 - Robert - Criado metodo AtuZZA.
//

#Include "Protheus.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsCarSaf ()
return


// ==========================================================================
CLASS ClsCarSaf

	// Declaracao das propriedades da Classe
	public  data aIntegGrau  // Registros referentes a esta carga na tabela ZZA (integracao com leitor de grau)
	public  data Aglutin     // ZE_AGLUTIN - Situacao quanto a aglutinacao de cargas: O=Origem (aglutinada em outra carga);D=Destino (aglutinadora);N=Nenhuma(carga normal)
	public  data Carga       // ZE_CARGA
	public  data CXouGranel  // Indica se recebe em caixas ou a granel (tombador)
	public  data Compart1    // ZE_CargaC1 - Carga compartilhada com outro fornecedor
	public  data Compart2    // ZE_CargaC2 - Carga compartilhada com outro fornecedor (atualmente, no maximo 2)
	public  data Contranota  // ZE_NFGER
	public  data Filial      // ZE_FILIAL
	public  data Fornece     // ze_assoc
	public  data ItDescri    // Array de Itens da carga - Descricao do produto
	public  data ItGrau      // Array de Itens da carga - zf_grau
	public  data ItItem      // Array de Itens da carga - zf_item
	public  data ItProduto   // Array de Itens da carga - zf_produto
	public  data Loja        // ze_lojasso
	public  data NomeFornec  // A2_NOME - nome do fornecedor
	public  data PesoBruto   // ZE_PESOBRU
	public  data PesoTara    // ZE_PESOTAR
	public  data PortImpTk   // Porta / caminho para impressao do ticket
	public  data RegSZE      // recno() da tabela SZE.
	public  data Safra       // ZE_SAFRA
	public  data Segregada   // ZE_SEGREG
	public  data SerieCtrn   // ze_serie
	public  data StatusCar   // ze_status
	public  data UltMsg      // Ultima mensagem gerada

	// Declaracao dos Metodos da classe
	public METHOD New ()
	public METHOD AddItem ()    // Adiciona uma posicao nas arrays de itens
	public METHOD AtuAgenda ()  // Envia atualizacao para o sistema de agendamento
	public METHOD AtuZZA ()     // Envia atualizacao para o programa de medicao de grau
	public METHOD DefImprTk ()  // Define porta para impressao do ticket
	public METHOD GeraAtrib ()
	public METHOD EnderEstq ()  // Enderecar (ou estornar) estoque
	public METHOD GrvEvt ()
	public METHOD ImprimeTk ()  // Gera impressao do ticket
	public METHOD Log ()
	public METHOD StatusZZA ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor da classe pelo R_E_C_N_O_ da tabela SZE.
METHOD New (_nNumReg) Class ClsCarSaf
	local _aAreaAnt := U_ML_SRArea ()

	// Como o metodo GeraAtrib eh chamado de varios lugares depois que o objeto
	// jah foi instanciado, achei que seria desnecessario ler novamente algumas
	// coisas que apenas degradariam a performance, entao jah vou deixar setadas
	// aqui. Havendo necessidades especificas, poderao ser alteradas depois.
	::DefImprTk ()

	// Se receber valor numerico, eh por que se trata do numero de registro do SZE.
	if valtype (_nNumReg) == "N" .and. _nNumReg > 0
		SZE -> (dbgoto (_nNumReg))
		::GeraAtrib ("SZE")
	else
		// Alimenta atributos com valores default de uma carga nova (vazia).
		::GeraAtrib ("")
	endif

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Instanciada carga p/ Filial ' + ::Filial + ' Safra ' + ::Safra + ' Carga ' + ::Carga + ' de ' + ::Fornece + '/' + ::Loja)
	U_ML_SRArea (_aAreaAnt)
Return ::self


// --------------------------------------------------------------------------
// Adiciona uma posicao em cada array de itens.
METHOD AddItem () Class ClsCarSaf
	aadd (::ItItem,    '')
	aadd (::ItProduto, '')
	aadd (::ItDescri,  '')
	aadd (::ItGrau,    '')
return


// --------------------------------------------------------------------------
// Altera o status do agendamento relacionado a esta carga na agenda do NaWeb.
METHOD AtuAgenda (_sStatPara) Class ClsCarSaf
	local _lRetWSNA  := .F.
	local _oWSNaWeb  := NIL
	local _sXMLCarg  := ''
	local _lContinua := .T.
	local _sZZAAtual := ''

	// Lista de status passados pela Daiana em 26/10/22:
	// Dis Disponível
	// AGE Agendado
	// RES Reservado
	// INS Inspecionado
	// AUT Autorizada entrada
	// LIB Liberada
	// EMP Em processamento
	// CON Concluido processamento
	// REJ Rejeitada
	// REI Reinspecionar
	// SEG Segregada
	// CNF Concluida NF

	// Analisa situacao do arquivo de integracao com medidor de grau
	_sZZAAtual = ::StatusZZA ()

	// Define o que vai enviar para o NaWeb
	_sStatPara = ''
	if _lContinua
		do case
		case ::Segregada
			_sStatPara = 'SEG'  // Segregada
		case ! empty (::Contranota)
			_sStatPara = 'CNF'  // Concluida NF
		case _sZZAAtual == '3'
			_sStatPara = 'CON'  // Processamento concluido
		case _sZZAAtual == '2'  // Muito provavelmente o NaWeb vai ver isso bem antes que o Protheus
			_sStatPara = 'EMP'  // Em processamento
		case ::PesoBruto > 0
			_sStatPara = 'LIB'  // Liberada (para ir ate o tombador e descarregar)
		otherwise
			u_help ("Situacao nao prevista. Nao sei o que enviar para o NaWeb para definir o status da carga " + ::Carga,, .T.)
			U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + ']_sZZAAtual: ' + cvaltochar (_sZZAAtual))
			u_logObj (::Self)
			_lContinua = .F.
		endcase
	endif

	if _lContinua
		_sXMLCarg := '<?xml version="1.0" encoding="utf-8"?>'
		_sXMLCarg += '<SDT_Cargas>'
		_sXMLCarg +=    '<Itens>'
		_sXMLCarg +=    '<Filial>'   + ::Filial   + '</Filial>'
		_sXMLCarg +=    '<Safra>'    + ::Safra    + '</Safra>'
		_sXMLCarg +=    '<Carga>'    + ::Carga    + '</Carga>'
		_sXMLCarg +=    '<Situacao>' + _sStatPara + '</Situacao>'
		_sXMLCarg +=    '</Itens>'
		_sXMLCarg += '</SDT_Cargas>'

		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sXMLCarg)
		
		_oWSNaWeb := WSPrcStatusAgendaSafraWS():New()
		_oWSNaWeb:cEntrada := _sXMLCarg
		_oWSNaWeb:Execute()
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retorno do NaWeb: ' + CVALTOCHAR (_oWSNaWeb:cSaida))

		if cvaltochar (_oWSNaWeb:cSaida) == 'OK'
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Alteracao da carga foi aceita pelo NaWeb')
			_lRetWSNA = .T.

			// Grava evento para posterior rastreamento
			::GrvEvt ('SZE004', "Enviado novo status (" + _sStatPara + ") para o NaWeb.")
		else
			::UltMsg += "Alteracao da carga '" + ::Carga + "' nao foi aceita pelo NaWeb: " + cvaltochar (_oWSNaWeb:cSaida)
			u_help (::UltMsg,, .t.)
			_lRetWSNA = .F.

			// Grava evento para posterior rastreamento
			::GrvEvt ('SZE004', "ERRO ao enviar novo status (" + _sStatPara + ") para o NaWeb: " + ::UltMsg)
		endif
	endif
return _lRetWSNA


// --------------------------------------------------------------------------
// Envia atualizacao para o sistema de medicao de grau.
METHOD AtuZZA (_lReenvio) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _lRetAtZZA := .T.
	local _nItem     := 0
	local _sChaveZZA := ''

	// Possiveis situacoes para o campo ZZA_STATUS:
	// 0 = carga cadastrada no Protheus, ainda nao pesada. Programa BL01 ignora-a;
	// 1 = carga com 1a.pesagem pronta, pode descarregar. Programa BL01 lista-a para o usuario ao clicar no botao 'Filial/Safra/Carga';
	// 2 = carga selecionada pelo usuario no programa BL01. Estah pronto para medir grau, ou jah medindo;
	// 3 = usuario clicou botao 'Armazenar' no programa BL01 e jah gravou tambem o ZZA_GRAU.
	// M = usuario (do Protheus) finalizou manualmente (ZZA_STATUS nao estava 3 por algum motivo).
	// C = Carga cancelada no Protheus

	if _lRetAtZZA .and. ::PesoBruto <= 0
		u_help ("Carga ainda nao tem peso bruto. Efetue, antes, a primeira pesagem.",, .t.)
		_lRetAtZZA = .F.
	endif
	if _lRetAtZZA .and. ::StatusCar $ 'R/N/D/C'  // 1=Primeira pesagem OK;2=Segunda pesagem OK;R=Recibo impresso;N=NF gerada;D=Redirecionada;C=Cancelada
		u_help ("Status da carga nao permite mais ser reenviada para leitura de grau.",, .t.)
		_lRetAtZZA = .F.
	endif
	if _lRetAtZZA .and. ::Aglutin $ 'D/O'
		u_help ("Esta eh uma carga aglutinada ou aglutinadora. Nao pode mais ser enviada para o grau.",, .t.)
		_lRetAtZZA = .F.
	endif
	if _lRetAtZZA
		zza -> (dbsetorder (1))  // ZZA_FILIAL, ZZA_SAFRA, ZZA_CARGA, ZZA_PRODUT
		for _nItem = 1 to len (::ItItem)
			_sChaveZZA = U_TamFixo (::Filial, 2) + U_TamFixo (::Safra, 4) + U_TamFixo (::Carga, 4) + U_TamFixo (::ItItem [_nItem], 15)
			U_Log2 ('debug', '[' + procname () + ']Pesqusando ZZA com >>' + _sChaveZZA + '<<')
		
			if ! zza -> (dbseek (_sChaveZZA, .F.))
				u_log2 ('info', '[' + procname () + ']Carga:' + ::Carga + ' Item: ' + ::ItItem [_nItem] + ' Incluindo ZZA')
				reclock ("ZZA", .T.)
				// Se nao existia ZZA, nem vou tratar como reenvio.
				_lReenvio = .F.
			else
				u_log2 ('info', '[' + procname () + ']Carga:' + ::Carga + ' Item: ' + ::ItItem [_nItem] + ' Vou alterar ZZA (zza_status encontra-se com ' + zza -> zza_status + ')')
				reclock ("ZZA", .F.)
			endif

			// Campos 'basicos' sao atualizados sempre.
			zza -> zza_filial = ::Filial
			zza -> zza_safra  = ::Safra
			zza -> zza_carga  = ::Carga
			zza -> zza_produt = ::ItItem [_nItem]
			zza -> zza_nprod  = ::ItDescri [_nItem]
			zza -> zza_nassoc = ::NomeFornec

			// Quando solicitado reenvio manualmente, faz algumas verificacoes adicionais.
			if _lReenvio
				if zza -> zza_status == '1'
					u_help ("Status do item " + zza -> zza_nprod + " ja encontra-se como 'aguardando leitura do grau'.",, .t.)
				elseif zza -> zza_status == '0' .or. (zza -> zza_status == '2' .and. U_MsgNoYes ("Item " + zza -> zza_nprod + " encontra-se com status 'em descarga' na tabela de integracao com medidor de grau. Deseja reiniciar o status?"))
					zza -> zza_status = iif (::PesoBruto <= 0, '0', '1')

				elseif zza -> zza_status $ '3/M'
					_sMsg = "Status do item " + zza -> zza_nprod + " encontra-se 'concluido' na tabela de integracao com o medidor de grau (resultado: " + cvaltochar (zza -> zza_grau) + " gravado em " + zza -> zza_inist3 + "."
					
					// Se foi gravado com grau zero, deve ter dado algum problema, ou clicaram em 'armazenar' sem medir nada.
					if zza -> zza_grau = 0
						if u_msgNoYes (_sMsg + " Deseja reenviar para nova medicao?")
							zza -> zza_status = iif (::PesoBruto <= 0, '0', '1')
						endif
					else
						u_help (_sMsg + " Reenvio para medicao de grau nao permitida, pois ja contem valor no grau.")
					endif
				endif
			else

				if ::StatusCar $ 'C/D'  // Carga [C]ancelada ou [D]irecionada para outra filial
					zza -> zza_status = 'C'
				elseif ::PesoBruto == 0
					zza -> zza_status = '0'
				elseif ::PesoTara > 0 .and. zza -> zza_status != '3' .and. val (::ItGrau [_nItem]) > 0  // Jah fez a segunda pesagem, sem finalizar no BL01.
					u_log2 ('info', '[' + procname () + ']Carga:' + ::Carga + ' Item: ' + ::ItItem [_nItem] + ' Alterando ZZA_STATUS para M por que jah estah sendo feita a segunda pesagem, mesmo sem finalizar no programa do grau.')
					zza -> zza_status = 'M'
				elseif ::PesoBruto > 0 .and. ::PesoTara == 0
					if empty (zza -> zza_status) .or. zza -> zza_status == '0'
						zza -> zza_status = '1'
					endif
				elseif ::PesoBruto > 0 .and. ::PesoTara > 0 .and. zza -> zza_status == '3'  // Segunda pesagem OK
					u_log2 ('aviso', "Nao vou enviar nada para o programa do grau por que, no grau, esta carga jah encontra-se com status=3 (finalizada)")
				else
					u_help ("Situacao imprevista na gravacao do campo ZZA_STATUS. Revise programa!",, .t.)
				endif
			endif
			msunlock ()
		next
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRetAtZZA


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD DefImprTk (_sFilial, _sCamFixo) Class ClsCarSaf
	//local _sIdImpr := ''

	_sFilial = iif (empty (_sFilial), ::Filial, _sFilial)

	if ! empty (_sCamFixo)
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Recebi um caminho fixo para impressora: ' + _sCamFixo)
		::PortImpTk = _sCamFixo
	else
		// Se for base teste, evita enviar para a impressora padrao para nao causar confusao com a safra normal.
		if U_AmbTeste()
			::PortImpTk := '\\192.168.1.3\siga\ticket.txt'
			U_Log2 ('aviso', '[' + GetClassName (::Self) + '.' + procname () + ']Ambiente de TESTE. Vou redirecionar o ticket para ' + ::PortImpTk)
		else
			::PortImpTk = GetMV ("VA_ITKSAFR")
			U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']::PortImTk = ' + ::PortImpTk + ' (lido do parametro VA_ITKSAFR)')
		endif
	endif
return


// --------------------------------------------------------------------------
// Faz o enderecamento (ou estorno)dos lotes de uva no estoque
METHOD EnderEstq (_sQueFazer) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _aAmbAnt   := U_SalvaAmb ()
	local _oSQL      := NIL
	local _aRegSDA   := {}
	local _nRegSDA   := 0
	local _aAutoSDA  := {}
	local _aAutoSDB  := {}
	local _aLinhaSDB := {}
	local _sFiltrSDA := ''
	local _lContinua := .T.

	// Se for estorno, filtra a tabela e chama tela padrao do sistema.
	// O usuario deverah clicar no botao 'estornar'.
	if _sQueFazer == 'E'  // Estornar
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Chamando tela estorno enderecamento docto ' + ::Contranota)
		oGetD := NIL
		nOpcA := 0
		aHeader := NIL
		aCols := NIL
		N := 1
		aRotina := NIL
	//	u_logobj (::Self)
		_sFiltrSDA := "da_filial='"      + ::Filial     + "'"
		_sFiltrSDA += ".and.da_doc='"    + ::Contranota + "'"
		_sFiltrSDA += ".and.da_serie='"  + ::SerieCtrn  + "'"
		_sFiltrSDA += ".and.da_clifor='" + ::Fornece    + "'"
		_sFiltrSDA += ".and.da_loja='"   + ::Loja       + "'"
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sFiltrSDA)
 		dbselectarea ("SDA")
		set filter to &(_sFiltrSDA)
		MATA265 ()
		dbselectarea ("SDA")
		set filter to

	elseif _sQueFazer == 'I'  // Incluir

		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Iniciando enderecamento docto ' + ::Contranota)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT SDA.R_E_C_N_O_"
		
		// Posso estar reenderecando uma nota. Nesse caso, preciso gerar o
		// campo DB_ITEM maior que 0001.
		_oSQL:_sQuery +=      " ,ISNULL ((SELECT MAX (DB_ITEM)
		_oSQL:_sQuery +=                  " FROM " + RetSQLName ("SDB") + " SDB "
		_oSQL:_sQuery +=                 " WHERE SDB.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=                   " AND SDB.DB_FILIAL = SDA.DA_FILIAL"
		_oSQL:_sQuery +=                  " AND SDB.DB_PRODUTO = SDA.DA_PRODUTO"
		_oSQL:_sQuery +=                  " AND SDB.DB_DOC = SDA.DA_DOC"
		_oSQL:_sQuery +=                  " AND SDB.DB_SERIE = SDA.DA_SERIE"
		_oSQL:_sQuery +=                  " AND SDB.DB_CLIFOR = SDA.DA_CLIFOR"
		_oSQL:_sQuery +=                  " AND SDB.DB_LOJA = SDA.DA_LOJA"
		_oSQL:_sQuery +=                  " AND SDB.DB_LOTECTL = SDA.DA_LOTECTL"
		_oSQL:_sQuery +=                  " AND SDB.DB_NUMSEQ = SDA.DA_NUMSEQ"
		_oSQL:_sQuery +=                  " AND SDB.DB_ORIGEM = SDA.DA_ORIGEM), '0000')"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD1") + " SD1, "
		_oSQL:_sQuery +=             RetSQLName ("SDA") + " SDA "
		_oSQL:_sQuery += " WHERE SD1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SD1.D1_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_DOC     = '" + ::Contranota + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_SERIE   = '" + ::SerieCtrn + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_FORNECE = '" + ::Fornece + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_LOJA    = '" + ::Loja + "'"
		_oSQL:_sQuery +=   " AND SDA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SDA.DA_FILIAL  = SD1.D1_FILIAL"
		_oSQL:_sQuery +=   " AND SDA.DA_DOC     = SD1.D1_DOC"
		_oSQL:_sQuery +=   " AND SDA.DA_SERIE   = SD1.D1_SERIE"
		_oSQL:_sQuery +=   " AND SDA.DA_CLIFOR  = SD1.D1_FORNECE"
		_oSQL:_sQuery +=   " AND SDA.DA_LOJA    = SD1.D1_LOJA"
		_oSQL:_sQuery +=   " AND SDA.DA_ORIGEM  = 'SD1'"
		_oSQL:_sQuery +=   " AND SDA.DA_NUMSEQ  = SD1.D1_NUMSEQ"
		_oSQL:_sQuery +=   " AND SDA.DA_PRODUTO = SD1.D1_COD"
		_oSQL:_sQuery +=   " AND SDA.DA_SALDO   > 0"
		_oSQL:Log ()
		_aRegSDA = _oSQL:Qry2Array (.F., .F.)
		if len (_aRegSDA) == 0
			u_help ("Nenhum produto com saldo a enderecar para esta carga/contranota.")
		endif
		for _nRegSDA = 1 to len (_aRegSDA)
			sda -> (dbgoto (_aRegSDA [_nRegSDA, 1]))
			_aAutoSDA = {}
			aadd (_aAutoSDA, {"DA_PRODUTO", sda -> da_produto, nil})
			aadd (_aAutoSDA, {"DA_LOCAL"  , SDA -> DA_LOCAL    , nil})
			aadd (_aAutoSDA, {"DA_NUMSEQ" , SDA -> DA_NUMSEQ   , nil})
			aadd (_aAutoSDA, {"DA_DOC"    , SDA -> DA_DOC      , nil})
			aadd (_aAutoSDA, {"DA_SERIE"  , SDA -> DA_SERIE    , nil})

			_aAutoSDB = {}
			_aLinhaSDB = {}
		//	aadd (_aLinhaSDB, {"DB_ITEM", '0001', nil})
			aadd (_aLinhaSDB, {"DB_ITEM", Soma1 (_aRegSDA [_nRegSDA, 2]), nil})
			if ::Filial == '01'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T01PCP03       ', nil})
			elseif ::Filial == '03'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T03 PCP AX 03  ', nil})
			elseif ::Filial == '07'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T07 PCP 03     ', nil})
			elseif ::Filial == '09'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T09 PCP AX 03  ', nil})
			endif
			aadd (_aLinhaSDB, {"DB_QUANT"  , SDA->DA_QTDORI   , nil})
			aadd (_aLinhaSDB, {"DB_DATA"   , dDATABASE        , nil})
			U_Log2 ('info', 'Enderecando docto ' + sda -> da_doc + ' / produto ' + sda -> da_produto)
			_aLinhaSDB = aclone (U_OrdAuto (_aLinhaSDB))
			aadd (_aAutoSDB, aclone (_aLinhaSDB))
			lMsErroAuto := .F.
			MSExecAuto({|x,y,z| mata265(x,y,z)}, _aAutoSDA, _aAutoSDB, 3)
			If lMsErroAuto
				u_log2 ('erro', 'lMsErroAuto')
				if ! empty (NomeAutoLog ())
					u_log2 ('erro', memoread (NomeAutoLog ()))
					MostraErro()
				else
					u_help ("Nao foi possivel ler o arquivo de log de erros da rotina de enderecamento de uva no estoque.",, .t.)
				endif
			endif
		next
	else
		u_help ('Sem tratamento para acao ' + _sQueFazer,, .t.)
	endif

	U_SalvaAmb (_aAmbAnt)
	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sOrigem) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _lContinua := .T.
	local _nItemGD   := 0

	// Defaults
	::aIntegGrau   = {}
	::Aglutin    = ''
	::Carga      = ''
	::Contranota = ''
	::Compart1   = ''
	::Compart2   = ''
	::CXouGranel = ''
	::Filial     = ''
	::Fornece    = ''
	::ItItem     = {}
	::ItProduto  = {}
	::ItDescri   = {}
	::ItGrau     = {}
	::Loja       = ''
	::NomeFornec = ''
	::PesoBruto  = 0
	::PesoTara   = 0
	::RegSZE     = 0
	::Safra      = ''
	::Segregada  = .F.
	::SerieCtrn  = ''
	::StatusCar  = ''
	::UltMsg     = ''

	do case
	case _sOrigem == 'M'  // Variaveis M->
		::Filial     = xfilial ("SZE")
		::Aglutin    = m->ze_aglutin
		::Safra      = m->safra
		::Carga      = m->carga
		::Compart1   = m->ze_cargaC1
		::Compart2   = m->ze_cargaC2
		::Contranota = m->ze_nfger
		::Fornece    = m->ze_assoc
		::Loja       = m->ze_lojasso
		::NomeFornec = m->ze_nomasso
		::PesoBruto  = m->ze_pesobru
		::PesoTara   = m->ze_pesotar
		::Segregada  = (m->ze_segreg == 'S')
		::SerieCtrn  = m->ze_serie
		::StatusCar  = m->ze_status

		// Alimenta array de itens
		for _nItemGD = 1 to len (aCols)
			::AddItem ()
			atail (::ItItem)    = GDFieldGet ("ZF_ITEM",    _nItemGD)
			atail (::ItProduto) = GDFieldGet ("ZF_PRODUTO", _nItemGD)
			atail (::ItDescri)  = GDFieldGet ("ZF_DESCRI",  _nItemGD)
			atail (::ItGrau)    = GDFieldGet ("ZF_GRAU",    _nItemGD)
		next

	case _sOrigem == "SZE"
		::Aglutin    = sze -> ze_aglutin
		::Carga      = sze -> ze_carga
		::Filial     = sze -> ze_filial
		::Compart1   = sze -> ze_cargaC1
		::Compart2   = sze -> ze_cargaC2
		::Contranota = sze -> ze_nfger
		::Fornece    = sze -> ze_assoc
		::Loja       = sze -> ze_lojasso
		::NomeFornec = sze -> ze_nomasso
		::PesoBruto  = sze -> ze_pesobru
		::PesoTara   = sze -> ze_pesotar
		::RegSZE     = sze -> (recno ())
		::Safra      = sze -> ze_safra
		::Segregada  = (sze -> ze_segreg == 'S')
		::SerieCtrn  = sze -> ze_serie
		::StatusCar  = sze -> ze_status

		// Alimenta array de itens
		szf -> (dbsetorder (1))  // filial + safra + carga + item
		szf -> (dbseek (xfilial ("SZF") + sze -> ze_safra + sze -> ze_carga, .T.))
		do while ! szf -> (eof ()) ;
			.and. szf -> zf_filial == xfilial ("SZF") ;
			.and. szf -> zf_safra  == sze -> ze_safra ;
			.and. szf -> zf_carga  == sze -> ze_carga

			::AddItem ()
			atail (::ItItem)    = szf -> zf_item
			atail (::ItProduto) = szf -> zf_produto
			atail (::ItDescri)  = fBuscaCpo ("SB1", 1, xfilial ("SB1") + szf -> zf_produto, "B1_DESC")
			atail (::ItGrau)    = szf -> zf_grau

			szf -> (dbskip ())
		enddo

	otherwise
		if ! empty (_sOrigem)  // Se origem vazia, eh por que estou apenas instanciando um objeto vazio.
			::UltMsg += "Impossivel gerar atributos. Origem '" + _sOrigem + "' desconhecida."
			u_help (::UltMsg,, .t.)
		endif
		_lContinua = .F.
	endcase

	if _lContinua
		::CxOuGranel = iif (::Filial == '03', 'C', 'G')  // Somente Livramento ainda recebe em caixas
	endif

	// Alimenta array de informacoes da tabela de integracao com medidor de grau.
	if _lContinua .and. ! empty (::Filial) .and. ! empty (::Safra) .and. ! empty (::Carga)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT ZZA_PRODUT, ZZA_STATUS, ZZA_GRAU"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZZA") + " ZZA"
		_oSQL:_sQuery += " WHERE ZZA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_FILIAL = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_SAFRA  = '" + ::Safra + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_CARGA  = '" + ::Carga + "'"
		_oSQL:_sQuery += " ORDER BY ZZA.ZZA_PRODUT"  // zza_produt = zf_item
		//_oSQL:_sQuery +=   " AND ZZA.ZZA_PRODUT = '01'"  // Tenho intencao de comecar a gravar apenas 1 item por carga, independentemente de haver mais de uma variedade.
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		::aIntegGrau := aclone (_oSQL:Qry2Array (.F., .F.))
//		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']aIntegGrau:')
//		U_Log2 ('debug', ::aIntegGrau)
	endif

	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Grava evento padrao do sistema.
METHOD GrvEvt (_sCodEvt, _sTxtEvt) Class ClsCarSaf
	local _oEvento := NIL

	_oEvento := ClsEvent():new ()
	_oEvento:CodEven   = _sCodEvt
	_oEvento:Texto    := 'Safra ' + ::Safra + ' Carga ' + ::Carga + ' ' + _sTxtEvt
	_oEvento:Recno     = ::RegSZE
	_oEvento:Alias     = 'SZE'
	_oEvento:CodAlias  = ::Safra + ::Carga
	_oEvento:NFEntrada = ::Contranota
	_oEvento:SerieEntr = ::SerieCtrn
	_oEvento:Fornece   = ::Fornece
	_oEvento:LojaFor   = ::Loja
	_oEvento:Grava ()
return


// --------------------------------------------------------------------------
// Gera (re)impressao do ticket da carga.
METHOD ImprimeTk (_nQualTk) Class ClsCarSaf
	local _nQtVias := 0
	// Se nao especificado qual ticket (1a. ou 2a. pesagem), verifica se quais dados jah tem.
	if empty (_nQualTk)
		_nQualTk = iif (::PesoTara != 0, 2, 1)
	endif
	
	// Producao propria: nao preciso entregar segunda via de ticket a ninguem.
	if ::Fornece == '001369' .and. ::Loja == '02'
		_nQtVias = 1
	else
		_nQtVias := iif (_nQualTk == 1, 1, 2)
	endif

	U_VA_RusTk (_nQualTk, ::PortImpTk, _nQtVias, {}, 'bematech', .t.)

return


// --------------------------------------------------------------------------
// Grava dados da carga em arquivo de log, para ajudar em rastreio de problemas.
METHOD Log () Class ClsCarSaf
	local _sLogCar  := ''
	local _nItCarga := 0

	_sLogCar += '  Filial: ' + ::Filial + ' Safra: ' + ::Safra + ' Carga: ' + ::Carga + chr (13) + chr (10)
	_sLogCar += '  Fornecedor: ' + ::Fornece + '/' + ::Loja + ' - ' + ::NomeFornec + chr (13) + chr (10)
	for _nItCarga = 1 to len (::ItItem)
		_sLogCar += '     '   + ::ItItem [_nItCarga]
		_sLogCar += ' - '   + alltrim (::ItProduto [_nItCarga])
		_sLogCar += ' - '   + alltrim (::ItDescri  [_nItCarga])
		_sLogCar += ' Gr: ' + ::ItGrau [_nItCarga]
		_sLogCar += chr (13) + chr (10)
	next
	U_Log2 ('info', '-----------------------------------------------')
	U_Log2 ('info', _sLogCar)
	U_Log2 ('info', '-----------------------------------------------')
return _sLogCar


// --------------------------------------------------------------------------
// Faz uma analise da integracao com o grau (pode ter mais de um item na carga)
// e procura definir o status do ZZA 'como um todo' para a carga.
METHOD StatusZZA () Class ClsCarSaf
	local _sRetStZZA := ''

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Avaliando carga recebida em ' + ::CXouGranel + ' com registros assim:')
	U_Log2 ('debug', ::aIntegGrau)
	
	// Quando a carga eh recebida em caixas, vale o 'menor' status por
	// que provavelmente cada variedade vai ser processada separadamente.
	if ::CXouGranel == 'C'
		if ascan (::aIntegGrau, {|_aVal| _aVal [2] == 'C'}) > 0
			_sRetStZZA = 'C'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '0'}) > 0
			_sRetStZZA = '0'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '1'}) > 0
			_sRetStZZA = '1'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '2'}) > 0
			_sRetStZZA = '2'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '3'}) > 0
			_sRetStZZA = '3'
		endif

	// Quando a carga eh recebida a granel, vale o 'maior' status por
	// que todas as variedades serao processadas junto. O programa do
	// grau vai dar o retorno em apenas um dos registros.
	elseif ::CXouGranel == 'G'
		if ascan (::aIntegGrau, {|_aVal| _aVal [2] == 'C'}) > 0
			_sRetStZZA = 'C'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '3'}) > 0
			_sRetStZZA = '3'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '2'}) > 0
			_sRetStZZA = '2'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '1'}) > 0
			_sRetStZZA = '1'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '0'}) > 0
			_sRetStZZA = '0'
		endif
		
	else
		u_help ("Conteudo desconhecido (" + ::CXouGranel + ") na analise do status da medicao de grau.")
	endif

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retornando statusZZA = ' + _sRetStZZA + ' para a carga ' + ::Carga)
return _sRetStZZA
