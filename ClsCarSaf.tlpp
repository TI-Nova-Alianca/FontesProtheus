// Programa:  ClsCarSaf
// Autor:     Robert Koch
// Data:      09/10/2022 (inicio)
// Descricao: Declaracao de classe de representacao de carga recebida na safra de uva.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa carga recebida durante safra de uva.
// #PalavasChave      #carga #safra
// #TabelasPrincipais #SZD #SZE
// #Modulos           #COOP

// Historico de alteracoes:
// 17/01/2023 - Robert - Quando producao propria, gera apenas 1 via do ticket 2a.pesagem.
// 20/01/2023 - Robert - Comecado a gravar arrays de itens (ItItem, ItProduto, ...)
// 25/01/2023 - Robert - Criado metodo AtuZZA.
//                     - Metodo New() passa a aceitar tanto recno() como chave filial+safra+carga.
//                     - Metodo SegPesTOk, melhorias gerais
// 03/02/2023 - Robert - Tratamentos para cargas compartilhadas.
//                     - Nao enviava cargas canceladas para o grau (nao alterava ZZA_STATUS para C).
// 08/02/2023 - Robert - Implementado metodo SegregarLt().
// 22/02/2023 - Robert - Gravacao evento passa a tratar novos atributos ClsEvent:Safra e ClsEvent:CargaSafra.
// 13/03/2023 - Robert - Eliminadas algumas linhas comentariadas; eventos deixam de gravar chave=safra+carga
// 29/04/2023 - Robert - Metodo VarMenorVl() passa a receber parametro indicando qual preco deve verificar.
//                     - Trocadas diversas chamadas de xfilial() por ::Filial.
// 13/11/2023 - Robert - Passa a herdar a chasse ClsBase para uso de metodos mais padronizados.
// 18/11/2023 - Robert - Versao inicial do metodo :PodeGravar().
// 01/01/2024 - Robert - Criado metodo :FormataGrau().
// 16/01/2024 - Robert - Exclusao de carga marcava o ZZA como deletado, mas precisa excluir de verdade.
// 23/01/2024 - Robert - Melhorado envio de atualizacao de agenda para NaWeb (algumas validacoes e mensagens) - GLPI 14778
// 02/02/2024 - Robert - Filial 01 passa a receber viniferas com clas.A/B/D (conversa pelo Whats com Andre Gasperin)
// 03/02/2024 - Robert - Logs diversos para rastrear gravação do ZZA (GLPI 14858)
// 10/02/2024 - Robert - Metodo Precifica() passa a fazer queries em vez de DbSeek()
//                       e deixa de validar sistema de conducao das uvas comuns.
// 12/02/2024 - Robert - Gravar evento quando usuario confirmar reenvio para grau (ocorre em determinadas situacoes)
// 20/02/2024 - Robert - Metodo :Precifica() nao considerava variedade de menor valor quando havia mistura de variedades!
//

#Include "Protheus.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsCarSaf ()
return


// ==========================================================================
CLASS ClsCarSaf from ClsBase

	// Declaracao das propriedades da Classe
	public  data aIntegGrau  // Registros referentes a esta carga na tabela ZZA (integracao com leitor de grau)
	public  data Aglutin     // ZE_AGLUTIN - Situacao quanto a aglutinacao de cargas: O=Origem (aglutinada em outra carga);D=Destino (aglutinadora);N=Nenhuma(carga normal)
	public  data AxEntrada   // Almoxarifado para onde devem ser geradas as NF de entrada da uva
	public  data Carga       // ZE_CARGA
	public  data CXouGranel  // Indica se recebe em caixas ou a granel (tombador)
	public  data CCompart    // ZE_CCompar - array de cargas compartilhadas (mesmo veiculo)
	public  data Contranota  // ZE_NFGER
	public  data Filial      // ZE_FILIAL
	public  data Fornece     // ze_assoc
	public  data GrupoPagamento   // Grupo A/B/C para parcelamento de pagamento da safra
	public  data ItClasEspaldeira // Array de Itens da carga - Classificao quando conducao em espaldeira
	public  data ItClasLatada     // Array de Itens da carga - Classificao quando conducao em latada
	public  data ItConducao       // Array de Itens da carga - Forma de conducao: [L]atada;[E]spaldeira
	public  data ItCor            // Array de Itens da carga - [T]inta;[B]ranca;[R]osada
	public  data ItDescri         // Array de Itens da carga - Descricao do produto
	public  data ItFinaOuComum    // Array de Itens da carga - [F]ina ou [C]omum
	public  data ItGrau           // Array de Itens da carga - zf_grau
	public  data ItItem           // Array de Itens da carga - zf_item
	public  data ItOrganica       // Array de Itens da carga - [C]onvencional/[O]rganica/[B]ordadura/[E]m conversao
	public  data ItObs            // Array de Itens da carga - Possiveis observacoes ref.calculo de preco.
	public  data ItPrcBase        // Array de Itens da carga - preco unitario para contranota
	public  data ItPrcParaNF      // Array de Itens da carga - preco unitario para contranota
	public  data ItProduto        // Array de Itens da carga - zf_produto
	public  data ItPropRur        // Array de Itens da carga - Codigo propriedade rural (antigo 'cadastro viticola')
	public  data Loja        // ze_lojasso
	public  data NomeFornec  // A2_NOME - nome do fornecedor
	public  data PesoBruto   // ZE_PESOBRU
	public  data PesoTara    // ZE_PESOTAR
	public  data PortImpTk   // Porta / caminho para impressao do ticket
	public  data TipoPrecoParaNF   // Indica qual (nao QUANTO) eh o preco para gerar contranota: 1=entrada (em desuso);2=compra;5=MOC;6=Cfe.atributo :TabelaPreco
	public  data RecebeOrg   // Indica se esta filial recebe uvas organicas
	public  data RecebeVini  // Indica se esta filial recebe uvas vifniferas
	public  data RegSZE      // recno() da tabela SZE.
	public  data Safra       // ZE_SAFRA
	public  data Segregada   // ZE_SEGREG
	public  data SerieCtrn   // ze_serie
	public  data StatusCar   // ze_status
	public  data TabelaPreco // Codigo da tabela de precos a ser buscada no arquivo ZBI
	public  data VariedadeMenorValorCodigo // Codigo da variedade de menor valor (em caso de mistura ou carga compartilhada)
	public  data VariedadeMenorValorConducao // Forma de conducao da variedade de menor valor (em caso de mistura ou carga compartilhada)

	// Declaracao dos Metodos da classe
	public METHOD New ()
	public METHOD AddItem ()    // Adiciona uma posicao nas arrays de itens
	public METHOD AtuAgenda ()  // Envia atualizacao para o sistema de agendamento
	public METHOD AtuZZA ()     // Envia atualizacao para o programa de medicao de grau
	public METHOD BuscaGrupoPagto () // Define em qual grupo de pagamento a carga deve ser enquadrada.
	public METHOD BuscaVarMenorVl () // Identifica a variedade de menor valor
	public METHOD ConsCompar () // Gera string bonitinha para consulta de compartilhamentos com outras cargas.
	public METHOD DefImprTk ()  // Define porta para impressao do ticket
	public METHOD GeraAtrib ()
	public METHOD EnderEstq ()  // Enderecar (ou estornar) estoque
	public METHOD ExclDef ()    // Exclusao definitiva (inclusive tabelas relacionadas)
	static METHOD FormataGrau ()  //Recebe o grau como numerico e retorna formatado em caracter.
	public METHOD GrvEvt ()
	public METHOD ImprimeTk ()  // Gera impressao do ticket
	public METHOD Log ()
	public METHOD PodeGravar ()   // Verifica se tudo ok para gravacao.
	public METHOD Precifica_ant ()    // Calcula os precos unitarios para usar na contranota.
	public METHOD Precifica ()    // Calcula os precos unitarios para usar na contranota.
	public METHOD SegPesTOk ()  // Verifica se 'tudo ok' com a segunda pesagem.
	public METHOD SegregarLt () // Segregar lote de estoque (mudar para lote 'NC')
	public METHOD SomaObsItem ()  // Acrescenta mensagem na obs do item.
	public METHOD StatusZZA ()
	public METHOD TodasComp ()  // Gera lista de todas as cargas compartilhadas com a atual.
ENDCLASS


// --------------------------------------------------------------------------
// Construtor da classe.
METHOD New (_xChvCar) Class ClsCarSaf
	local _aAreaAnt := U_ML_SRArea ()

	// Defaults (estou pensando em puxar todos do metodo GeraAtrib para ca.
	::PortImpTk   = ''

	// Alimenta atributos com valores default de uma carga nova.
	::GeraAtrib ("")

	// Como o metodo GeraAtrib eh chamado de varios lugares depois que o objeto
	// jah foi instanciado, achei que seria desnecessario ler novamente algumas
	// coisas que apenas degradariam a performance, entao jah vou deixar setadas
	// aqui. Havendo necessidades especificas, poderao ser alteradas depois.
	::DefImprTk ()

	// Se receber valor numerico, eh por que se trata do numero de registro do SZE.
	if valtype (_xChvCar) == "N" .and. _xChvCar > 0
		SZE -> (dbgoto (_xChvCar))
		::GeraAtrib ("SZE")

	// Se receber caracter, eh por que se trata de um codigo jah
	// existente nas tabelas, e preciso atualizar o objeto.
	elseif valtype (_xChvCar) == "C"
		sze -> (dbsetorder (1))  // ZE_FILIAL, ZE_SAFRA, ZE_CARGA, R_E_C_N_O_, D_E_L_E_T_
		if sze -> (dbseek (_xChvCar, .F.))
			::GeraAtrib ("SZE")
		else
			_Super:SomaMsg ("Problema ao instanciar carga: Nao localizei chave '" + _xChvCar + "' na tabela SZE.")
			U_help (::UltMsg,, .t.)
		endif
	endif

//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Instanciada carga p/ Filial ' + ::Filial + ' Safra ' + ::Safra + ' Carga ' + ::Carga + ' de ' + ::Fornece + '/' + ::Loja)
	U_ML_SRArea (_aAreaAnt)
Return ::self


// --------------------------------------------------------------------------
// Adiciona uma posicao em cada array de itens. Ao criar novo atributo ::It*
// deve-se adicionar tratamento aqui.
METHOD AddItem () Class ClsCarSaf
	aadd (::ItClasEspaldeira, '')
	aadd (::ItClasLatada,     '')
	aadd (::ItConducao,       '')
	aadd (::ItCor,            '')
	aadd (::ItDescri,         '')
	aadd (::ItFinaOuComum,    '')
	aadd (::ItItem,           '')
	aadd (::ItGrau,           '')
	aadd (::ItObs,            '')
	aadd (::ItOrganica,       '')
	aadd (::ItPrcBase,        0)
	aadd (::ItPrcParaNF,      0)
	aadd (::ItProduto,        '')
	aadd (::ItPropRur,        '')
return


// --------------------------------------------------------------------------
static function _Arr2Str (_a)
	local _n := 0
	local _sRet := ''
	for _n = 1 to len (_a)
		_sRet += cvaltochar (_a [_n]) + iif (_n < len (_a), '/', '')
	next
return _sRet


// --------------------------------------------------------------------------
// Altera o status do agendamento relacionado a esta carga na agenda do NaWeb.
METHOD AtuAgenda (_sStatPara) Class ClsCarSaf
	local _oWSNaWeb  := NIL
	local _sXMLCarg  := ''
	local _lContinua := .T.
	local _sZZAAtual := ''
	local _sStatAtu  := ''
	local _oSQL      := NIL
	local _sLinkSrv  := U_LkServer ('NAWEB')

	// Lista de status passados pela Daiana em 26/10/22:
	// Dis Disponível
	// AGE Agendado
	// RES Reservado
	// INS Inspecionado
	// AUT Autorizada entrada
	// LIB Liberada
	// EMP Em processamento
	// CON Concluido processamento
	// REJ Rejeitada
	// REI Reinspecionar
	// SEG Segregada
	// CNF Concluida NF

	// Obs. ref. status de cargas compartilhadas, sendo uma delas segregada:
	// Questionei o Leonardo (agronomia) assim: "posso assumir que em caso de
	// cargas compartilhadas, se uma carga for segregada, obrigatoriamente a
	// outra tambem deve ser, pois as uvas foram misturadas no transporte?"
	// Ele me explicou que, fisicamente, de fato as uvas sao misturadas. Mas
	// ocorre caso de problemas somente na documentacao, etc. e o outro
	// produtor nao merece a mesma penalidade. Robert, 02/02/2023.

	if _lContinua .and. ::Segregada
		_Super:SomaMsg ("Carga segregada. Nao atualizarei mais o status no NaWeb.")
		_lContinua = .F.
	endif

	if _lContinua .and. empty (_sLinkSrv)
		_Super:SomaMsg ("Linked server para o NaWeb nao definido.")
		_lContinua = .F.
	endif

	if _lContinua

		// Analisa situacao do arquivo de integracao com medidor de grau
		_sZZAAtual = ::StatusZZA ()

		// Define o que vai enviar para o NaWeb
		_sStatPara = ''
		do case
		case ::Segregada
			_sStatPara = 'SEG'  // Segregada
		case ! empty (::Contranota)
			_sStatPara = 'CNF'  // Concluida NF
		case _sZZAAtual == '3'
			_sStatPara = 'CON'  // Processamento concluido
		case _sZZAAtual == '2'  // Muito provavelmente o NaWeb vai ver isso bem antes que o Protheus
			_sStatPara = 'EMP'  // Em processamento
		case ::PesoBruto > 0
			_sStatPara = 'LIB'  // Liberada (para ir ate o tombador e descarregar)
		otherwise
			u_help ("Situacao nao prevista. Nao sei o que enviar para o NaWeb para definir o status da carga " + ::Carga,, .T.)
			_Super:SomaMsg ("Situacao nao prevista. Nao sei o que enviar para o NaWeb para definir o status da carga")
			U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + ']_sZZAAtual: ' + cvaltochar (_sZZAAtual))
			u_logObj (::Self)

			// Grava evento para posterior rastreamento
			::GrvEvt ('SZE004', "Situacao nao prevista. Nao sei o que enviar para o NaWeb para definir o status da carga", 360)

			_lContinua = .F.
		endcase
	endif

	// Valida algumas coisas cfe. status atual da agenda
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery += " SELECT SITUACAO"
		_oSQL:_sQuery +=   " FROM " + _sLinkSrv + ".VA_VINSPECOES_SAFRA_" + ::Safra
		_oSQL:_sQuery +=  " WHERE SAFRA  = '" + ::Safra  + "'"
		_oSQL:_sQuery +=    " AND FILIAL = '" + ::Filial + "'"
		_oSQL:_sQuery +=    " AND CARGA  = '" + ::Carga  + "'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_sStatAtu = alltrim (upper (_oSQL:RetQry (1, .f.)))
		U_Log2 ('debug', '[' + procname () + ']Situacao retornada pela view VA_VINSPECOES_SAFRA: ' + _sStatAtu)
		if ! empty (_sStatAtu)
			if _sStatAtu == 'SEG' .and. _sStatPara != 'SEG'
				_Super:SomaMsg ("Carga ja consta com status " + _sStatAtu + " no NaWeb e nao pode mais ser alterada.")
				_lContinua = .F.
			endif
		endif
	endif

	if _lContinua
		_sXMLCarg := '<?xml version="1.0" encoding="utf-8"?>'
		_sXMLCarg += '<SDT_Cargas>'
		_sXMLCarg +=    '<Itens>'
		_sXMLCarg +=    '<Filial>'   + ::Filial   + '</Filial>'
		_sXMLCarg +=    '<Safra>'    + ::Safra    + '</Safra>'
		_sXMLCarg +=    '<Carga>'    + ::Carga    + '</Carga>'
		_sXMLCarg +=    '<Situacao>' + _sStatPara + '</Situacao>'
		_sXMLCarg +=    '</Itens>'
		_sXMLCarg += '</SDT_Cargas>'

		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sXMLCarg)
		
		_oWSNaWeb := WSPrcStatusAgendaSafraWS():New()
		_oWSNaWeb:cEntrada := _sXMLCarg
		_oWSNaWeb:Execute()
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retorno do NaWeb: ' + CVALTOCHAR (_oWSNaWeb:cSaida))

		if cvaltochar (_oWSNaWeb:cSaida) == 'OK'
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Alteracao da carga foi aceita pelo NaWeb')

			// Grava evento para posterior rastreamento
			::GrvEvt ('SZE004', "Enviado novo status (" + _sStatPara + ") para o NaWeb", 360)

			_lContinua = .T.
		else
		//	::UltMsg += "Alteracao da carga '" + ::Carga + "' nao foi aceita pelo NaWeb: " + cvaltochar (_oWSNaWeb:cSaida)
			_Super:SomaMsg ("Alteracao da carga '" + ::Carga + "' nao foi aceita pelo NaWeb: " + cvaltochar (_oWSNaWeb:cSaida))
		//	u_help (::UltMsg,, .t.)
			_lContinua = .F.

			// Grava evento para posterior rastreamento
			::GrvEvt ('SZE004', "ERRO ao enviar novo status (" + _sStatPara + ") para o NaWeb: " + ::UltMsg, 360)
		endif
	endif
return _lContinua


// --------------------------------------------------------------------------
// Envia atualizacao para o sistema de medicao de grau.
METHOD AtuZZA (_lReenvio as logical) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _lRetAtZZA := .T.
	local _nItem     := 0
	local _sChaveZZA := ''
	local _sMsgReen  := ''
	local _lConfReen := .f.
//	local _oSQL      := NIL


//	// Estou com o campo ZZA_INIST1 ficando vazio e nao sei onde ocorre... desabilitar este trecho depois!
//	_oSQL := ClsSQL ():New ()
//	_oSQL:_sQuery := ""
//	_oSQL:_sQuery += "SELECT *"
//	_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZZA") + " ZZA"
//	_oSQL:_sQuery += " WHERE ZZA.D_E_L_E_T_ = ''"
//	_oSQL:_sQuery +=   " AND ZZA.ZZA_FILIAL = '" + xfilial ("ZZA") + "'"
//	_oSQL:_sQuery +=   " AND ZZA.ZZA_SAFRA  = '" + ::Safra + "'"
//	_oSQL:_sQuery +=   " AND ZZA.ZZA_CARGA  = '" + ::Carga + "'"
//	_oSQL:_sQuery += " ORDER BY ZZA_FILIAL, ZZA_SAFRA, ZZA_CARGA, ZZA_PRODUT"
//	_aDebugZZA := aclone (_oSQL:Qry2Array (.f., .t.))
//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Entrando no metodo com o ZZA assim:')
//	U_Log2 ('debug', _aDebugZZA)



	// Possiveis situacoes para o campo ZZA_STATUS:
	// 0 = carga cadastrada no Protheus, ainda nao pesada. Programa BL01 ignora-a;
	// 1 = carga com 1a.pesagem pronta, pode descarregar. Programa BL01 lista-a para o usuario ao clicar no botao 'Filial/Safra/Carga';
	// 2 = carga selecionada pelo usuario no programa BL01. Estah pronto para medir grau, ou jah medindo;
	// 3 = usuario clicou botao 'Armazenar' no programa BL01 e jah gravou tambem o ZZA_GRAU.
	// M = usuario (do Protheus) finalizou manualmente (ZZA_STATUS nao estava 3 por algum motivo).
	// C = Carga cancelada no Protheus

//	if _lRetAtZZA .and. ::PesoBruto <= 0 .and. ::StatusCar != 'C'
//		u_help ("Carga ainda nao tem peso bruto. Efetue, antes, a primeira pesagem.",, .t.)
//		_lRetAtZZA = .F.
//	endif
	if _lRetAtZZA .and. ::StatusCar $ 'R/N/D'  // 1=Primeira pesagem OK;2=Segunda pesagem OK;R=Recibo impresso;N=NF gerada;D=Redirecionada;C=Cancelada
		u_help ("Status da carga nao permite mais ser reenviada para leitura de grau.",, .t.)
		_lRetAtZZA = .F.
	endif
	if _lRetAtZZA .and. ::Aglutin $ 'D/O'
		u_help ("Esta eh uma carga aglutinada ou aglutinadora. Nao pode mais ser enviada para o grau.",, .t.)
		_lRetAtZZA = .F.
	endif
	if _lRetAtZZA
		zza -> (dbsetorder (1))  // ZZA_FILIAL, ZZA_SAFRA, ZZA_CARGA, ZZA_PRODUT
		for _nItem = 1 to len (::ItItem)
			_sChaveZZA = U_TamFixo (::Filial, 2) + U_TamFixo (::Safra, 4) + U_TamFixo (::Carga, 4) + U_TamFixo (::ItItem [_nItem], 15)
		//	U_Log2 ('debug', '[' + procname () + ']Pesqusando ZZA com >>' + _sChaveZZA + '<<')
		
			if ! zza -> (dbseek (_sChaveZZA, .F.))
				u_log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Carga:' + ::Carga + ' Item: ' + ::ItItem [_nItem] + ' Incluindo ZZA')
				reclock ("ZZA", .T.)
				_lReenvio = .F.  // // Se nao existia ZZA, nem vou tratar como reenvio.
			else
				u_log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Carga:' + ::Carga + ' Item: ' + ::ItItem [_nItem] + ' Vou alterar ZZA (zza_status encontra-se com ' + zza -> zza_status + ')')
				reclock ("ZZA", .F.)
			endif

			// Campos 'basicos' sao atualizados sempre.
			zza -> zza_filial = ::Filial
			zza -> zza_safra  = ::Safra
			zza -> zza_carga  = ::Carga
			zza -> zza_produt = ::ItItem [_nItem]
			zza -> zza_nprod  = ::ItDescri [_nItem]
			zza -> zza_nassoc = ::NomeFornec

			// Quando solicitado reenvio manualmente, faz algumas verificacoes adicionais.
			if _lReenvio
				U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Reenvio = .T.')
				if zza -> zza_status == '1'
					u_help ("Status do item " + zza -> zza_nprod + " ja encontra-se como 'aguardando leitura do grau'.",, .t.)
//				elseif zza -> zza_status == '0' .or. (zza -> zza_status == '2' .and. U_MsgNoYes ("Item " + zza -> zza_nprod + " encontra-se com status 'em descarga' na tabela de integracao com medidor de grau. Deseja reiniciar o status?"))
				elseif zza -> zza_status == '0'
					zza -> zza_status = iif (::PesoBruto <= 0, '0', '1')
				elseif zza -> zza_status == '2'
					_sMsgReen = "Item " + alltrim (zza -> zza_nprod) + " encontra-se com status 'em descarga' na tabela de integracao com medidor de grau."
					if U_MsgNoYes (_sMsgReen + "Deseja reiniciar o status?")
						zza -> zza_status = iif (::PesoBruto <= 0, '0', '1')
						_lConfReen = .t.
					endif

				elseif zza -> zza_status $ '3/M'
					_sMsg = "Status do item " + alltrim (zza -> zza_nprod) + " encontra-se 'concluido' na tabela de integracao com o medidor de grau (resultado: " + cvaltochar (zza -> zza_grau) + " gravado em " + zza -> zza_inist3 + "."
					
					// Se foi gravado com grau zero, deve ter dado algum problema, ou clicaram em 'armazenar' sem medir nada.
					if zza -> zza_grau = 0
						if u_msgNoYes (_sMsg + " Deseja reenviar para nova medicao?")
							zza -> zza_status = iif (::PesoBruto <= 0, '0', '1')
							_sMsgReen = _sMsg
							_lConfReen = .t.
						endif
					else
						u_help (_sMsg + " Reenvio para medicao de grau nao permitida, pois ja contem valor no grau.")
					endif
				endif
			else

				if ::StatusCar $ 'C/D'  // Carga [C]ancelada ou [D]irecionada para outra filial
					zza -> zza_status = 'C'
				elseif ::PesoBruto == 0
					zza -> zza_status = '0'
				elseif ::PesoTara > 0 .and. zza -> zza_status != '3' .and. val (::ItGrau [_nItem]) > 0  // Jah fez a segunda pesagem, sem finalizar no BL01.
					u_log2 ('info', '[' + procname () + ']Carga:' + ::Carga + ' Item: ' + ::ItItem [_nItem] + ' Alterando ZZA_STATUS para M por que jah estah sendo feita a segunda pesagem, mesmo sem finalizar no programa do grau.')
					zza -> zza_status = 'M'
				elseif ::PesoBruto > 0 .and. ::PesoTara == 0
					if empty (zza -> zza_status) .or. zza -> zza_status == '0'
						zza -> zza_status = '1'
					endif
				elseif ::PesoBruto > 0 .and. ::PesoTara > 0 .and. zza -> zza_status == '3'  // Segunda pesagem OK
					u_log2 ('aviso', '[' + GetClassName (::Self) + '.' + procname () + "]Nao vou enviar nada para o programa do grau por que, no grau, esta carga jah encontra-se com status=3 (finalizada)")
				else
					u_help ("Situacao imprevista na gravacao do campo ZZA_STATUS. Revise programa!",, .t.)
				endif
			endif
			msunlock ()
		next
	endif

//	// Estou com o campo ZZA_INIST1 ficando vazio e nao sei onde ocorre... desabilitar este trecho depois!
//	_oSQL := ClsSQL ():New ()
//	_oSQL:_sQuery := ""
//	_oSQL:_sQuery += "SELECT *"
//	_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZZA") + " ZZA"
//	_oSQL:_sQuery += " WHERE ZZA.D_E_L_E_T_ = ''"
//	_oSQL:_sQuery +=   " AND ZZA.ZZA_FILIAL = '" + xfilial ("ZZA") + "'"
//	_oSQL:_sQuery +=   " AND ZZA.ZZA_SAFRA  = '" + ::Safra + "'"
//	_oSQL:_sQuery +=   " AND ZZA.ZZA_CARGA  = '" + ::Carga + "'"
//	_oSQL:_sQuery += " ORDER BY ZZA_FILIAL, ZZA_SAFRA, ZZA_CARGA, ZZA_PRODUT"
//	_aDebugZZA := aclone (_oSQL:Qry2Array (.f., .t.))
//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Saindo do metodo com o ZZA assim:')
//	U_Log2 ('debug', _aDebugZZA)

	// Grava evento para posterior rastreamento
	if _lConfReen
		::GrvEvt ('SZE012', "Usuario confirmou reenvio da carga para o programa de medicao de grau, com a seguinte mensagem: " + _sMsgReen, 720)
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRetAtZZA


// --------------------------------------------------------------------------
// Gera uma string formatada para mostrar em tela as cargas compartilhadas.
METHOD ConsCompar () Class ClsCarSaf
	local _sConsComp := ''
	local _aComp := {}
	local _nComp := 0
	local _aAreaAnt := U_ML_SRArea ()


	_aComp = aclone (U_SeparaCpo (::TodasComp (), '/'))
	if len (_aComp) == 0
		_sConsComp = "Carga nao compartilhada com nenhuma outra."
	else
		_sConsComp = "Carga compartilhada com:" + chr (13) + chr (10)
	endif
	for _nComp = 1 to len (_aComp)
		if _aComp [_nComp] != ::Carga  // A carga atual tambem consta na lista, mas fica estranho listar ela aqui
			_sConsComp += 'Carga ' + _aComp [_nComp]
			_sConsComp += ' de ' + fBuscaCpo ("SZE", 1, ::Filial + ::Safra + _aComp [_nComp], "ZE_NOMASSO")
			_sConsComp += chr (13) + chr (10)
		endif
	next

	U_ML_SRArea (_aAreaAnt)
return _sConsComp


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD DefImprTk (_sFilial, _sCamFixo) Class ClsCarSaf
	local _lRet := .T.

	_sFilial = iif (empty (_sFilial), ::Filial, _sFilial)

	if ! empty (_sCamFixo)
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Recebi um caminho fixo para impressora: ' + _sCamFixo)
		::PortImpTk = _sCamFixo
	else
		// Se for base teste, evita enviar para a impressora padrao por que
		// causa confusao com a safra normal (eh comum rodarmos testes mesmo
		// enquanto a safra estah ocorrendo em producao).
		if U_AmbTeste()
			::PortImpTk := '\\192.168.1.3\siga\ticket.txt'
		else
			::PortImpTk = GetMV ("VA_ITKSAFR")
		endif
	endif
	if empty (::PortImpTk)
		_Super:SomaMsg ("Nao foi possivel definir porta para impressao de ticket.")
		_lRet = .F.
	endif
return _lRet


// --------------------------------------------------------------------------
// Faz o enderecamento (ou estorno)dos lotes de uva no estoque
METHOD EnderEstq (_sQueFazer) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _aAmbAnt   := U_SalvaAmb ()
	local _oSQL      := NIL
	local _aRegSDA   := {}
	local _nRegSDA   := 0
	local _aAutoSDA  := {}
	local _aAutoSDB  := {}
	local _aLinhaSDB := {}
	local _lContinua := .T.
	local _sItemSDB  := ''

	// Se for estorno, filtra a tabela e chama tela padrao do sistema.
	// O usuario deverah clicar no botao 'estornar'.
	if _sQueFazer == 'E'  // Estornar
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Chamando tela estorno enderecamento docto ' + ::Contranota)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT SDA.R_E_C_N_O_ AS REGSDA, SDB.R_E_C_N_O_ AS REGSDB"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD1") + " SD1, "
		_oSQL:_sQuery +=             RetSQLName ("SDA") + " SDA, "
		_oSQL:_sQuery +=             RetSQLName ("SDB") + " SDB "
		_oSQL:_sQuery += " WHERE SD1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SD1.D1_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_DOC     = '" + ::Contranota + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_SERIE   = '" + ::SerieCtrn + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_FORNECE = '" + ::Fornece + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_LOJA    = '" + ::Loja + "'"
		_oSQL:_sQuery +=   " AND SDA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SDA.DA_FILIAL  = SD1.D1_FILIAL"
		_oSQL:_sQuery +=   " AND SDA.DA_DOC     = SD1.D1_DOC"
		_oSQL:_sQuery +=   " AND SDA.DA_SERIE   = SD1.D1_SERIE"
		_oSQL:_sQuery +=   " AND SDA.DA_CLIFOR  = SD1.D1_FORNECE"
		_oSQL:_sQuery +=   " AND SDA.DA_LOJA    = SD1.D1_LOJA"
		_oSQL:_sQuery +=   " AND SDA.DA_ORIGEM  = 'SD1'"
		_oSQL:_sQuery +=   " AND SDA.DA_NUMSEQ  = SD1.D1_NUMSEQ"
		_oSQL:_sQuery +=   " AND SDA.DA_PRODUTO = SD1.D1_COD"
		_oSQL:_sQuery +=   " AND SDA.DA_SALDO   < SDA.DA_QTDORI"
		_oSQL:_sQuery +=   " AND SDB.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SDB.DB_FILIAL  = SDA.DA_FILIAL"
		_oSQL:_sQuery +=   " AND SDB.DB_DOC     = SDA.DA_DOC"
		_oSQL:_sQuery +=   " AND SDB.DB_SERIE   = SDA.DA_SERIE"
		_oSQL:_sQuery +=   " AND SDB.DB_CLIFOR  = SDA.DA_CLIFOR"
		_oSQL:_sQuery +=   " AND SDB.DB_LOJA    = SDA.DA_LOJA"
		_oSQL:_sQuery +=   " AND SDB.DB_ORIGEM  = SDA.DA_ORIGEM"
		_oSQL:_sQuery +=   " AND SDB.DB_NUMSEQ  = SDA.DA_NUMSEQ"
		_oSQL:_sQuery +=   " AND SDB.DB_PRODUTO = SDA.DA_PRODUTO"
		_oSQL:Log ()
		_aRegSDA = _oSQL:Qry2Array (.F., .F.)
		if len (_aRegSDA) == 0
			_Super:SomaMsg ("Nao encontrei enderecamento para estornar.")
			_lContinua = .F.
		else

			U_Log2 ('debug', _aRegSDA)
			sda -> (dbgoto (_aRegSDA [1, 1]))  // SDA usa apenas 1 registro
			_aAutoSDA = {}
			aadd (_aAutoSDA, {"DA_PRODUTO", sda -> da_produto, nil})
			aadd (_aAutoSDA, {"DA_LOCAL"  , SDA -> DA_LOCAL,   nil})
			aadd (_aAutoSDA, {"DA_NUMSEQ" , SDA -> DA_NUMSEQ,  nil})
			aadd (_aAutoSDA, {"DA_DOC"    , SDA -> DA_DOC,     nil})
			aadd (_aAutoSDA, {"DA_SERIE"  , SDA -> DA_SERIE,   nil})
			_aAutoSDB = {}
			for _nRegSDA = 1 to len (_aRegSDA)  // SBD eh uma linha para cada registro (pensar que trata-se de um aCols)
				U_Log2 ('debug', '[' + procname () + ']Linha:' + cvaltochar (_nRegSDA))
				U_Log2 ('debug', _aRegSDA [_nRegSDA])
				sdb -> (dbgoto (_aRegSDA [_nRegSDA, 2]))
				_aLinhaSDB = {}
				aadd (_aLinhaSDB, {"DB_ITEM"   , sdb -> db_item,    nil})
				aadd (_aLinhaSDB, {"DB_ESTORNO", 'S', nil})
				aadd (_aLinhaSDB, {"DB_LOCALIZ", sdb -> db_localiz, nil})
				aadd (_aLinhaSDB, {"DB_QUANT"  , sdb -> db_quant,   nil})
				aadd (_aLinhaSDB, {"DB_DATA"   , sdb -> db_data,    nil})
				_aLinhaSDB = aclone (U_OrdAuto (_aLinhaSDB))
				U_Log2 ('debug', _aLinhaSDB)
				aadd (_aAutoSDB, aclone (_aLinhaSDB))
			next
			lMsErroAuto := .F.
			MSExecAuto({|x,y,z| mata265(x,y,z)}, _aAutoSDA, _aAutoSDB, 4)
			If lMsErroAuto
				u_log2 ('erro', 'lMsErroAuto')
				if ! empty (NomeAutoLog ())
					u_log2 ('erro', memoread (NomeAutoLog ()))
//					MostraErro()
					_Super:SomaMsg (U_LeErro (memoread (NomeAutoLog ())))
				else
					_Super:SomaMsg ("Nao foi possivel ler o arquivo de log de erros da rotina de enderecamento de uva no estoque.",, .t.)
				endif
				_lContinua = .F.
			else
				U_Log2 ('debug', '[' + procname () + ']MATA265 retornou OK')
			endif
		endif

	elseif _sQueFazer == 'I'  // Incluir

		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Iniciando enderecamento docto ' + ::Contranota)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT SDA.R_E_C_N_O_"
		
		// Posso estar reenderecando uma nota. Nesse caso, preciso gerar o
		// campo DB_ITEM maior que 0001.
		_oSQL:_sQuery +=      " ,ISNULL ((SELECT MAX (DB_ITEM)
		_oSQL:_sQuery +=                  " FROM " + RetSQLName ("SDB") + " SDB "
		_oSQL:_sQuery +=                 " WHERE SDB.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=                   " AND SDB.DB_FILIAL = SDA.DA_FILIAL"
		_oSQL:_sQuery +=                  " AND SDB.DB_PRODUTO = SDA.DA_PRODUTO"
		_oSQL:_sQuery +=                  " AND SDB.DB_DOC = SDA.DA_DOC"
		_oSQL:_sQuery +=                  " AND SDB.DB_SERIE = SDA.DA_SERIE"
		_oSQL:_sQuery +=                  " AND SDB.DB_CLIFOR = SDA.DA_CLIFOR"
		_oSQL:_sQuery +=                  " AND SDB.DB_LOJA = SDA.DA_LOJA"
		_oSQL:_sQuery +=                  " AND SDB.DB_LOTECTL = SDA.DA_LOTECTL"
		_oSQL:_sQuery +=                  " AND SDB.DB_NUMSEQ = SDA.DA_NUMSEQ"
		_oSQL:_sQuery +=                  " AND SDB.DB_ORIGEM = SDA.DA_ORIGEM), '0000')"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD1") + " SD1, "
		_oSQL:_sQuery +=             RetSQLName ("SDA") + " SDA "
		_oSQL:_sQuery += " WHERE SD1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SD1.D1_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_DOC     = '" + ::Contranota + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_SERIE   = '" + ::SerieCtrn + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_FORNECE = '" + ::Fornece + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_LOJA    = '" + ::Loja + "'"
		_oSQL:_sQuery +=   " AND SDA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SDA.DA_FILIAL  = SD1.D1_FILIAL"
		_oSQL:_sQuery +=   " AND SDA.DA_DOC     = SD1.D1_DOC"
		_oSQL:_sQuery +=   " AND SDA.DA_SERIE   = SD1.D1_SERIE"
		_oSQL:_sQuery +=   " AND SDA.DA_CLIFOR  = SD1.D1_FORNECE"
		_oSQL:_sQuery +=   " AND SDA.DA_LOJA    = SD1.D1_LOJA"
		_oSQL:_sQuery +=   " AND SDA.DA_ORIGEM  = 'SD1'"
		_oSQL:_sQuery +=   " AND SDA.DA_NUMSEQ  = SD1.D1_NUMSEQ"
		_oSQL:_sQuery +=   " AND SDA.DA_PRODUTO = SD1.D1_COD"
		_oSQL:_sQuery +=   " AND SDA.DA_SALDO   > 0"
		_oSQL:Log ()
		_aRegSDA = _oSQL:Qry2Array (.F., .F.)
		if len (_aRegSDA) == 0
			_Super:SomaMsg ("Nenhum produto com saldo a enderecar para esta carga/contranota.")
			_lContinua = .F.
		endif
		_sItemSDB = Soma1 (_aRegSDA [1, 2])
		for _nRegSDA = 1 to len (_aRegSDA)
			sda -> (dbgoto (_aRegSDA [_nRegSDA, 1]))
			_aAutoSDA = {}
			aadd (_aAutoSDA, {"DA_PRODUTO", sda -> da_produto, nil})
			aadd (_aAutoSDA, {"DA_LOCAL"  , SDA -> DA_LOCAL    , nil})
			aadd (_aAutoSDA, {"DA_NUMSEQ" , SDA -> DA_NUMSEQ   , nil})
			aadd (_aAutoSDA, {"DA_DOC"    , SDA -> DA_DOC      , nil})
			aadd (_aAutoSDA, {"DA_SERIE"  , SDA -> DA_SERIE    , nil})

			_aAutoSDB = {}
			_aLinhaSDB = {}
			aadd (_aLinhaSDB, {"DB_ITEM", _sItemSDB, nil})
			if ::Filial == '01'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T01PCP03       ', nil})
			elseif ::Filial == '03'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T03 PCP AX 03  ', nil})
			elseif ::Filial == '07'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T07 PCP 03     ', nil})
			elseif ::Filial == '09'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T09 PCP AX 03  ', nil})
			endif
			aadd (_aLinhaSDB, {"DB_QUANT"  , SDA->DA_QTDORI   , nil})
			aadd (_aLinhaSDB, {"DB_DATA"   , dDATABASE        , nil})
			U_Log2 ('info', 'Enderecando docto ' + sda -> da_doc + ' / produto ' + sda -> da_produto)
			_aLinhaSDB = aclone (U_OrdAuto (_aLinhaSDB))
			aadd (_aAutoSDB, aclone (_aLinhaSDB))
			lMsErroAuto := .F.
			MSExecAuto({|x,y,z| mata265(x,y,z)}, _aAutoSDA, _aAutoSDB, 3)
			If lMsErroAuto
				u_log2 ('erro', 'lMsErroAuto')
				if ! empty (NomeAutoLog ())
					u_log2 ('erro', memoread (NomeAutoLog ()))
				//	MostraErro()
					_Super:SomaMsg (U_LeErro (memoread (NomeAutoLog ())))
				else
					_Super:SomaMsg ("Nao foi possivel ler o arquivo de log de erros da rotina de enderecamento de uva no estoque.")
				endif
				_lContinua = .F.
			endif
			_sItemSDB = soma1 (_sItemSDB)
		next
	else
		_Super:SomaMsg ('Sem tratamento para acao ' + _sQueFazer)
		_lContinua = .F.
	endif

	U_SalvaAmb (_aAmbAnt)
	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Exclusao definitiva (inclusive tabelas relacionadas).
// Antes da safra eh comum fazermos muitas cargas para simulacao e ajuste de
// programas, e essas cargas ficam poluindo o sistema (muitas vezes, ateh,
// seguindo a numeracao do ano anterior).
METHOD ExclDef (_sOrigem) Class ClsCarSaf
	local _lRetED   := .T.
	local _aAreaAnt := U_ML_SRArea ()
	local _sFrom    := ''
	local _oSQL     := NIL

	if _lRetED .and. sze -> ze_status != 'C'
		::UltMsg += "Somente cargas com status C-cancelada podem ser definitivamente excluidas."
		_lRetED = .F.
	endif

	// Se for carga gerada atraves da aglutinacao de outras, desmarca o flag
	// de aglutinacao das cargas originais e deleta a tabela de cargas relacionadas.
	if _lRetED .and. ::Aglutin == "D"
		_sFrom := ""
		_sFrom += " FROM " + RetSQLName ("SZE") + " SZE, "
		_sFrom +=            RetSQLName ("ZZD") + " ZZD "
		_sFrom += " WHERE SZE.D_E_L_E_T_ = ''"
		_sFrom +=   " AND SZE.ZE_FILIAL  = '" + ::Filial + "'"
		_sFrom +=   " AND SZE.ZE_SAFRA   = '" + ::Safra + "'"
		_sFrom +=   " AND ZZD.D_E_L_E_T_ = ''"
		_sFrom +=   " AND ZZD.ZZD_FILIAL = '" + ::Filial + "'"
		_sFrom +=   " AND ZZD.ZZD_SAFRA  = SZE.ZE_SAFRA"
		_sFrom +=   " AND ZZD.ZZD_CARDES = '" + ::Carga + "'"
		_sFrom +=   " AND ZZD.ZZD_CARORI = SZE.ZE_CARGA"
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery = "UPDATE SZE SET SZE.ZE_AGLUTIN = 'N' " + _sFrom
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lRetED = _oSQL:Exec ()
		if _lRetED
			_oSQL:_sQuery = "UPDATE ZZD SET ZZD.D_E_L_E_T_ = '*' " + _sFrom
			_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			_lRetED = _oSQL:Exec ()
		endif
	endif

	// Exclui esta carga das listas de compartilhamento das demais
	if _lRetED
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery := "UPDATE SZE SET SZE.ZE_CCOMPAR = replace (replace (SZE.ZE_CCOMPAR, '" + ::Carga + "', ''), '//', '/')"
		_oSQL:_sQuery := "UPDATE SZE SET SZE.ZE_CCOMPAR = replace (replace (SZE.ZE_CCOMPAR, '" + ::Carga + "', ''), '//', '/')"
		_oSQL:_sQuery += " FROM " + RetSQLName ("SZE") + " SZE "
		_oSQL:_sQuery += " WHERE SZE.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SZE.ZE_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND SZE.ZE_SAFRA   = '" + ::Safra + "'"
		_oSQL:_sQuery +=   " AND SZE.ZE_CCOMPAR LIKE '%" + ::Carga + "%'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lRetED = _oSQL:Exec ()
	endif

	// Exclui eventos relacionados a esta carga
	if _lRetED
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery := "UPDATE " + RetSQLName ("SZN")
		_oSQL:_sQuery +=   " SET D_E_L_E_T_ = '*'"
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZN_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND ZN_ALIAS   = 'SZE'"
		_oSQL:_sQuery +=   " AND ZN_COD     = '" + ::Safra + ::Carga + "'"
		_oSQL:_sQuery +=   " AND ZN_RECNO   = " + cvaltochar (::RegSZE)
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lRetED = _oSQL:Exec ()
	endif

	// Exclui itens da carga
	if _lRetED
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery := "UPDATE " + RetSQLName ("SZF")
		_oSQL:_sQuery +=   " SET D_E_L_E_T_ = '*'"
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZF_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND ZF_SAFRA   = '" + ::Safra  + "'"
		_oSQL:_sQuery +=   " AND ZF_CARGA   = '" + ::Carga  + "'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lRetED = _oSQL:Exec ()
	endif

	// Exclui itens enviados para o grau
	if _lRetED
		_oSQL := ClsSQL():New ()
		// Nao posso marcar como excluido por que o programa do grau (BL01)
		// desconhece esse conceito. Preciso excluir, mesmo!
		//_oSQL:_sQuery := "UPDATE " + RetSQLName ("ZZA")
		// _oSQL:_sQuery +=   " SET D_E_L_E_T_ = '*'"
		_oSQL:_sQuery := "DELETE " + RetSQLName ("ZZA")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZZA_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND ZZA_SAFRA   = '" + ::Safra  + "'"
		_oSQL:_sQuery +=   " AND ZZA_CARGA   = '" + ::Carga  + "'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lRetED = _oSQL:Exec ()
	endif

	// Exclui cabecalho da carga
	if _lRetED
		sze -> (dbgoto (::RegSZE))
		reclock ("SZE", .f.)
		sze -> (dbdelete ())
		msunlock ()
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRetED


// --------------------------------------------------------------------------
// Recebe o grau como numerico e retorna formatado em caracter.
METHOD FormataGrau (_nGrau as numeric) Class ClsCarSaf
	local _nInt  := 0
	local _nDec  := 0
	local _sInt  := ""
	local _sDec  := ""
	local _sGrau := ""
	local _aFmtGrau    := {2, 1}  // Formatacao para grau: {qt.digitos inteiros, qt.decimais}
	
	_nGrau = round (_nGrau, _aFmtGrau [2])  // Arredonda decimais
	_nInt = int (_nGrau)
	_sInt = strzero (_nInt, _aFmtGrau [1])
	if _aFmtGrau [2] > 0
		_nDec = (_nGrau - _nInt) * 10 * _aFmtGrau [2]
		_sDec = strzero (_nDec, _aFmtGrau [2])
	else
		_sDec = '0'
	endif
	_sGrau = _sInt + '.' + _sDec
return _sGrau


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sOrigem) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _lContinua := .T.
	local _nItemGD   := 0

	// Defaults
	::aIntegGrau  = {}
	::Aglutin     = ''
	::AxEntrada   = ''
	::Carga       = ''
	::Contranota  = ''
	::CCompart    = {}
	::CXouGranel  = ''
	::Filial      = ''
	::Fornece     = ''
	::GrupoPagamento   = ''
	::ItClasEspaldeira = {}
	::ItClasLatada     = {}
	::ItConducao       = {}
	::ItCor            = {}
	::ItDescri         = {}
	::ItFinaOuComum    = {}
	::ItGrau           = {}
	::ItItem           = {}
	::ItObs            = {}
	::ItOrganica       = {}
	::ItPrcBase        = {}
	::ItPrcParaNF      = {}
	::ItProduto        = {}
	::ItPropRur        = {}
	::Loja        = ''
	::NomeFornec  = ''
	::PesoBruto   = 0
	::PesoTara    = 0
	// migrado para o metoto NEW ---> ::PortImpTk   = ''
	::TipoPrecoParaNF   = ''
	::RecebeOrg   = ''
	::RecebeVini  = ''
	::RegSZE      = 0
	::Safra       = ''
	::Segregada   = .F.
	::SerieCtrn   = ''
	::StatusCar   = ''
	::TabelaPreco = ''
	::UltMsg      = ''
	::VariedadeMenorValorCodigo = ''
	::VariedadeMenorValorConducao = ''

	do case
	case _sOrigem == 'M'  // Variaveis M->  (preciso pegar os dados 'da tela')
		::Filial     = xfilial ("SZE")
		::Aglutin    = m->ze_aglutin
		::Safra      = m->ze_safra
		::Carga      = m->ze_carga
		::CCompart   = aclone (U_SeparaCpo (alltrim (m->ze_ccompar), '/'))
		::Contranota = m->ze_nfger
		::Fornece    = m->ze_assoc
		::Loja       = m->ze_lojasso
		::NomeFornec = m->ze_nomasso
		::PesoBruto  = m->ze_pesobru
		::PesoTara   = m->ze_pesotar
		::Segregada  = (m->ze_segreg == 'S')
		::SerieCtrn  = m->ze_serie
		::StatusCar  = m->ze_status

		// Alimenta array de itens
		for _nItemGD = 1 to len (aCols)
			::AddItem ()
			atail (::ItClasEspaldeira) = GDFieldGet ("ZF_PRM99",   _nItemGD)
			atail (::ItClasLatada)     = GDFieldGet ("ZF_CLASABD", _nItemGD)
			atail (::ItConducao)       = GDFieldGet ("ZF_CONDUC",  _nItemGD)
			atail (::ItCor)            = fBuscaCpo ('SB1', 1, xfilial ("SB1") + GDFieldGet ("ZF_PRODUTO", _nItemGD), "B1_VACOR")
			atail (::ItDescri)         = GDFieldGet ("ZF_DESCRI",  _nItemGD)
			atail (::ItFinaOuComum)    = fBuscaCpo ('SB1', 1, xfilial ("SB1") + GDFieldGet ("ZF_PRODUTO", _nItemGD), "B1_VARUVA")
			atail (::ItGrau)           = GDFieldGet ("ZF_GRAU",    _nItemGD)
			atail (::ItItem)           = GDFieldGet ("ZF_ITEM",    _nItemGD)
			atail (::ItObs)            = GDFieldGet ("ZF_OBS",     _nItemGD)
			atail (::ItOrganica)       = fBuscaCpo ('SB1', 1, xfilial ("SB1") + GDFieldGet ("ZF_PRODUTO", _nItemGD), "B1_VAORGAN")
			atail (::ItPrcBase)        = 0  // Ateh o momento, esse campo nao fica persistido no SZF.
			atail (::ItPrcParaNF)      = 0  // Ateh o momento, esse campo nao fica persistido no SZF.
			atail (::ItProduto)        = GDFieldGet ("ZF_PRODUTO", _nItemGD)
			atail (::ItPropRur)        = GDFieldGet ("ZF_CADVITI", _nItemGD)
		next

	case _sOrigem == "SZE"
		::Aglutin    = sze -> ze_aglutin
		::Carga      = sze -> ze_carga
		::Filial     = sze -> ze_filial
		::CCompart   = aclone (U_SeparaCpo (alltrim (sze->ze_ccompar), '/'))
		::Contranota = sze -> ze_nfger
		::Fornece    = sze -> ze_assoc
		::Loja       = sze -> ze_lojasso
		::NomeFornec = sze -> ze_nomasso
		::PesoBruto  = sze -> ze_pesobru
		::PesoTara   = sze -> ze_pesotar
		::RegSZE     = sze -> (recno ())
		::Safra      = sze -> ze_safra
		::Segregada  = (sze -> ze_segreg == 'S')
		::SerieCtrn  = sze -> ze_serie
		::StatusCar  = sze -> ze_status

		// Alimenta array de itens
		szf -> (dbsetorder (1))  // filial + safra + carga + item
		szf -> (dbseek (::Filial + ::Safra + ::Carga, .T.))
		do while ! szf -> (eof ()) ;
			.and. szf -> zf_filial == ::Filial ;
			.and. szf -> zf_safra  == ::Safra ;
			.and. szf -> zf_carga  == ::Carga

			::AddItem ()
			atail (::ItClasEspaldeira) = szf -> zf_prm99
			atail (::ItClasLatada)     = szf -> zf_clasabd
			atail (::ItConducao)       = szf -> zf_conduc
			atail (::ItCor)            = fBuscaCpo ('SB1', 1, xfilial ("SB1") + szf -> zf_produto, "B1_VACOR")
			atail (::ItDescri)         = fBuscaCpo ("SB1", 1, xfilial ("SB1") + szf -> zf_produto, "B1_DESC")
			atail (::ItFinaOuComum)    = fBuscaCpo ('SB1', 1, xfilial ("SB1") + szf -> zf_produto, "B1_VARUVA")
			atail (::ItGrau)           = szf -> zf_grau
			atail (::ItItem)           = szf -> zf_item
			atail (::ItObs)            = szf -> zf_obs
			atail (::ItOrganica)       = fBuscaCpo ('SB1', 1, xfilial ("SB1") + szf -> zf_produto, "B1_VAORGAN")
			atail (::ItPrcBase)        = 0  // Ateh o momento, esse campo nao fica persistido no SZF.
			atail (::ItPrcParaNF)      = 0  // Ateh o momento, esse campo nao fica persistido no SZF.
			atail (::ItProduto)        = szf -> zf_produto
			atail (::ItPropRur)        = szf -> zf_cadviti

			szf -> (dbskip ())
		enddo

	otherwise
		if ! empty (_sOrigem)  // Se origem vazia, eh por que estou apenas instanciando um objeto vazio.
			_Super:SomaMsg ("Impossivel gerar atributos. Origem '" + _sOrigem + "' desconhecida.")
			u_help (::UltMsg,, .t.)
		endif
		_lContinua = .F.
	endcase

	// A partir de 2024 pretendo eliminar o conceito de 'balancas' e ficar
	// apenas com 'filiais'. Criei o conceito de 'balanca' por volta de 2014
	// quando havia recebimento noutros locais que nao eram nossas filiais e
	// faziamos o lancamento de todas as NF de produtos na filial 01, mas era
	// necessario saber, pelo menos, o local fisico onde fora recebida a uva.
	if _lContinua
		if ::Safra >= '2024'
			// Como esta eh uma definicao das normas de safra, que sao
			// determinadas ainda antes da safra, acho que nao vale a pena
			// manter um 'cadastro'. Posso, muito bem, chumbar no programa.
			do case
			case ::Filial == '01'
				::RecebeOrg  = 'S'  // Recebe convencionais e organicas
				// Passado para '2' em 02/02/2024 apos conversa pelo Whats com Andre Gasperin. ---> ::RecebeVini = '4'  // Recepcao de viniferas: 1=nao recebe;2=classif.latada(A/B/D);3=classif.espaldeira(PR/AA/A/B/C/D/DS);4=recebe viniferas, mas classifica como comum
				::RecebeVini = '2'  // Recepcao de viniferas: 1=nao recebe;2=classif.latada(A/B/D);3=classif.espaldeira(PR/AA/A/B/C/D/DS);4=recebe viniferas, mas classifica como comum
				::AxEntrada  = '03' // Almox.para o qual devo gerar contranota. Geralmente '03'.
				::CxOuGranel = 'G'
			case ::Filial == '03'
				::RecebeOrg  = 'N'  // Nao recebe organicas (apenas convencionais)
				::RecebeVini = '3'  // Recepcao de viniferas: 1=nao recebe;2=classif.latada(A/B/D);3=classif.espaldeira(PR/AA/A/B/C/D/DS);4=recebe viniferas, mas classifica como comum
				::AxEntrada  = '03' // Almox.para o qual devo gerar contranota. Geralmente '03'.
				::CxOuGranel = 'C'
			case ::Filial == '07'
				::RecebeOrg  = 'N'  // Nao recebe organicas (apenas convencionais).
				::RecebeVini = '2'  // Recepcao de viniferas: 1=nao recebe;2=classif.latada(A/B/D);3=classif.espaldeira(PR/AA/A/B/C/D/DS);4=recebe viniferas, mas classifica como comum
				::AxEntrada  = '03' // Almox.para o qual devo gerar contranota. Geralmente '03'.
				::CxOuGranel = 'G'
			otherwise
				_Super:SomaMsg ('Filial sem definicao de recebimento de organicas, viniferas, etc.')
				_lContinua = .F.
			endcase
		endif
	endif

	// Define qual o tipo de preco a ser usado para geracao de contranota.
	// Procuro usar as mesmas posicoes retornadas pelas funcoes de calculo do
	// preco de cada ano: 1=entrada (em desuso);2=compra;5=MOC
	if _lContinua
		do case
		case ::Safra $ '2019/2021/2022'  // Para 2024 ainda nao tenho OK da direcao !!!
			::TipoPrecoParaNF = 1  // pos.2=preco de compra
		case ::Safra $ '2020/2023'
			::TipoPrecoParaNF = 5  // pos.5=preco MOC
		case ::Safra $ '2024/'
			::TipoPrecoParaNF = 6  // Buscar no arquivo ZBI
			::TabelaPreco = '24A '  // Codigo tabela precos (jah deve existir previamente no arquivo ZBI)
		otherwise
			_Super:SomaMsg ("Sem definicao de qual preco devo usar para gerar contranota (entrada/compra/MOC/...)")
			_lContinua = .F.
		endcase
	endif

	// Alimenta array de informacoes da tabela de integracao com medidor de grau.
	if _lContinua .and. ! empty (::Filial) .and. ! empty (::Safra) .and. ! empty (::Carga)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT ZZA_PRODUT, ZZA_STATUS, ZZA_GRAU"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZZA") + " ZZA"
		_oSQL:_sQuery += " WHERE ZZA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_FILIAL = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_SAFRA  = '" + ::Safra + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_SAFRA  = '" + ::Safra + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_CARGA  = '" + ::Carga + "'"
		_oSQL:_sQuery += " ORDER BY ZZA.ZZA_PRODUT"
		//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		::aIntegGrau := aclone (_oSQL:Qry2Array (.F., .F.))
	endif

	// Se teve problemas, limpa alguns atributos basicos para que tornar o objeto invalido
	if ! _lContinua
		::Filial    = ''
		::Safra     = ''
		::Carga     = ''
		::ItItem    = {}
		::Fornece   = ''
		::PesoBruto = 0
		::PesoTara  = 0
	endif
	//u_logobj (::Self)
	//U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Gerei atributos usando origem = ' + _sOrigem + ' e ficou assim:')
	//::Log ()
	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Define em qual grupo de pagamentos a carga deve ser enquadrada.
METHOD BuscaGrupoPagto () Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _lContinua := .T.
	local _sRetGrpPg := ''
	local _sQualProdutoUsar := ''
	local _sQualConducaoUsar := ''

	// Grupo pagto.eh definido pela variedade de menor valor presente na carga.
	if _lContinua .and. ! ::BuscaVarMenorVl ()
		_Super:SomaMsg ("Problemas na verificacao da variedade de menor valor. Impossivel definir grupo para pagamento.")
		_lContinua = .F.
	endif

	if _lContinua
		// Se houver uma variedade de menor valor, usa-a. Senao, usa o primeiro item da carga,
		if ! empty (::VariedadeMenorValorCodigo)
			_sQualProdutoUsar = ::VariedadeMenorValorCodigo
			_sQualConducaoUsar = ::VariedadeMenorValorConducao
			U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Vou definir grupo para pagamento com base na variedade de menor valor: ' + _sQualProdutoUsar)
		else
			_sQualProdutoUsar = ::ItProduto [1]
			_sQualConducaoUsar = ::ItConducao [1]
			U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Vou definir grupo para pagamento com base no primeiro item da carga: ' + _sQualProdutoUsar)
		endif

		sb1 -> (dbsetorder (1))
		if ! sb1 -> (dbseek (xfilial ("SB1") + _sQualProdutoUsar, .F.))
			_Super:SomaMsg ("Produto '" + _sQualProdutoUsar + "' nao cadastrado. Impossivel determinar o grupo para pagamento.")
			_lContinua = .F.
		else
		
			// Segue politicas definidas para cada safra.
			// DEVEM SER CONSISTENTES com o que retorna na tag <regraPagamento>
			// do metodo ClsAssoc:FechSafra()
			do case
			case ::Safra == '2020'
				// Nao tenho muitas opcoes alem de fazer alguns testes com codigos fixos...
				if alltrim (sb1 -> b1_cod) $ '9925'  // bordo
					_sRetGrpPg = 'A'
				elseif alltrim (sb1 -> b1_codpai) $ '9925'  // Alguma possivel nova variacao de bordo
					_sRetGrpPg = 'A'
				elseif sb1 -> b1_vaorgan == 'O'  // Organicas
					_sRetGrpPg = 'A'
				elseif sb1 -> b1_vattr == 'S'  // Tintorias
					_sRetGrpPg = 'B'
				elseif sb1 -> b1_varuva == 'F'
					if _sQualConducaoUsar == 'E'  // Viniferas em espaldeira
						_sRetGrpPg = 'B'
					elseif _sQualConducaoUsar == 'L'
						_sRetGrpPg = 'C'
					else
						_Super:SomaMsg ("Sistema de conducao '" + _sQualConducaoUsar + "' invalido.")
						_lContinua = .F.
					endif
				else
					_sRetGrpPg = 'C'
				endif

			case ::Safra $ '2021/2022/2023/2024'
				// Nao tenho muitas opcoes alem de fazer alguns testes com codigos fixos...
				if alltrim (sb1 -> b1_cod) $ '9925/9904/9922/9855'  // bordo, niagara, concord
					_sRetGrpPg = 'A'
				elseif alltrim (sb1 -> b1_codpai) $ '9925/9904/9922/9855'  // Alguma possivel nova variacao de bordo, niagara, concord
					_sRetGrpPg = 'A'
				elseif sb1 -> b1_vaorgan == 'O'  // Organicas
					_sRetGrpPg = 'A'
				elseif sb1 -> b1_vattr == 'S'  // Tintorias
					_sRetGrpPg = 'B'
				elseif sb1 -> b1_varuva == 'F'
					if _sQualConducaoUsar == 'E'
						_sRetGrpPg = 'B'
					elseif _sQualConducaoUsar == 'L'
						_sRetGrpPg = 'C'
					else
						_Super:SomaMsg ("Sistema de conducao '" + _sQualConducaoUsar + "' invalido.")
						_lContinua = .F.
					endif
				else
					_sRetGrpPg = 'C'
				endif

			otherwise
				_Super:SomaMsg ("Sem definicao de regras para grupos de pagamento para esta safra.")
				_lContinua = .F.
			endcase
		endif
	endif
	if _lContinua
		::GrupoPagamento = _sRetGrpPg
	else
		::GrupoPagamento = ''
	endif
	U_ML_SRArea (_aAreaAnt)
return _lContinua



// --------------------------------------------------------------------------
// Grava evento padrao do sistema.
METHOD GrvEvt (_sCodEvt as character, _sTxtEvt as character, _nDiasValid as numeric) Class ClsCarSaf
	local _oEvento := NIL

	_oEvento := ClsEvent():new ()
	_oEvento:CodEven    = _sCodEvt
	_oEvento:Texto      = _sTxtEvt
	_oEvento:Safra      = ::Safra
	_oEvento:CargaSafra = ::Carga
//	_oEvento:Alias      = 'SZE'
//	_oEvento:CodAlias   = ::Safra + ::Carga
	_oEvento:NFEntrada  = ::Contranota
	_oEvento:SerieEntr  = ::SerieCtrn
	_oEvento:Fornece    = ::Fornece
	_oEvento:LojaFor    = ::Loja
	_oEvento:DiasValid  = iif (_nDiasValid == NIL, 0, _nDiasValid)
	_oEvento:Grava ()
return


// --------------------------------------------------------------------------
// Gera (re)impressao do ticket da carga.
METHOD ImprimeTk (_nQualTk as numeric) Class ClsCarSaf
	local _nQtVias := 0
	local _lRet    := .T.

//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']iniciando...' + cvaltochar (_nQualTk))
	if _lRet .and. empty (_nQualTk)
		_Super:SomaMsg ("Para impressao de ticket deve ser informado se deseja 1a. ou 2a. pesagem.")
		_lRet  = .F.
	endif
	if _lRet .and. ! (_nQualTk == 1 .or. _nQualTk == 2)
		_Super:SomaMsg ("Opcao de impressao de ticket somente para 1a. ou 2a. pesagem.")
		_lRet  = .F.
	endif
	if _lRet .and. _nQualTk == 2 .and. ::PesoTara == 0
		_Super:SomaMsg ("Solicitada impressao de ticket de 2a. pesagem, mas a carga ainda nao tem peso tara.")
		_lRet  = .F.
	endif
	if _lRet
		// Producao propria: nao preciso entregar segunda via de ticket a ninguem.
		if ::Fornece == '001369' .and. ::Loja == '02'
			_nQtVias = 1
		else
			_nQtVias := iif (_nQualTk == 1, 1, 2)
		endif
//		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']vou chamar U_VA_RusTk')
		U_VA_RusTk (_nQualTk, ::PortImpTk, _nQtVias, {}, 'bematech', .t.)
	endif
return _lRet


// --------------------------------------------------------------------------
// Grava dados da carga em arquivo de log, para ajudar em rastreio de problemas.
METHOD Log () Class ClsCarSaf
	local _sLogCar  := ''
	local _nItCarga := 0

	_sLogCar += '## Filial: ' + ::Filial + '  Safra: ' + ::Safra + '  Carga: ' + ::Carga + '  Status: ' + ::StatusCar + '  Segregada: ' + iif (::Segregada, 'SIM', 'Nao') + '  Contranota: ' + ::Contranota + chr (13) + chr (10)
	_sLogCar += '## Peso bruto: ' + cvaltochar (::PesoBruto) + ' Peso tara: ' + cvaltochar (::PesoTara) + chr (13) + chr (10)
	_sLogCar += '## Fornecedor: ' + ::Fornece + '/' + ::Loja + ' - ' + ::NomeFornec + chr (13) + chr (10)
	_sLogCar += '## Porta ticket: ' + cvaltochar (::PortImpTk) + chr (13) + chr (10)
	for _nItCarga = 1 to len (::ItItem)
		_sLogCar += '##   It.' + ::ItItem [_nItCarga] + ': '
		_sLogCar += U_TamFixo (::ItProduto [_nItCarga], 7, ' ')  // Se criarem itens maiores, ajustar aqui
		_sLogCar += U_TamFixo (alltrim (::ItDescri  [_nItCarga]), 25, ' ')
		_sLogCar += ' ' + ::ItFinaOuComum [_nItCarga]
		_sLogCar += ' ' + ::ItConducao [_nItCarga]
		_sLogCar += ' Gr:' + ::ItGrau [_nItCarga]
		if ::ItFinaOuComum [_nItCarga] == 'F'
			if ::ItConducao [_nItCarga] == 'L'
				_sLogCar += ' ' + ::ItClasEspaldeira [_nItCarga]
			elseif ::ItConducao [_nItCarga] == 'L'
				_sLogCar += ' ' + ::ItClasLatada [_nItCarga]
			endif
		endif
		_sLogCar += ' $base: ' + transform (::ItPrcBase [_nItCarga], "@E 9.9999")
		_sLogCar += ' $NF: ' + transform (::ItPrcParaNF [_nItCarga], "@E 9.9999")
		_sLogCar += ' Vitic: ' + ::ItPropRur [_nItCarga]
		_sLogCar += ' Obs: ' + ::ItObs [_nItCarga]
	//	_sLogCar += iif (_nItCarga < len (::ItItem), chr (13) + chr (10), '')
		_sLogCar += chr (13) + chr (10)
	next
	_sLogCar += '## Varied.menor valor: ' + ::VariedadeMenorValorCodigo + ' (conducao: ' + ::VariedadeMenorValorConducao + ')' + chr (13) + chr (10)
	_sLogCar += '## Grupo pagto: ' + ::GrupoPagamento + chr (13) + chr (10)
	if ! empty (::UltMsg)
		_sLogCar += '## Ult.msg: ' + ::UltMsg + chr (13) + chr (10)
	endif
	if len (::CCompart) > 0
		_sLogCar += '## ' + ::ConsCompar ()
	endif
	if right (_sLogCar, 2) == chr (13) + chr (10)  // Remove ultima linha vazia
		_sLogCar = left (_sLogCar, len (_sLogCar) - 2)
	endif
	//U_Log2 ('info', 'vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv')
	U_Log2 ('info', _sLogCar)
	//U_Log2 ('info', '^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^')
return _sLogCar


// --------------------------------------------------------------------------
// Verifica se pode incluir a carga.
METHOD PodeGravar () Class ClsCarSaf
	local _lRet  := .T.
	local _nItem := 0

	// Este teste parece que vai exigir manutencao eterna...
	if _lRet .and. ::Safra >= '2014' .and. ! cEmpAnt + cFilAnt $ '0101/0103/0107'
		_Super:SomaMsg ("Filial nao liberada para recebimento nesta safra.")
		_lRet = .F.
	endif
	if _lRet .and. (empty (::AxEntrada) .or. empty (::RecebeOrg) .or. empty (::RecebeVini))
		u_help ("Parametros de Almox.entrada estoque uva / Recepcao de organicas / Recepcao de viniferas nao definido(s). Verifique se esta filial consta na tabela 09 do arquivo ZX5.")
		_lRet = .F.
	endif
	if _lRet
		for _nItem = 1 to len (::ItItem)
			if ::ItOrganica [_nItem] $ 'O/E/B' .and. ::RecebeOrg != 'S'
				_Super:SomaMsg ("Item " + cvaltochar (_nItem) + ":Nao ha previsao de recebimento de uvas organicas nesta filial.")
				_lRet = .F.
			endif
		next
	endif

	// Pra ajudar durante depuracao de programas...
	if ! _lRet
		U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + ']Gravacao de carga nao vai ser permitida. Log da carga:')
		::Log ()
	endif
return _lRet

/*
// --------------------------------------------------------------------------
// Alimenta, nas arrays de itens da carga, o preco unitario de cada variedade.
// Sao buscados 2 precos diferentes para cada variedade:
// Preco base: sempre no mesmo grau e mesma classificacao, Vai ser usado para
//             identificar a variedade de menor valor, em caso de mistura.
// Preco Para NF: considera grau, classificacao e demais politicas.
METHOD Precifica_old (_sQualPreco as character) class ClsCarSaf
	local _lContinua     := .T.
	local _aAreaAnt      := U_ML_SRArea ()
	local _nIdxItem      := 0
	local _sChaveZBI     := ''
	local _lUsarPrecoDS  := .F.
	local _oSQL          := NIL
	local _sProdutoAUsar := ''
	local _sClasFina     := ''
	local _sMenorVlr     := ''

	if ! _sQualPreco $ 'Base/ParaNF'
		_Super:SomaMsg ("Sem tratamento para precificar '" + _sQualPreco + "'")
		_lContinua = .F.
	endif

	if _lContinua
		//U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Carga para precificar:')
		//::Log ()
		//u_logObj (::Self, .t., .f.)

		for _nIdxItem = 1 to len (::ItItem)
			U_Log2 ('debug', '[' + procname () + ']_nIdxItem = ' + cvaltochar (_nIdxItem))

			_sClasFina = ''
			if ::ItFinaOuComum [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'L'
				_sClasFina = alltrim (::ItClasLatada [_nIdxItem])
			elseif ::ItFinaOuComum [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'E'
				_sClasFina = alltrim (::ItClasEspaldeira [_nIdxItem])
			endif

			// Apesar de que provavelmente nunca mais use, tentarei guardar historico de safras anteriores.
			if ::Safra == '2019'
				if _sQualPreco == 'Base'
					::ItPrcBase [_nIdxItem]   = U_PrcUva19 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem])[::TipoPrecoParaNF]
				elseif _sQualPreco == 'ParaNF'
					::ItPrcParaNF [_nIdxItem] = U_PrcUva19 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem])[::TipoPrecoParaNF]
				endif
			elseif ::Safra == '2020'
				if _sQualPreco == 'Base'
					::ItPrcBase [_nIdxItem]   = U_PrcUva20 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F.)[::TipoPrecoParaNF]  // pos.5=preco MOC
				elseif _sQualPreco == 'ParaNF'
					::ItPrcParaNF [_nIdxItem] = U_PrcUva20 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F.)[::TipoPrecoParaNF]  // pos.5=preco MOC
				endif
			elseif ::Safra == '2021'
				if _sQualPreco == 'Base'
					::ItPrcBase [_nIdxItem]   = U_PrcUva21 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2=preco de compra
				elseif _sQualPreco == 'ParaNF'
					::ItPrcParaNF [_nIdxItem] = U_PrcUva21 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2=preco de compra
				endif
			elseif ::Safra == '2022'
				if _sQualPreco == 'Base'
					::ItPrcBase [_nIdxItem]   = U_PrcUva22 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2 = preco de compra.
				elseif _sQualPreco == 'ParaNF'
					::ItPrcParaNF [_nIdxItem] = U_PrcUva22 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2 = preco de compra.
				endif
			elseif ::Safra == '2023'
				if _sQualPreco == 'Base'
					::ItPrcBase [_nIdxItem]   = U_PrcUva23 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.5 = preco MOC
				elseif _sQualPreco == 'ParaNF'
					if ! ::BuscaVarMenorVl ()
						_Super:SomaMsg ("Problemas ao buscar variedade de menor valor.")
					else
						::ItPrcParaNF [_nIdxItem] = U_PrcUva23 (::Filial, iif (! empty (::VariedadeMenorValorCodigo), ::VariedadeMenorValorCodigo, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.5 = preco MOC
					endif
				endif
			
			// A partir deste ano pretendo ter os valores prontos na tabela ZBI.
			elseif ::Safra >= '2024'
				if _sQualPreco == 'Base'
					_sChaveZBI := xfilial ("ZBI")
					_sChaveZBI += ::TabelaPreco
					_sChaveZBI += ::ItProduto [_nIdxItem]
					_sChaveZBI += ::ItConducao [_nIdxItem]
					_sChaveZBI += '15.0'
					if ::ItFinaOuComum [_nIdxItem] == 'F'
						_sChaveZBI += 'B '
					elseif ::ItFinaOuComum [_nIdxItem] == 'C'
						_sChaveZBI += '  ' // Uvas comuns nao tem classificacao.
					endif
					U_Log2 ('debug', '[' + procname () + ']Pesquisando ZBI com chave >>' + _sChaveZBI + '<<')
					zbi -> (dbsetorder (1))  // ZBI_FILIAL, ZBI_CODTAB, ZBI_PRODUT, ZBI_CONDUC, ZBI_GRAU, ZBI_CLASSE, R_E_C_N_O_, D_E_L_E_T_
					if ! zbi -> (dbseek (_sChaveZBI, .T.))
						_Super:SomaMsg ("Nao localizada a chave '" + _sChaveZBI + "' na tabela ZBI (precos). Verifique se a tabela foi gerada.")
						_lContinua = .F.
					else
						::ItPrcBase [_nIdxItem] = zbi -> zbi_vunit1
					endif

				elseif _sQualPreco == 'ParaNF'

					// Tratamentos para situacoes especiais
					if ::ItFinaOuComum  [_nIdxItem] == 'F' .and. ::RecebeVini $ '1/4'  // 1=nao recebe viniferas; 4=recebe viniferas, mas classifica como comum
						_lUsarPrecoDS = .T.
					endif
					if ::ItFinaOuComum  [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'L' .and. ::ItCor [_nIdxItem] == 'T' .and. val (::ItGrau [_nIdxItem]) < 14 //.and. ! alltrim (sb1 -> b1_cod) $ '9911/9969'  // Nao se aplica ao moscato branco e alicante
						_lUsarPrecoDS = .T.
						::SomaObsItem (_nIdxItem, "Vinif.ttas.latadas abaixo de 14 graus: precifica como DS.")
					endif
					if ::ItFinaOuComum  [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'L' .and. ::ItCor [_nIdxItem] != 'T' .and. val (::ItGrau [_nIdxItem]) < 11 //.and. ! alltrim (sb1 -> b1_cod) $ '9911/9969'  // Nao se aplica ao moscato branco e alicante
						_lUsarPrecoDS = .T.
						::SomaObsItem (_nIdxItem, "Vinif.bcas.latadas abaixo de 11 graus: precifica como DS.")
					endif

					if ::TipoPrecoParaNF == 6  // Buscar na tabela ZBI
						if _lUsarPrecoDS
							// Se a variedade recebida jah for a 'classificada como cumum', nem preciso procurar mais.
							if fBuscaCpo ("SB1", 1, xfilial ("SB1") + ::ItProduto [_nIdxItem], "B1_VAFCUVA") == 'C'
								_sProdutoAUsar = ::ItProduto [_nIdxItem]
							else
								_oSQL := ClsSQL ():New ()
								_oSQL:_sQuery := ""
								_oSQL:_sQuery += "SELECT COD_FINA_CLAS_COMUM"
								_oSQL:_sQuery +=  " FROM VA_VFAMILIAS_UVAS"
								_oSQL:_sQuery += " WHERE COD_BASE = '" + ::ItProduto [_nIdxItem] + "'"
								_sProdutoAUsar = _oSQL:RetQry (1, .f.)
								if empty (_sProdutoAUsar)
									_Super:SomaMsg ("Nao foi possivel definir o codigo 'fina_sem_classificacao' correspondente ao produto '" + ::ItProduto [_nIdxItem] + "'. Impossivel determinao o preco para NF.")
									_lContinua = .F.
								endif
							endif
						else
							_sProdutoAUsar = ::ItProduto [_nIdxItem]
						endif
						_sChaveZBI := xfilial ("ZBI")
						_sChaveZBI += ::TabelaPreco
						_sChaveZBI += _sProdutoAUsar
						_sChaveZBI += ::ItConducao [_nIdxItem]
						_sChaveZBI += ::ItGrau [_nIdxItem]
						if ::ItFinaOuComum [_nIdxItem] == 'F'
							if ::ItConducao [_nIdxItem] == 'L'
								_sChaveZBI += U_TamFixo (::ItClasLatada [_nIdxItem], 2, ' ')
							elseif ::ItConducao [_nIdxItem] == 'E'
								_sChaveZBI += U_TamFixo (::ItClasEspaldeira [_nIdxItem], 2, ' ')
							else
								_sChaveZBI += '?'
								_Super:SomaMsg ("Sem tratamento para conducao '" + ::ItConducao [_nIdxItem] + "' no momento da precificacao.")
								_lContinua = .F.
							endif
						elseif ::ItFinaOuComum [_nIdxItem] == 'C'
							// Como as uvas comuns nao consideram classificacao para
							// o preco (pelo menos nao nesta safra), achei mais economico
							// nem gerar todas as combinacoes no ZBI.
							_sChaveZBI += '  '
						endif
						if _lContinua
							U_Log2 ('debug', '[' + procname () + ']Pesquisando ZBI com chave >>' + _sChaveZBI + '<<')
							zbi -> (dbsetorder (1))  // ZBI_FILIAL, ZBI_CODTAB, ZBI_PRODUT, ZBI_CONDUC, ZBI_GRAU, ZBI_CLASSE, R_E_C_N_O_, D_E_L_E_T_
							if ! zbi -> (dbseek (_sChaveZBI, .T.))
								_Super:SomaMsg ("Nao localizada a chave '" + _sChaveZBI + "' na tabela ZBI (precos). Verifique se a tabela foi gerada.")
								_lContinua = .F.
							else
								::ItPrcParaNF [_nIdxItem] = zbi -> zbi_vunit1
							endif
						endif
					else
						_Super:SomaMsg ("Sem tratamento para precificacao com tipo de precos '" + cvaltochar (::TipoPrecoParaNF) + "'.")
						_lContinua = .F.
					endif
				endif
			else
				_Super:SomaMsg ('Sem tratamento para precificacao para esta safra.')
				_lContinua = .F.
			endif
		next
	endif

	U_ML_SRArea (_aAreaAnt)
//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retornando ' + cvaltochar (_lContinua))
return _lContinua
*/

// --------------------------------------------------------------------------
// Alimenta, nas arrays de itens da carga, o preco unitario de cada variedade.
// Sao buscados 2 precos diferentes para cada variedade:
// Preco base: sempre no mesmo grau e mesma classificacao, Vai ser usado para
//             identificar a variedade de menor valor, em caso de mistura.
// Preco Para NF: considera grau, classificacao e demais politicas.
METHOD Precifica_ant (_sQualPreco as character) class ClsCarSaf
	local _lContinua     := .T.
	local _aAreaAnt      := U_ML_SRArea ()
	local _nIdxItem      := 0
	local _lUsarPrecoDS  := .F.
	local _oSQL          := NIL
	local _sProdutoAUsar := ''
	local _sClasFina     := ''
	local _sMenorVlr     := ''

	if ! _sQualPreco $ 'Base/ParaNF'
		_Super:SomaMsg ("Sem tratamento para precificar '" + _sQualPreco + "'")
		_lContinua = .F.
	endif

	if _lContinua
		//U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Carga para precificar:')
		//::Log ()
		//u_logObj (::Self, .t., .f.)

		for _nIdxItem = 1 to len (::ItItem)
			_sClasFina = ''
			if ::ItFinaOuComum [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'L'
				_sClasFina = alltrim (::ItClasLatada [_nIdxItem])
			elseif ::ItFinaOuComum [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'E'
				_sClasFina = alltrim (::ItClasEspaldeira [_nIdxItem])
			endif

			// Apesar de que provavelmente nunca mais use, tentarei guardar historico de safras anteriores.
			if ::Safra == '2019'
				if _sQualPreco == 'Base'
					::ItPrcBase [_nIdxItem]   = U_PrcUva19 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem])[::TipoPrecoParaNF]
				elseif _sQualPreco == 'ParaNF'
					::ItPrcParaNF [_nIdxItem] = U_PrcUva19 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem])[::TipoPrecoParaNF]
				endif
			elseif ::Safra == '2020'
				if _sQualPreco == 'Base'
					::ItPrcBase [_nIdxItem]   = U_PrcUva20 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F.)[::TipoPrecoParaNF]  // pos.5=preco MOC
				elseif _sQualPreco == 'ParaNF'
					::ItPrcParaNF [_nIdxItem] = U_PrcUva20 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F.)[::TipoPrecoParaNF]  // pos.5=preco MOC
				endif
			elseif ::Safra == '2021'
				if _sQualPreco == 'Base'
					::ItPrcBase [_nIdxItem]   = U_PrcUva21 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2=preco de compra
				elseif _sQualPreco == 'ParaNF'
					::ItPrcParaNF [_nIdxItem] = U_PrcUva21 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2=preco de compra
				endif
			elseif ::Safra == '2022'
				if _sQualPreco == 'Base'
					::ItPrcBase [_nIdxItem]   = U_PrcUva22 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2 = preco de compra.
				elseif _sQualPreco == 'ParaNF'
					::ItPrcParaNF [_nIdxItem] = U_PrcUva22 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2 = preco de compra.
				endif
			elseif ::Safra == '2023'
				if _sQualPreco == 'Base'
					::ItPrcBase [_nIdxItem]   = U_PrcUva23 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.5 = preco MOC
				elseif _sQualPreco == 'ParaNF'
					if ! ::BuscaVarMenorVl ()
						_Super:SomaMsg ("Problemas ao buscar variedade de menor valor.")
					else
						::ItPrcParaNF [_nIdxItem] = U_PrcUva23 (::Filial, iif (! empty (::VariedadeMenorValorCodigo), ::VariedadeMenorValorCodigo, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.5 = preco MOC
					endif
				endif
			
			// A partir deste ano pretendo ter os valores prontos na tabela ZBI.
			elseif ::Safra >= '2024'
				if _sQualPreco == 'Base'
					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := ""
					_oSQL:_sQuery += "SELECT top 1 ISNULL (ZBI_VUNIT1, 0)"
					_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZBI") + " ZBI"
					_oSQL:_sQuery += " WHERE ZBI.D_E_L_E_T_ = ''"
					_oSQL:_sQuery +=   " AND ZBI.ZBI_FILIAL = '" + xfilial ("ZBI") + "'"
					_oSQL:_sQuery +=   " AND ZBI.ZBI_CODTAB = '" + ::TabelaPreco + "'"
					_oSQL:_sQuery +=   " AND ZBI.ZBI_PRODUT = '" + ::ItProduto [_nIdxItem] + "'"
					_oSQL:_sQuery +=   " AND ZBI.ZBI_GRAU   = '15.0'"

					if ::ItFinaOuComum [_nIdxItem] == 'F'
						// Somente ha diferenciacao de preco por de forma de conducao nas uvas finas.
						_oSQL:_sQuery +=   " AND ZBI.ZBI_CONDUC = '" + ::ItConducao [_nIdxItem] + "'"

						// Como as uvas comuns nao consideram classificacao para
						// o preco (pelo menos nao nesta safra), achei mais economico
						// nem gerar todas as combinacoes no ZBI.
						_oSQL:_sQuery +=   " AND ZBI.ZBI_CLASSE = 'B'"
					endif

				//	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
					::ItPrcBase [_nIdxItem] = _oSQL:RetQry (1, .f.)
					if ::ItPrcBase [_nIdxItem] == 0
						_Super:SomaMsg ("Nao localizado preco base da uva na tabela ZBI (precos). Verifique se a tabela foi gerada. Dados usados na consulta: " + _oSQL:_sQuery)
						_lContinua = .F.
					endif

				elseif _sQualPreco == 'ParaNF'

					// Tratamentos para situacoes especiais
					if ::ItFinaOuComum  [_nIdxItem] == 'F' .and. ::RecebeVini $ '1/4'  // 1=nao recebe viniferas; 4=recebe viniferas, mas classifica como comum
						_lUsarPrecoDS = .T.
					endif
					if ::ItFinaOuComum  [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'L' .and. ::ItCor [_nIdxItem] == 'T' .and. val (::ItGrau [_nIdxItem]) < 14 //.and. ! alltrim (sb1 -> b1_cod) $ '9911/9969'  // Nao se aplica ao moscato branco e alicante
						_lUsarPrecoDS = .T.
						::SomaObsItem (_nIdxItem, "Vinif.ttas.latadas abaixo de 14 graus: precifica como DS.")
					endif
					if ::ItFinaOuComum  [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'L' .and. ::ItCor [_nIdxItem] != 'T' .and. val (::ItGrau [_nIdxItem]) < 11 //.and. ! alltrim (sb1 -> b1_cod) $ '9911/9969'  // Nao se aplica ao moscato branco e alicante
						_lUsarPrecoDS = .T.
						::SomaObsItem (_nIdxItem, "Vinif.bcas.latadas abaixo de 11 graus: precifica como DS.")
					endif

					if ::TipoPrecoParaNF == 6  // Buscar na tabela ZBI
						if _lUsarPrecoDS
							// Se a variedade recebida jah for a 'classificada como cumum', nem preciso procurar mais.
							if fBuscaCpo ("SB1", 1, xfilial ("SB1") + ::ItProduto [_nIdxItem], "B1_VAFCUVA") == 'C'
								_sProdutoAUsar = ::ItProduto [_nIdxItem]
							else
								_oSQL := ClsSQL ():New ()
								_oSQL:_sQuery := ""
								_oSQL:_sQuery += "SELECT COD_FINA_CLAS_COMUM"
								_oSQL:_sQuery +=  " FROM VA_VFAMILIAS_UVAS"
								_oSQL:_sQuery += " WHERE COD_BASE = '" + ::ItProduto [_nIdxItem] + "'"
								_sProdutoAUsar = _oSQL:RetQry (1, .f.)
								if empty (_sProdutoAUsar)
									_Super:SomaMsg ("Nao foi possivel definir o codigo 'fina_sem_classificacao' correspondente ao produto '" + ::ItProduto [_nIdxItem] + "'. Impossivel determinao o preco para NF.")
									_lContinua = .F.
								endif
							endif
						else
							_sProdutoAUsar = ::ItProduto [_nIdxItem]
						endif

						_oSQL := ClsSQL ():New ()
						_oSQL:_sQuery := ""
						_oSQL:_sQuery += "SELECT top 1 ISNULL (ZBI_VUNIT1, 0)"
						_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZBI") + " ZBI"
						_oSQL:_sQuery += " WHERE ZBI.D_E_L_E_T_ = ''"
						_oSQL:_sQuery +=   " AND ZBI.ZBI_FILIAL = '" + xfilial ("ZBI") + "'"
						_oSQL:_sQuery +=   " AND ZBI.ZBI_CODTAB = '" + ::TabelaPreco + "'"
						_oSQL:_sQuery +=   " AND ZBI.ZBI_PRODUT = '" + _sProdutoAUsar + "'"
						_oSQL:_sQuery +=   " AND ZBI.ZBI_GRAU   = '" + ::ItGrau [_nIdxItem] + "'"

						if ::ItFinaOuComum [_nIdxItem] == 'F'
							// Somente ha diferenciacao de preco por de forma de conducao nas uvas finas.
							_oSQL:_sQuery +=   " AND ZBI.ZBI_CONDUC = '" + ::ItConducao [_nIdxItem] + "'"

							// Como as uvas comuns nao consideram classificacao para
							// o preco (pelo menos nao nesta safra), achei mais economico
							// nem gerar todas as combinacoes no ZBI.
							if ::ItConducao [_nIdxItem] == 'L'
								_oSQL:_sQuery += " AND ZBI.ZBI_CLASSE = '" + ::ItClasLatada [_nIdxItem] + "'"
							elseif ::ItConducao [_nIdxItem] == 'E'
								_oSQL:_sQuery += " AND ZBI.ZBI_CLASSE = '" + ::ItClasEspaldeira [_nIdxItem] + "'"
							else
								_Super:SomaMsg ("Sem tratamento para conducao '" + ::ItConducao [_nIdxItem] + "' no momento da precificacao.")
								_lContinua = .F.
							endif
						endif

				//		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
						::ItPrcParaNF [_nIdxItem] = _oSQL:RetQry (1, .f.)
						if ::ItPrcParaNF [_nIdxItem] == 0
							_Super:SomaMsg ("Nao localizado preco base da uva na tabela ZBI (precos). Verifique se a tabela foi gerada. Dados usados na consulta: " + _oSQL:_sQuery)
							_lContinua = .F.
						endif
					else
						_Super:SomaMsg ("Sem tratamento para precificacao com tipo de precos '" + cvaltochar (::TipoPrecoParaNF) + "'.")
						_lContinua = .F.
					endif
				endif
			else
				_Super:SomaMsg ('Sem tratamento para precificacao nesta safra.')
				_lContinua = .F.
			endif
		next
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Alimenta, nas arrays de itens da carga, o preco unitario de cada variedade.
// Sao buscados 2 precos diferentes para cada variedade:
// Preco base: sempre no mesmo grau e mesma classificacao, Vai ser usado para
//             identificar a variedade de menor valor, em caso de mistura.
// Preco Para NF: considera grau, classificacao e demais politicas.
METHOD Precifica (_sQualPreco as character) class ClsCarSaf
	local _lContinua     := .T.
	local _aAreaAnt      := U_ML_SRArea ()
	local _nIdxItem      := 0
	local _lUsarPrecoDS  := .F.
	local _oSQL          := NIL
	local _sProdutoAUsar := ''
	local _sClasFina     := ''
	local _sMenorVlr     := ''

	if ! _sQualPreco $ 'Base/ParaNF'
		_Super:SomaMsg ("Sem tratamento para precificar '" + _sQualPreco + "'")
		_lContinua = .F.
	endif

	_nIdxItem = 1
	do while _lContinua .and. _nIdxItem <= len (::ItItem)
		_sClasFina = ''
		if ::ItFinaOuComum [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'L'
			_sClasFina = alltrim (::ItClasLatada [_nIdxItem])
		elseif ::ItFinaOuComum [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'E'
			_sClasFina = alltrim (::ItClasEspaldeira [_nIdxItem])
		endif

		// Apesar de que provavelmente nunca mais use, tentarei guardar historico de safras anteriores.
		if ::Safra == '2019'
			if _sQualPreco == 'Base'
				::ItPrcBase [_nIdxItem]   = U_PrcUva19 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem])[::TipoPrecoParaNF]
			elseif _sQualPreco == 'ParaNF'
				::ItPrcParaNF [_nIdxItem] = U_PrcUva19 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem])[::TipoPrecoParaNF]
			endif
		elseif ::Safra == '2020'
			if _sQualPreco == 'Base'
				::ItPrcBase [_nIdxItem]   = U_PrcUva20 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F.)[::TipoPrecoParaNF]  // pos.5=preco MOC
			elseif _sQualPreco == 'ParaNF'
				::ItPrcParaNF [_nIdxItem] = U_PrcUva20 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F.)[::TipoPrecoParaNF]  // pos.5=preco MOC
			endif
		elseif ::Safra == '2021'
			if _sQualPreco == 'Base'
				::ItPrcBase [_nIdxItem]   = U_PrcUva21 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2=preco de compra
			elseif _sQualPreco == 'ParaNF'
				::ItPrcParaNF [_nIdxItem] = U_PrcUva21 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2=preco de compra
			endif
		elseif ::Safra == '2022'
			if _sQualPreco == 'Base'
				::ItPrcBase [_nIdxItem]   = U_PrcUva22 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2 = preco de compra.
			elseif _sQualPreco == 'ParaNF'
				::ItPrcParaNF [_nIdxItem] = U_PrcUva22 (::Filial, iif (! empty (_sMenorVlr), _sMenorVlr, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.2 = preco de compra.
			endif
		elseif ::Safra == '2023'
			if _sQualPreco == 'Base'
				::ItPrcBase [_nIdxItem]   = U_PrcUva23 (::Filial, ::ItProduto [_nIdxItem], 15.0, 'B', ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.5 = preco MOC
			elseif _sQualPreco == 'ParaNF'
				if ! ::BuscaVarMenorVl ()
					_Super:SomaMsg ("Problemas ao buscar variedade de menor valor.")
				else
					::ItPrcParaNF [_nIdxItem] = U_PrcUva23 (::Filial, iif (! empty (::VariedadeMenorValorCodigo), ::VariedadeMenorValorCodigo, ::ItProduto [_nIdxItem]), val (::ItGrau [_nIdxItem]), _sClasFina, ::ItConducao [_nIdxItem], .F., .T.)[::TipoPrecoParaNF]  // pos.5 = preco MOC
				endif
			endif
		
		// A partir deste ano pretendo ter os valores prontos na tabela ZBI.
		elseif ::Safra >= '2024'

			// Verifica se trata-se de uva vinifera que deve ser tratada como 'sem classificacao'
			if ::ItFinaOuComum  [_nIdxItem] == 'F' .and. ::RecebeVini $ '1/4'  // 1=nao recebe viniferas; 4=recebe viniferas, mas classifica como comum
				_lUsarPrecoDS = .T.
			endif
			if ::ItFinaOuComum  [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'L' .and. ::ItCor [_nIdxItem] == 'T' .and. val (::ItGrau [_nIdxItem]) < 14 //.and. ! alltrim (sb1 -> b1_cod) $ '9911/9969'  // Nao se aplica ao moscato branco e alicante
				_lUsarPrecoDS = .T.
				::SomaObsItem (_nIdxItem, "Vinif.ttas.latadas abaixo de 14 graus: precifica como DS.")
			endif
			if ::ItFinaOuComum  [_nIdxItem] == 'F' .and. ::ItConducao [_nIdxItem] == 'L' .and. ::ItCor [_nIdxItem] != 'T' .and. val (::ItGrau [_nIdxItem]) < 11 //.and. ! alltrim (sb1 -> b1_cod) $ '9911/9969'  // Nao se aplica ao moscato branco e alicante
				_lUsarPrecoDS = .T.
				::SomaObsItem (_nIdxItem, "Vinif.bcas.latadas abaixo de 11 graus: precifica como DS.")
			endif

			if _lUsarPrecoDS
				// Se a variedade recebida jah for a 'classificada como comum', nem preciso procurar mais.
				if fBuscaCpo ("SB1", 1, xfilial ("SB1") + ::ItProduto [_nIdxItem], "B1_VAFCUVA") == 'C'
					_sProdutoAUsar = ::ItProduto [_nIdxItem]
				else
					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := ""
					_oSQL:_sQuery += "SELECT COD_FINA_CLAS_COMUM"
					_oSQL:_sQuery +=  " FROM VA_VFAMILIAS_UVAS"
					_oSQL:_sQuery += " WHERE COD_BASE = '" + ::ItProduto [_nIdxItem] + "'"
					_sProdutoAUsar = _oSQL:RetQry (1, .f.)
					if empty (_sProdutoAUsar)
						_Super:SomaMsg ("Nao foi possivel definir o codigo 'fina_sem_classificacao' correspondente ao produto '" + ::ItProduto [_nIdxItem] + "'. Impossivel determinao o preco para NF.")
						_lContinua = .F.
					endif
				endif
			else
				_sProdutoAUsar = ::ItProduto [_nIdxItem]
			endif

			if _sQualPreco == 'Base'
				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := ""
				_oSQL:_sQuery += "SELECT top 1 ISNULL (ZBI_VUNIT1, 0)"
				_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZBI") + " ZBI"
				_oSQL:_sQuery += " WHERE ZBI.D_E_L_E_T_ = ''"
				_oSQL:_sQuery +=   " AND ZBI.ZBI_FILIAL = '" + xfilial ("ZBI") + "'"
				_oSQL:_sQuery +=   " AND ZBI.ZBI_CODTAB = '" + ::TabelaPreco + "'"
				_oSQL:_sQuery +=   " AND ZBI.ZBI_PRODUT = '" + _sProdutoAUsar + "'"
				_oSQL:_sQuery +=   " AND ZBI.ZBI_GRAU   = '15.0'"  // Um grau 'medio' que costuma atender a todas as variedades.

				if ::ItFinaOuComum [_nIdxItem] == 'F'
					// Somente ha diferenciacao de preco por de forma de conducao nas uvas finas.
					_oSQL:_sQuery +=   " AND ZBI.ZBI_CONDUC = '" + ::ItConducao [_nIdxItem] + "'"

					// Como as uvas comuns nao consideram classificacao para
					// o preco (pelo menos nao nesta safra), achei mais economico
					// nem gerar todas as combinacoes no ZBI.
					_oSQL:_sQuery +=   " AND ZBI.ZBI_CLASSE = 'B'"
				endif

			//	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				::ItPrcBase [_nIdxItem] = _oSQL:RetQry (1, .f.)
				if ::ItPrcBase [_nIdxItem] == 0
					_Super:SomaMsg ("Nao localizado preco base da uva na tabela ZBI (precos). Verifique se a tabela foi gerada. Dados usados na consulta: " + _oSQL:_sQuery)
					_lContinua = .F.
				endif

			elseif _sQualPreco == 'ParaNF'

				// Se tiver mais de uma variedade, preciso usar a de menor
				// valor para precificar todas as variedades da carga.
				if ! ::BuscaVarMenorVl ()
					_Super:SomaMsg ("Problemas ao buscar variedade de menor valor.")
					_lContinua = .F.
				endif
				if _lContinua
					if ! empty (::VariedadeMenorValorCodigo)
						_sProdutoAUsar = ::VariedadeMenorValorCodigo
						U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Vou definir preco para NF do item ' + cvaltochar (_nIdxItem) + ' com base na variedade de menor valor: ' + _sProdutoAUsar)
					else
						_sProdutoAUsar = ::ItProduto [_nIdxItem]
						U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Vou definir preco para NF do item ' + cvaltochar (_nIdxItem) + ' com o codigo da propria variedade: ' + _sProdutoAUsar)
					endif
				endif

				if _lContinua
					if ::TipoPrecoParaNF == 6  // Buscar na tabela ZBI
						_oSQL := ClsSQL ():New ()
						_oSQL:_sQuery := ""
						_oSQL:_sQuery += "SELECT top 1 ISNULL (ZBI_VUNIT1, 0)"
						_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZBI") + " ZBI"
						_oSQL:_sQuery += " WHERE ZBI.D_E_L_E_T_ = ''"
						_oSQL:_sQuery +=   " AND ZBI.ZBI_FILIAL = '" + xfilial ("ZBI") + "'"
						_oSQL:_sQuery +=   " AND ZBI.ZBI_CODTAB = '" + ::TabelaPreco + "'"
						_oSQL:_sQuery +=   " AND ZBI.ZBI_PRODUT = '" + _sProdutoAUsar + "'"
						_oSQL:_sQuery +=   " AND ZBI.ZBI_GRAU   = '" + ::ItGrau [_nIdxItem] + "'"

						if ::ItFinaOuComum [_nIdxItem] == 'F'
							// Somente ha diferenciacao de preco por de forma de conducao nas uvas finas.
							_oSQL:_sQuery +=   " AND ZBI.ZBI_CONDUC = '" + ::ItConducao [_nIdxItem] + "'"

							// Como as uvas comuns nao consideram classificacao para
							// o preco (pelo menos nao nesta safra), achei mais economico
							// nem gerar todas as combinacoes no ZBI.
							if ::ItConducao [_nIdxItem] == 'L'
								_oSQL:_sQuery += " AND ZBI.ZBI_CLASSE = '" + ::ItClasLatada [_nIdxItem] + "'"
							elseif ::ItConducao [_nIdxItem] == 'E'
								_oSQL:_sQuery += " AND ZBI.ZBI_CLASSE = '" + ::ItClasEspaldeira [_nIdxItem] + "'"
							else
								_Super:SomaMsg ("Sem tratamento para conducao '" + ::ItConducao [_nIdxItem] + "' no momento da precificacao.")
								_lContinua = .F.
							endif
						endif

			//			_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
						::ItPrcParaNF [_nIdxItem] = _oSQL:RetQry (1, .f.)
						if ::ItPrcParaNF [_nIdxItem] == 0
							_Super:SomaMsg ("Nao localizado preco base da uva na tabela ZBI (precos). Verifique se a tabela foi gerada. Dados usados na consulta: " + _oSQL:_sQuery)
							_lContinua = .F.
						endif
					else
						_Super:SomaMsg ("Sem tratamento para precificacao com tipo de precos '" + cvaltochar (::TipoPrecoParaNF) + "'.")
						_lContinua = .F.
					endif
				endif
			endif
		else
			_Super:SomaMsg ('Sem tratamento para precificacao nesta safra.')
			_lContinua = .F.
		endif
		_nIdxItem ++
	enddo

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Verifica se 'tudo ok' na segunda pesagem da carga.
METHOD SegPesTOk () Class ClsCarSaf
	local _aAreaAnt := U_ML_SRArea ()
	local _l2PesTOK := .T.
	local _sGrau    := ''
	local _nItemCar := 0
	local _sMsg     := ''
	local _nCompart := 0

//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']iniciando...')

	// Para referenciar alguma outra carga como compartilhada, essa deve existir.
	if _l2PesTOK
		sze -> (dbsetorder (1))  // ZE_FILIAL+ZE_SAFRA+ZE_CARGA
		for _nCompart = 1 to len (::CCompart)
			if ! sze -> (dbseek (::Filial + ::Safra + ::CCompart [_nCompart], .F.))
				::UltMsg += "Carga compartilhada '" + ::CCompart [_nCompart] + "' nao foi localizada!"
				_l2PesTOK = .F.
			else
				// Se estou incluindo/gerando carga nova
				if ::PesoBruto == 0 .and. sze -> ze_pesotar > 0
					::UltMsg += "A carga compartilhada '" + ::CCompart [_nCompart] + "' ja encontra-se com segunda pesagem. O normal seria gerar as cargas compartilhadas todas em sequencia, e somente depois disso, comecar as pesagens e o recebimento."
					_l2PesTOK = .F.
				endif
			endif
		next
	endif

	// Todas as variedades da carga devem ter mesmo grau (excecao para Livramento
	// que, no momento em que estou fazendo esta validacao, recebe uva em caixas
	// e, portanto, tem condicao de medir o grau separadamente.
	if _l2PesTOK .and. ::PesoTara > 0
		_sMsg = ''
		_sGrau = ''
		for _nItemCar = 1 to len (_oCarSaf:ItItem)
			if empty (_sGrau)
				_sGrau = _oCarSaf:ItGrau [_nItemCar]
			else
				if _oCarSaf:ItGrau [_nItemCar] != _sGrau
					_l2PesTOK = .F.
					exit
				endif
			endif
		next
		if ! _l2PesTOK
			_sMsg = "Todos os itens da carga deveriam apresentar o mesmo grau"
			if cFilAnt == '03'
				if U_MsgNoYes (_sMsg + " . Confirma?")
					_sMsg += " (mas, sendo recebimento em caixas, existe possibilidade de medicao do grau em separado)."
					_l2PesTOK = .T.
					U_Log2 ('aviso', '[' + procname () + ']Gravar aqui um evento de graus diferentes na carga!')
				endif
			else
				_sMsg += ", uma vez que a carga foi recebida a granel."
				::UltMsg += _sMsg
			endif
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _l2PesTOK


// --------------------------------------------------------------------------
// Altera o lote de estoque para 'NC' (nao conforme).
// Tive tantos casos de 'esquecemos de segregar a carga' que resolvi automatizar um pouco.
METHOD SegregarLt () Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _lContinua := .t.
	local _sWhereSD1 := ''
	local _aLotesSD1 := {}
	local _nLoteSD1  := 0
	local _sWhereSB8 := ''
	local _aLotesSB8 := {}
	local _sWhereSBF := ''
	local _aLotesSBF := {}
	local _sLoteNovo := ''

	if _lContinua .and. ! ::Segregada
		::UltMsg += "Carga nao eh segregada"
		_lContinua = .F.
	endif
	if _lContinua
		_sWhereSD1 +=  " FROM " + RetSQLName ("SD1") + " SD1"
		_sWhereSD1 += " WHERE SD1.D_E_L_E_T_ = ''"
		_sWhereSD1 +=   " AND SD1.D1_FILIAL  = '" + ::Filial + "'"
		_sWhereSD1 +=   " AND SD1.D1_DOC     = '" + ::Contranota + "'"
		_sWhereSD1 +=   " AND SD1.D1_SERIE   = '" + ::SerieCtrn + "'"
		_sWhereSD1 +=   " AND SD1.D1_FORNECE = '" + ::Fornece + "'"
		_sWhereSD1 +=   " AND SD1.D1_LOJA    = '" + ::Loja + "'"
		_sWhereSD1 +=   " AND substring (SD1.D1_LOTECTL, 9, 2) != 'NC'"
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT D1_COD, D1_LOTECTL, D1_NUMSEQ"
		_oSQL:_sQuery += _sWhereSD1
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_aLotesSD1 = aclone (_oSQL:Qry2Array (.f., .f.))
		U_Log2 ('debug', _aLotesSD1)
		if len (_aLotesSD1) == 0
			u_help ("Nao encontrei nenhum lote de estoque precisando ser alterado para 'NC'")
		endif
	endif

	// Verifica se teve movimentacao e se pode alterar os lotes
	if _lContinua
		for _nLoteSD1 = 1 to len (_aLotesSD1)
			_lContinua = .T.  // Para tentar os proximos lotes, caso de problema neste.
			_sWhereSB8 :=  " FROM " + RetSQLName ("SB8") + " SB8"
			_sWhereSB8 += " WHERE SB8.D_E_L_E_T_ = ''"
			_sWhereSB8 +=   " AND SB8.B8_FILIAL  = '" + ::Filial + "'"
			_sWhereSB8 +=   " AND SB8.B8_PRODUTO = '" + _aLotesSD1 [_nLoteSD1, 1] + "'"
			_sWhereSB8 +=   " AND SB8.B8_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"
			_sWhereSB8 +=   " AND SB8.B8_DOC     = '" + ::Contranota + "'"
			_sWhereSB8 +=   " AND SB8.B8_SERIE   = '" + ::SerieCtrn  + "'"
			_sWhereSB8 +=   " AND SB8.B8_CLIFOR  = '" + ::Fornece    + "'"
			_sWhereSB8 +=   " AND SB8.B8_LOJA    = '" + ::Loja       + "'"
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT B8_QTDORI, B8_SALDO, B8_LOCAL"
			_oSQL:_sQuery += _sWhereSB8
			_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			_aLotesSB8 = aclone (_oSQL:Qry2Array (.f., .f.))
			if len (_aLotesSB8) != 1
				::UltMsg += "Problema na leitura de lotes na tabela SB8. Nenhum (ou mais de um) registro encontrado!"
				_lContinua = .F.
			else
				if _aLotesSB8 [1, 1] != _aLotesSB8 [1, 2]
					::UltMsg += "Saldo do lote na tabela SB8 difere do original (ja teve movimentacao). Lote '" + _aLotesSD1 [_nLoteSD1, 2] + "' nao pode mais ser alterado."
					_lContinua = .F.
				else
					// Verifica se jah foi enderecado.
					_sWhereSBF :=  " FROM " + RetSQLName ("SBF") + " SBF"
					_sWhereSBF += " WHERE SBF.D_E_L_E_T_ = ''"
					_sWhereSBF +=   " AND SBF.BF_FILIAL  = '" + ::Filial + "'"
					_sWhereSBF +=   " AND SBF.BF_PRODUTO = '" + _aLotesSD1 [_nLoteSD1, 1] + "'"
					_sWhereSBF +=   " AND SBF.BF_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"
					_sWhereSBF +=   " AND SBF.BF_LOCAL   = '" + _aLotesSB8 [1, 3] + "'"
					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := "SELECT BF_LOCALIZ, BF_QUANT, SUM (BF_QUANT) OVER ()"
					_oSQL:_sQuery += _sWhereSBF
					_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
					_aLotesSBF = aclone (_oSQL:Qry2Array (.f., .f.))
					if len (_aLotesSBF) > 0 .and. _aLotesSBF [1, 3] != _aLotesSB8 [1, 2]
						::UltMsg += "Quant.total enderecada diferente do saldo inicial do lote (ja teve movimentacao). Lote '" + _aLotesSD1 [_nLoteSD1, 2] + "' nao pode mais ser alterado."
						_lContinua = .F.
					endif
				endif
			endif
			
			// Se cheguei ateh aqui sem erros para este lote, posso alterar ele.
			if _lContinua
				U_Log2 ('debug', '[' + procname () + ']Testes iniciais ok... alterando lote ' + _aLotesSD1 [_nLoteSD1, 2])
				_sLoteNovo = left (_aLotesSD1 [_nLoteSD1, 2], 8) + 'NC'
				begin transaction

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SD1 SET D1_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery += _sWhereSD1
				_oSQL:_sQuery += " AND D1_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:_sQuery += " AND D1_NUMSEQ  = '" + _aLotesSD1 [_nLoteSD1, 3] + "'"
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SB8 SET B8_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery += _sWhereSB8
				_oSQL:_sQuery += " AND B8_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SBF SET BF_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery += _sWhereSBF
				_oSQL:_sQuery += " AND BF_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SDA SET DA_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery +=  " FROM " + RetSQLName ("SDA") + " SDA"
				_oSQL:_sQuery += " WHERE SDA.D_E_L_E_T_ = ''"
				_oSQL:_sQuery +=   " AND SDA.DA_FILIAL  = '" + ::Filial + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_DOC     = '" + ::Contranota + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_SERIE   = '" + ::SerieCtrn + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_CLIFOR  = '" + ::Fornece + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_LOJA    = '" + ::Loja + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_PRODUTO = '" + _aLotesSD1 [_nLoteSD1, 1] + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:_sQuery +=   " AND SDA.DA_NUMSEQ  = '" + _aLotesSD1 [_nLoteSD1, 3] + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_ORIGEM  = 'SD1'"
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SDB SET DB_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery +=  " FROM " + RetSQLName ("SDB") + " SDB"
				_oSQL:_sQuery += " WHERE SDB.D_E_L_E_T_ = ''"
				_oSQL:_sQuery +=   " AND SDB.DB_FILIAL  = '" + ::Filial + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_DOC     = '" + ::Contranota + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_SERIE   = '" + ::SerieCtrn + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_CLIFOR  = '" + ::Fornece + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_LOJA    = '" + ::Loja + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_PRODUTO = '" + _aLotesSD1 [_nLoteSD1, 1] + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:_sQuery +=   " AND SDB.DB_NUMSEQ  = '" + _aLotesSD1 [_nLoteSD1, 3] + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_ORIGEM  = 'SD1'"
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SD5 SET D5_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD5") + " SD5"
				_oSQL:_sQuery += " WHERE SD5.D_E_L_E_T_ = ''"
				_oSQL:_sQuery +=   " AND SD5.D5_FILIAL  = '" + ::Filial + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_DOC     = '" + ::Contranota + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_SERIE   = '" + ::SerieCtrn + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_CLIFOR  = '" + ::Fornece + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_LOJA    = '" + ::Loja + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_PRODUTO = '" + _aLotesSD1 [_nLoteSD1, 1] + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:_sQuery +=   " AND SD5.D5_NUMSEQ  = '" + _aLotesSD1 [_nLoteSD1, 3] + "'"
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				end transaction
				
				// Reprocessa saldo atual
				if _lContinua
					if ! U__Mata300 (_aLotesSD1 [_nLoteSD1, 1], _aLotesSD1 [_nLoteSD1, 1], _aLotesSD1 [_nLoteSD1, 2], _aLotesSD1 [_nLoteSD1, 2])
						::UltMsg += "Erro no reprocessamento do saldo atual do produto " + _aLotesSD1 [_nLoteSD1, 1]
						_lContinua = .F.
					else
						if ! U_ConsEstq (cFilAnt, _aLotesSD1 [_nLoteSD1, 1], _aLotesSD1 [_nLoteSD1, 2], '')
							::UltMsg += "Estoques do produto " + _aLotesSD1 [_nLoteSD1, 1] + " ficaram inconsistentes depois de segregar o lote!"
							_lContinua = .F.
						endif
					endif
				endif
			endif
		next
	endif

	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Faz uma analise da integracao com o grau (pode ter mais de um item na carga)
// e procura definir o status do ZZA 'como um todo' para a carga.
METHOD StatusZZA () Class ClsCarSaf
	local _sRetStZZA := ''

//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Avaliando carga recebida em ' + ::CXouGranel + ' com registros assim:')
//	U_Log2 ('debug', ::aIntegGrau)
	
	// Quando a carga eh recebida em caixas, vale o 'menor' status por
	// que provavelmente cada variedade vai ser processada separadamente.
	if ::CXouGranel == 'C'
		if ascan (::aIntegGrau, {|_aVal| _aVal [2] == 'C'}) > 0
			_sRetStZZA = 'C'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '0'}) > 0
			_sRetStZZA = '0'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '1'}) > 0
			_sRetStZZA = '1'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '2'}) > 0
			_sRetStZZA = '2'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '3'}) > 0
			_sRetStZZA = '3'
		endif

	// Quando a carga eh recebida a granel, vale o 'maior' status por
	// que todas as variedades serao processadas junto. O programa do
	// grau vai dar o retorno em apenas um dos registros.
	elseif ::CXouGranel == 'G'
		if ascan (::aIntegGrau, {|_aVal| _aVal [2] == 'C'}) > 0
			_sRetStZZA = 'C'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '3'}) > 0
			_sRetStZZA = '3'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '2'}) > 0
			_sRetStZZA = '2'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '1'}) > 0
			_sRetStZZA = '1'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '0'}) > 0
			_sRetStZZA = '0'
		endif
		
	else
		u_help ("Conteudo desconhecido (" + ::CXouGranel + ") na analise do status da medicao de grau.")
	endif

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retornando statusZZA = ' + _sRetStZZA + ' para a carga ' + ::Carga)
return _sRetStZZA


// --------------------------------------------------------------------------
// Adiciona (sempre no inicio, para que a mensagem mais recente seja vista
// antes) uma mensagem na string ::ItObs
METHOD SomaObsItem (_nItem as numeric, _sMsg as character) Class ClsCarSaf
	local _sMsgAux := alltrim (_sMsg)
	if ! alltrim (_sMsgAux) $ ::ItObs [_nItem]
		::ItObs [_nItem] = alltrim (_sMsgAux) + '; ' + ::ItObs [_nItem]
	endif
return


// --------------------------------------------------------------------------
// Uma vez que cargas podem ser compartilhadas (mais de um produtor rural
// usando o mesmo veiculo, como se viesse de carona), preciso uma forma de
// saber todas as cargas compartilhadas com a atual.
METHOD TodasComp (_sLista) Class ClsCarSaf
	local _nCompart := 0
	local _oCarAux  := NIL

	_sLista = iif (_sLista == NIL, '', _sLista)  // para o caso de ser chamada sem parametros.

//	U_Log2 ('debug', '[' + procname () + ']iniciando TodasComp para a carga ' + ::Carga + ' que tem ::CCompart = ' + _Arr2Str (::CCompart))

	// Se esta propria carga ainda nao estiver na lista, adiciona-a.
	if ! ::Carga $ _sLista
		_sLista += iif (empty (_sLista), '', '/') + ::Carga
	endif

	// Criterio de final de execucao: quando a carga nao apontar para nenhuma outra.
	if len (::CCompart) == 0
	else
		for _nCompart = 1 to len (::CCompart)
			if ! ::CCompart [_nCompart] $ _sLista
				_oCarAux := ClsCarSaf ():New (::Filial + ::Safra + ::CCompart [_nCompart])
				_sLista = _oCarAux:TodasComp (_sLista)
			endif
		next
	endif
return _sLista


// --------------------------------------------------------------------------
// Identifica a variedade de menor valor entre todas envolvidas nesta carga.
// A lista de 'variedades envolvidas' considera, tambem, cargas compartilhadas.
// O parametro 'qual preco' deve manter compatibilidade com a funcao de calculo
// de precos da safra em questao.
METHOD BuscaVarMenorVl () class ClsCarSaf
	local _lContinua := .T.
	local _aProdut   := {}
	local _nProdut   := 0
	local _aTodasCar := {}
	local _nTodasCar := {}
	local _oCarAux   := NIL
	local _aAreaAnt  := U_ML_SRArea ()
	local _aAux      := {}

	// Faz uma lista de cargas compartilhadas (se houver) a verificar.
	if len (::CCompart) > 0
		_aTodasCar = U_SeparaCpo (::TodasComp (), '/')
	else  // Se nao tiver compartilhamento, eh somente a propria carga.
		_aTodasCar = {::Carga}
	endif
	//U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']_aTodasCar:')
	//U_Log2 ('debug', _aTodasCar)

	// Monta lista de todas as variedades envolvidas.
	for _nTodasCar = 1 to len (_aTodasCar)

		// Se for a carga atual, leio seus atributos (pode ainda nao estar gravada)
		if _aTodasCar [_nTodasCar] == ::Carga
			if ::Precifica ('Base')
//				U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Depois de precificar a carga original:')
//				::Log ()
				for _nProdut = 1 to len (::ItItem)
					if ascan (_aProdut, {|_aVal| _aVal [1] == ::ItProduto [_nProdut] .and. _aVal [3] == ::ItConducao [_nProdut]}) == 0
						aadd (_aProdut, {::ItProduto [_nProdut], ::ItPrcBase [_nProdut], ::ItConducao [_nProdut]})
					endif
				next
			else
				_Super:SomaMsg ("Problemas ao buscar precos base para esta carga.")
				_lContinua = .F.
			endif
		else
			_oCarAux := ClsCarSaf ():New (::Filial + ::Safra + _aTodasCar [_nTodasCar])
			if empty (_oCarAux:Carga)
				_Super:SomaMsg ("Impossivel instanciar carga compartilhada '" + _aTodasCar [_nTodasCar] + "'. Verificacao de variedade de menor valor nao pode ser feita.")
				_lContinua = .F.
			else
				if _oCarAux:Precifica ('Base')
//					U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Depois de precificar a carga auxiliar:')
//					_oCarAux:Log ()
					for _nProdut = 1 to len (_oCarAux:ItItem)
						if ascan (_aProdut, {|_aVal| _aVal [1] == _oCarAux:ItProduto [_nProdut] .and. _aVal [3] == _oCarAux:ItConducao [_nProdut]}) == 0
							aadd (_aProdut, {_oCarAux:ItProduto [_nProdut], _oCarAux:ItPrcBase [_nProdut], _oCarAux:ItConducao [_nProdut]})
						endif
					next
				else
					_Super:SomaMsg ("Problemas ao buscar precos base para a carga compartilhada '" + _oCarAux:Carga + "'.")
					_lContinua = .F.
				endif
			endif
		endif
	next

	// Elimina produtos com precos iguais.
	_aAux = {}
	for _nProdut = 1 to len (_aProdut)
		if ascan (_aAux, {|_aVal| _aVal [2] = _aProdut [_nProdut, 2]}) == 0
			aadd (_aAux, aclone (_aProdut [_nProdut]))
		endif
	next

	// Ordena por codigo de produto para o caso de, a seguir, ter dois
	// produtos de mesmo preco, ficar ordenado por preco + codigo.
	// Achei um tanto perigoso ordenar na mesma operacao...
	_aProdut = asort (_aProdut,,, {|_x, _y| _x[1] < _y [1]})

	// Ordena por preco, de forma que, depois, baste pegar a primeira linha.
	_aProdut = asort (_aProdut,,, {|_x, _y| _x[2] < _y [2]})
	
//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Variedade(s) de menor valor envolvidas:')
//	U_Log2 ('debug', _aProdut)

	if len (_aProdut) < 1
		_Super:SomaMsg ("Problemas na busca da variedade de menor valor: nenhuma variedade lida!")
		_aProdut = {}
		_lContinua = .F.
	endif

	// Se alguma variedade ficou sem valor, eh melhor nao retornar nada, pois
	// eh importante que eu consiga, sempre, buscar os precos de todas.
	if _lContinua .and. len (_aProdut) >= 1 .and. _aProdut [1, 2] == 0
		_Super:SomaMsg ("Problemas na busca da variedade de menor valor: variedade '" + alltrim (_aProdut [1, 1]) + "' ficou sem valor!")
		_aProdut = {}
		_lContinua = .F.
	endif

	// Se cheguei aqui com mais de um produto, significa que ha, de fato,
	// uma variedade 'de menor valor'.
	if _lContinua
		if len (_aProdut) > 1
			::VariedadeMenorValorCodigo   = _aProdut [1, 1]
			::VariedadeMenorValorConducao = _aProdut [1, 3]
		else
			::VariedadeMenorValorCodigo   = ''
			::VariedadeMenorValorConducao = ''
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua
