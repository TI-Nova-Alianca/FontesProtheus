// Programa:  ClsCarSaf
// Autor:     Robert Koch
// Data:      09/10/2022 (inicio)
// Descricao: Declaracao de classe de representacao de carga recebida na safra de uva.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa carga recebida durante safra de uva.
// #PalavasChave      #carga #safra
// #TabelasPrincipais #SZD #SZE
// #Modulos           #COOP

// Historico de alteracoes:
// 17/01/2023 - Robert - Quando producao propria, gera apenas 1 via do ticket 2a.pesagem.
// 20/01/2023 - Robert - Comecado a gravar arrays de itens (ItItem, ItProduto, ...)
// 25/01/2023 - Robert - Criado metodo AtuZZA.
//                     - Metodo New() passa a aceitar tanto recno() como chave filial+safra+carga.
//                     - Metodo SegPesTOk, melhorias gerais
// 03/02/2023 - Robert - Tratamentos para cargas compartilhadas.
//                     - Nao enviava cargas canceladas para o grau (nao alterava ZZA_STATUS para C).
// 08/02/2023 - Robert - Implementado metodo SegregarLt().
// 22/02/2023 - Robert - Gravacao evento passa a tratar novos atributos ClsEvent:Safra e ClsEvent:CargaSafra.
//

#Include "Protheus.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsCarSaf ()
return



// ==========================================================================
CLASS ClsCarSaf

	// Declaracao das propriedades da Classe
	public  data aIntegGrau  // Registros referentes a esta carga na tabela ZZA (integracao com leitor de grau)
	public  data Aglutin     // ZE_AGLUTIN - Situacao quanto a aglutinacao de cargas: O=Origem (aglutinada em outra carga);D=Destino (aglutinadora);N=Nenhuma(carga normal)
	public  data Carga       // ZE_CARGA
	public  data CXouGranel  // Indica se recebe em caixas ou a granel (tombador)
	public  data CCompart    // ZE_CCompar - array de cargas compartilhadas (mesmo veiculo)
	public  data Contranota  // ZE_NFGER
	public  data Filial      // ZE_FILIAL
	public  data Fornece     // ze_assoc
	public  data ItConducao  // Array de Itens da carga - Forma de conducao: [L]atada;[E]spaldeira
	public  data ItDescri    // Array de Itens da carga - Descricao do produto
	public  data ItGrau      // Array de Itens da carga - zf_grau
	public  data ItItem      // Array de Itens da carga - zf_item
	public  data ItProduto   // Array de Itens da carga - zf_produto
	public  data Loja        // ze_lojasso
	public  data NomeFornec  // A2_NOME - nome do fornecedor
	public  data PesoBruto   // ZE_PESOBRU
	public  data PesoTara    // ZE_PESOTAR
	public  data PortImpTk   // Porta / caminho para impressao do ticket
	public  data RegSZE      // recno() da tabela SZE.
	public  data Safra       // ZE_SAFRA
	public  data Segregada   // ZE_SEGREG
	public  data SerieCtrn   // ze_serie
	public  data StatusCar   // ze_status
	public  data UltMsg      // Ultima mensagem gerada

	// Declaracao dos Metodos da classe
	public METHOD New ()
	public METHOD AddItem ()    // Adiciona uma posicao nas arrays de itens
	public METHOD AtuAgenda ()  // Envia atualizacao para o sistema de agendamento
	public METHOD AtuZZA ()     // Envia atualizacao para o programa de medicao de grau
	public METHOD ConsCompar () // Gera string bonitinha para consulta de compartilhamentos com outras cargas.
	public METHOD DefImprTk ()  // Define porta para impressao do ticket
	public METHOD GeraAtrib ()
	public METHOD EnderEstq ()  // Enderecar (ou estornar) estoque
	public METHOD ExclDef ()    // Exclusao definitiva (inclusive tabelas relacionadas)
	public METHOD GrvEvt ()
	public METHOD ImprimeTk ()  // Gera impressao do ticket
	public METHOD Log ()
	public METHOD SegPesTOk ()  // Verifica se 'tudo ok' com a segunda pesagem.
	public METHOD SegregarLt () // Segregar lote de estoque (mudar para lote 'NC')
	public METHOD StatusZZA ()
	public METHOD TodasComp ()  // Gera lista de todas as cargas compartilhadas com a atual.
	public METHOD VarMenorVl () // Identifica a variedade de menor valor
ENDCLASS


// --------------------------------------------------------------------------
// Construtor da classe.
METHOD New (_xChvCar) Class ClsCarSaf
	local _aAreaAnt := U_ML_SRArea ()

	// Alimenta atributos com valores default de uma carga nova.
	::GeraAtrib ("")

	// Como o metodo GeraAtrib eh chamado de varios lugares depois que o objeto
	// jah foi instanciado, achei que seria desnecessario ler novamente algumas
	// coisas que apenas degradariam a performance, entao jah vou deixar setadas
	// aqui. Havendo necessidades especificas, poderao ser alteradas depois.
	::DefImprTk ()

	// Se receber valor numerico, eh por que se trata do numero de registro do SZE.
	if valtype (_xChvCar) == "N" .and. _xChvCar > 0
		SZE -> (dbgoto (_xChvCar))
		::GeraAtrib ("SZE")

	// Se receber caracter, eh por que se trata de um codigo jah
	// existente nas tabelas, e preciso atualizar o objeto.
	elseif valtype (_xChvCar) == "C"
		sze -> (dbsetorder (1))  // ZE_FILIAL, ZE_SAFRA, ZE_CARGA, R_E_C_N_O_, D_E_L_E_T_
		if sze -> (dbseek (_xChvCar, .F.))
			::GeraAtrib ("SZE")
		else
			::UltMsg += "Problema ao instanciar carga: Nao localizei chave '" + _xChvCar + "' na tabela SZE."
			U_help (::UltMsg,, .t.)
		endif
	endif

//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Instanciada carga p/ Filial ' + ::Filial + ' Safra ' + ::Safra + ' Carga ' + ::Carga + ' de ' + ::Fornece + '/' + ::Loja)
	U_ML_SRArea (_aAreaAnt)
Return ::self


// --------------------------------------------------------------------------
// Adiciona uma posicao em cada array de itens.
METHOD AddItem () Class ClsCarSaf
	aadd (::ItConducao, '')
	aadd (::ItDescri,   '')
	aadd (::ItItem,     '')
	aadd (::ItGrau,     '')
	aadd (::ItProduto,  '')
return


// --------------------------------------------------------------------------
// Altera o status do agendamento relacionado a esta carga na agenda do NaWeb.
METHOD AtuAgenda (_sStatPara) Class ClsCarSaf
	local _lRetWSNA  := .F.
	local _oWSNaWeb  := NIL
	local _sXMLCarg  := ''
	local _lContinua := .T.
	local _sZZAAtual := ''

	// Lista de status passados pela Daiana em 26/10/22:
	// Dis Disponível
	// AGE Agendado
	// RES Reservado
	// INS Inspecionado
	// AUT Autorizada entrada
	// LIB Liberada
	// EMP Em processamento
	// CON Concluido processamento
	// REJ Rejeitada
	// REI Reinspecionar
	// SEG Segregada
	// CNF Concluida NF

	// Obs. ref. status de cargas compartilhadas, sendo uma delas segregada:
	// Questionei o Leonardo (agronomia) assim: "posso assumir que em caso de
	// cargas compartilhadas, se uma carga for segregada, obrigatoriamente a
	// outra tambem deve ser, pois as uvas foram misturadas no transporte?"
	// Ele me explicou que, fisicamente, de fato as uvas sao misturadas. Mas
	// ocorre caso de problemas somente na documentacao, etc. e o outro
	// produtor nao merece a mesma penalidade. Robert, 02/02/2023.

	// Analisa situacao do arquivo de integracao com medidor de grau
	_sZZAAtual = ::StatusZZA ()

	// Define o que vai enviar para o NaWeb
	_sStatPara = ''
	if _lContinua
		do case
		case ::Segregada
			_sStatPara = 'SEG'  // Segregada
		case ! empty (::Contranota)
			_sStatPara = 'CNF'  // Concluida NF
		case _sZZAAtual == '3'
			_sStatPara = 'CON'  // Processamento concluido
		case _sZZAAtual == '2'  // Muito provavelmente o NaWeb vai ver isso bem antes que o Protheus
			_sStatPara = 'EMP'  // Em processamento
		case ::PesoBruto > 0
			_sStatPara = 'LIB'  // Liberada (para ir ate o tombador e descarregar)
		otherwise
			u_help ("Situacao nao prevista. Nao sei o que enviar para o NaWeb para definir o status da carga " + ::Carga,, .T.)
			U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + ']_sZZAAtual: ' + cvaltochar (_sZZAAtual))
			u_logObj (::Self)
			_lContinua = .F.
		endcase
	endif

	if _lContinua
		_sXMLCarg := '<?xml version="1.0" encoding="utf-8"?>'
		_sXMLCarg += '<SDT_Cargas>'
		_sXMLCarg +=    '<Itens>'
		_sXMLCarg +=    '<Filial>'   + ::Filial   + '</Filial>'
		_sXMLCarg +=    '<Safra>'    + ::Safra    + '</Safra>'
		_sXMLCarg +=    '<Carga>'    + ::Carga    + '</Carga>'
		_sXMLCarg +=    '<Situacao>' + _sStatPara + '</Situacao>'
		_sXMLCarg +=    '</Itens>'
		_sXMLCarg += '</SDT_Cargas>'

		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sXMLCarg)
		
		_oWSNaWeb := WSPrcStatusAgendaSafraWS():New()
		_oWSNaWeb:cEntrada := _sXMLCarg
		_oWSNaWeb:Execute()
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retorno do NaWeb: ' + CVALTOCHAR (_oWSNaWeb:cSaida))

		if cvaltochar (_oWSNaWeb:cSaida) == 'OK'
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Alteracao da carga foi aceita pelo NaWeb')
			_lRetWSNA = .T.

			// Grava evento para posterior rastreamento
		//nao precisa mais... estah funcionando muito bem	::GrvEvt ('SZE004', "Enviado novo status (" + _sStatPara + ") para o NaWeb.")
		else
			::UltMsg += "Alteracao da carga '" + ::Carga + "' nao foi aceita pelo NaWeb: " + cvaltochar (_oWSNaWeb:cSaida)
			u_help (::UltMsg,, .t.)
			_lRetWSNA = .F.

			// Grava evento para posterior rastreamento
			::GrvEvt ('SZE004', "ERRO ao enviar novo status (" + _sStatPara + ") para o NaWeb: " + ::UltMsg)
		endif
	endif
return _lRetWSNA


// --------------------------------------------------------------------------
// Gera uma string formatada para mostrar em tela as cargas compartilhadas.
METHOD ConsCompar () Class ClsCarSaf
	local _sConsComp := ''
	local _aComp := {}
	local _nComp := 0
	local _aAreaAnt := U_ML_SRArea ()


	_aComp = aclone (U_SeparaCpo (::TodasComp (), '/'))
	if len (_aComp) == 0
		_sConsComp = "Carga nao compartilhada com nenhuma outra."
	else
		_sConsComp = "Carga compartilhada com:" + chr (13) + chr (10)
	endif
	for _nComp = 1 to len (_aComp)
		if _aComp [_nComp] != ::Carga  // A carga atual tambem consta na lista, mas fica estranho listar ela aqui
			_sConsComp += 'Carga ' + _aComp [_nComp]
			_sConsComp += ' de ' + fBuscaCpo ("SZE", 1, ::Filial + ::Safra + _aComp [_nComp], "ZE_NOMASSO")
			_sConsComp += chr (13) + chr (10)
		endif
	next

	U_ML_SRArea (_aAreaAnt)
return _sConsComp


// --------------------------------------------------------------------------
// Envia atualizacao para o sistema de medicao de grau.
METHOD AtuZZA (_lReenvio) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _lRetAtZZA := .T.
	local _nItem     := 0
	local _sChaveZZA := ''

	// Possiveis situacoes para o campo ZZA_STATUS:
	// 0 = carga cadastrada no Protheus, ainda nao pesada. Programa BL01 ignora-a;
	// 1 = carga com 1a.pesagem pronta, pode descarregar. Programa BL01 lista-a para o usuario ao clicar no botao 'Filial/Safra/Carga';
	// 2 = carga selecionada pelo usuario no programa BL01. Estah pronto para medir grau, ou jah medindo;
	// 3 = usuario clicou botao 'Armazenar' no programa BL01 e jah gravou tambem o ZZA_GRAU.
	// M = usuario (do Protheus) finalizou manualmente (ZZA_STATUS nao estava 3 por algum motivo).
	// C = Carga cancelada no Protheus

	if _lRetAtZZA .and. ::PesoBruto <= 0 .and. ::StatusCar != 'C'
		u_help ("Carga ainda nao tem peso bruto. Efetue, antes, a primeira pesagem.",, .t.)
		_lRetAtZZA = .F.
	endif
	if _lRetAtZZA .and. ::StatusCar $ 'R/N/D'  // 1=Primeira pesagem OK;2=Segunda pesagem OK;R=Recibo impresso;N=NF gerada;D=Redirecionada;C=Cancelada
		u_help ("Status da carga nao permite mais ser reenviada para leitura de grau.",, .t.)
		_lRetAtZZA = .F.
	endif
	if _lRetAtZZA .and. ::Aglutin $ 'D/O'
		u_help ("Esta eh uma carga aglutinada ou aglutinadora. Nao pode mais ser enviada para o grau.",, .t.)
		_lRetAtZZA = .F.
	endif
	if _lRetAtZZA
		zza -> (dbsetorder (1))  // ZZA_FILIAL, ZZA_SAFRA, ZZA_CARGA, ZZA_PRODUT
		for _nItem = 1 to len (::ItItem)
			_sChaveZZA = U_TamFixo (::Filial, 2) + U_TamFixo (::Safra, 4) + U_TamFixo (::Carga, 4) + U_TamFixo (::ItItem [_nItem], 15)
			U_Log2 ('debug', '[' + procname () + ']Pesqusando ZZA com >>' + _sChaveZZA + '<<')
		
			if ! zza -> (dbseek (_sChaveZZA, .F.))
				u_log2 ('info', '[' + procname () + ']Carga:' + ::Carga + ' Item: ' + ::ItItem [_nItem] + ' Incluindo ZZA')
				reclock ("ZZA", .T.)
				// Se nao existia ZZA, nem vou tratar como reenvio.
				_lReenvio = .F.
			else
				u_log2 ('info', '[' + procname () + ']Carga:' + ::Carga + ' Item: ' + ::ItItem [_nItem] + ' Vou alterar ZZA (zza_status encontra-se com ' + zza -> zza_status + ')')
				reclock ("ZZA", .F.)
			endif

			// Campos 'basicos' sao atualizados sempre.
			zza -> zza_filial = ::Filial
			zza -> zza_safra  = ::Safra
			zza -> zza_carga  = ::Carga
			zza -> zza_produt = ::ItItem [_nItem]
			zza -> zza_nprod  = ::ItDescri [_nItem]
			zza -> zza_nassoc = ::NomeFornec

			// Quando solicitado reenvio manualmente, faz algumas verificacoes adicionais.
			if _lReenvio
				if zza -> zza_status == '1'
					u_help ("Status do item " + zza -> zza_nprod + " ja encontra-se como 'aguardando leitura do grau'.",, .t.)
				elseif zza -> zza_status == '0' .or. (zza -> zza_status == '2' .and. U_MsgNoYes ("Item " + zza -> zza_nprod + " encontra-se com status 'em descarga' na tabela de integracao com medidor de grau. Deseja reiniciar o status?"))
					zza -> zza_status = iif (::PesoBruto <= 0, '0', '1')

				elseif zza -> zza_status $ '3/M'
					_sMsg = "Status do item " + zza -> zza_nprod + " encontra-se 'concluido' na tabela de integracao com o medidor de grau (resultado: " + cvaltochar (zza -> zza_grau) + " gravado em " + zza -> zza_inist3 + "."
					
					// Se foi gravado com grau zero, deve ter dado algum problema, ou clicaram em 'armazenar' sem medir nada.
					if zza -> zza_grau = 0
						if u_msgNoYes (_sMsg + " Deseja reenviar para nova medicao?")
							zza -> zza_status = iif (::PesoBruto <= 0, '0', '1')
						endif
					else
						u_help (_sMsg + " Reenvio para medicao de grau nao permitida, pois ja contem valor no grau.")
					endif
				endif
			else

				if ::StatusCar $ 'C/D'  // Carga [C]ancelada ou [D]irecionada para outra filial
					zza -> zza_status = 'C'
				elseif ::PesoBruto == 0
					zza -> zza_status = '0'
				elseif ::PesoTara > 0 .and. zza -> zza_status != '3' .and. val (::ItGrau [_nItem]) > 0  // Jah fez a segunda pesagem, sem finalizar no BL01.
					u_log2 ('info', '[' + procname () + ']Carga:' + ::Carga + ' Item: ' + ::ItItem [_nItem] + ' Alterando ZZA_STATUS para M por que jah estah sendo feita a segunda pesagem, mesmo sem finalizar no programa do grau.')
					zza -> zza_status = 'M'
				elseif ::PesoBruto > 0 .and. ::PesoTara == 0
					if empty (zza -> zza_status) .or. zza -> zza_status == '0'
						zza -> zza_status = '1'
					endif
				elseif ::PesoBruto > 0 .and. ::PesoTara > 0 .and. zza -> zza_status == '3'  // Segunda pesagem OK
					u_log2 ('aviso', "Nao vou enviar nada para o programa do grau por que, no grau, esta carga jah encontra-se com status=3 (finalizada)")
				else
					u_help ("Situacao imprevista na gravacao do campo ZZA_STATUS. Revise programa!",, .t.)
				endif
			endif
			msunlock ()
		next
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRetAtZZA


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD DefImprTk (_sFilial, _sCamFixo) Class ClsCarSaf
	//local _sIdImpr := ''

	_sFilial = iif (empty (_sFilial), ::Filial, _sFilial)

	if ! empty (_sCamFixo)
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Recebi um caminho fixo para impressora: ' + _sCamFixo)
		::PortImpTk = _sCamFixo
	else
		// Se for base teste, evita enviar para a impressora padrao para nao causar confusao com a safra normal.
		if U_AmbTeste()
			::PortImpTk := '\\192.168.1.3\siga\ticket.txt'
		else
			::PortImpTk = GetMV ("VA_ITKSAFR")
		endif
	endif
return


// --------------------------------------------------------------------------
// Faz o enderecamento (ou estorno)dos lotes de uva no estoque
METHOD EnderEstq (_sQueFazer) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _aAmbAnt   := U_SalvaAmb ()
	local _oSQL      := NIL
	local _aRegSDA   := {}
	local _nRegSDA   := 0
	local _aAutoSDA  := {}
	local _aAutoSDB  := {}
	local _aLinhaSDB := {}
	local _lContinua := .T.
	local _sItemSDB  := ''

	// Se for estorno, filtra a tabela e chama tela padrao do sistema.
	// O usuario deverah clicar no botao 'estornar'.
	if _sQueFazer == 'E'  // Estornar
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Chamando tela estorno enderecamento docto ' + ::Contranota)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT SDA.R_E_C_N_O_ AS REGSDA, SDB.R_E_C_N_O_ AS REGSDB"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD1") + " SD1, "
		_oSQL:_sQuery +=             RetSQLName ("SDA") + " SDA, "
		_oSQL:_sQuery +=             RetSQLName ("SDB") + " SDB "
		_oSQL:_sQuery += " WHERE SD1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SD1.D1_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_DOC     = '" + ::Contranota + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_SERIE   = '" + ::SerieCtrn + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_FORNECE = '" + ::Fornece + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_LOJA    = '" + ::Loja + "'"
		_oSQL:_sQuery +=   " AND SDA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SDA.DA_FILIAL  = SD1.D1_FILIAL"
		_oSQL:_sQuery +=   " AND SDA.DA_DOC     = SD1.D1_DOC"
		_oSQL:_sQuery +=   " AND SDA.DA_SERIE   = SD1.D1_SERIE"
		_oSQL:_sQuery +=   " AND SDA.DA_CLIFOR  = SD1.D1_FORNECE"
		_oSQL:_sQuery +=   " AND SDA.DA_LOJA    = SD1.D1_LOJA"
		_oSQL:_sQuery +=   " AND SDA.DA_ORIGEM  = 'SD1'"
		_oSQL:_sQuery +=   " AND SDA.DA_NUMSEQ  = SD1.D1_NUMSEQ"
		_oSQL:_sQuery +=   " AND SDA.DA_PRODUTO = SD1.D1_COD"
		_oSQL:_sQuery +=   " AND SDA.DA_SALDO   < SDA.DA_QTDORI"
		_oSQL:_sQuery +=   " AND SDB.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SDB.DB_FILIAL  = SDA.DA_FILIAL"
		_oSQL:_sQuery +=   " AND SDB.DB_DOC     = SDA.DA_DOC"
		_oSQL:_sQuery +=   " AND SDB.DB_SERIE   = SDA.DA_SERIE"
		_oSQL:_sQuery +=   " AND SDB.DB_CLIFOR  = SDA.DA_CLIFOR"
		_oSQL:_sQuery +=   " AND SDB.DB_LOJA    = SDA.DA_LOJA"
		_oSQL:_sQuery +=   " AND SDB.DB_ORIGEM  = SDA.DA_ORIGEM"
		_oSQL:_sQuery +=   " AND SDB.DB_NUMSEQ  = SDA.DA_NUMSEQ"
		_oSQL:_sQuery +=   " AND SDB.DB_PRODUTO = SDA.DA_PRODUTO"
		_oSQL:Log ()
		_aRegSDA = _oSQL:Qry2Array (.F., .F.)
		if len (_aRegSDA) == 0
			u_help ("Nao encontrei enderecamento para estornar.")
		else

			U_Log2 ('debug', _aRegSDA)
			sda -> (dbgoto (_aRegSDA [1, 1]))  // SDA usa apenas 1 registro
			_aAutoSDA = {}
			aadd (_aAutoSDA, {"DA_PRODUTO", sda -> da_produto, nil})
			aadd (_aAutoSDA, {"DA_LOCAL"  , SDA -> DA_LOCAL,   nil})
			aadd (_aAutoSDA, {"DA_NUMSEQ" , SDA -> DA_NUMSEQ,  nil})
			aadd (_aAutoSDA, {"DA_DOC"    , SDA -> DA_DOC,     nil})
			aadd (_aAutoSDA, {"DA_SERIE"  , SDA -> DA_SERIE,   nil})
			_aAutoSDB = {}
			for _nRegSDA = 1 to len (_aRegSDA)  // SBD eh uma linha para cada registro (pensar que trata-se de um aCols)
				U_Log2 ('debug', '[' + procname () + ']Linha:' + cvaltochar (_nRegSDA))
				U_Log2 ('debug', _aRegSDA [_nRegSDA])
				sdb -> (dbgoto (_aRegSDA [_nRegSDA, 2]))
				_aLinhaSDB = {}
				aadd (_aLinhaSDB, {"DB_ITEM"   , sdb -> db_item,    nil})
				aadd (_aLinhaSDB, {"DB_ESTORNO", 'S', nil})
				aadd (_aLinhaSDB, {"DB_LOCALIZ", sdb -> db_localiz, nil})
				aadd (_aLinhaSDB, {"DB_QUANT"  , sdb -> db_quant,   nil})
				aadd (_aLinhaSDB, {"DB_DATA"   , sdb -> db_data,    nil})
				_aLinhaSDB = aclone (U_OrdAuto (_aLinhaSDB))
				U_Log2 ('debug', _aLinhaSDB)
				aadd (_aAutoSDB, aclone (_aLinhaSDB))
			next
			lMsErroAuto := .F.
			MSExecAuto({|x,y,z| mata265(x,y,z)}, _aAutoSDA, _aAutoSDB, 4)
			If lMsErroAuto
				_lContinua = .F.
				u_log2 ('erro', 'lMsErroAuto')
				if ! empty (NomeAutoLog ())
					u_log2 ('erro', memoread (NomeAutoLog ()))
					MostraErro()
				else
					u_help ("Nao foi possivel ler o arquivo de log de erros da rotina de enderecamento de uva no estoque.",, .t.)
				endif
			else
				U_Log2 ('debug', '[' + procname () + ']MATA265 retornou OK')
			endif

		endif
	elseif _sQueFazer == 'I'  // Incluir

		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Iniciando enderecamento docto ' + ::Contranota)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT SDA.R_E_C_N_O_"
		
		// Posso estar reenderecando uma nota. Nesse caso, preciso gerar o
		// campo DB_ITEM maior que 0001.
		_oSQL:_sQuery +=      " ,ISNULL ((SELECT MAX (DB_ITEM)
		_oSQL:_sQuery +=                  " FROM " + RetSQLName ("SDB") + " SDB "
		_oSQL:_sQuery +=                 " WHERE SDB.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=                   " AND SDB.DB_FILIAL = SDA.DA_FILIAL"
		_oSQL:_sQuery +=                  " AND SDB.DB_PRODUTO = SDA.DA_PRODUTO"
		_oSQL:_sQuery +=                  " AND SDB.DB_DOC = SDA.DA_DOC"
		_oSQL:_sQuery +=                  " AND SDB.DB_SERIE = SDA.DA_SERIE"
		_oSQL:_sQuery +=                  " AND SDB.DB_CLIFOR = SDA.DA_CLIFOR"
		_oSQL:_sQuery +=                  " AND SDB.DB_LOJA = SDA.DA_LOJA"
		_oSQL:_sQuery +=                  " AND SDB.DB_LOTECTL = SDA.DA_LOTECTL"
		_oSQL:_sQuery +=                  " AND SDB.DB_NUMSEQ = SDA.DA_NUMSEQ"
		_oSQL:_sQuery +=                  " AND SDB.DB_ORIGEM = SDA.DA_ORIGEM), '0000')"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD1") + " SD1, "
		_oSQL:_sQuery +=             RetSQLName ("SDA") + " SDA "
		_oSQL:_sQuery += " WHERE SD1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SD1.D1_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_DOC     = '" + ::Contranota + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_SERIE   = '" + ::SerieCtrn + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_FORNECE = '" + ::Fornece + "'"
		_oSQL:_sQuery +=   " AND SD1.D1_LOJA    = '" + ::Loja + "'"
		_oSQL:_sQuery +=   " AND SDA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SDA.DA_FILIAL  = SD1.D1_FILIAL"
		_oSQL:_sQuery +=   " AND SDA.DA_DOC     = SD1.D1_DOC"
		_oSQL:_sQuery +=   " AND SDA.DA_SERIE   = SD1.D1_SERIE"
		_oSQL:_sQuery +=   " AND SDA.DA_CLIFOR  = SD1.D1_FORNECE"
		_oSQL:_sQuery +=   " AND SDA.DA_LOJA    = SD1.D1_LOJA"
		_oSQL:_sQuery +=   " AND SDA.DA_ORIGEM  = 'SD1'"
		_oSQL:_sQuery +=   " AND SDA.DA_NUMSEQ  = SD1.D1_NUMSEQ"
		_oSQL:_sQuery +=   " AND SDA.DA_PRODUTO = SD1.D1_COD"
		_oSQL:_sQuery +=   " AND SDA.DA_SALDO   > 0"
		_oSQL:Log ()
		_aRegSDA = _oSQL:Qry2Array (.F., .F.)
		if len (_aRegSDA) == 0
			u_help ("Nenhum produto com saldo a enderecar para esta carga/contranota.")
		endif
		_sItemSDB = Soma1 (_aRegSDA [1, 2])
		for _nRegSDA = 1 to len (_aRegSDA)
			sda -> (dbgoto (_aRegSDA [_nRegSDA, 1]))
			_aAutoSDA = {}
			aadd (_aAutoSDA, {"DA_PRODUTO", sda -> da_produto, nil})
			aadd (_aAutoSDA, {"DA_LOCAL"  , SDA -> DA_LOCAL    , nil})
			aadd (_aAutoSDA, {"DA_NUMSEQ" , SDA -> DA_NUMSEQ   , nil})
			aadd (_aAutoSDA, {"DA_DOC"    , SDA -> DA_DOC      , nil})
			aadd (_aAutoSDA, {"DA_SERIE"  , SDA -> DA_SERIE    , nil})

			_aAutoSDB = {}
			_aLinhaSDB = {}
		//	aadd (_aLinhaSDB, {"DB_ITEM", '0001', nil})
			aadd (_aLinhaSDB, {"DB_ITEM", _sItemSDB, nil})
			if ::Filial == '01'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T01PCP03       ', nil})
			elseif ::Filial == '03'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T03 PCP AX 03  ', nil})
			elseif ::Filial == '07'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T07 PCP 03     ', nil})
			elseif ::Filial == '09'
				aadd (_aLinhaSDB, {"DB_LOCALIZ", 'T09 PCP AX 03  ', nil})
			endif
			aadd (_aLinhaSDB, {"DB_QUANT"  , SDA->DA_QTDORI   , nil})
			aadd (_aLinhaSDB, {"DB_DATA"   , dDATABASE        , nil})
			U_Log2 ('info', 'Enderecando docto ' + sda -> da_doc + ' / produto ' + sda -> da_produto)
			_aLinhaSDB = aclone (U_OrdAuto (_aLinhaSDB))
			aadd (_aAutoSDB, aclone (_aLinhaSDB))
			lMsErroAuto := .F.
			MSExecAuto({|x,y,z| mata265(x,y,z)}, _aAutoSDA, _aAutoSDB, 3)
			If lMsErroAuto
				_lContinua = .F.
				u_log2 ('erro', 'lMsErroAuto')
				if ! empty (NomeAutoLog ())
					u_log2 ('erro', memoread (NomeAutoLog ()))
					MostraErro()
				else
					u_help ("Nao foi possivel ler o arquivo de log de erros da rotina de enderecamento de uva no estoque.",, .t.)
				endif
			endif
			_sItemSDB = soma1 (_sItemSDB)
		next
	else
		u_help ('Sem tratamento para acao ' + _sQueFazer,, .t.)
	endif

	U_SalvaAmb (_aAmbAnt)
	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Exclusao definitiva (inclusive tabelas relacionadas).
// Antes da safra eh comum fazermos muitas cargas para simulacao e ajuste de
// programas, e essas cargas ficam poluindo o sistema (muitas vezes, ateh,
// seguindo a numeracao do ano anterior).
METHOD ExclDef (_sOrigem) Class ClsCarSaf
	local _lRetED   := .T.
	local _aAreaAnt := U_ML_SRArea ()
	local _sFrom    := ''
	local _oSQL     := NIL

	if _lRetED .and. sze -> ze_status != 'C'
		::UltMsg += "Somente cargas com status C-cancelada podem ser definitivamente excluidas."
		_lRetED = .F.
	endif

	// Se for carga gerada atraves da aglutinacao de outras, desmarca o flag
	// de aglutinacao das cargas originais e deleta a tabela de cargas relacionadas.
	if _lRetED .and. ::Aglutin == "D"
		_sFrom := ""
		_sFrom += " FROM " + RetSQLName ("SZE") + " SZE, "
		_sFrom +=            RetSQLName ("ZZD") + " ZZD "
		_sFrom += " WHERE SZE.D_E_L_E_T_ = ''"
		_sFrom +=   " AND SZE.ZE_FILIAL  = '" + xfilial ("SZE") + "'"
		_sFrom +=   " AND SZE.ZE_SAFRA   = '" + ::Safra + "'"
		_sFrom +=   " AND ZZD.D_E_L_E_T_ = ''"
		_sFrom +=   " AND ZZD.ZZD_FILIAL = '" + xfilial ("ZZD") + "'"
		_sFrom +=   " AND ZZD.ZZD_SAFRA  = SZE.ZE_SAFRA"
		_sFrom +=   " AND ZZD.ZZD_CARDES = '" + ::Carga + "'"
		_sFrom +=   " AND ZZD.ZZD_CARORI = SZE.ZE_CARGA"
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery = "UPDATE SZE SET SZE.ZE_AGLUTIN = 'N' " + _sFrom
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lRetED = _oSQL:Exec ()
		if _lRetED
			_oSQL:_sQuery = "UPDATE ZZD SET ZZD.D_E_L_E_T_ = '*' " + _sFrom
			_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			_lRetED = _oSQL:Exec ()
		endif
	endif

	// Exclui esta carga das listas de compartilhamento das demais
	if _lRetED
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery := "UPDATE SZE SET SZE.ZE_CCOMPAR = replace (replace (SZE.ZE_CCOMPAR, '" + ::Carga + "', ''), '//', '/')"
		_oSQL:_sQuery := "UPDATE SZE SET SZE.ZE_CCOMPAR = replace (replace (SZE.ZE_CCOMPAR, '" + ::Carga + "', ''), '//', '/')"
		_oSQL:_sQuery += " FROM " + RetSQLName ("SZE") + " SZE "
		_oSQL:_sQuery += " WHERE SZE.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SZE.ZE_FILIAL  = '" + xfilial ("SZE") + "'"
		_oSQL:_sQuery +=   " AND SZE.ZE_SAFRA   = '" + ::Safra + "'"
		_oSQL:_sQuery +=   " AND SZE.ZE_CCOMPAR LIKE '%" + ::Carga + "%'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lRetED = _oSQL:Exec ()
	endif

	// Exclui eventos relacionados a esta carga
	if _lRetED
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery := "UPDATE " + RetSQLName ("SZN")
		_oSQL:_sQuery +=   " SET D_E_L_E_T_ = '*'"
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZN_FILIAL  = '" + xfilial ("SZN") + "'"
		_oSQL:_sQuery +=   " AND ZN_ALIAS   = 'SZE'"
		_oSQL:_sQuery +=   " AND ZN_COD     = '" + ::Safra + ::Carga + "'"
		_oSQL:_sQuery +=   " AND ZN_RECNO   = " + cvaltochar (::RegSZE)
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lRetED = _oSQL:Exec ()
	endif

	// Exclui itens da carga
	if _lRetED
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery := "UPDATE " + RetSQLName ("SZF")
		_oSQL:_sQuery +=   " SET D_E_L_E_T_ = '*'"
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZF_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND ZF_SAFRA   = '" + ::Safra  + "'"
		_oSQL:_sQuery +=   " AND ZF_CARGA   = '" + ::Carga  + "'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lRetED = _oSQL:Exec ()
	endif

	// Exclui itens enviados para o grau
	if _lRetED
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery := "UPDATE " + RetSQLName ("ZZA")
		_oSQL:_sQuery +=   " SET D_E_L_E_T_ = '*'"
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZZA_FILIAL  = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND ZZA_SAFRA   = '" + ::Safra  + "'"
		_oSQL:_sQuery +=   " AND ZZA_CARGA   = '" + ::Carga  + "'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lRetED = _oSQL:Exec ()
	endif

	// Exclui cabecalho da carga
	if _lRetED
		sze -> (dbgoto (::RegSZE))
		reclock ("SZE", .f.)
		sze -> (dbdelete ())
		msunlock ()
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRetED


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sOrigem) Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _lContinua := .T.
	local _nItemGD   := 0

	// Defaults
	::aIntegGrau   = {}
	::Aglutin    = ''
	::Carga      = ''
	::Contranota = ''
	::CCompart   = {}
	::CXouGranel = ''
	::Filial     = ''
	::Fornece    = ''
	::ItConducao = {}
	::ItDescri   = {}
	::ItGrau     = {}
	::ItItem     = {}
	::ItProduto  = {}
	::Loja       = ''
	::NomeFornec = ''
	::PesoBruto  = 0
	::PesoTara   = 0
	::RegSZE     = 0
	::Safra      = ''
	::Segregada  = .F.
	::SerieCtrn  = ''
	::StatusCar  = ''
	::UltMsg     = ''

	do case
	case _sOrigem == 'M'  // Variaveis M->
		::Filial     = xfilial ("SZE")
		::Aglutin    = m->ze_aglutin
		::Safra      = m->ze_safra
		::Carga      = m->ze_carga
		::CCompart   = aclone (U_SeparaCpo (alltrim (m->ze_ccompar), '/'))
		::Contranota = m->ze_nfger
		::Fornece    = m->ze_assoc
		::Loja       = m->ze_lojasso
		::NomeFornec = m->ze_nomasso
		::PesoBruto  = m->ze_pesobru
		::PesoTara   = m->ze_pesotar
		::Segregada  = (m->ze_segreg == 'S')
		::SerieCtrn  = m->ze_serie
		::StatusCar  = m->ze_status

		// Alimenta array de itens
		for _nItemGD = 1 to len (aCols)
			::AddItem ()
			atail (::ItConducao) = GDFieldGet ("ZF_CONDUC",  _nItemGD)
			atail (::ItDescri)   = GDFieldGet ("ZF_DESCRI",  _nItemGD)
			atail (::ItGrau)     = GDFieldGet ("ZF_GRAU",    _nItemGD)
			atail (::ItItem)     = GDFieldGet ("ZF_ITEM",    _nItemGD)
			atail (::ItProduto)  = GDFieldGet ("ZF_PRODUTO", _nItemGD)
		next

	case _sOrigem == "SZE"
		::Aglutin    = sze -> ze_aglutin
		::Carga      = sze -> ze_carga
		::Filial     = sze -> ze_filial
		::CCompart   = aclone (U_SeparaCpo (alltrim (sze->ze_ccompar), '/'))
		::Contranota = sze -> ze_nfger
		::Fornece    = sze -> ze_assoc
		::Loja       = sze -> ze_lojasso
		::NomeFornec = sze -> ze_nomasso
		::PesoBruto  = sze -> ze_pesobru
		::PesoTara   = sze -> ze_pesotar
		::RegSZE     = sze -> (recno ())
		::Safra      = sze -> ze_safra
		::Segregada  = (sze -> ze_segreg == 'S')
		::SerieCtrn  = sze -> ze_serie
		::StatusCar  = sze -> ze_status

		// Alimenta array de itens
		szf -> (dbsetorder (1))  // filial + safra + carga + item
		szf -> (dbseek (xfilial ("SZF") + sze -> ze_safra + sze -> ze_carga, .T.))
		do while ! szf -> (eof ()) ;
			.and. szf -> zf_filial == xfilial ("SZF") ;
			.and. szf -> zf_safra  == sze -> ze_safra ;
			.and. szf -> zf_carga  == sze -> ze_carga

			::AddItem ()
			atail (::ItConducao) = szf -> zf_conduc
			atail (::ItDescri)   = fBuscaCpo ("SB1", 1, xfilial ("SB1") + szf -> zf_produto, "B1_DESC")
			atail (::ItGrau)     = szf -> zf_grau
			atail (::ItItem)     = szf -> zf_item
			atail (::ItProduto)  = szf -> zf_produto

			szf -> (dbskip ())
		enddo

	otherwise
		if ! empty (_sOrigem)  // Se origem vazia, eh por que estou apenas instanciando um objeto vazio.
			::UltMsg += "Impossivel gerar atributos. Origem '" + _sOrigem + "' desconhecida."
			u_help (::UltMsg,, .t.)
		endif
		_lContinua = .F.
	endcase

	if _lContinua
		::CxOuGranel = iif (::Filial == '03', 'C', 'G')  // Somente Livramento ainda recebe em caixas
	endif

	// Alimenta array de informacoes da tabela de integracao com medidor de grau.
	if _lContinua .and. ! empty (::Filial) .and. ! empty (::Safra) .and. ! empty (::Carga)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT ZZA_PRODUT, ZZA_STATUS, ZZA_GRAU"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZZA") + " ZZA"
		_oSQL:_sQuery += " WHERE ZZA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_FILIAL = '" + ::Filial + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_SAFRA  = '" + ::Safra + "'"
		_oSQL:_sQuery +=   " AND ZZA.ZZA_CARGA  = '" + ::Carga + "'"
		_oSQL:_sQuery += " ORDER BY ZZA.ZZA_PRODUT"
		//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		::aIntegGrau := aclone (_oSQL:Qry2Array (.F., .F.))
	endif

	//u_logobj (::Self)
	//U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Gerei atributos usando origem = ' + _sOrigem + ' e ficou assim:')
	//::Log ()
	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Grava evento padrao do sistema.
METHOD GrvEvt (_sCodEvt, _sTxtEvt) Class ClsCarSaf
	local _oEvento := NIL

	_oEvento := ClsEvent():new ()
	_oEvento:CodEven    = _sCodEvt
//	_oEvento:Texto      = 'Safra ' + ::Safra + ' Carga ' + ::Carga + ' ' + _sTxtEvt
	_oEvento:Texto      = _sTxtEvt
//	_oEvento:Recno      = ::RegSZE
	_oEvento:Safra      = ::Safra
	_oEvento:CargaSafra = ::Carga
	_oEvento:Alias      = 'SZE'
	_oEvento:CodAlias   = ::Safra + ::Carga
	_oEvento:NFEntrada  = ::Contranota
	_oEvento:SerieEntr  = ::SerieCtrn
	_oEvento:Fornece    = ::Fornece
	_oEvento:LojaFor    = ::Loja
	_oEvento:Grava ()
return


// --------------------------------------------------------------------------
// Gera (re)impressao do ticket da carga.
METHOD ImprimeTk (_nQualTk) Class ClsCarSaf
	local _nQtVias := 0
	// Se nao especificado qual ticket (1a. ou 2a. pesagem), verifica se quais dados jah tem.
	if empty (_nQualTk)
		_nQualTk = iif (::PesoTara != 0, 2, 1)
	endif
	
	// Producao propria: nao preciso entregar segunda via de ticket a ninguem.
	if ::Fornece == '001369' .and. ::Loja == '02'
		_nQtVias = 1
	else
		_nQtVias := iif (_nQualTk == 1, 1, 2)
	endif

	U_VA_RusTk (_nQualTk, ::PortImpTk, _nQtVias, {}, 'bematech', .t.)

return


// --------------------------------------------------------------------------
// Grava dados da carga em arquivo de log, para ajudar em rastreio de problemas.
METHOD Log () Class ClsCarSaf
	local _sLogCar  := ''
	local _nItCarga := 0
//	local _nCompart := 0

	_sLogCar += '  Filial: ' + ::Filial + ' Safra: ' + ::Safra + ' Carga: ' + ::Carga + ' Status: ' + ::StatusCar + chr (13) + chr (10)
	_sLogCar += '  Peso bruto: ' + cvaltochar (::PesoBruto) + ' Peso tara: ' + cvaltochar (::PesoTara) + chr (13) + chr (10)
	_sLogCar += '  Fornecedor: ' + ::Fornece + '/' + ::Loja + ' - ' + ::NomeFornec + chr (13) + chr (10)
	for _nItCarga = 1 to len (::ItItem)
		_sLogCar += '    It.' + ::ItItem [_nItCarga] + ': '
		_sLogCar += alltrim (::ItProduto [_nItCarga])
		_sLogCar += U_TamFixo (' - '   + alltrim (::ItDescri  [_nItCarga]), 25, ' ')
		_sLogCar += ' Gr: ' + ::ItGrau [_nItCarga]
		_sLogCar += ' Sist.cond: ' + ::ItConducao [_nItCarga]
		_sLogCar += chr (13) + chr (10)
	next
	if len (::CCompart) > 0
		_sLogCar += '  ' + ::ConsCompar ()
	endif
	U_Log2 ('info', '-----------------------------------------------')
	U_Log2 ('info', _sLogCar)
	U_Log2 ('info', '-----------------------------------------------')
return _sLogCar


// --------------------------------------------------------------------------
// Verifica se 'tudo ok' na segunda pesagem da carga.
METHOD SegPesTOk () Class ClsCarSaf
	local _aAreaAnt := U_ML_SRArea ()
	local _l2PesTOK := .T.
	local _sGrau    := ''
	local _nItemCar := 0
	local _sMsg     := ''
	local _nCompart := 0

//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']iniciando...')

	// Para referenciar alguma outra carga como compartilhada, essa deve existir.
	if _l2PesTOK
		sze -> (dbsetorder (1))  // ZE_FILIAL+ZE_SAFRA+ZE_CARGA
		for _nCompart = 1 to len (::CCompart)
			if ! sze -> (dbseek (::Filial + ::Safra + ::CCompart [_nCompart], .F.))
				::UltMsg += "Carga compartilhada '" + ::CCompart [_nCompart] + "' nao foi localizada!"
				_l2PesTOK = .F.
			else
				// Se estou incluindo/gerando carga nova
				if ::PesoBruto == 0 .and. sze -> ze_pesotar > 0
					::UltMsg += "A carga compartilhada '" + ::CCompart [_nCompart] + "' ja encontra-se com segunda pesagem. O normal seria gerar as cargas compartilhadas todas em sequencia, e somente depois disso, comecar as pesagens e o recebimento."
					_l2PesTOK = .F.
				endif
			endif
		next
	endif

	// Todas as variedades da carga devem ter mesmo grau (excecao para Livramento
	// que, no momento em que estou fazendo esta validacao, recebe uva em caixas
	// e, portanto, tem condicao de medir o grau separadamente.
	if _l2PesTOK .and. ::PesoTara > 0
		_sMsg = ''
		_sGrau = ''
		for _nItemCar = 1 to len (_oCarSaf:ItItem)
			if empty (_sGrau)
				_sGrau = _oCarSaf:ItGrau [_nItemCar]
			else
				if _oCarSaf:ItGrau [_nItemCar] != _sGrau
					_l2PesTOK = .F.
					exit
				endif
			endif
		next
		if ! _l2PesTOK
			_sMsg = "Todos os itens da carga deveriam apresentar o mesmo grau"
			if cFilAnt == '03'
				if U_MsgNoYes (_sMsg + " . Confirma?")
					_sMsg += " (mas, sendo recebimento em caixas, existe possibilidade de medicao do grau em separado)."
					_l2PesTOK = .T.
					U_Log2 ('aviso', '[' + procname () + ']Gravar aqui um evento de graus diferentes na carga!')
				endif
			else
				_sMsg += ", uma vez que a carga foi recebida a granel."
				::UltMsg += _sMsg
			endif
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _l2PesTOK


// --------------------------------------------------------------------------
// Altera o lote de estoque para 'NC' (nao conforme).
// Tive tantos casos de 'esquecemos de segregar a carga' que resolvi automatizar um pouco.
METHOD SegregarLt () Class ClsCarSaf
	local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _lContinua := .t.
	local _sWhereSD1 := ''
	local _aLotesSD1 := {}
	local _nLoteSD1  := 0
	local _sWhereSB8 := ''
	local _aLotesSB8 := {}
	local _sWhereSBF := ''
	local _aLotesSBF := {}
	local _sLoteNovo := ''

	if _lContinua .and. ! ::Segregada
		::UltMsg += "Carga nao eh segregada"
		_lContinua = .F.
	endif
	if _lContinua
		_sWhereSD1 +=  " FROM " + RetSQLName ("SD1") + " SD1"
		_sWhereSD1 += " WHERE SD1.D_E_L_E_T_ = ''"
		_sWhereSD1 +=   " AND SD1.D1_FILIAL  = '" + xfilial ("SD1") + "'"
		_sWhereSD1 +=   " AND SD1.D1_DOC     = '" + ::Contranota + "'"
		_sWhereSD1 +=   " AND SD1.D1_SERIE   = '" + ::SerieCtrn + "'"
		_sWhereSD1 +=   " AND SD1.D1_FORNECE = '" + ::Fornece + "'"
		_sWhereSD1 +=   " AND SD1.D1_LOJA    = '" + ::Loja + "'"
		_sWhereSD1 +=   " AND substring (SD1.D1_LOTECTL, 9, 2) != 'NC'"
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT D1_COD, D1_LOTECTL, D1_NUMSEQ"
		_oSQL:_sQuery += _sWhereSD1
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_aLotesSD1 = aclone (_oSQL:Qry2Array (.f., .f.))
		U_Log2 ('debug', _aLotesSD1)
		if len (_aLotesSD1) == 0
			u_help ("Nao encontrei nenhum lote de estoque precisando ser alterado para 'NC'")
		endif
	endif

	// Verifica se teve movimentacao e se pode alterar os lotes
	if _lContinua
		for _nLoteSD1 = 1 to len (_aLotesSD1)
			_lContinua = .T.  // Para tentar os proximos lotes, caso de problema neste.
			_sWhereSB8 :=  " FROM " + RetSQLName ("SB8") + " SB8"
			_sWhereSB8 += " WHERE SB8.D_E_L_E_T_ = ''"
			_sWhereSB8 +=   " AND SB8.B8_FILIAL  = '" + xfilial ("SB8") + "'"
			_sWhereSB8 +=   " AND SB8.B8_PRODUTO = '" + _aLotesSD1 [_nLoteSD1, 1] + "'"
			_sWhereSB8 +=   " AND SB8.B8_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"
			_sWhereSB8 +=   " AND SB8.B8_DOC     = '" + ::Contranota + "'"
			_sWhereSB8 +=   " AND SB8.B8_SERIE   = '" + ::SerieCtrn  + "'"
			_sWhereSB8 +=   " AND SB8.B8_CLIFOR  = '" + ::Fornece    + "'"
			_sWhereSB8 +=   " AND SB8.B8_LOJA    = '" + ::Loja       + "'"
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT B8_QTDORI, B8_SALDO, B8_LOCAL"
			_oSQL:_sQuery += _sWhereSB8
			_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			_aLotesSB8 = aclone (_oSQL:Qry2Array (.f., .f.))
			if len (_aLotesSB8) != 1
				::UltMsg += "Problema na leitura de lotes na tabela SB8. Nenhum (ou mais de um) registro encontrado!"
				_lContinua = .F.
			else
				if _aLotesSB8 [1, 1] != _aLotesSB8 [1, 2]
					::UltMsg += "Saldo do lote na tabela SB8 difere do original (ja teve movimentacao). Lote '" + _aLotesSD1 [_nLoteSD1, 2] + "' nao pode mais ser alterado."
					_lContinua = .F.
				else
					// Verifica se jah foi enderecado.
					_sWhereSBF :=  " FROM " + RetSQLName ("SBF") + " SBF"
					_sWhereSBF += " WHERE SBF.D_E_L_E_T_ = ''"
					_sWhereSBF +=   " AND SBF.BF_FILIAL  = '" + xfilial ("SBF") + "'"
					_sWhereSBF +=   " AND SBF.BF_PRODUTO = '" + _aLotesSD1 [_nLoteSD1, 1] + "'"
					_sWhereSBF +=   " AND SBF.BF_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"
					_sWhereSBF +=   " AND SBF.BF_LOCAL   = '" + _aLotesSB8 [1, 3] + "'"
					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := "SELECT BF_LOCALIZ, BF_QUANT, SUM (BF_QUANT) OVER ()"
					_oSQL:_sQuery += _sWhereSBF
					_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
					_aLotesSBF = aclone (_oSQL:Qry2Array (.f., .f.))
					if len (_aLotesSBF) > 0 .and. _aLotesSBF [1, 3] != _aLotesSB8 [1, 2]
						::UltMsg += "Quant.total enderecada diferente do saldo inicial do lote (ja teve movimentacao). Lote '" + _aLotesSD1 [_nLoteSD1, 2] + "' nao pode mais ser alterado."
						_lContinua = .F.
					endif
				endif
			endif
			
			// Se cheguei ateh aqui sem erros para este lote, posso alterar ele.
			if _lContinua
				U_Log2 ('debug', '[' + procname () + ']Testes iniciais ok... alterando lote ' + _aLotesSD1 [_nLoteSD1, 2])
				_sLoteNovo = left (_aLotesSD1 [_nLoteSD1, 2], 8) + 'NC'
				begin transaction

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SD1 SET D1_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery += _sWhereSD1
				_oSQL:_sQuery += " AND D1_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:_sQuery += " AND D1_NUMSEQ  = '" + _aLotesSD1 [_nLoteSD1, 3] + "'"
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SB8 SET B8_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery += _sWhereSB8
				_oSQL:_sQuery += " AND B8_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SBF SET BF_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery += _sWhereSBF
				_oSQL:_sQuery += " AND BF_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SDA SET DA_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery +=  " FROM " + RetSQLName ("SDA") + " SDA"
				_oSQL:_sQuery += " WHERE SDA.D_E_L_E_T_ = ''"
				_oSQL:_sQuery +=   " AND SDA.DA_FILIAL  = '" + xfilial ("SDA") + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_DOC     = '" + ::Contranota + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_SERIE   = '" + ::SerieCtrn + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_CLIFOR  = '" + ::Fornece + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_LOJA    = '" + ::Loja + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_PRODUTO = '" + _aLotesSD1 [_nLoteSD1, 1] + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:_sQuery +=   " AND SDA.DA_NUMSEQ  = '" + _aLotesSD1 [_nLoteSD1, 3] + "'"
				_oSQL:_sQuery +=   " AND SDA.DA_ORIGEM  = 'SD1'"
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SDB SET DB_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery +=  " FROM " + RetSQLName ("SDB") + " SDB"
				_oSQL:_sQuery += " WHERE SDB.D_E_L_E_T_ = ''"
				_oSQL:_sQuery +=   " AND SDB.DB_FILIAL  = '" + xfilial ("SDB") + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_DOC     = '" + ::Contranota + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_SERIE   = '" + ::SerieCtrn + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_CLIFOR  = '" + ::Fornece + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_LOJA    = '" + ::Loja + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_PRODUTO = '" + _aLotesSD1 [_nLoteSD1, 1] + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:_sQuery +=   " AND SDB.DB_NUMSEQ  = '" + _aLotesSD1 [_nLoteSD1, 3] + "'"
				_oSQL:_sQuery +=   " AND SDB.DB_ORIGEM  = 'SD1'"
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := "UPDATE SD5 SET D5_LOTECTL = '" + _sLoteNovo + "'"
				_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD5") + " SD5"
				_oSQL:_sQuery += " WHERE SD5.D_E_L_E_T_ = ''"
				_oSQL:_sQuery +=   " AND SD5.D5_FILIAL  = '" + xfilial ("SD5") + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_DOC     = '" + ::Contranota + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_SERIE   = '" + ::SerieCtrn + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_CLIFOR  = '" + ::Fornece + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_LOJA    = '" + ::Loja + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_PRODUTO = '" + _aLotesSD1 [_nLoteSD1, 1] + "'"
				_oSQL:_sQuery +=   " AND SD5.D5_LOTECTL = '" + _aLotesSD1 [_nLoteSD1, 2] + "'"  // Para o case de ter mais de um item na nota
				_oSQL:_sQuery +=   " AND SD5.D5_NUMSEQ  = '" + _aLotesSD1 [_nLoteSD1, 3] + "'"
				_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
				if ! _oSQL:Exec ()
					DisarmTransaction ()
					_lContinua = .F.
				endif

				end transaction
				
				// Reprocessa saldo atual
				if _lContinua
					if ! U__Mata300 (_aLotesSD1 [_nLoteSD1, 1], _aLotesSD1 [_nLoteSD1, 1], _aLotesSD1 [_nLoteSD1, 2], _aLotesSD1 [_nLoteSD1, 2])
						::UltMsg += "Erro no reprocessamento do saldo atual do produto " + _aLotesSD1 [_nLoteSD1, 1]
						_lContinua = .F.
					else
						if ! U_ConsEstq (cFilAnt, _aLotesSD1 [_nLoteSD1, 1], _aLotesSD1 [_nLoteSD1, 2], '')
							::UltMsg += "Estoques do produto " + _aLotesSD1 [_nLoteSD1, 1] + " ficaram inconsistentes depois de segregar o lote!"
							_lContinua = .F.
						endif
					endif
				endif
			endif
		next
	endif

	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Faz uma analise da integracao com o grau (pode ter mais de um item na carga)
// e procura definir o status do ZZA 'como um todo' para a carga.
METHOD StatusZZA () Class ClsCarSaf
	local _sRetStZZA := ''

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Avaliando carga recebida em ' + ::CXouGranel + ' com registros assim:')
	U_Log2 ('debug', ::aIntegGrau)
	
	// Quando a carga eh recebida em caixas, vale o 'menor' status por
	// que provavelmente cada variedade vai ser processada separadamente.
	if ::CXouGranel == 'C'
		if ascan (::aIntegGrau, {|_aVal| _aVal [2] == 'C'}) > 0
			_sRetStZZA = 'C'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '0'}) > 0
			_sRetStZZA = '0'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '1'}) > 0
			_sRetStZZA = '1'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '2'}) > 0
			_sRetStZZA = '2'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '3'}) > 0
			_sRetStZZA = '3'
		endif

	// Quando a carga eh recebida a granel, vale o 'maior' status por
	// que todas as variedades serao processadas junto. O programa do
	// grau vai dar o retorno em apenas um dos registros.
	elseif ::CXouGranel == 'G'
		if ascan (::aIntegGrau, {|_aVal| _aVal [2] == 'C'}) > 0
			_sRetStZZA = 'C'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '3'}) > 0
			_sRetStZZA = '3'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '2'}) > 0
			_sRetStZZA = '2'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '1'}) > 0
			_sRetStZZA = '1'
		elseif ascan (::aIntegGrau, {|_aVal| _aVal [2] == '0'}) > 0
			_sRetStZZA = '0'
		endif
		
	else
		u_help ("Conteudo desconhecido (" + ::CXouGranel + ") na analise do status da medicao de grau.")
	endif

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Retornando statusZZA = ' + _sRetStZZA + ' para a carga ' + ::Carga)
return _sRetStZZA


// --------------------------------------------------------------------------
// Uma vez que cargas podem ser compartilhadas (mais de um produtor rural
// usando o mesmo veiculo, como se viesse de carona), preciso uma forma de
// saber todas as cargas compartilhadas com a atual.
METHOD TodasComp (_sLista) Class ClsCarSaf
	local _nCompart := 0
	local _oCarAux  := NIL

	_sLista = iif (_sLista == NIL, '', _sLista)  // para o caso de ser chamada sem parametros.

//	U_Log2 ('debug', '[' + procname () + ']iniciando TodasComp para a carga ' + ::Carga + ' que tem ::CCompart = ' + _Arr2Str (::CCompart))

	// Se esta propria carga ainda nao estiver na lista, adiciona-a.
	if ! ::Carga $ _sLista
		_sLista += iif (empty (_sLista), '', '/') + ::Carga
	endif

	// Criterio de final de execucao: quando a carga nao apontar para nenhuma outra.
	if len (::CCompart) == 0
	else
		for _nCompart = 1 to len (::CCompart)
			if ! ::CCompart [_nCompart] $ _sLista
				_oCarAux := ClsCarSaf ():New (::Filial + ::Safra + ::CCompart [_nCompart])
				_sLista = _oCarAux:TodasComp (_sLista)
			endif
		next
	endif
return _sLista


static function _Arr2Str (_a)
	local _n := 0
	local _sRet := ''
	for _n = 1 to len (_a)
		_sRet += cvaltochar (_a [_n]) + iif (_n < len (_a), '/', '')
	next
return _sRet


// --------------------------------------------------------------------------
// Identifica a variedade de menor valor
METHOD VarMenorVl () class ClsCarSaf
	local _aProdut   := {}
	local _nProdut   := 0
	local _aTodasCar := {}
	local _nTodasCar := {}
	local _oCarAux   := NIL
	local _aAreaAnt  := U_ML_SRArea ()
	local _aAux      := {}

	// Faz uma lista de cargas compartilhadas (se houver) a verificar.
	if len (::CCompart) > 0
		_aTodasCar = U_SeparaCpo (::TodasComp (), '/')
	else  // Se nao tiver compartilhamento, eh somente a propria carga.
		_aTodasCar = {::Carga}
	endif
	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Lista de todas as cargas a verificar: ' + _Arr2Str (_aTodasCar))

	// Monta lista de todas as variedades envolvidas.
	for _nTodasCar = 1 to len (_aTodasCar)

		// Se for a carga atual, leio seus atributos (pode ainda nao estar gravada)
		if _aTodasCar [_nTodasCar] == ::Carga
			for _nProdut = 1 to len (::ItItem)
				if ascan (_aProdut, {|_aVal| _aVal [1] == ::ItProduto [_nProdut] .and. _aVal [3] == ::ItConducao [_nProdut]}) == 0
					aadd (_aProdut, {::ItProduto [_nProdut], 0, ::ItConducao [_nProdut]})
				endif
			next
		else
			_oCarAux := ClsCarSaf ():New (::Filial + ::Safra + _aTodasCar [_nTodasCar])
			if empty (_oCarAux:Carga)
				u_help ("Impossivel instanciar carga compartilhada '" + _aTodasCar [_nTodasCar] + "'. Verificacao de variedade de menor valor nao pode ser feita.",, .t.)
			else
				for _nProdut = 1 to len (_oCarAux:ItItem)
					if ascan (_aProdut, {|_aVal| _aVal [1] == _oCarAux:ItProduto [_nProdut] .and. _aVal [3] == _oCarAux:ItConducao [_nProdut]}) == 0
						aadd (_aProdut, {_oCarAux:ItProduto [_nProdut], 0, _oCarAux:ItConducao [_nProdut]})
					endif
				next
			endif
		endif
	next

	// Busca precos para as variedades envolvidas.
	// Manter aqui sempre a mesma politica do VA_RUSN !!!
	for _nProdut = 1 to len (_aProdut)
		if ::Safra == '2019'
			_aProdut [_nProdut, 2] = U_PrcUva19 (::Filial, _aProdut [_nProdut, 1], 15.0, 'B', _aProdut [_nProdut, 3])[1]
		elseif ::Safra == '2020'
			_aProdut [_nProdut, 2] = U_PrcUva20 (::Filial, _aProdut [_nProdut, 1], 15.0, 'B', _aProdut [_nProdut, 3], .F.)[5]  // pos.5=preco MOC
		elseif ::Safra == '2021'
			_aProdut [_nProdut, 2] = U_PrcUva21 (::Filial, _aProdut [_nProdut, 1], 15.0, 'B', _aProdut [_nProdut, 3], .F., .T.)[2]  // pos.2=preco de compra
		elseif ::Safra == '2022'
			_aProdut [_nProdut, 2] = U_PrcUva22 (::Filial, _aProdut [_nProdut, 1], 15.0, 'B', _aProdut [_nProdut, 3], .F., .T.)[2]  // pos.2 = preco de compra.
		elseif ::Safra == '2023'
			_aProdut [_nProdut, 2] = U_PrcUva23 (::Filial, _aProdut [_nProdut, 1], 15.0, 'B', _aProdut [_nProdut, 3], .F., .T.)[5]  // pos.5 = preco MOC
		else
			u_help (procname (1) + '.' + procname () + ": Sem tratamento para verificar precificacao em caso de mistura de variedades nesta safra.",, .t.)
		endif
	next
	
	// Elimina produtos com precos iguais.
	_aAux = {}
	for _nProdut = 1 to len (_aProdut)
		if ascan (_aAux, {|_aVal| _aVal [2] = _aProdut [_nProdut, 2]}) == 0
			aadd (_aAux, aclone (_aProdut [_nProdut]))
		endif
	next

	// Ordena por preco, de forma que, depois, baste pegar a primeira linha.
	_aProdut = asort (_aProdut,,, {|_x, _y| _x[2] < _y [2]})
	
	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Variedade(s) de menor valor envolvidas:')
	U_Log2 ('debug', _aProdut)

	// Se alguma variedade ficou sem valor, eh melhor nao retornar nada, pois
	// eh importante que eu consiga, sempre, buscar os precos de todas.
	if len (_aProdut) < 1
		u_help ("Problemas na busca da variedade de menor valor: nenhuma variedade lida!",, .t.)
		_aProdut = {}
	endif
	if _aProdut [1, 2] == 0
		u_help ("Problemas na busca da variedade de menor valor: variedade '" + alltrim (_aProdut [1, 1]) + "' ficou sem valor!",, .t.)
		_aProdut = {}
	endif

	U_ML_SRArea (_aAreaAnt)
return _aProdut
