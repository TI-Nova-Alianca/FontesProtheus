// Programa:  ClsEtiq
// Autor:     Robert Koch
// Data:      28/03/2022
// Descricao: Declaracao de classe de representacao de etiquetas usadas na producao.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa etiquetas usadas para identificacao de produtos e movimentacoes de estoque / integracoes com FullWMS.
// #PalavasChave      #etiquetas #integracao #FullWMS #producao
// #TabelasPrincipais #ZA1
// #Modulos           #EST #PCP

// Historico de alteracoes:
// 28/03/2022 - Robert - Criada a classe e iniciada migracao de diversos outros fontes para ca.
// 13/06/2022 - Robert - Ajuste leitura filial ZAG na impressao.
// 15/06/2022 - Robert - Ao instanciar etiqueta jah existente, tentava sempre buscar
//                       dados de lote, mesmo quando b1_rastro!='L' (GLPI 12220)
//                     - Impede exclusao de etiqueta de NF (migrado do VA_ETQPLL.PRW)
// 16/06/2022 - Robert - Verif.se a etiq.existe no FullWMS antes excluir (GLPI 12220).
// 26/07/2022 - Robert - Implementada verif.disponib.estq no metodo PodeApont() - GLPI 11994
// 29/07/2022 - Robert - Verif.saldo empenhos desconsiderava empenhos zerados.
// 01/08/2022 - Robert - Ajuste formula verif.saldo empenhos (GLPI 11994)
// 11/08/2022 - Robert - Criado metodo :Imprime (por enquanto, ainda chamando rotina externa)
//                     - Criado atributo :UltMsg
// 12/08/2022 - Robert - Criado atributo :AlmDest (GLPI 12474)
//                     - Melhorias leitura lote origem (ZAG e SD1)
// 25/08/2022 - Robert - Criado metodo :ApontaOP
// 23/09/2022 - Robert - Criado atributo :CBEmbCol e metodo :ValCBEmb - GLPI 11994
// 26/09/2022 - Robert - Funcao de inutilizacao migrada do fonte ZA1IN para metodo :Inutiliza()
// 05/10/2022 - Robert - Iniciado tratamento para etiquetas geradas a partir do SD5 (GLPI 12651)
// 24/10/2022 - Robert - Criado atributo :FinalidOP
// 31/10/2022 - Robert - Quando transf.p/ax01 via ZAG, busca zag_lotori (nao gera mais lote fajuto)
// 09/12/2022 - Robert - Criados atributos B1_CodBar, B1_VAFullW, DescriProd, PesoBruto, UM.
// 18/01/2023 - Robert - Criado atributo OPInvalida e testes para impedir impressao nesses casos.
// 19/01/2023 - Robert - Criado atributo AlmApontOP (almox.onde foi apontada a OP)
// 27/01/2023 - Robert - Metodo New passa a aceitar R_E_C_N_O_ ou chave de pesquisa.
//                     - Criados mais atributos alimentados pela leitura do SD3.
// 10/02/2023 - Robert - Tratamento para mais de uma etiqueta no metodo GeraPorSD5 - GLPI 13134.
// 13/02/2023 - Robert - Criado campo ZA1_QTGRUP
//

#Include "Protheus.ch"
#Include "RwMake.ch"
#Include "TbiConn.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsEtiq ()
return


// ==========================================================================
CLASS ClsEtiq

	// Declaracao das propriedades da Classe
	public  data AlmApontOP   // Almox.onde foi feito o apontamento da OP (quando etiq. de epontamento de OP)
	public  data AlmDest      // Almox.destino, quando transferencia (ZAG) ou apontamento de OP
	public  data AlmOrig      // Almox.origem, quando transferencia (ZAG) ou gerada com base no SD5 (lotes iniciais).
	public  data Apontada     // ZA1_APONT - Apontamento de producao ja executado (quando etiq. para OP)
	public  data B1_CodBar    // B1_CODBAR
	public  data B1_VAFullW   // B1_VAFULLW
	public  data Codigo       // ZA1_CODIGO - Numero da etiqueta
	public  data CBEmbCol     // C2_VABARCX - Cod.barras embalagem coletiva - Para validacao no momento de apontar a producao.
	public  data D5_NUMSEQ    // D5_NUMSEQ - Quando etiq. gerada a partir de um registro de origem MAN do SD5.
	public  data DescriProd   // B1_DESC
	public  data DocEntrForn  // ZA1_FORNEC - Quando refere-se a NF de entrada
	public  data DocEntrItem  // ZA1_ITEM - Quando refere-se a NF de entrada
	public  data DocEntrLoja  // ZA1_LOJAF - Quando refere-se a NF de entrada
	public  data DocEntrNum   // ZA1_DOCE - Quando refere-se a NF de entrada
	public  data DocEntrSerie // ZA1_SERIEE - Quando refere-se a NF de entrada
	public  data DtEmis       // ZA1_DATA
	public  data DtFabrLote   // Data de fabricacao do lote de produto
	public  data Filial       // ZA1_FILIAL
	public  data FinalidOP    // C2_vaOpEsp: N=Normal;R=Reprocesso;E=externa (em 3os);T=Terceirizacao (para 3os);F=Filtracao
	public  data IdZAG        // ZA1_IDZAG - Identificador de registro da tabela ZAG
	public  data Impressa     // ZA1_IMPRES - Jah impressa
	public  data Inutilizada  // ZA1_APONT='I' - Indica que foi inutilizada manualmente
	public  data ImprCBProd   // Indica se deve obrigatoriamente imprimir o cod.barras do produto.
	public  data LoteProduto
	public  data OP           // ZA1_OP
	public  data OPInvalida   // Jah tive casos de reimpressao de etiquetas de OPs excluidas!
	public  data PesoBruto    // B1_PESBRU * qtid (peso bruto total da etiqueta)
	public  data Produto      // ZA1_PROD
	public  data QtApontada   // Quando relacionada a uma OP
	public  data QtDE4        // Quantidade movimentada com D3_CF=DE4
	public  data QtEstornada  // Quando relacionada a uma OP
	public  data QtEtqGrupo   // C2_VAQTETQ - Quantidade de etiquetas do grupo (geralmente usada com OP)
	public  data QtPerdida    // Quando relacionada a uma OP
	public  data QtRE4        // Quantidade movimentada com D3_CF=RE4
	public  data Quantidade   // ZA1_QUANT
	private data RegZA1       // Numero registro (RECNO) no ZA1.
	public  data SeqNoGrupo   // ZA1_SEQ - Sequencia dentro do grupo, geralmente de OP. Ex.: 1 de 10, 2 de 10, ...
	public  data UltMsg       // Ultima mensagem gerada.
	public  data UM           // B1_UM
	public  data UsrIncl      // ZA1_USRINC - Usuario que incluiu/gerou a etiqueta
	public  data ValidLote    // Validade do lote

	// Declaracao dos Metodos da classe
	public METHOD New ()
	public METHOD ApontaOP ()
	public METHOD EnviaFull ()
	public METHOD Exclui ()
	public METHOD Imprime ()
	public METHOD Inutiliza ()
	public METHOD GeraAtrib ()
	public METHOD Grava ()
	public METHOD NovaPorSD5 ()
	public METHOD PodeEnvFul ()
	public METHOD PodeExcluir ()
	public METHOD PodeApont ()
	public METHOD ValCBEmb ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor.
METHOD New (_xChave) Class ClsEtiq

	// Se receber numerico, eh por que se trata do numero de registro
	// jah existente no ZA1 e preciso atualizar o objeto.
	if valtype (_xChave) == "N"
		ZA1 -> (dbgoto (_xChave))
		::GeraAtrib ("ZA1")

	// Se receber caracter, eh por que se trata de um codigo jah
	// existente nas tabelas, e preciso atualizar o objeto.
	elseif valtype (_xChave) == "C"
		//U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + '] >>' + xfilial ("ZA1") + _xChave + '<<')
		za1 -> (dbsetorder (1))  // ZA1_FILIAL+ZA1_CODIGO+ZA1_DATA+ZA1_OP
		if za1 -> (dbseek (xfilial ("ZA1") + _xChave, .F.))
			::GeraAtrib ("ZA1")
		else
			::UltMsg += "Problema ao instanciar etiqueta: Nao localizei codigo de etiqueta '" + _xChave + "' para a filial atual na tabela ZA1."
			U_help (::UltMsg,, .t.)
		endif

	else
		// Alimenta atributos com valores default de uma etiqueta nova.
		::GeraAtrib ("")
	endif
Return ::self


// --------------------------------------------------------------------------
// Gera apontamento de producao
METHOD ApontaOP (_dDtProd, _sTnoProd) Class ClsEtiq
	local _lRetAp    := .T.
	local _aAutoSD3  := {}

	if ! ::PodeApont (::Quantidade, 0)
		_lRetAp = .F.
	else
//		U_PerfMon ("I", "ClsEtiqApontaOP")  // Medicao de tempos de execucao
		aadd (_aAutoSD3, {"D3_OP",      ::OP,       NIL})
		aadd (_aAutoSD3, {"D3_VAETIQ",  ::Codigo,   NIL})
		aadd (_aAutoSD3, {"D3_VADTPRD", _dDtProd,   NIL})
		aadd (_aAutoSD3, {"D3_VATURNO", _sTnoProd,  NIL})
		aadd (_aAutoSD3, {"D3_VAMOTIV", 'PRODUCAO', NIL})
		aadd (_aAutoSD3, {"ATUEMP",     "T",        NIL})  // Para que sempre seja feita a baixa dos empenhos.
		_aAutoSD3 := aclone (U_OrdAuto (_aAutoSD3))
		//U_Log2 ('debug', _aAutoSD3)
		lMsErroAuto  := .F.
		_sErroAuto := ''
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Apontando etiq. ' + ::Codigo)
		//U_Log2 ('info', 'Executando MATA250')
		dbselectarea ("SD3")
		dbsetorder (1)
		MATA250 (_aAutoSD3, 3)
		If lMsErroAuto
			_lRetAp = .F.
			if ! empty (_sErroAuto)
				::UltMsg += _sErroAuto + '; '
			elseif ! empty (NomeAutoLog ())
				::UltMsg += U_LeErro (memoread (NomeAutoLog ())) + '; '
			endif
			u_help ('Erro rot.aut:' + alltrim (::UltMsg),, .t.)
		else
			::UltMsg += "Etiq." + ::Codigo + " apontada com sucesso (d3_numseq = " + sd3 -> d3_numseq + ")"
		endif
//		U_PerfMon ("F", "ClsEtiqApontaOP")  // Medicao de tempos de execucao
	endif
return _lRetAp


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sOrigem) Class ClsEtiq
	local _aAreaAnt := U_ML_SRArea ()
	local _oSQL     := NIL
	local _aLoteVal := {}
	local _aRetSD3  := {}
	local _nRegSD5  := 0

	// Defaults
	::AlmApontOP   = ''
	::AlmDest      = ''
	::AlmOrig      = ''
	::Apontada     = 'N'
	::B1_CodBar    = ''
	::B1_VAFullW   = ''
	::Codigo       = ''
	::CBEmbCol     = ''
	::D5_NUMSEQ    = ''
	::DescriProd   = ''
	::DocEntrForn  = ''
	::DocEntrItem  = ''
	::DocEntrLoja  = ''
	::DocEntrNum   = ''
	::DocEntrSerie = ''
	::DtEmis       = dDataBase //ctod ('')
	::DtFabrLote   = ctod ('')
	::Filial       = xfilial ("ZA1")
	::FinalidOP    = ''
	::IdZAG        = ''
	::Impressa     = 'N'
	::Inutilizada  = .F.
	::ImprCBProd   = 'N'
	::LoteProduto  = ''
	::OP           = ''
	::OPInvalida   = .F.  // Ateh prova em contrario...
	::PesoBruto    = 0
	::Produto      = ''
	::QtApontada   = 0
	::QtDE4        = 0
	::QtEstornada  = 0
	::QtEtqGrupo   = 0
	::QtPerdida    = 0
	::QtRE4        = 0
	::Quantidade   = 0
	::RegZA1       = 0
	::SeqNoGrupo   = ''
	::UltMsg       = ''
	::UM           = ''
	::UsrIncl      = cUserName
	::ValidLote    = ctod ('')

	do case
	case _sOrigem == 'M'  // Variaveis M->
		::Apontada     = m->ZA1_APONT
		::Codigo       = m->ZA1_CODIGO
		::D5_NUMSEQ    = m->ZA1_D5NSEQ
		::DocEntrForn  = m->ZA1_FORNEC
		::DocEntrItem  = m->ZA1_ITEM
		::DocEntrLoja  = m->ZA1_LOJAF
		::DocEntrNum   = m->ZA1_DOCE
		::DocEntrSerie = m->ZA1_SERIEE
		::DtEmis       = m->ZA1_DATA
		::Filial       = xfilial ("SZI")
		::IdZAG        = m->ZA1_IDZAG
		::Impressa     = m->ZA1_IMPRES
		::Inutilizada  = (m->za1_apont == 'I')
		::OP           = m->ZA1_OP
		::Produto      = m->ZA1_PROD
		::Quantidade   = m->ZA1_QUANT
		::QtEtqGrupo   = m->ZA1_QTGRUP
		::SeqNoGrupo   = m->ZA1_SEQ
		::UsrIncl      = m->ZA1_USRINC

	case _sOrigem == "ZA1"

		::Apontada     = za1 -> ZA1_APONT
		::Codigo       = za1 -> ZA1_CODIGO
		::D5_NUMSEQ    = za1 -> ZA1_D5NSEQ
		::DocEntrForn  = za1 -> ZA1_FORNEC
		::DocEntrItem  = za1 -> ZA1_ITEM
		::DocEntrLoja  = za1 -> ZA1_LOJAF
		::DocEntrNum   = za1 -> ZA1_DOCE
		::DocEntrSerie = za1 -> ZA1_SERIEE
		::DtEmis       = za1 -> ZA1_DATA
		::Filial       = za1 -> za1_filial
		::IdZAG        = za1 -> ZA1_IDZAG
		::Impressa     = za1 -> ZA1_IMPRES
		::Inutilizada  = (za1 -> za1_apont == 'I')
		::OP           = za1 -> ZA1_OP
		::Produto      = za1 -> ZA1_PROD
		::Quantidade   = za1 -> ZA1_QUANT
		::QtEtqGrupo   = za1 -> ZA1_QTGRUP
		::RegZA1       = za1 -> (recno ())
		::SeqNoGrupo   = za1 -> ZA1_SEQ
		::UsrIncl      = za1 -> ZA1_USRINC
	otherwise
		if ! empty (_sOrigem)  // Se origem vazia, eh por que estou apenas instanciando um objeto vazio.
			::UltMsg += "Impossivel gerar atributos. Origem '" + _sOrigem + "' desconhecida."
			u_help (::UltMsg,, .t.)
		endif
	endcase

	// Alimenta dados adicionais conforme a origem da etiqueta.
	if _sOrigem == 'M' .or. _sOrigem == "ZA1"
		sb1 -> (dbsetorder (1))
		if ! sb1 -> (dbseek (xfilial ("SB1") + ::Produto, .f.))
			u_help ('[' + GetClassName (::Self) + '.' + procname () + "]Nao localizado cadastro do produto '" + ::Produto + "' relacionado `a etiqueta '" + ::Codigo + "'.",, .t.)
		else
			::B1_CodBar  = sb1 -> b1_codbar
			::B1_VAFullW = sb1 -> b1_vafullw
			::DescriProd = sb1 -> b1_desc
			::PesoBruto  = sb1 -> b1_pesbru * ::Quantidade
			::UM         = sb1 -> b1_um
			do case
			case ! empty (::OP)
				::LoteProduto = substring (::OP, 1, 8)
				::AlmDest = sb1 -> b1_locpad
				sc2 -> (dbsetorder (1))
				if ! sc2 -> (dbseek (xfilial ("SC2") + ::OP, .f.))
					::OPInvalida = .T.
					u_help ('[' + GetClassName (::Self) + '.' + procname () + "]Impossivel encontrar a OP '" + ::OP + "' relacionada `a etiqueta '" + ::Codigo + "'.",, .t.)
				else
					::AlmOrig    = sc2 -> c2_local
					::CBEmbCol   = sc2 -> c2_vaBarCx
					::FinalidOP  = sc2 -> c2_vaOpEsp
					
					// DEIXAR ISTO POR UM TEMPO ATEH O CAMPO ZA1_QTGRUP ESTAR BEM POPULADO.
					// (OU FAZER UM UPDATE ZA1_QTGRUP = C2_VAQTETQ)
					if ::QtEtqGrupo == 0
						::QtEtqGrupo = sc2 -> c2_vaqtetq
					endif
					
					// Jah peguei casos de excluirem uma OP e cadastrarem uma
					// nova de mesmo numero, para outro produto!
					if ::Produto != sc2 -> c2_produto
						::UltMsg = "Produto da etiq.(" + alltrim (::Produto) + ") nao pode ser diferente do produto da OP (" + alltrim (sc2 -> c2_produto) + ")."
						u_help ('[' + GetClassName (::Self) + '.' + procname () + "]" + ::UltMsg,, .t.)
						::Produto = ''
						::OP = ''
					endif

					// OP de reprocesso assume dt valid do lote original, cfe informada pelo usuario.
					if sc2 -> c2_vaopesp == 'R'  // OP de reprocesso assume dt valid do lote original, cfe informada pelo usuario.
						if empty (sc2 -> c2_vadvori)
							u_help ('[' + GetClassName (::Self) + '.' + procname () + "]Impossivel buscar a data de validade do lote  da etiqueta '" + ::Codigo + "': a OP referenciada (" + ::OP + ") eh uma OP de reprocesso, e nao foi informada a data de validade do lote original no campo C2_VADVORI (" + alltrim (rettitle ("C2_VADVORI")) + ").",, .t.)
						else
							::ValidLote = sc2 -> c2_vadvori
						endif
					else
						::ValidLote = sc2 -> c2_datprf + sb1 -> b1_prvalid
					endif

					// Busca dados de apontamento de producao desta etiqueta.
					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := ""
					_oSQL:_sQuery += "SELECT ISNULL (SUM (CASE WHEN D3_ESTORNO != 'S' AND D3_CF LIKE 'PR%' THEN D3_QUANT   ELSE 0  END), 0) AS APONTAM"
					_oSQL:_sQuery +=      ", ISNULL (SUM (CASE WHEN D3_ESTORNO != 'S' AND D3_CF LIKE 'PR%' THEN D3_PERDA   ELSE 0  END), 0) AS PERDA"
					_oSQL:_sQuery +=      ", ISNULL (SUM (CASE WHEN D3_ESTORNO  = 'S' AND D3_CF LIKE 'ER%' THEN D3_QUANT   ELSE 0  END), 0) AS ESTORNO"
					_oSQL:_sQuery +=      ", ISNULL (MIN (CASE WHEN D3_ESTORNO != 'S' AND D3_CF LIKE 'PR%' THEN D3_VADTPRD ELSE '' END), 0) AS DTFABRIC"
					_oSQL:_sQuery +=      ", ISNULL (MAX (CASE WHEN D3_ESTORNO != 'S' AND D3_CF LIKE 'PR%' THEN D3_LOCAL   ELSE '' END), 0) AS ALMAPONT"
					_oSQL:_sQuery +=      ", ISNULL (SUM (CASE WHEN D3_ESTORNO != 'S' AND D3_CF = 'RE4' THEN D3_QUANT ELSE 0 END), 0) AS QT_RE4"
					_oSQL:_sQuery +=      ", ISNULL (SUM (CASE WHEN D3_ESTORNO != 'S' AND D3_CF = 'DE4' THEN D3_QUANT ELSE 0 END), 0) AS QT_DE4"
					_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD3") + " SD3"
					_oSQL:_sQuery += " WHERE SD3.D_E_L_E_T_ = ''"
					_oSQL:_sQuery +=   " AND SD3.D3_FILIAL  = '" + xfilial ("SD3") + "'"
					_oSQL:_sQuery +=   " AND SD3.D3_VAETIQ  = '" + ::Codigo + "'"
					//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
					_aRetSD3 := aclone (_oSQL:Qry2Array (.f., .f.))
					::QtApontada  = _aRetSD3 [1 , 1]
					::QtPerdida   = _aRetSD3 [1 , 2]
					::QtEstornada = _aRetSD3 [1 , 3]
					::DtFabrLote  = stod (_aRetSD3 [1 , 4])
					::AlmApontOP  = _aRetSD3 [1 , 5]
					::QtRE4       = _aRetSD3 [1 , 6]
					::QtDE4       = _aRetSD3 [1 , 7]
				endif

			case ! empty (::DocEntrNum)  // Etiqueta gerada por NF de entrada
				sd1 -> (dbsetorder (1))  // D1_FILIAL, D1_DOC, D1_SERIE, D1_FORNECE, D1_LOJA, D1_COD, D1_ITEM, R_E_C_N_O_, D_E_L_E_T_
				if ! sd1 -> (dbseek (::Filial + ::DocEntrNum + ::DocEntrSerie + ::DocEntrForn + ::DocEntrLoja + ::Produto + ::DocEntrItem, .F.))
					u_help ("NF/fornecedor/produto/item '" + ::DocEntrNum + '/' + ::DocEntrForn + '/' + ::Produto + '/' +::DocEntrItem + "' referenciada pela etiqueta '" + ::Codigo + "' nao foi localizada na tabela SD1.",, .t.)
				else
					::AlmDest    = sd1 -> d1_local
					if sb1 -> b1_rastro == 'L'
						_oSQL := ClsSQL ():New ()
						_oSQL:_sQuery := "SELECT B8_LOTECTL, B8_DTVALID, B8_DFABRIC"
						_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB8") + " SB8 "
						_oSQL:_sQuery += " WHERE SB8.D_E_L_E_T_ = ''"
						_oSQL:_sQuery +=   " AND SB8.B8_FILIAL  = '" + sd1 -> d1_filial  + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOTECTL = '" + sd1 -> d1_lotectl + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_PRODUTO = '" + sd1 -> d1_cod     + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOCAL   = '" + sd1 -> d1_local   + "'"
						//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
						_aLoteVal = aclone (_oSQL:RetFixo (1, "ao consultar lote do produto da etiqueta '" + ::Codigo + "' na NF de entrada '" + ::DocEntrNum + "'.", .T.))
						if len (_aLoteVal) == 1
							::LoteProduto = _aLoteVal [1, 1]
							::ValidLote   = stod (_aLoteVal [1, 2])
							::DtFabrLote  = stod (_aLoteVal [1, 3])
						endif
					endif
				endif

			case ! empty (::IdZAG)
				zag -> (dbsetorder (1))  // ZAG_FILIAL, ZAG_DOC, R_E_C_N_O_, D_E_L_E_T_
			//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Pesquisando ZAG com >>' + xfilial ("ZAG") + ::IdZAG + '<< para buscar lote e validade.')
				if ! zag -> (dbseek (xfilial ("ZAG") + ::IdZAG, .F.))
					u_help ("Solicitacao de transferencia '" + ::IdZAG + "' referenciada pela etiqueta '" + ::Codigo + "' nao foi localizada na tabela ZAG.",, .t.)
				else
					::AlmDest     = zag -> zag_almdst
					::LoteProduto = zag -> zag_lotdst  // zag_lotOri
					if sb1 -> b1_rastro == 'L'
						_oSQL := ClsSQL ():New ()
						_oSQL:_sQuery := "SELECT B8_LOTECTL, B8_DTVALID, B8_DFABRIC"
						_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB8") + " SB8 "
						_oSQL:_sQuery += " WHERE SB8.D_E_L_E_T_ = ''"
						_oSQL:_sQuery +=   " AND SB8.B8_FILIAL  = '" + zag -> zag_filori + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOTECTL = '" + zag -> zag_lotori + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_PRODUTO = '" + zag -> zag_prdori + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOCAL   = '" + zag -> zag_almori + "'"
						//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
						_aLoteVal = aclone (_oSQL:RetFixo (1, "ao consultar lote do produto da etiqueta '" + ::Codigo + "' na solicitacao de transferencia numero '" + ::IdZAG + "'.", .T.))
						if len (_aLoteVal) == 1
							::ValidLote   = stod (_aLoteVal [1, 2])
							::DtFabrLote  = stod (_aLoteVal [1, 3])
						endif
					endif
					
					// Se quero enviar para o FullWMS, tenho que ter algum lote
					// e validade. Enquanto eu nao tiver isso (seja por que o
					// produto nao controla lote no Protheus, ou por que ainda
					// nao implementamos uma maneira de informar na solicitacao
					// de transferencia), vou gerar uma validade fajuta.
					// Essa validade e lote serao enviados ao Full atraves da
					// tabela tb_wms_etiquetas (todas as entradas no Full devem
					// ser acompanhadas de uma etiqueta).
					if ::AlmDest == '01' .and. ! empty (::LoteProduto) .and. sb1 -> b1_rastro != 'L'
						::ValidLote   = date () + sb1 -> b1_prvalid
						U_Log2 ('aviso', '[' + GetClassName (::Self) + '.' + procname () + ']Gerando validade fajuta (' + dtoc (::ValidLote) + ') por que o Protheus nao controla rastro deste item, mas o Full vai exigir.')
					endif
				endif
			case ! empty (::D5_NUMSEQ)
				_nRegSD5 = _AchaSD5 (::Produto, ::D5_NUMSEQ)
				if _nRegSD5 > 0
					sd5 -> (dbgoto (_nRegSD5))
					::AlmDest     = sd5 -> d5_local
					::AlmOrig     = sd5 -> d5_local
					::LoteProduto = sd5 -> d5_lotectl
					::ValidLote   = sd5 -> d5_dtvalid

					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := "SELECT B8_LOTECTL, B8_DTVALID, B8_DFABRIC"
					_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB8") + " SB8 "
					_oSQL:_sQuery += " WHERE SB8.D_E_L_E_T_ = ''"
					_oSQL:_sQuery +=   " AND SB8.B8_FILIAL  = '" + ::Filial + "'"
					_oSQL:_sQuery +=   " AND SB8.B8_LOTECTL = '" + ::LoteProduto + "'"
					_oSQL:_sQuery +=   " AND SB8.B8_PRODUTO = '" + ::Produto + "'"
					_oSQL:_sQuery +=   " AND SB8.B8_LOCAL   = '" + ::AlmOrig + "'"
					//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
					_aLoteVal = aclone (_oSQL:RetFixo (1, "ao consultar lote do produto da etiqueta '" + ::Codigo + "' na implantacao de saldo/lote numero '" + ::D5_NUMSEQ + "'.", .T.))
					if len (_aLoteVal) == 1
						::DtFabrLote  = stod (_aLoteVal [1, 3])
					endif
				endif
			otherwise
				::UltMsg += "Impossivel determinar atributos adicionais. Origem de etiqueta desconhecida."
				u_help (::UltMsg,, .t.)
			endcase
		endif
	endif
	
	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Grava nova etiqueta na tabela ZA1.
// Minha intencao eh migrar a funcao U_IncEtqPll para este metodo.
METHOD Grava () Class ClsEtiq
	local _lGravou   := .F.
	local _aAreaAnt  := U_ML_SRArea ()
	local _sNextNum  := ''
	local _nSeqEtq   := 0
	local _sTxtLog   := ''
	local _lContinua := .T.

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Iniciando gravacao etiq')
	//u_logObj (::Self)
	if empty (::Produto)
		::UltMsg += "Produto nao informado. Gravacao de etiqueta nao permitida."
		_lContinua = .F.
	endif
	if empty (::DtEmis)
		::UltMsg += "Data emissao etiq.nao informada. Gravacao de etiqueta nao permitida."
		_lContinua = .F.
	endif
	if empty (::OP) .and. empty (::DocEntrNum) .and. empty (::IdZAG) .and. empty (::D5_NUMSEQ)
		::UltMsg += "Origem (OP, NF, sol.transf. ou D5_NUMSEQ) nao informada. Gravacao de etiqueta nao permitida."
		_lContinua = .F.
	endif
	if ::Quantidade <= 0
		::UltMsg += "Quantidade nao informada. Gravacao de etiqueta nao permitida."
		_lContinua = .F.
	endif
	if ! empty (::DocEntrNum) .and. (empty (::DocEntrSerie) .or. empty (::DocEntrItem) .or. empty (::DocEntrForn) .or. empty (::DocEntrLoja))
		::UltMsg += "Para NF entrada, devem ser informadas tambem serie, fornecedor, loja e item da nota. Gravacao de etiqueta nao permitida."
		_lContinua = .F.
	endif
	
	// Gera sequencial da etiqueta dentro do grupo (OP ou NF) a que pertence.
	if _lContinua
		if ! empty (::OP) .or. ! empty (::DocEntrNum)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += " SELECT COUNT (*)"
			_oSQL:_sQuery +=   " FROM " + RetSQLName ("ZA1")
			_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=    " AND ZA1_OP     = '" + ::OP + "'"
			_oSQL:_sQuery +=    " AND ZA1_DOCE   = '" + ::DocEntrNum + "'"
			_oSQL:_sQuery +=    " AND ZA1_SERIEE = '" + ::DocEntrSerie + "'"
			_oSQL:_sQuery +=    " AND ZA1_ITEM = '"   + ::DocEntrItem + "'"
			_oSQL:_sQuery +=    " AND ZA1_FORNEC = '" + ::DocEntrForn + "'"
			_oSQL:_sQuery +=    " AND ZA1_LOJAF  = '" + ::DocEntrLoja + "'"
			_nSeqEtq = _oSQL:RetQry () + 1
		endif
	endif

	if _lContinua
		begin transaction
		_sNextNum = U_NxtZA1 (::Produto)
		reclock ("ZA1",.T.)
		ZA1 -> ZA1_FILIAL = ::Filial
		ZA1 -> ZA1_CODIGO = _sNextNum
		ZA1 -> ZA1_DATA   = ::DtEmis
		ZA1 -> ZA1_OP     = ::OP
		ZA1 -> ZA1_PROD   = ::Produto
		ZA1 -> ZA1_QUANT  = ::Quantidade
		za1 -> za1_doce   = ::DocEntrNum
		za1 -> za1_seriee = ::DocEntrSerie
		za1 -> za1_item   = ::DocEntrItem
		za1 -> za1_fornec = ::DocEntrForn
		za1 -> za1_lojaf  = ::DocEntrLoja
		za1 -> za1_seq    = _nSeqEtq
		za1 -> za1_usrinc = cUserName
		za1 -> za1_idZAG  = ::IdZAG
		za1 -> ZA1_D5NSEQ = ::D5_NUMSEQ
		za1 -> ZA1_qtgrup = ::QtEtqGrupo
		msunlock()
		::Codigo     = za1 -> za1_codigo
		::SeqNoGrupo = za1 -> za1_seq
		::RegZA1     = za1 -> (recno ())
		_lGravou = .T.
		end transaction
	endif

	// Grava sequenciais, se existirem.
	do while __lSX8
		ConfirmSX8 ()
	enddo

	// Monta um textinho bonitinho para log.
	if _lGravou
		_sTxtLog := 'Etiqueta ' + za1 -> za1_codigo + ' gravada.'
		_sTxtLog += ' Produto: ' + alltrim (za1 -> za1_prod)
		_sTxtLog += iif (! empty (za1 -> za1_op),     ' OP: '     + alltrim (za1 -> za1_op),     '')
		_sTxtLog += iif (! empty (za1 -> za1_idZAG),  ' ZAG: '    + alltrim (za1 -> za1_idZAG),  '')
		_sTxtLog += iif (! empty (za1 -> za1_doce),   ' NF: '     + alltrim (za1 -> za1_doce),   '')
		_sTxtLog += iif (! empty (za1 -> za1_d5nseq), ' D5NSEQ: ' + alltrim (za1 -> ZA1_D5NSEQ), '')
		u_log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sTxtLog)
	else
		U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + ']Etiqueta NAO gravada.' + ::UltMsg)
	endif

	U_ML_SRArea (_aAreaAnt)
return _lGravou


// --------------------------------------------------------------------------
// Gera etiquetas para lote jah existente no estoque. A intencao desta operacao
// eh poder etiquetar lotes jah existentes no estoque quando a rastreabilidade
// for habilitada para um produto, pois esses 'lotes iniciais' nao terao sua
// origem a partir de um movimento de estoque (lotes posteriores serao criados
// atraves de um apontamento de OP, ou uma nota de compra, etc.)
METHOD NovaPorSD5 (_sProduto, _sLote, _sAlmox, _sNumSeq, _nQtDesta, _nQtGrupo, _nSeqNoGrp) Class ClsEtiq
	local _aAreaAnt := U_ML_SRArea ()
	local _nRegSD5  := 0
	local _lRetNSD5 := .T.

	U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Tentando criar etiqueta para produto/lote/almox/numseq ' + _sProduto + '/' + _sLote + '/' + _sAlmox + '/' + _sNumSeq)
	_nRegSD5 = _AchaSD5 (_sProduto, _sNumSeq)
	if _nRegSD5 == 0
		::UltMsg += "Nao encontrei registro com origem MAN para o produto/lote/almox/NumSeq informados. Geracao de etiquetas cancelada."
		u_help (::UltMsg,, .t.)
		_lRetNSD5 = .F.
	else
		sd5 -> (dbgoto (_nRegSD5))
		::AlmDest     = sd5 -> d5_local
		::AlmOrig     = sd5 -> d5_local
		::D5_NUMSEQ   = sd5 -> d5_numseq
		::DtEmis      = date ()
		::Filial      = xfilial ("ZA1")
		::LoteProduto = sd5 -> d5_lotectl
		::Produto     = sd5 -> d5_produto
		::Quantidade  = _nQtDesta  //sd5 -> d5_quant
		::QtEtqGrupo  = _nQtGrupo  // contagem total de etiq.gerada para este registro do SD5. Ex.: "eiqueta 1 de 5"
		::SeqNoGrupo  = _nSeqNoGrp
		::ValidLote   = sd5 -> d5_dtvalid
		if ! ::Grava ()
			::UltMsg += "Nao foi possivel gravar a etiqueta."
			u_help (::UltMsg,, .t.)
			_lRetNSD5 = .F.
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRetNSD5


// --------------------------------------------------------------------------
// Verifica se pode ser feito apontamento de producao da etiqueta.
METHOD PodeApont (_nQtApont, _nQtPerda) Class ClsEtiq
	Local _aAreaAnt  := U_ML_SRArea ()
	local _lContinua := .T.
	local _nQtTot    := 0
	local _oSQL      := NIL
	local _aSemSaldo := {}
	local _nSemSaldo := 0
	local _sMsgSaldo := ''

	if _lContinua .and. empty (::OP)
		u_help ("Etiq.'" + ::Codigo + "' nao vinculada a nenhuma OP.",, .t.)
		_lContinua = .f.
	endif
	if _lContinua .and. ::Inutilizada
		::UltMsg += "Etiq.'" + ::Codigo + "' inutilizada."
		_lContinua := .F.
	endif
	if _lContinua .and. ::Impressa != 'S'
		u_help ("Etiq.'" + ::Codigo + "' ainda nao impressa.",, .t.)
		_lContinua = .f.
	endif
	if _lContinua .and. (::QtApontada + ::QtPerdida) > 0
		u_help ("Etiq.'" + ::Codigo + "' ja gerou apontamento de producao.",, .t.)
		_lContinua = .f.
	endif
	if _lContinua .and. ::QtEstornada > 0
		U_help ("Etiq.'" + ::Codigo + "' ja foi apontada e ESTORNADA. Gere nova etiqueta.",, .t.)
		_lContinua = .F.
	endif
	if _lContinua .and. empty (::CBEmbCol)
		U_help ("Cod.barras p/embalagem coletiva nao informado na OP.",, .t.)
		_lContinua = .F.
	endif
	if _lContinua
		_nQtTot = ::QtApontada + ::QtPerdida + _nQtApont + _nQtPerda
		if _nQtTot != ::Quantidade
			u_help ("Erro etiq.'" + ::Codigo + "':Qt.produzida+perdida (" + cvaltochar (_nQtTot) + ") nao pode ser diferente da quantidade prevista da etiqueta (" + cvaltochar (::Quantidade) + ").",, .t.)
			_lContinua = .F.
		endif
	endif

	// Verifica disponibilidade de saldo dos empenhos.
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " WITH C AS ("
		_oSQL:_sQuery += " SELECT D4_COD"
		_oSQL:_sQuery +=        ",B1_DESC"
	//	_oSQL:_sQuery +=        ",(SUM (D4_QTDEORI) * " + cvaltochar (_nQtApont + _nQtPerda) + ") / C2_QUANT AS QT_A_REQ"
		_oSQL:_sQuery +=        ",CASE WHEN SUM (D4_QUANT) = 0"
		_oSQL:_sQuery +=             " THEN 0"
		_oSQL:_sQuery +=             " ELSE (SUM(D4_QTDEORI) * " + cvaltochar (_nQtApont + _nQtPerda) + ") / C2_QUANT"
		_oSQL:_sQuery +=        " END AS QT_A_REQ"
		_oSQL:_sQuery +=        ",ISNULL (SB2.B2_QATU, 0) AS ESTQ"
		_oSQL:_sQuery +=        ",B1_UM"
		_oSQL:_sQuery +=        ",D4_LOCAL"
		_oSQL:_sQuery += " FROM " + RetSQLName ("SC2") + " SC2"
		_oSQL:_sQuery +=      "," + RetSQLName ("SB1") + " SB1"
		_oSQL:_sQuery +=      "," + RetSQLName ("SD4") + " SD4"
		_oSQL:_sQuery +=     " LEFT JOIN " + RetSQLName ("SB2") + " SB2"
		_oSQL:_sQuery +=          " ON (SB2.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=          " AND SB2.B2_FILIAL  = SD4.D4_FILIAL"
		_oSQL:_sQuery +=          " AND SB2.B2_COD     = SD4.D4_COD"
		_oSQL:_sQuery +=          " AND SB2.B2_LOCAL   = SD4.D4_LOCAL)"
		_oSQL:_sQuery += " WHERE SD4.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SD4.D4_FILIAL  = '" + xfilial ("SD4") + "'"
		_oSQL:_sQuery +=   " AND SD4.D4_OP      = '" + ::OP + "'"
		_oSQL:_sQuery +=   " AND SC2.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SC2.C2_FILIAL  = SD4.D4_FILIAL"
		_oSQL:_sQuery +=   " AND SC2.C2_NUM     = SUBSTRING (SD4.D4_OP, 1, 6)"
		_oSQL:_sQuery +=   " AND SC2.C2_ITEM    = SUBSTRING (SD4.D4_OP, 7, 2)"
		_oSQL:_sQuery +=   " AND SC2.C2_SEQUEN  = SUBSTRING (SD4.D4_OP, 9, 3)"
		_oSQL:_sQuery +=   " AND SC2.C2_ITEMGRD = SUBSTRING (SD4.D4_OP, 12, 2)"
		_oSQL:_sQuery +=   " AND SB1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
		_oSQL:_sQuery +=   " AND SB1.B1_COD     = SD4.D4_COD"
		_oSQL:_sQuery +=   " AND SB1.B1_TIPO    NOT IN ('MO')"
		_oSQL:_sQuery += " GROUP BY D4_COD"
		_oSQL:_sQuery +=       ",D4_LOCAL"
		_oSQL:_sQuery +=       ",SC2.C2_QUANT"
		_oSQL:_sQuery +=       ",SB2.B2_QATU"
		_oSQL:_sQuery +=       ",B1_DESC"
		_oSQL:_sQuery +=       ",B1_UM"
		_oSQL:_sQuery += ")"
		_oSQL:_sQuery += " SELECT *"
		_oSQL:_sQuery +=   " FROM C"
		_oSQL:_sQuery +=  " WHERE QT_A_REQ > ESTQ""
		//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_aSemSaldo := aclone (_oSQL:Qry2Array (.F., .F.))
		//U_Log2 ('debug', _aSemSaldo)
		if len (_aSemSaldo) > 0
			_sMsgSaldo := "Sem saldo:"
			for _nSemSaldo = 1 to len (_aSemSaldo)
				_sMsgSaldo += alltrim (_aSemSaldo [_nSemSaldo, 1]) + '-' + alltrim (_aSemSaldo [_nSemSaldo, 2])
				_sMsgSaldo += ' Qt.necessaria: ' + cvaltochar (_aSemSaldo [_nSemSaldo, 3])
				_sMsgSaldo += ' Qt.disponivel: ' + cvaltochar (_aSemSaldo [_nSemSaldo, 4])
				_sMsgSaldo += ' ' + _aSemSaldo [_nSemSaldo, 5]
				_sMsgSaldo += ' (almox.' + _aSemSaldo [_nSemSaldo, 6] + ')'
				if _nSemSaldo < len (_aSemSaldo)
					_sMsgSaldo += '; '
				endif
			next
			u_help (_sMsgSaldo,, .t.)
			_lContinua = .F.
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua



// --------------------------------------------------------------------------
// Verifica se a etiqueta pode ser enviada para o FullWMS (quando tratar-se de integracao)
METHOD PodeEnvFul () Class ClsEtiq
	local _lContinua := .T.
	Local _aAreaAnt  := U_ML_SRArea ()

	if _lContinua .and. ::AlmDest != '01'
		u_help ("Etiqueta '" + ::Codigo + "' nao deve ser enviada para o FullWMS, pois destina-se ao almox." + ::AlmDest,, .t.)
		_lContinua = .f.
	endif

	if _lContinua .and. left (::Codigo, 1) == '0'
		u_Help ("Impossivel enviar etiqueta '" + ::Codigo + "' para o FullWMS: Etiquetas iniciadas por '0' sao geradas diretamente pelo FullWMS.",, .t.)
		_lContinua = .F.
	endif
	if _lContinua .and. ::Impressa != 'S'
		u_help ("Etiqueta '" + ::Codigo + "' nao deve ser enviada para o FullWMS antes de estar impressa.",, .t.)
		_lContinua = .f.
	endif
	if _lContinua .and. empty (::LoteProduto)
		u_help ("Etiqueta '" + ::Codigo + "' nao pode ser enviada para o FullWMS pois nao tem lote informado.",, .t.)
		_lContinua = .f.
	endif

	// Se o produto nao pode ser enviado para o FulLWMS, nem adianta enviar a etiqueta.
	if _lContinua
		if ! empty (::OP)
			if _lContinua .and. ::QtEstornada > 0
				U_Log2 ('info', "Etiqueta '" + ::Codigo + "' teve sua quantidade estornada (" + cvaltochar (::QtEstornada) + "), entao nao ha utilidade em envia-la para o FullWMS.",, .t.)
				_lContinua = .F.
			endif
			if _lContinua .and. (::QtApontada + ::QtPerdida) == 0
				U_Log2 ('info', "Etiqueta '" + ::Codigo + "' refere-se a uma OP e, portanto, deve ser enviada somente depois que tiver producao/perda apontada.",, .t.)
				_lContinua = .F.
			endif
		else
			if ! empty (::IdZAG)
				if ::AlmDest == '01' .and. ! U_SB1PEF (::Produto)
					u_log2 ('erro', 'Envio da etiqueta ' + ::Codigo + ' para o FullWMS nao vai ser permitido por que o produto da etiqueta nao encontra-se em condicoes de ser enviado para o FullWMS.')
					_lContinua = .F.
				endif
			endif
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Verifica se pode excluir a etiqueta.
METHOD PodeExcluir (_lComTela) Class ClsEtiq
	local _lContinua := .T.
	Local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _sMsgNaoEx := ''
	local _sLinkSrv  := ""

	if ::QtApontada + ::QtPerdida + ::QtEstornada > 0
		_sMsgNaoEx += "Etiqueta '" + ::Codigo + "' ja foi apontada e/ou estornada. Exclusao nao permitida."
		_lContinua = .F.
	endif
	if ::Inutilizada
		_sMsgNaoEx += "Etiqueta '" + ::Codigo + "' ja foi inutilizada. Exclusao nao permitida."
		_lContinua = .F.
	endif
	if ! empty (::DocEntrNum)
		_sMsgNaoEx += "A etiqueta '" + ::Codigo + "' nao pode ser excluida, pois trata-se de uma etiqueta de nota fiscal (rastreabilidade). Use opcao de 'inutilizar'."
		_lContinua := .F.
	endif

	// Etiqueta nao deve esistir no FullWMS
	if _lContinua
	
		// Busca o caminho do banco de dados do FullWMS
		_sLinkSrv = U_LkServer ('FULLWMS_AX01')
	
		if empty (_sLinkSrv)
			_sMsgNaoEx += "Impossivel verificar existencia da etiqueta '" + ::Codigo + "' no sistema FullWMS. Verifique parametrizacao para que o Protheus acesse o banco de dados do FullWMS."
			_lContinua = .F.
		else
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT CONTAGEM"
			_oSQL:_sQuery += " FROM openquery (" + _sLinkSrv + ","
			_oSQL:_sQuery += " 'select count (*) as CONTAGEM"
			_oSQL:_sQuery +=  " from wms_etiquetas"
			_oSQL:_sQuery += " where wms_etiqueta_id = " + ::Codigo
			_oSQL:_sQuery += " ')"
			_oSQL:Log ('[' + procname () + ']')
			if _oSQL:RetQry (1, .f.) > 0
				_sMsgNaoEx += "Etiqueta '" + ::Codigo + "' encontrada no banco de dados do sistema FullWMS. Verifique (no FullWMS) a tela WF0101 - Consulta de etiquetas de producao."
				_lContinua = .F.
			endif
		endif
	endif

	if ! empty (_sMsgNaoEx)
		if _lComTela
			u_help (_sMsgNaoEx, iif (valtype (_oSQL) == 'O', _oSQL:_sQuery, ''), .t.)
		else
			U_Log2 ('aviso', '[' + procname () + ']' + _sMsgNaoEx)
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Disponibiliza ('envia') a etiqueta para o FullWMS.
METHOD EnviaFull (_lMsg) Class ClsEtiq
	Local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _lContinua := .T.

	_lMsg := iif (_lMsg == NIL, .T., _lMsg)

	if _lContinua
		_lContinua = ::PodeEnvFul ()
	endif

	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "select count (*)"
		_oSQL:_sQuery +=  " from tb_wms_etiquetas"
		_oSQL:_sQuery += " where id = '" + cvaltochar (::Codigo) + "'"
		//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		if _oSQL:RetQry () > 0
			if _lMsg
				u_help ("Impossivel enviar etiqueta '" + ::Codigo + "' para o FullWMS: Etiqueta jah existe na tabela tb_wms_etiquetas.", _oSQL:_sQuery, .t.)
			else
				U_Log2 ('aviso', '[' + procname () + "]Impossivel enviar etiqueta '" + ::Codigo + "' para o FullWMS: Etiqueta jah existe na tabela tb_wms_etiquetas.")
			endif
			_lContinua = .F.
		endif
	endif

	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " insert into tb_wms_etiquetas (id, coditem, lote, qtde, validade, empresa, cd, status)"
		_oSQL:_sQuery += " values (" + cvaltochar (::Codigo) + ","
		_oSQL:_sQuery +=          "'" + alltrim (::Produto) + "',"
		_oSQL:_sQuery +=          "'" + alltrim (::LoteProduto) + "',"
		_oSQL:_sQuery +=          cvaltochar (::Quantidade) + ","
		_oSQL:_sQuery +=          "'" + dtos (::ValidLote) + "',"
		_oSQL:_sQuery +=          "'01',"
		_oSQL:_sQuery +=          "'" + ::Filial + "',"
		_oSQL:_sQuery +=          "'N')"  // N=ainda nao lida pelo Full
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		if ! _oSQL:Exec ()
			U_help ("Erro ao enviar etiqueta para FullWMS: " + _oSQL:_sQuery,, .t.)
			_lRetEnv = .F.
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Exclusao da etiqueta.
METHOD Exclui () Class ClsEtiq
	Local _aAreaAnt  := U_ML_SRArea ()
	local _lContinua := .T.

	if _lContinua

		// Se a chamada for feita para um registro jah deletado, eh por que a
		// exclusao deve estar sendo feita pela tela de manutencao (usuario)
		// e o registro do SZI jah foi deletado pela funcao AxDeleta().
		// Faltaria, no caso, fazer as exclusoes de dados relacionados.
		if ! za1 -> (deleted ())
			U_Log2 ('debug', '[' + procname () + ']Deletando registro no ZA1')
			reclock ("ZA1", .F.)
			za1 -> (dbdelete ())
			msunlock ()
		else
			U_Log2 ('debug', '[' + procname () + ']Registro jah encontra-se deletado no ZA1')
		endif

		// Verifica necessidade de enviar algum dado para FullWMS.
		_AtuFull (::Codigo, 'E')
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Envia para impressora (ou porta relacionada a esta)
METHOD Imprime (_sCodImpr) Class ClsEtiq
	local _lContinua := .T.

	// Ainda tenho algumas leituras do ZA1, entao tenho que ter ele posicionado.
	// A intencao eh pegar tudo do objeto oEtiq.
	za1 -> (dbgoto (::RegZA1))
	
	if _lContinua .and. ::Inutilizada
		u_help ("Etiquetas inutilizadas nao podem mais ser impressas.",, .t.)
		_lContinua = .F.
	endif
	if _lContinua .and. ! empty (::OP) .and. ::OPInvalida
		u_help ("Etiq. referenciando uma OP invalida (" + alltrim (::OP) + ").",, .t.)
		_lContinua = .F.
	endif
	if _lContinua .and. ! empty (::OP) .and. (::QtApontada != 0 .or. ::QtPerdida != 0 .or. ::QtEstornada != 0)
		_lContinua = U_MsgNoYes ("Etiq.ja tem movimentacao. Deseja imprimir mesmo assim?")
	endif
	if _lContinua
		_lContinua = U_ImpZA1 (_sCodImpr, ::Self)
	endif

return _lContinua


// --------------------------------------------------------------------------
// Inutiliza a etiqueta.
METHOD Inutiliza (_lMsg) Class ClsEtiq
	local _lContinua := .T.
	local _oEvento   := NIL
	local _oSQL      := NIL
	local _aStatWMS  := {}
	local _aAreaAnt  := U_ML_SRArea ()

	_lMsg := iif (_lMsg == NIL, .F., _lMsg)
	if _lContinua .and. (::Inutilizada)
		::UltMsg += "A etiqueta '" + ::Codigo + "' ja encontra-se inutilizada."
		_lContinua := .F.
	endif

	// Verifica se o usuario tem liberacao.
	if ! empty (::OP) .and. ! U_ZZUVL ('073', __cUserID, .T.)
		::UltMsg += "Usuario sem acesso para inutilizar etiquetas de OP."
		_lContinua = .F.
	endif
	if ! empty (::DocEntrNum) .and. ! U_ZZUVL ('074', __cUserID, .T.)
		::UltMsg += "Usuario sem acesso para inutilizar etiquetas de NF."
		_lContinua = .F.
	endif
	if _lContinua .and. ! empty (::OP)
		if ::QtApontada > 0
			::UltMsg := "etiq." + ::Codigo + " jah apontada. Nao pode ser inutilizada."
			_lContinua := .F.
		endif
		if ::QtPerdida > 0
			::UltMsg := "etiq." + ::Codigo + " tem quantidade perdida. Nao pode ser inutilizada."
			_lContinua := .F.
		endif
	endif


	// Se foi gerada por solicitacao de transf.estoque, vou ver do que se trata.
	if _lContinua .and. ! empty (::IdZAG) .and. ::AlmDest == '01'
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " select status, status_protheus"
		_oSQL:_sQuery +=   " from tb_wms_entrada"
		// _oSQL:_sQuery +=  " where entrada_id = 'ZA1" + ::Filial + ::Codigo + "'"
		_oSQL:_sQuery +=  " where entrada_id = 'ZA1" + xfilial ("ZA1") + ::Codigo + "'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_aStatWMS = _oSQL:Qry2Array (.f., .f.)
		U_Log2 ('debug', _aStatWMS)
		if len (_aStatWMS) > 0 .and. ! empty (_aStatWMS [1, 1]) .and. _aStatWMS [1, 1] != '9'
			::UltMsg += "A etiqueta '" + ::Codigo + "' ja foi vista pelo FullWMS"
			::UltMsg += " e nao pode ser inutilizada por que encontra-se com status '" + _aStatWMS [1, 1] + "'"
			::UltMsg += " no campo STATUS da tabela de integracao tb_wms_entrada."
			::UltMsg += "Essa entrada deve ser excluida, antes, na tela de recebimentos do FullWMS."
			_lContinua = .F.
		endif
		if len (_aStatWMS) > 0 .and. ! empty (_aStatWMS [1, 2]) .and. _aStatWMS [1, 2] != 'C'
			::UltMsg += "A etiqueta '" + ::Codigo + "' ja foi enviada para o FullWMS"
			::UltMsg += " e nao pode ser inutilizada por que encontra-se com status '" + _aStatWMS [1, 2] + "'"
			::UltMsg += " no campo STATUS_PROTHEUS da tabela de integracao tb_wms_entrada."
			::UltMsg += "Essa operacao de 'guarda' deve ser abortada manualmente nesta tabela para poder inutilizar a etiqueta."
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. _lMsg
		_lContinua = U_MsgNoYes ("Confirma a inutilização da etiqueta?")
	endif
		
	if _lContinua
		za1 -> (dbgoto (::RegZA1))
		begin transaction
			reclock ("ZA1", .f.)
			za1 -> za1_apont = 'I'
			msunlock ()

			// Grava evento para posterior rastreamento
			_oEvento := ClsEvent():new ()
			_oEvento:CodEven   = "ZA1002"
			_oEvento:Texto     = "Inutilizacao etiqueta " + ::Codigo
			_oEvento:Recno     = ::RegZA1
			_oEvento:Alias     = 'ZA1'
			_oEvento:CodAlias  = ::Codigo
			_oEvento:Etiqueta  = ::Codigo
			_oEvento:Produto   = ::Produto
			_oEvento:OP        = ::OP
			_oEvento:NFEntrada = ::DocEntrNum
			_oEvento:SerieEntr = ::DocEntrSerie
			_oEvento:Fornece   = ::DocEntrForn
			_oEvento:LojaFor   = ::DocEntrLoja
			_oEvento:Grava ()
		end transaction
		::Inutilizada = .T.

		::UltMsg += "Etiqueta '" + ::Codigo + "' inutilizada (Remover do Recipiente)"
		if _lMsg
			u_help (::UltMsg)
		endif
	else
		u_help (::UltMsg,, .t.)
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
METHOD ValCBEmb () Class ClsEtiq
	local _lRetVCBE := .T.

	if _sCBEmbCol != _oEtiq:CBEmbCol
		::UltMsg += "Barras embalagem coletiva nao conferem com campo C2_VABARCX da OP."
		_lRetVCBE = .F.
	endif
return _lRetVCBE


// --------------------------------------------------------------------------
// Atualiza dados para integracao com Fullsoft.
static function _AtuFull (_sEtiq, _sQueFazer)
	local _oSQL      := NIL

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	if _sQueFazer == 'E'
		_oSQL:_sQuery += " delete tb_wms_etiquetas"
		_oSQL:_sQuery += " where id = " + cvaltochar (_sEtiq)
		_oSQL:Exec ()
	endif
return


// --------------------------------------------------------------------------
// Localiza registro na tabela SD5, para alimentar dados de nova etiqueta.
static function _AchaSD5 (_sProduto, _sNumSeq)
	local _oSQL    := NIL
	local _nRetSD5 := 0

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += "SELECT TOP 1 R_E_C_N_O_"  // Nao espero encontrar mais de 1, mas, para garantir...
	_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD5") + " SD5"
	_oSQL:_sQuery += " WHERE SD5.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=   " AND SD5.D5_FILIAL  = '" + xfilial ("SD5") + "'"
	_oSQL:_sQuery +=   " AND SD5.D5_PRODUTO = '" + _sProduto + "'"
	//_oSQL:_sQuery +=   " AND SD5.D5_LOTECTL = '" + _sLote    + "'"
	//_oSQL:_sQuery +=   " AND SD5.D5_LOCAL   = '" + _sAlmox   + "'"
	_oSQL:_sQuery +=   " AND SD5.D5_NUMSEQ  = '" + _sNumSeq  + "'"
	_oSQL:_sQuery +=   " AND SD5.D5_ORIGLAN = 'MAN'"  // Soh vou aceitar (por enqto) lotes criados manualmente.
	_oSQL:_sQuery += " ORDER BY SD5.D5_DATA, SD5.D5_NUMSEQ"
	_oSQL:Log ('[' + procname () + ']')
	_nRetSD5 = _oSQL:RetQry (1, .f.)
return _nRetSD5
