// Programa:  ClsEtiq
// Autor:     Robert Koch
// Data:      28/03/2022
// Descricao: Declaracao de classe de representacao de etiquetas usadas na producao.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa etiquetas usadas para identificacao de produtos e movimentacoes de estoque / integracoes com FullWMS.
// #PalavasChave      #etiquetas #integracao #FullWMS #producao
// #TabelasPrincipais #ZA1
// #Modulos           #EST #PCP

// Historico de alteracoes:
// 28/03/2022 - Robert - Criada a classe e iniciada migracao de diversos outros fontes para ca.
// 13/06/2022 - Robert - Ajuste leitura filial ZAG na impressao.
// 15/06/2022 - Robert - Ao instanciar etiqueta jah existente, tentava sempre buscar
//                       dados de lote, mesmo quando b1_rastro!='L' (GLPI 12220)
//                     - Impede exclusao de etiqueta de NF (migrado do VA_ETQPLL.PRW)
// 16/06/2022 - Robert - Verif.se a etiq.existe no FullWMS antes excluir (GLPI 12220).
// 26/07/2022 - Robert - Implementada verif.disponib.estq no metodo PodeApont() - GLPI 11994
// 29/07/2022 - Robert - Verif.saldo empenhos desconsiderava empenhos zerados.
// 01/08/2022 - Robert - Ajuste formula verif.saldo empenhos (GLPI 11994)
// 11/08/2022 - Robert - Criado metodo :Imprime (por enquanto, ainda chamando rotina externa)
//                     - Criado atributo :UltMsg
// 12/08/2022 - Robert - Criado atributo :AlmDest (GLPI 12474)
//                     - Melhorias leitura lote origem (ZAG e SD1)
// 25/08/2022 - Robert - Criado metodo :ApontaOP
// 23/09/2022 - Robert - Criado atributo :CBEmbCol e metodo :ValCBEmb - GLPI 11994
// 26/09/2022 - Robert - Funcao de inutilizacao migrada do fonte ZA1IN para metodo :Inutiliza()
// 05/10/2022 - Robert - Iniciado tratamento para etiquetas geradas a partir do SD5 (GLPI 12651)
// 24/10/2022 - Robert - Criado atributo :FinalidOP
// 31/10/2022 - Robert - Quando transf.p/ax01 via ZAG, busca zag_lotori (nao gera mais lote fajuto)
// 09/12/2022 - Robert - Criados atributos B1_CodBar, B1_VAFullW, DescriProd, PesoBruto, UM.
// 18/01/2023 - Robert - Criado atributo OPInvalida e testes para impedir impressao nesses casos.
// 19/01/2023 - Robert - Criado atributo AlmApontOP (almox.onde foi apontada a OP)
// 27/01/2023 - Robert - Metodo New passa a aceitar R_E_C_N_O_ ou chave de pesquisa.
//                     - Criados mais atributos alimentados pela leitura do SD3.
// 10/02/2023 - Robert - Tratamento para mais de uma etiqueta no metodo GeraPorSD5 - GLPI 13134.
// 13/02/2023 - Robert - Criado campo ZA1_QTGRUP
// 22/02/2023 - Robert - Metodo PodeEnvFul() passa a receber variavel para mostrar ou nao msg de erro.
// 10/03/2023 - Robert - Tratamentos para novo campo ZAG_SEQ (ZA1_IDZAG passa a concatenar ZAG_DOC + ZAG_SEQ).
// 15/03/2023 - Robert - Nao enviar etiquetas para FullWMS quando diferente da filial 01.
//                     - Apos gravar, arquivo ZA1 nao ficava posicionado no registro recem gravado.
// 19/03/2023 - Robert - Criado metodo CmdImpr() - intencao eliminar o prog ImpZA1.prw
// 27/03/2023 - Robert - Implementado metodo Recebe3() e tratamento campo ZA1_FULLW
// 28/03/2023 - Robert - Metodo Imprime() passa a usar metodo CmdImp() e nao mais a funcao U_ImpZA1().
//                     - Criado metodo SomaMsg().
// 06/04/2023 - Robert - Melhoradas mensagens de erro na geracao de comandos de impressao.
// 10/04/2023 - Robert - Implementado metodo PodeIncl().
// 12/04/2023 - Robert - Passa a controlar semaforo para gravacao.
// 17/04/2023 - Robert - Metodo PodeApont() passa a usar metodo SomaMsg() em ves de u_help() para mostrar os erros.
// 12/05/2023 - Robert - Gera msg ao tentar imprimir etiq.de OP e campo C2_VABARCX estiver vazio  (GLPI 13561).
// 07/06/2023 - Robert - Melhorada msg cod barras da OP (GLPI 13695).
// 18/10/2023 - Robert - Valida qt.prevista da OP antes de permitir incluir nova etiqueta (GLPI 13212)
// 01/11/2023 - Robert - Manda 1 dia a menos na tb_wms_etiqueta para evitar erro no Full "produto com validade menor que vida util do item"
// 20/11/2023 - Robert - Busca :ValidLote no b8_dtvalid e nao mais no d5_dtvalid (data pode ter tido manutencao posterior)
// 24/11/2023 - Robert - Na impressao originada por NF entrada, nao buscava o lote interno (GLPI 14550).
// 07/12/2023 - Robert - No metodo :Recebe3() passa a gravar tambem o produto no evento de recebimento da etiqueta.
//                     - Apesar de popular o atributo ::LoteProduto na geracao de atributos, sobrepunha (desnecessariamente) no metodo ::CmdImpr().
//                     - Tratamento temporario e especifico para 8 etiq.impressas com lote errado - GLPI 14605
// 19/02/2024 - Robert - Implementado metodo EndGuardaFull()
// 04/03/2024 - Robert - Nao gravava campo ZA1_FULLW=1 quando etiqueta gerada pelo ZAG com destino ao ax.01 (GLPI 15030)
// 22/03/2024 - Robert - Chamadas de metodos de ClsSQL() nao recebiam parametros.
// 06/05/2024 - Robert - Valid.qt.etiq. x qt.prev.OP desconsiderava etiquetas estornadas.
//

#Include "Protheus.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsEtiq ()
return


// ==========================================================================
CLASS ClsEtiq

	// Declaracao das propriedades da Classe
	public  data AlmApontOP   // Almox.onde foi feito o apontamento da OP (quando etiq. de epontamento de OP)
	public  data AlmDest      // Almox.destino, quando transferencia (ZAG) ou apontamento de OP
	public  data AlmOrig      // Almox.origem, quando transferencia (ZAG) ou gerada com base no SD5 (lotes iniciais).
	public  data Apontada     // ZA1_APONT - Apontamento de producao ja executado (quando etiq. para OP)
	public  data B1_CodBar    // B1_CODBAR
	public  data B1_VAFullW   // B1_VAFULLW
	public  data Codigo       // ZA1_CODIGO - Numero da etiqueta
	public  data CBEmbCol     // C2_VABARCX - Cod.barras embalagem coletiva - Para validacao no momento de apontar a producao.
	public  data D5_NUMSEQ    // D5_NUMSEQ - Quando etiq. gerada a partir de um registro de origem MAN do SD5.
	public  data DescriProd   // B1_DESC
	public  data DocEntrForn  // ZA1_FORNEC - Quando refere-se a NF de entrada
	public  data DocEntrItem  // ZA1_ITEM - Quando refere-se a NF de entrada
	public  data DocEntrLoja  // ZA1_LOJAF - Quando refere-se a NF de entrada
	public  data DocEntrNum   // ZA1_DOCE - Quando refere-se a NF de entrada
	public  data DocEntrSerie // ZA1_SERIEE - Quando refere-se a NF de entrada
	public  data DtEmis       // ZA1_DATA
	public  data DtFabrLote   // Data de fabricacao do lote de produto
	public  data Filial       // ZA1_FILIAL
	public  data FinalidOP    // C2_vaOpEsp: N=Normal;R=Reprocesso;E=externa (em 3os);T=Terceirizacao (para 3os);F=Filtracao
	public  data IdZAG        // ZA1_IDZAG - Identificador de registro da tabela ZAG (ZAG_DOC+ZAG_SEQ)
	public  data Impressa     // ZA1_IMPRES - Jah impressa
	public  data Inutilizada  // ZA1_APONT='I' - Indica que foi inutilizada manualmente
	public  data ImprCBProd   // Indica se deve obrigatoriamente imprimir o cod.barras do produto.
	public  data IntegraFull  // ZA1_FULLW - Status integracao com FullWMS
	public  data LoteProduto
	public  data OP           // ZA1_OP
	public  data OPInvalida   // Jah tive casos de reimpressao de etiquetas de OPs excluidas!
	public  data PesoBruto    // B1_PESBRU * qtid (peso bruto total da etiqueta)
	public  data Produto      // ZA1_PROD
	public  data QtApontada   // Quando relacionada a uma OP
	public  data QtDE4        // Quantidade movimentada com D3_CF=DE4
	public  data QtEstornada  // Quando relacionada a uma OP
	public  data QtEtqGrupo   // za1_qtgrup (antigo C2_VAQTETQ) - Quantidade de etiquetas do grupo (geralmente usada com OP)
	public  data QtPerdida    // Quando relacionada a uma OP
	public  data QtRE4        // Quantidade movimentada com D3_CF=RE4
	public  data Quantidade   // ZA1_QUANT
	private data RegZA1       // Numero registro (RECNO) no ZA1.
	public  data SeqNoGrupo   // ZA1_SEQ - Sequencia dentro do grupo, geralmente de OP. Ex.: 1 de 10, 2 de 10, ...
	public  data UltMsg       // Ultima mensagem gerada.
	public  data UM           // B1_UM
	public  data UsrIncl      // ZA1_USRINC - Usuario que incluiu/gerou a etiqueta
	public  data ValidLote    // Validade do lote

	// Declaracao dos Metodos da classe
	public METHOD New ()
	public METHOD ApontaOP ()
	public METHOD CmdImpr ()  // Intencao de remover o metodo :Imprime()
	public METHOD EndGuardaFull ()  // Endereco onde foi guardada no FullWMS quando recebeu da producao
	public METHOD EnviaFull ()
	public METHOD Exclui ()
	public METHOD Imprime ()
	public METHOD Inutiliza ()
	public METHOD GeraAtrib ()
	public METHOD Grava ()
	public METHOD NovaPorSD5 ()
	public METHOD PodeEnvFul ()
	public METHOD PodeExcluir ()
	public METHOD PodeIncl ()
	public METHOD PodeApont ()
	public METHOD Recebe3 ()
	public METHOD SomaMsg ()  // Adiciona mensagem ao inicio da string ::UltMsg
	public METHOD ValCBEmb ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor.
METHOD New (_xChave) Class ClsEtiq

	// Gera atributos com valores default
	::GeraAtrib ()

	// Se receber numerico, eh por que se trata do numero de registro
	// jah existente no ZA1 e preciso atualizar o objeto.
	if valtype (_xChave) == "N"
		ZA1 -> (dbgoto (_xChave))
		::GeraAtrib ("ZA1")

	// Se receber caracter, eh por que se trata de um codigo jah
	// existente nas tabelas, e preciso atualizar o objeto.
	elseif valtype (_xChave) == "C"
		//U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + '] >>' + xfilial ("ZA1") + _xChave + '<<')
		za1 -> (dbsetorder (1))  // ZA1_FILIAL+ZA1_CODIGO+ZA1_DATA+ZA1_OP
		if za1 -> (dbseek (xfilial ("ZA1") + _xChave, .F.))
			::GeraAtrib ("ZA1")
		else
//			u_log (valtype (::UltMsg))
//			u_log (cvaltochar (_xChave))
			::SomaMsg ("Problema ao instanciar etiqueta: Nao localizei codigo de etiqueta '" + cvaltochar (_xChave) + "' para a filial atual na tabela ZA1.")
			U_help (::UltMsg,, .t.)
		endif

	else
		// Alimenta atributos com valores default de uma etiqueta nova.
		::GeraAtrib ("")
	endif
Return ::self


// --------------------------------------------------------------------------
// Gera apontamento de producao
METHOD ApontaOP (_dDtProd, _sTnoProd) Class ClsEtiq
	local _lRetAp    := .T.
	local _aAutoSD3  := {}

	if ! ::PodeApont (::Quantidade, 0)
		_lRetAp = .F.
	else
		aadd (_aAutoSD3, {"D3_OP",      ::OP,       NIL})
		aadd (_aAutoSD3, {"D3_VAETIQ",  ::Codigo,   NIL})
		aadd (_aAutoSD3, {"D3_VADTPRD", _dDtProd,   NIL})
		aadd (_aAutoSD3, {"D3_VATURNO", _sTnoProd,  NIL})
		aadd (_aAutoSD3, {"D3_VAMOTIV", 'PRODUCAO', NIL})
		aadd (_aAutoSD3, {"ATUEMP",     "T",        NIL})  // Para que sempre seja feita a baixa dos empenhos.
		_aAutoSD3 := aclone (U_OrdAuto (_aAutoSD3))
		//U_Log2 ('debug', _aAutoSD3)
		lMsErroAuto  := .F.
		_sErroAuto := ''
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Apontando etiq. ' + ::Codigo)
		//U_Log2 ('info', 'Executando MATA250')
		dbselectarea ("SD3")
		dbsetorder (1)
		MATA250 (_aAutoSD3, 3)
//		U_Log2 ('debug', '[' + procname () + ']lMsErroAuto = ' + cvaltochar (lMsErroAuto))
//		U_Log2 ('debug', '[' + procname () + ']_sErroAuto = ' + _sErroAuto)
//		U_LogTrb ('SD3')
		If lMsErroAuto .or. ! empty (_sErroAuto)
			_lRetAp = .F.
			::SomaMsg (_sErroAuto)
			if ! empty (NomeAutoLog ())
				::SomaMsg (U_LeErro (memoread (NomeAutoLog ())))
			endif
			u_help ('Erro rot.aut:' + alltrim (::UltMsg),, .t.)
		else
			// Jah tive casos do P.E. MT250TOK retornar .F. e a gravacao nao
			// ser relizada, mas nao alimentou a variavel lMSErroAuto.
			if sd3 -> d3_vaetiq == ::Codigo .and. sd3 -> d3_op == ::OP .and. substr (sd3 -> d3_cf,1, 2) == 'PR'
				::SomaMsg ("Etiq." + ::Codigo + " apontada com sucesso (d3_numseq = " + sd3 -> d3_numseq + ")")
			else
				::SomaMsg ("Apontamento da etiq." + ::Codigo + " NAO REALIZADO.")
				_lRetAp = .F.
			endif
		endif
	endif
//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Terminando metodo')
return _lRetAp


// --------------------------------------------------------------------------
// Gera string com os comandos para impressao.
METHOD CmdImpr (_nModelImp, _lPrimeira) Class ClsEtiq
	local _aAreaAnt   := U_ML_SRArea ()
	local _lContinua  := .T.
	local _sAlmOri    := ''
	local _sTxtEtiq   := ''
	local _lBarProdu  := .F.
	private _sEtqImp   := ''
	private _sProdImp  := ''
	private _sUMImp    := ''
	private _sQtdImp   := ''
	private _sDProImp1 := ''
	private _sDProImp2 := ''
	private _sDProImp3 := ''
	private _sPesoBImp := ''
	private _sCBarProd := ''
	private _sLoteImp  := ''
	private _sLtForImp := ''
	private _sVldLtImp := ''
	private _sDtFabImp := ''
	private _sFornImp1 := ""
	private _sFornImp2 := ""
	private _sSeqImp   := ""
	private _sDocImp   := ''
	private _sObsImp1  := ''
	private _sObsImp2  := ''
	private _sDImpImp  := ''
	private _sOPImp    := ''
	private _Enter     := chr(13)+chr(10)
	private _Esc       := chr(27)
	private _lRetImpr  := .T.  // Deixar PRIVATE para funcoes internas poderem gravar em caso de erro.

	if _lContinua .and. ::Inutilizada
		::SomaMsg ("Etiquetas inutilizadas nao podem mais ser impressas.")
		_lContinua = .F.
	endif
	if _lContinua .and. ! empty (::OP) .and. ::OPInvalida
		::SomaMsg ("Etiq. referenciando uma OP invalida (" + alltrim (::OP) + ").")
		_lContinua = .F.
	endif

	// Ateh este momento, o procedimento para OPs feitas em terceiros eh apontar 'de mentirinha'
	// como se tivesse sido produzida aqui, e enviar para a logistica. Robert, 24/10/2022
	if ! empty (::OP) .and. (::FinalidOP == 'E' .or. GetMv ("VA_ETQOCBP") == 'S' .or. ::ImprCBProd == 'S')
		_lBarProdu = .T.
	endif

	// Deixa o maximo de variaveis prontas para impressao, buscando manter
	// integridade entre as diferentes funcoes de impressao.
	if _lContinua
		_sEtqImp   = alltrim (::Codigo)
		_sProdImp  = alltrim (::Produto)
		_sUMImp    = ::UM
		_sQtdImp   = alltrim (cvaltochar (::Quantidade))
		_sDProImp1 = substr (alltrim (::Produto) + ' - ' + ::DescriProd, 1, 25)
		_sDProImp2 = substr (alltrim (::Produto) + ' - ' + ::DescriProd, 26, 25)
		_sDProImp3 = substr (alltrim (::Produto) + ' - ' + ::DescriProd, 51, 25)
		_sPesoBImp = alltrim (cvaltochar (::PesoBruto))
		_sDImpImp  = iif (::Impressa == 'S', 'Reimpr:', 'Dt.Impr:') + dtoc (date ()) + ' ' + time ()
		_sVldLtImp = dtoc (::ValidLote)
		_sDtFabImp = dtoc (::DtFabrLote)
		_sLoteImp  = ::LoteProduto
		if ::B1_VAFullW == 'S'
			if empty (::B1_CodBar)
				::SomaMsg ("Produto '" + alltrim (::Produto) + "' sem cod.DUN14 no campo '" + alltrim (RetTitle ("B1_CODBAR")) + "'.")
				_lContinua = .F.
			else
				_sCBarProd = alltrim (::B1_CodBar)
			endif
		endif

		do case
		case ! empty (::IdZAG)
			zag -> (dbsetorder (1))  // ZAG_FILIAL+ ZAG_DOC + ZAG_SEQ
			if ! zag -> (dbseek (xfilial ("ZAG") + ::IdZAG, .F.))
				::SomaMsg ("Documento de transferencia '" + ::IdZAG + "' nao encontrado.")
				_lContinua = .F.
			else
				_sDocImp  = 'Solic.transf:' + substr (::IdZAG, 1, 10) + '/' + substr (::IdZAG, 11, 2)
	//			_sLoteImp = ::LoteProduto
				_sAlmOri  = zag -> zag_almori
				_sObsImp1 = left ('Tr.alm.' + zag -> zag_almori + ' -> ' + zag -> zag_almdst + ' (' + alltrim (zag -> zag_usrinc) + ')', 31)
				if zag -> zag_almdst != '01'  // Nao imprimir para nao aparecer 'devolucao', etc.
					_sObs2 = left (zag -> zag_motivo, 25)
				endif
			endif

		case ! empty (::OP)
			_sOPImp   = substr (::OP, 1, 6) + '.' + substr (::OP, 7, 2) + '.' + substr (::OP, 9)
	//		_sLoteImp = iif (! empty (::OP), substr (::OP, 1, 8), '')
			_sAlmOri = ::AlmOrig

			// O cod.barras da OP sobrepoe o do produto, pois vai ser usado no apontamento.
			if _lBarProdu  // Se vou precisar imprimir as barras do produto...
				if empty (::CBEmbCol)  // ... mas nao estao definidas na OP...
					::SomaMsg ("Cod.barras p/embalagem coletiva nao informado na OP.")
					_lContinua = .F.
				else
					_sCBarProd = alltrim (::CBEmbCol)
				endif
			endif

			// Sequencial de etiquetas (1 e 3, 2 de 3, ...) para ver se nao ficou alguma esquecida.
			if ::QtEtqGrupo != 0 .and. ::SeqNoGrupo != 0
				_sSeqImp = padc (alltrim (str (::SeqNoGrupo)) + '/' + alltrim (str (::QtEtqGrupo)), 9, ' ')
			else
				_sSeqImp = ''
			endif

		case ! empty (::DocEntrNum)
	//		_sLoteImp = ::LoteProduto
			_sDocImp = 'NF.' + alltrim (::DocEntrNum) + '/' + alltrim (::DocEntrSerie)
			sa2 -> (dbsetorder (1))
			if ! sa2 -> (dbseek (xfilial ("SA2") + ::DocEntrForn + ::DocEntrLoja, .F.))
				::SomaMsg ("Fornecedor '" + ::DocEntrForn + '/' + ::DocEntrloja + "' referenciado na etiqueta '" + ::Codigo + "' nao localizado!")
				_lContinua = .F.
			else
				_sFornImp1 := substr ('Forn:' + SA2 -> a2_cod + '/' + sa2 -> a2_loja + ' - ' + SA2 -> A2_nome, 1, 25)
				_sFornImp2 := substr ('     ' + SA2 -> a2_cod + '/' + sa2 -> a2_loja + ' - ' + SA2 -> A2_nome, 26, 25)
			endif

		case ! empty (::D5_NUMSEQ)  // Etiqueta gerada com base na tabela SD5.
	//		_sLoteImp = ::LoteProduto
			_sAlmOri  = ::AlmOrig

		otherwise
			::SomaMsg ("Tipo de etiqueta sem tratamento na leitura de dados iniciais para impressao no programa " + procname ())
			_lContinua = .F.
		endcase
	endif

	// Se chegou aqui com todos os dados prontos, gera etiqueta em arquivo
	// temporario e copia-o para a porta selecionada.
	if _lContinua

		// Comandos iniciais e finais sao os mesmos, independente do tipo de etiqueta
		_sTxtEtiq = ''
		if _nModelImp == 1  // Sato
			if _lPrimeira
				_sTxtEtiq += _Esc + 'A'   + _Enter + _Esc + 'CS6' + _Enter + _Esc + 'Z'   + _Enter  // Velocidade
				_sTxtEtiq += _Esc + 'A'   + _Enter + _Esc + '#E1' + _Enter + _Esc + 'Z'   + _Enter  // Claridade
				_sTxtEtiq += _Esc + 'PC03,0' + _Enter  // Velocidade
				_sTxtEtiq += _Esc + 'PC09,2' + _Enter  // Darkness
			//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']inseri comandos iniciais: ' + _sTxtEtiq)
			endif
			_sTxtEtiq += _Esc + 'A' + _Enter  	  // Inicializa etiqueta
			_sTxtEtiq += _Esc + '%1' + _Enter      // Rotacao

			// Adiciona 'miolo' da etiqueta, formatado conforme o tipo de aplicacao da etiqueta
			if ! empty (::OP)
				_sTxtEtiq += _FmtOP (_nModelImp, @::UltMsg, _lBarProdu)
			elseif ! empty (::IdZAG)
				_sTxtEtiq += _FmtZAG (_nModelImp, @::UltMsg)
			elseif ! empty (::DocEntrNum) .or. ! empty (::D5_NUMSEQ)
				_sTxtEtiq += _FmtNF (_nModelImp, @::UltMsg)
			else
				::SomaMsg ("Sem definicao de formatacao de etiqueta deste tipo na Sato.")
				_lRetImpr = .F.
			endif
			_sTxtEtiq += _Esc + 'Q1' + _Enter  // Quantidade
			_sTxtEtiq += _Esc + 'Z'  + _Enter  // Finaliza impressao

		elseif _nModelImp == 2  // Datamax

			_sTxtEtiq += chr (2) + 'L' + _Enter  // Comando de entrada de formato de etiqueta
			_sTxtEtiq += chr (2) + 'f220' + _Enter  //  STX - avanco para corte da etiqueta
			_sTxtEtiq += chr (2) + 'SA' + _Enter  //  STX + S = velocidade avanco etiquetas (de A a E)
			_sTxtEtiq += chr (1) + 'D' + _Enter  // SOH - inicio de header
			_sTxtEtiq += chr (2) + 'n' + _Enter  // Fixa a unidade em polegadas
			_sTxtEtiq += 'D11' + _Enter  // Tamanho padrao para pixel
			_sTxtEtiq += 'H13' + _Enter  // Temperatura
			_sTxtEtiq += 'PA'  + _Enter  // Velocidade de impressao (de A a D)

			// Adiciona 'miolo' da etiqueta, formatado conforme o tipo de aplicacao da etiqueta
			if ! empty (::OP)
				_sTxtEtiq += _FmtOP (_nModelImp, @::UltMsg, _lBarProdu)
			elseif ! empty (::IdZAG)
				_sTxtEtiq += _FmtZAG (_nModelImp, @::UltMsg)
			elseif ! empty (::DocEntrNum) .or. ! empty (::D5_NUMSEQ)
				_sTxtEtiq += _FmtNF (_nModelImp, @::UltMsg)
			else
				::SomaMsg ("Sem definicao de formatacao de etiqueta deste tipo na Datamax.")
				_lRetImpr = .F.
			endif
			_sTxtEtiq += 'Q0001' + _Enter  // Quantidade
			_sTxtEtiq += 'E' + _Enter  // Final de impressao
		

		// ainda nao pronto, fiz uma para quebra-galho
		elseif _nModelImp == 4  // BPLA usado pela Elgin L42 - manual online em https://docplayer.net/59879244-Programmer-s-manual-bpla.html
			_sTxtEtiq += chr (2) + 'L' + _Enter  //  STX - inicio de etiqueta
			_sTxtEtiq += 'n' + _Enter  // polegadas
			_sTxtEtiq += 'H25' + _Enter  // H=Temperatura (de 00 a 30)
			_sTxtEtiq += 'PE' + _Enter  // P=velocidade (de A a T)

			// Adiciona 'miolo' da etiqueta, formatado conforme o tipo de aplicacao da etiqueta
			if ! empty (::OP)
				_sTxtEtiq += _FmtOP (_nModelImp, @::UltMsg, _lBarProdu)
			elseif ! empty (::IdZAG)
				_sTxtEtiq += _FmtZAG (_nModelImp, @::UltMsg)
			elseif ! empty (::DocEntrNum) .or. ! empty (::D5_NUMSEQ)
				_sTxtEtiq += _FmtNF (_nModelImp, @::UltMsg)
			else
				::SomaMsg ("Sem definicao de formatacao de etiqueta deste tipo na Elgin.")
				_lRetImpr = .F.
			endif
			_sTxtEtiq += 'Q0001' + _Enter  // Quantidade
			_sTxtEtiq += 'E' + _Enter  // Final de impressao
		
		else
			::SomaMsg ("Sem definicao de comandos iniciais para este modelo de impressora (" + cvaltochar (_nModelImp) + ').')
			_lRetImpr = .F.
		endif
	endif
	if ! _lContinua
		::SomaMsg ("Erro ao gerar impressao.")
		_lRetImpr = .F.
	endif
//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']_sTxtEtiq antes de retornar:' + _sTxtEtiq)
	U_ML_SRArea (_aAreaAnt)
return iif (_lRetImpr, _sTxtEtiq, '')


// --------------------------------------------------------------------------
// Busca o endereco onde a etiqueta foi guardada no FullWMS, quando recebida da producao.
METHOD EndGuardaFull () Class ClsEtiq
	local _oSQL := NIL
	local _sRet := ''
	local _sLinkSrv := ''

	_sLinkSrv = U_LkServer ('FULLWMS_AX01')
	if empty (_sLinkSrv)
		_Super:SomaMsg ("Linked server para o FullWMS nao definido. Impossivel verificar onde a etiqueta foi guardada.")
	else
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "select *"
		_oSQL:_sQuery += " FROM OPENQUERY(" + _sLinkSrv
		_oSQL:_sQuery +=     " ,'select decode(m.cod_ruasarm_destino, null, m.codigo_area_destino, m.cod_ruasarm_destino || ''-'' ||"
		_oSQL:_sQuery +=              " m.cod_predio_destino || ''-'' ||"
		_oSQL:_sQuery +=              " m.cod_la_destino ||"
		_oSQL:_sQuery +=              " decode(m.cod_subla_destino, null, null, ''-'' ||"
		_oSQL:_sQuery +=              " m.cod_subla_destino)) as ENDERECO"
		_oSQL:_sQuery +=         " from wms_tarefas_cd t"
		_oSQL:_sQuery +=              " left join wms_sub_tarefas_cd s"
		_oSQL:_sQuery +=                 " left join wms_mov_estoques_cd m"
		_oSQL:_sQuery +=                    " on (m.empr_codemp = s.empr_codemp"
		_oSQL:_sQuery +=                    " and m.movestcd_id = s.movestcd_movestcd_id)"
		_oSQL:_sQuery +=                 " on (s.empr_codemp = t.empr_codemp"
		_oSQL:_sQuery +=                 " and s.centdist_cod_centdist = t.centdist_cod_centdist"
		_oSQL:_sQuery +=                 " and s.tarcd_cod_tarefa_cd = t.cod_tarefa_cd)"
		_oSQL:_sQuery +=        " where t.armovto_codigo_area_origem = ''PROD01''"
		_oSQL:_sQuery +=          " and t.pal_palete_id = ''" + ::Codigo + "''')"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_sRet = _oSQL:RetQry (1, .f.)
	endif
return _sRet


// --------------------------------------------------------------------------
// Disponibiliza ('envia') a etiqueta para o FullWMS.
METHOD EnviaFull (_lMsg) Class ClsEtiq
	Local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _lContinua := .T.

	_lMsg := iif (_lMsg == NIL, .T., _lMsg)

	if _lContinua
		_lContinua = ::PodeEnvFul (_lMsg)
	endif

	// O FullWMS somente aceita etiquetas cujos dados tenham sido previamente
	// inseridos na tabela tb_wms_etiquetas.
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "select count (*)"
		_oSQL:_sQuery +=  " from tb_wms_etiquetas"
		_oSQL:_sQuery += " where id = '" + cvaltochar (::Codigo) + "'"
		//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		if _oSQL:RetQry (1, .f.) > 0
			if _lMsg
				u_help ("Impossivel enviar etiqueta '" + ::Codigo + "' para o FullWMS: Etiqueta jah existe na tabela tb_wms_etiquetas.", _oSQL:_sQuery, .t.)
			else
				U_Log2 ('aviso', '[' + procname () + "]Impossivel enviar etiqueta '" + ::Codigo + "' para o FullWMS: Etiqueta jah existe na tabela tb_wms_etiquetas.")
			endif
			_lContinua = .F.
		endif
	endif

	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " insert into tb_wms_etiquetas (id, coditem, lote, qtde, validade, empresa, cd, status)"
		_oSQL:_sQuery += " values (" + cvaltochar (::Codigo) + ","
		_oSQL:_sQuery +=          "'" + alltrim (::Produto) + "',"
		_oSQL:_sQuery +=          "'" + alltrim (::LoteProduto) + "',"
		_oSQL:_sQuery +=          cvaltochar (::Quantidade) + ","
	//	_oSQL:_sQuery +=          "'" + dtos (::ValidLote) + "',"
		_oSQL:_sQuery +=          "'" + dtos (::ValidLote - 3) + "',"  // Manda uns dias a menos para evitar erro no Full "produto com validade menor que vida util do item"
		_oSQL:_sQuery +=          "'01',"
		_oSQL:_sQuery +=          "'" + ::Filial + "',"
		_oSQL:_sQuery +=          "'N')"  // N=ainda nao lida pelo Full
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		if ! _oSQL:Exec ()
			U_help ("Erro ao enviar etiqueta para FullWMS: " + _oSQL:_sQuery,, .t.)
			_lRetEnv = .F.
		endif
	endif

	// Conforme o almoxarifado onde foi feito o apontamento, quero disponilibizar
	// para ser guardada imediatamente (produtos envasados em terceiros, apesar
	// da OP estar apontada, somente deverao ser recebidos pelo FullWMS depois
	// que chegarem fisicamente do terceiro).
	if _lContinua
		if ! empty (::OP) .and. ::AlmOrig == '11'
			U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Disponibilizando etiq na view v_wms_entrada por que alm.orig.=' + ::AlmOrig)
			if ::IntegraFull == '2'
				::SomaMsg ("Etiqueta ja recebida pelo FullWMS.")
				_lContinua = .F.
			endif
			if _lContinua
				za1 -> (dbgoto (::RegZA1))
				reclock ("ZA1", .f.)
				za1 -> za1_fullw = '1'  // 1=disponibilizar na v_wms_entrada;2=jah recebido (nao precisa mais ficar na view)
				msunlock ()
				::IntegraFull = za1 -> za1_fullw
			endif
		endif
		if ! empty (::IdZAG) .and. ::AlmDest == '01'
			za1 -> (dbgoto (::RegZA1))
			reclock ("ZA1", .f.)
			za1 -> za1_fullw = '1'  // 1=disponibilizar na v_wms_entrada;2=jah recebido (nao precisa mais ficar na view)
			msunlock ()
			::IntegraFull = za1 -> za1_fullw
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Exclusao da etiqueta.
METHOD Exclui () Class ClsEtiq
	Local _aAreaAnt  := U_ML_SRArea ()
	local _lContinua := .T.
	local _oSQL      := NIL

	if _lContinua

		// Se a chamada for feita para um registro jah deletado, eh por que a
		// exclusao deve estar sendo feita pela tela de manutencao (usuario)
		// e o registro do SZI jah foi deletado pela funcao AxDeleta().
		// Faltaria, no caso, fazer as exclusoes de dados relacionados.
		if ! za1 -> (deleted ())
			U_Log2 ('debug', '[' + procname () + ']Deletando registro no ZA1')
			reclock ("ZA1", .F.)
			za1 -> (dbdelete ())
			msunlock ()
		else
			U_Log2 ('debug', '[' + procname () + ']Registro jah encontra-se deletado no ZA1')
		endif

		// Verifica necessidade de enviar algum dado para FullWMS.
//		_AtuFull (::Codigo, 'E')
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := " delete tb_wms_etiquetas"
		_oSQL:_sQuery += " where id = " + cvaltochar (::Codigo)
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lContinua = _oSQL:Exec ()
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sOrigem) Class ClsEtiq
	local _aAreaAnt := U_ML_SRArea ()
	local _oSQL     := NIL
	local _aLoteVal := {}
	local _aRetSD3  := {}
	local _nRegSD5  := 0

	// Defaults
	::AlmApontOP   = ''
	::AlmDest      = ''
	::AlmOrig      = ''
	::Apontada     = 'N'
	::B1_CodBar    = ''
	::B1_VAFullW   = ''
	::Codigo       = ''
	::CBEmbCol     = ''
	::D5_NUMSEQ    = ''
	::DescriProd   = ''
	::DocEntrForn  = ''
	::DocEntrItem  = ''
	::DocEntrLoja  = ''
	::DocEntrNum   = ''
	::DocEntrSerie = ''
	::DtEmis       = dDataBase //ctod ('')
	::DtFabrLote   = ctod ('')
	::Filial       = xfilial ("ZA1")
	::FinalidOP    = ''
	::IdZAG        = ''
	::ImprCBProd   = 'N'
	::Impressa     = 'N'
	::Inutilizada  = .F.
	::IntegraFull  = ''
	::LoteProduto  = ''
	::OP           = ''
	::OPInvalida   = .F.  // Ateh prova em contrario...
	::PesoBruto    = 0
	::Produto      = ''
	::QtApontada   = 0
	::QtDE4        = 0
	::QtEstornada  = 0
	::QtEtqGrupo   = 0
	::QtPerdida    = 0
	::QtRE4        = 0
	::Quantidade   = 0
	::RegZA1       = 0
	::SeqNoGrupo   = ''
	::UltMsg       = ''
	::UM           = ''
	::UsrIncl      = cUserName
	::ValidLote    = ctod ('')

	do case
	case _sOrigem == 'M'  // Variaveis M->
		::Apontada     = m->ZA1_APONT
		::Codigo       = m->ZA1_CODIGO
		::D5_NUMSEQ    = m->ZA1_D5NSEQ
		::DocEntrForn  = m->ZA1_FORNEC
		::DocEntrItem  = m->ZA1_ITEM
		::DocEntrLoja  = m->ZA1_LOJAF
		::DocEntrNum   = m->ZA1_DOCE
		::DocEntrSerie = m->ZA1_SERIEE
		::DtEmis       = m->ZA1_DATA
		::Filial       = xfilial ("SZI")
		::IdZAG        = m->ZA1_IDZAG
		::Impressa     = m->ZA1_IMPRES
		::Inutilizada  = (m->za1_apont == 'I')
		::IntegraFull  = m->za1_fullw
		::OP           = m->ZA1_OP
		::Produto      = m->ZA1_PROD
		::Quantidade   = m->ZA1_QUANT
		::QtEtqGrupo   = m->ZA1_QTGRUP
		::SeqNoGrupo   = m->ZA1_SEQ
		::UsrIncl      = m->ZA1_USRINC

	case _sOrigem == "ZA1"

		::Apontada     = za1 -> ZA1_APONT
		::Codigo       = za1 -> ZA1_CODIGO
		::D5_NUMSEQ    = za1 -> ZA1_D5NSEQ
		::DocEntrForn  = za1 -> ZA1_FORNEC
		::DocEntrItem  = za1 -> ZA1_ITEM
		::DocEntrLoja  = za1 -> ZA1_LOJAF
		::DocEntrNum   = za1 -> ZA1_DOCE
		::DocEntrSerie = za1 -> ZA1_SERIEE
		::DtEmis       = za1 -> ZA1_DATA
		::Filial       = za1 -> za1_filial
		::IdZAG        = za1 -> ZA1_IDZAG
		::Impressa     = za1 -> ZA1_IMPRES
		::Inutilizada  = (za1 -> za1_apont == 'I')
		::IntegraFull  = za1 -> za1_fullw
		::OP           = za1 -> ZA1_OP
		::Produto      = za1 -> ZA1_PROD
		::Quantidade   = za1 -> ZA1_QUANT
		::QtEtqGrupo   = za1 -> ZA1_QTGRUP
		::RegZA1       = za1 -> (recno ())
		::SeqNoGrupo   = za1 -> ZA1_SEQ
		::UsrIncl      = za1 -> ZA1_USRINC
	otherwise
		if ! empty (_sOrigem)  // Se origem vazia, eh por que estou apenas instanciando um objeto vazio.
			::SomaMsg ("Impossivel gerar atributos (parte 1). Origem '" + _sOrigem + "' desconhecida.")
			u_help (::UltMsg,, .t.)
		endif
	endcase

	// Alimenta dados adicionais conforme a origem da etiqueta.
	if _sOrigem == 'M' .or. _sOrigem == "ZA1"
		sb1 -> (dbsetorder (1))
		if ! sb1 -> (dbseek (xfilial ("SB1") + ::Produto, .f.))
			u_help ('[' + GetClassName (::Self) + '.' + procname () + "]Nao localizado cadastro do produto '" + ::Produto + "' relacionado `a etiqueta '" + ::Codigo + "'.",, .t.)
		else
			::B1_CodBar  = sb1 -> b1_codbar
			::B1_VAFullW = sb1 -> b1_vafullw
			::DescriProd = sb1 -> b1_desc
			::PesoBruto  = sb1 -> b1_pesbru * ::Quantidade
			::UM         = sb1 -> b1_um
			do case
			case ! empty (::OP)
				::LoteProduto = substring (::OP, 1, 8)

				::AlmDest = sb1 -> b1_locpad
				sc2 -> (dbsetorder (1))
				if ! sc2 -> (dbseek (xfilial ("SC2") + ::OP, .f.))
					::OPInvalida = .T.
					u_help ('[' + GetClassName (::Self) + '.' + procname () + "]Impossivel encontrar a OP '" + ::OP + "' relacionada `a etiqueta '" + ::Codigo + "'.",, .t.)
				else
					::AlmOrig    = sc2 -> c2_local
					::CBEmbCol   = sc2 -> c2_vaBarCx
					::FinalidOP  = sc2 -> c2_vaOpEsp
					
			//		// DEIXAR ISTO POR UM TEMPO ATEH O CAMPO ZA1_QTGRUP ESTAR BEM POPULADO.
			//		// (OU FAZER UM UPDATE ZA1_QTGRUP = C2_VAQTETQ)
			//		if ::QtEtqGrupo == 0
			//			::QtEtqGrupo = sc2 -> c2_vaqtetq
			//		endif
					
					// Jah peguei casos de excluirem uma OP e cadastrarem uma
					// nova de mesmo numero, para outro produto!
					if ::Produto != sc2 -> c2_produto
						::UltMsg = "Produto da etiq.(" + alltrim (::Produto) + ") nao pode ser diferente do produto da OP (" + alltrim (sc2 -> c2_produto) + ")."
						u_help ('[' + GetClassName (::Self) + '.' + procname () + "]" + ::UltMsg,, .t.)
						::Produto = ''
						::OP = ''
					endif

					// OP de reprocesso assume dt valid do lote original, cfe informada pelo usuario.
					if sc2 -> c2_vaopesp == 'R'  // OP de reprocesso assume dt valid do lote original, cfe informada pelo usuario.
						if empty (sc2 -> c2_vadvori)
							u_help ('[' + GetClassName (::Self) + '.' + procname () + "]Impossivel buscar a data de validade do lote  da etiqueta '" + ::Codigo + "': a OP referenciada (" + ::OP + ") eh uma OP de reprocesso, e nao foi informada a data de validade do lote original no campo C2_VADVORI (" + alltrim (rettitle ("C2_VADVORI")) + ").",, .t.)
						else
							::ValidLote = sc2 -> c2_vadvori
						endif
					else
						::ValidLote = sc2 -> c2_datprf + sb1 -> b1_prvalid
					endif

					// Busca dados de apontamento de producao desta etiqueta.
					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := ""
					_oSQL:_sQuery += "SELECT ISNULL (SUM (CASE WHEN D3_ESTORNO != 'S' AND D3_CF LIKE 'PR%' THEN D3_QUANT   ELSE 0  END), 0) AS APONTAM"
					_oSQL:_sQuery +=      ", ISNULL (SUM (CASE WHEN D3_ESTORNO != 'S' AND D3_CF LIKE 'PR%' THEN D3_PERDA   ELSE 0  END), 0) AS PERDA"
					_oSQL:_sQuery +=      ", ISNULL (SUM (CASE WHEN D3_ESTORNO  = 'S' AND D3_CF LIKE 'ER%' THEN D3_QUANT   ELSE 0  END), 0) AS ESTORNO"
					_oSQL:_sQuery +=      ", ISNULL (MIN (CASE WHEN D3_ESTORNO != 'S' AND D3_CF LIKE 'PR%' THEN D3_VADTPRD ELSE '' END), 0) AS DTFABRIC"
					_oSQL:_sQuery +=      ", ISNULL (MAX (CASE WHEN D3_ESTORNO != 'S' AND D3_CF LIKE 'PR%' THEN D3_LOCAL   ELSE '' END), 0) AS ALMAPONT"
					_oSQL:_sQuery +=      ", ISNULL (SUM (CASE WHEN D3_ESTORNO != 'S' AND D3_CF = 'RE4' THEN D3_QUANT ELSE 0 END), 0) AS QT_RE4"
					_oSQL:_sQuery +=      ", ISNULL (SUM (CASE WHEN D3_ESTORNO != 'S' AND D3_CF = 'DE4' THEN D3_QUANT ELSE 0 END), 0) AS QT_DE4"
					_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD3") + " SD3"
					_oSQL:_sQuery += " WHERE SD3.D_E_L_E_T_ = ''"
					_oSQL:_sQuery +=   " AND SD3.D3_FILIAL  = '" + xfilial ("SD3") + "'"
					_oSQL:_sQuery +=   " AND SD3.D3_VAETIQ  = '" + ::Codigo + "'"
					//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
					_aRetSD3 := aclone (_oSQL:Qry2Array (.f., .f.))
					::QtApontada  = _aRetSD3 [1 , 1]
					::QtPerdida   = _aRetSD3 [1 , 2]
					::QtEstornada = _aRetSD3 [1 , 3]
					::DtFabrLote  = stod (_aRetSD3 [1 , 4])
					::AlmApontOP  = _aRetSD3 [1 , 5]
					::QtRE4       = _aRetSD3 [1 , 6]
					::QtDE4       = _aRetSD3 [1 , 7]
				endif

			case ! empty (::DocEntrNum)  // Etiqueta gerada por NF de entrada
				sd1 -> (dbsetorder (1))  // D1_FILIAL, D1_DOC, D1_SERIE, D1_FORNECE, D1_LOJA, D1_COD, D1_ITEM, R_E_C_N_O_, D_E_L_E_T_
				if ! sd1 -> (dbseek (::Filial + ::DocEntrNum + ::DocEntrSerie + ::DocEntrForn + ::DocEntrLoja + ::Produto + ::DocEntrItem, .F.))
					u_help ("NF/fornecedor/produto/item '" + ::DocEntrNum + '/' + ::DocEntrForn + '/' + ::Produto + '/' +::DocEntrItem + "' referenciada pela etiqueta '" + ::Codigo + "' nao foi localizada na tabela SD1.",, .t.)
				else
					::AlmDest    = sd1 -> d1_local
					if sb1 -> b1_rastro == 'L'
						_oSQL := ClsSQL ():New ()
						_oSQL:_sQuery := "SELECT B8_LOTECTL, B8_DTVALID, B8_DFABRIC"
						_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB8") + " SB8 "
						_oSQL:_sQuery += " WHERE SB8.D_E_L_E_T_ = ''"
						_oSQL:_sQuery +=   " AND SB8.B8_FILIAL  = '" + sd1 -> d1_filial  + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOTECTL = '" + sd1 -> d1_lotectl + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_PRODUTO = '" + sd1 -> d1_cod     + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOCAL   = '" + sd1 -> d1_local   + "'"
					//	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
						_aLoteVal = aclone (_oSQL:RetFixo (1, "ao consultar lote do produto da etiqueta '" + ::Codigo + "' na NF de entrada '" + ::DocEntrNum + "'.", .T.))
					//	U_Log2 ('debug', '[' + procname () + ']_aLoteVal:')
					//	U_Log2 ('debug', _aLoteVal)
						if len (_aLoteVal) == 1
							::LoteProduto = _aLoteVal [1, 1]
							::ValidLote   = stod (_aLoteVal [1, 2])
							::DtFabrLote  = stod (_aLoteVal [1, 3])
						endif
					endif
				endif

			case ! empty (::IdZAG)
				zag -> (dbsetorder (1))  // ZAG_FILIAL, ZAG_DOC, ZAG_SEQ, R_E_C_N_O_, D_E_L_E_T_
			//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Pesquisando ZAG com >>' + xfilial ("ZAG") + ::IdZAG + '<< para buscar lote e validade.')
				if ! zag -> (dbseek (xfilial ("ZAG") + ::IdZAG, .F.))
					u_help ("Solicitacao de transferencia '" + ::IdZAG + "' referenciada pela etiqueta '" + ::Codigo + "' nao foi localizada na tabela ZAG.",, .t.)
				else
					::AlmDest     = zag -> zag_almdst
					::LoteProduto = zag -> zag_lotdst  // zag_lotOri
					if sb1 -> b1_rastro == 'L'
						_oSQL := ClsSQL ():New ()
						_oSQL:_sQuery := "SELECT B8_LOTECTL, B8_DTVALID, B8_DFABRIC"
						_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB8") + " SB8 "
						_oSQL:_sQuery += " WHERE SB8.D_E_L_E_T_ = ''"
						_oSQL:_sQuery +=   " AND SB8.B8_FILIAL  = '" + zag -> zag_filori + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOTECTL = '" + zag -> zag_lotori + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_PRODUTO = '" + zag -> zag_prdori + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOCAL   = '" + zag -> zag_almori + "'"
						//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
						_aLoteVal = aclone (_oSQL:RetFixo (1, "ao consultar lote do produto da etiqueta '" + ::Codigo + "' na solicitacao de transferencia numero '" + ::IdZAG + "'.", .T.))
						if len (_aLoteVal) == 1
							::ValidLote   = stod (_aLoteVal [1, 2])
							::DtFabrLote  = stod (_aLoteVal [1, 3])
						endif
					endif
					
					// Se quero enviar para o FullWMS, tenho que ter algum lote
					// e validade. Enquanto eu nao tiver isso (seja por que o
					// produto nao controla lote no Protheus, ou por que ainda
					// nao implementamos uma maneira de informar na solicitacao
					// de transferencia), vou gerar uma validade fajuta.
					// Essa validade e lote serao enviados ao Full atraves da
					// tabela tb_wms_etiquetas (todas as entradas no Full devem
					// ser acompanhadas de uma etiqueta).
					if ::AlmDest == '01' .and. ! empty (::LoteProduto) .and. sb1 -> b1_rastro != 'L'
						::ValidLote   = date () + sb1 -> b1_prvalid
						U_Log2 ('aviso', '[' + GetClassName (::Self) + '.' + procname () + ']Gerando validade fajuta (' + dtoc (::ValidLote) + ') por que o Protheus nao controla rastro deste item, mas o Full vai exigir.')
					endif
				endif

			case ! empty (::D5_NUMSEQ)
				_nRegSD5 = _AchaSD5 (::Produto, ::D5_NUMSEQ)
				if _nRegSD5 > 0
					sd5 -> (dbgoto (_nRegSD5))
					::AlmDest     = sd5 -> d5_local
					::AlmOrig     = sd5 -> d5_local
					::LoteProduto = sd5 -> d5_lotectl
	//				::ValidLote   = sd5 -> d5_dtvalid
	//				U_Log2 ('debug', '[' + procname () + ']Gerei validade ' + cvaltochar (::ValidLote) + ' pelo registro ' + cvaltochar (sd5 -> (recno ())) + ' do SD5')

					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := "SELECT B8_LOTECTL, B8_DTVALID, B8_DFABRIC"
					_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB8") + " SB8 "
					_oSQL:_sQuery += " WHERE SB8.D_E_L_E_T_ = ''"
					_oSQL:_sQuery +=   " AND SB8.B8_FILIAL  = '" + ::Filial + "'"
					_oSQL:_sQuery +=   " AND SB8.B8_LOTECTL = '" + ::LoteProduto + "'"
					_oSQL:_sQuery +=   " AND SB8.B8_PRODUTO = '" + ::Produto + "'"
					_oSQL:_sQuery +=   " AND SB8.B8_LOCAL   = '" + ::AlmOrig + "'"
				//	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
					_aLoteVal = aclone (_oSQL:RetFixo (1, "ao consultar lote do produto da etiqueta '" + ::Codigo + "' na implantacao de saldo/lote numero '" + ::D5_NUMSEQ + "'.", .T.))
					if len (_aLoteVal) == 1
						::ValidLote   = stod (_aLoteVal [1, 2])
						::DtFabrLote  = stod (_aLoteVal [1, 3])
					endif
				endif
			otherwise
				::SomaMsg ("Impossivel determinar atributos adicionais (parte 2). Origem de etiqueta desconhecida.")
				u_help (::UltMsg,, .t.)
			endcase
	//		U_Log2 ('debug', '[' + procname () + ']terminei o CASE com ::LoteProduto = ' + cvaltochar (::LoteProduto))
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Grava nova etiqueta na tabela ZA1.
// Minha intencao eh migrar a funcao U_IncEtqPll para este metodo.
METHOD Grava (_lSemafExt) Class ClsEtiq
	local _lGravou   := .F.
	local _aAreaAnt  := U_ML_SRArea ()
	local _sNextNum  := ''
	local _nSeqEtq   := 0
	local _sTxtLog   := ''
	local _lContinua := .T.
	local _nLock     := 0

	_lSemafExt := iif (_lSemafExt == NIL, .F., _lSemafExt)

	_lContinua = ::PodeIncl ()
//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + '] _lContinua = ' + cvaltochar (_lContinua))

	// Controla semaforo de gravacao, por que a numeracao deve ser unica.
	//
	// Se a funcao chamadora jah implementou um semaforo de gravacao, nao
	// preciso mais me preocupar aqui.
	if ! _lSemafExt  // Semaforo nao foi criado externamente.
//		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Semaforo externo: ainda nao tem. Vou criar um agora.')
		_nLock := U_Semaforo ('GeraNumeroZA1', .T.)  // Usar a mesma chave em todas as chamadas!
		if _nLock == 0
			::SomaMsg ("Bloqueio de semaforo")
			_lContinua = .F.
		endif
//	else
//		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Semaforo externo: jah tem.')
	endif

	// Gera sequencial da etiqueta dentro do grupo (OP ou NF) a que pertence.
	if _lContinua
		if ! empty (::OP) .or. ! empty (::DocEntrNum)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += " SELECT COUNT (*)"
			_oSQL:_sQuery +=   " FROM " + RetSQLName ("ZA1")
			_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=    " AND ZA1_OP     = '" + ::OP + "'"
			_oSQL:_sQuery +=    " AND ZA1_DOCE   = '" + ::DocEntrNum + "'"
			_oSQL:_sQuery +=    " AND ZA1_SERIEE = '" + ::DocEntrSerie + "'"
			_oSQL:_sQuery +=    " AND ZA1_ITEM = '"   + ::DocEntrItem + "'"
			_oSQL:_sQuery +=    " AND ZA1_FORNEC = '" + ::DocEntrForn + "'"
			_oSQL:_sQuery +=    " AND ZA1_LOJAF  = '" + ::DocEntrLoja + "'"
	//		_nSeqEtq = _oSQL:RetQry () + 1
			_nSeqEtq = _oSQL:RetQry (1, .f.) + 1
		endif
	endif

	if _lContinua
	//	U_Log2 ('debug', '[' + procname () + ']O que vou tentar gravar:')
	//	u_logobj (::Self, .t., .f.)
		begin transaction
		_sNextNum = U_NxtZA1 (::Produto, .t.)
		reclock ("ZA1",.T.)
		ZA1 -> ZA1_FILIAL = ::Filial
		ZA1 -> ZA1_CODIGO = _sNextNum
		ZA1 -> ZA1_DATA   = ::DtEmis
		ZA1 -> ZA1_OP     = ::OP
		ZA1 -> ZA1_PROD   = ::Produto
		ZA1 -> ZA1_QUANT  = ::Quantidade
		za1 -> za1_doce   = ::DocEntrNum
		za1 -> za1_seriee = ::DocEntrSerie
		za1 -> za1_item   = ::DocEntrItem
		za1 -> za1_fornec = ::DocEntrForn
		za1 -> za1_lojaf  = ::DocEntrLoja
		za1 -> za1_seq    = _nSeqEtq
		za1 -> za1_usrinc = cUserName
		za1 -> za1_idZAG  = ::IdZAG
		za1 -> ZA1_D5NSEQ = ::D5_NUMSEQ
		za1 -> ZA1_qtgrup = ::QtEtqGrupo
		msunlock()
		::Codigo     = za1 -> za1_codigo
		::SeqNoGrupo = za1 -> za1_seq
		::RegZA1     = za1 -> (recno ())
		_lGravou = .T.
		end transaction
	endif

	// Grava sequenciais, se existirem.
	do while __lSX8
		ConfirmSX8 ()
	enddo

	// Libera semaforo.
	if _nLock > 0
		U_Semaforo (_nLock)
	endif

	// Monta um textinho bonitinho para log.
	if _lGravou
		_sTxtLog := 'Etiqueta ' + za1 -> za1_codigo + ' gravada.'
		_sTxtLog += ' Produto: ' + alltrim (za1 -> za1_prod)
		_sTxtLog += iif (! empty (za1 -> za1_op),     ' OP: '     + alltrim (za1 -> za1_op),     '')
		_sTxtLog += iif (! empty (za1 -> za1_idZAG),  ' IdZAG: '  + alltrim (za1 -> za1_idZAG),  '')
		_sTxtLog += iif (! empty (za1 -> za1_doce),   ' NF: '     + alltrim (za1 -> za1_doce),   '')
		_sTxtLog += iif (! empty (za1 -> za1_d5nseq), ' D5NSEQ: ' + alltrim (za1 -> ZA1_D5NSEQ), '')
		u_log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sTxtLog)
	else
		U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + ']Etiqueta NAO gravada.' + ::UltMsg)
	endif

	U_ML_SRArea (_aAreaAnt)
	
	// Deixo ZA1 posicionado no registro que acabei de gravar
	if _lGravou
		za1 -> (dbgoto (::RegZA1))
	endif
return _lGravou


// --------------------------------------------------------------------------
// Envia para impressora (ou porta relacionada a esta)
METHOD Imprime (_sCodImpr) Class ClsEtiq
	local _lContinua := .T.
	local _sCmdImp   := ''  // Comando de impressao de cada etiqueta
	local _sArq      := ''
	local _nHdl      := ''
	local _sPortaImp := ''
	local _nModelImp := 0

	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']_sCodImpr = ' + _sCodImpr)
	if _lContinua .and. ::Inutilizada
		u_help ("Etiquetas inutilizadas nao podem mais ser impressas.",, .t.)
		_lContinua = .F.
	endif
	if _lContinua .and. ! empty (::OP) .and. ::OPInvalida
		u_help ("Etiq. referenciando uma OP invalida (" + alltrim (::OP) + ").",, .t.)
		_lContinua = .F.
	endif
	if _lContinua .and. ! empty (::OP) .and. (::QtApontada != 0 .or. ::QtPerdida != 0 .or. ::QtEstornada != 0)
		_lContinua = U_MsgNoYes ("Etiq.ja movimentada (apont/perda/estorno). Deseja imprimir mesmo assim?")
	endif
	if _lContinua
		//_lContinua = U_ImpZA1 (_sCodImpr, ::Self)
		_sPortaImp = U_RetZX5 ('49', _sCodImpr, 'ZX5_49CAM')
		_nModelImp = val (U_RetZX5 ('49', _sCodImpr, 'ZX5_49LING'))
		if empty (_sPortaImp)
			::SomaMsg ("Caminho/porta nao definido para impressora '" + _sCodImpr + "'. Verifique tabela 49 do arquivo ZX5.")
			_lContinua = .F.
		endif
		if empty (_nModelImp)
			::SomaMsg ("Modelo nao definido para impressora '" + _sCodImpr + "'. Verifique tabela 49 do arquivo ZX5.")
			_lContinua = .F.
		endif
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']_sPortaImp = ' + _sPortaImp)
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']_nModelImp = ' + cvaltochar (_nModelImp))
	endif
	if _lContinua
		_sCmdImp = ::CmdImpr (_nModelImp, .t.)
		if empty (_sCmdImp)
			::SomaMsg ("Cmd.impr.vazios.")
			_lContinua = .F.
		else
			// Envia para a impressora (ou arquivo, caso porta = caminho de arquivo).
			if ! empty (_sCmdImp)
				_sArq = criatrab (NIL, .F.)
				_nHdl = fcreate (_sArq, 0)
				fwrite (_nHdl, _sCmdImp)
				fclose (_nHdl)
				copy file (_sArq) to (_sPortaImp)
				delete file (_sArq)
				U_Log2 ('debug', '[' + procname () + ']' + _sCmdImp)
				u_log2 ('debug', '[' + procname () + ']Copiei comandos para ' + _sPortaImp)
					
				// Marca etiqueta como jah impressa.
				za1 -> (dbgoto (::RegZA1))
				reclock ("ZA1", .f.)
				za1 -> za1_impres = 'S'
				msunlock ()
				::Impressa = za1 -> za1_impres
			endif
		endif
	endif
return _lContinua


// --------------------------------------------------------------------------
// Inutiliza a etiqueta.
METHOD Inutiliza (_lMsg) Class ClsEtiq
	local _lContinua := .T.
	local _oEvento   := NIL
	local _oSQL      := NIL
	local _aStatWMS  := {}
	local _aAreaAnt  := U_ML_SRArea ()

	_lMsg := iif (_lMsg == NIL, .F., _lMsg)
	if _lContinua .and. (::Inutilizada)
		::SomaMsg ("A etiqueta '" + ::Codigo + "' ja encontra-se inutilizada.")
		_lContinua := .F.
	endif

	// Verifica se o usuario tem liberacao.
	if ! empty (::OP) .and. ! U_ZZUVL ('073', __cUserID, .T.)
		::SomaMsg ("Usuario sem acesso para inutilizar etiquetas de OP.")
		_lContinua = .F.
	endif
	if ! empty (::DocEntrNum) .and. ! U_ZZUVL ('074', __cUserID, .T.)
		::SomaMsg ("Usuario sem acesso para inutilizar etiquetas de NF.")
		_lContinua = .F.
	endif
	if _lContinua .and. ! empty (::OP)
		if ::QtApontada > 0
			::SomaMsg ("Etiq." + ::Codigo + " jah apontada. Nao pode ser inutilizada.")
			_lContinua := .F.
		endif
		if ::QtPerdida > 0
			::SomaMsg ("Etiq." + ::Codigo + " tem quantidade perdida. Nao pode ser inutilizada.")
			_lContinua := .F.
		endif
	endif


	// Se foi gerada por solicitacao de transf.estoque, vou ver do que se trata.
	if _lContinua .and. ! empty (::IdZAG) .and. ::AlmDest == '01'
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " select status, status_protheus"
		_oSQL:_sQuery +=   " from tb_wms_entrada"
		_oSQL:_sQuery +=  " where entrada_id = 'ZA1" + xfilial ("ZA1") + ::Codigo + "'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_aStatWMS = _oSQL:Qry2Array (.f., .f.)
		U_Log2 ('debug', _aStatWMS)
//		if len (_aStatWMS) > 0 .and. ! empty (_aStatWMS [1, 1]) .and. _aStatWMS [1, 1] != '9'
		if len (_aStatWMS) > 0 .and. ! empty (_aStatWMS [1, 1]) .and. _aStatWMS [1, 1] != '9' .and. _aStatWMS [1, 2] != 'C'
			::SomaMsg ("A etiqueta '" + ::Codigo + "' ja foi vista pelo FullWMS" + ;
			           " e nao pode ser inutilizada por que encontra-se com status '" + _aStatWMS [1, 1] + "'" + ;
			           " no campo STATUS da tabela de integracao tb_wms_entrada." + ;
			           "Essa entrada deve ser excluida, antes, na tela de recebimentos do FullWMS.")
			_lContinua = .F.
		endif
		if len (_aStatWMS) > 0 .and. ! empty (_aStatWMS [1, 2]) .and. _aStatWMS [1, 2] != 'C'
			::SomaMsg ("A etiqueta '" + ::Codigo + "' ja foi enviada para o FullWMS" + ;
			           " e nao pode ser inutilizada por que encontra-se com status '" + _aStatWMS [1, 2] + "'" + ;
			           " no campo STATUS_PROTHEUS da tabela de integracao tb_wms_entrada." + ;
			           "Essa operacao de 'guarda' deve ser abortada manualmente nesta tabela para poder inutilizar a etiqueta.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. _lMsg
		_lContinua = U_MsgNoYes ("Confirma a inutilizao da etiqueta?")
	endif
		
	if _lContinua
		za1 -> (dbgoto (::RegZA1))
		begin transaction
			reclock ("ZA1", .f.)
			za1 -> za1_apont = 'I'
			msunlock ()

			// Grava evento para posterior rastreamento
			_oEvento := ClsEvent():new ()
			_oEvento:CodEven   = "ZA1002"
			_oEvento:Texto     = "Inutilizacao etiqueta " + ::Codigo
			_oEvento:Recno     = ::RegZA1
			_oEvento:Alias     = 'ZA1'
			_oEvento:CodAlias  = ::Codigo
			_oEvento:Etiqueta  = ::Codigo
			_oEvento:Produto   = ::Produto
			_oEvento:OP        = ::OP
			_oEvento:NFEntrada = ::DocEntrNum
			_oEvento:SerieEntr = ::DocEntrSerie
			_oEvento:Fornece   = ::DocEntrForn
			_oEvento:LojaFor   = ::DocEntrLoja
			_oEvento:Grava ()
		end transaction
		::Inutilizada = .T.

		::SomaMsg ("Etiqueta '" + ::Codigo + "' inutilizada (Remover do Recipiente)")
		if _lMsg
			u_help (::UltMsg)
		endif
	else
		u_help (::UltMsg,, .t.)
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Gera etiquetas para lote jah existente no estoque. A intencao desta operacao
// eh poder etiquetar lotes jah existentes no estoque quando a rastreabilidade
// for habilitada para um produto, pois esses 'lotes iniciais' nao terao sua
// origem a partir de um movimento de estoque (lotes posteriores serao criados
// atraves de um apontamento de OP, ou uma nota de compra, etc.)
METHOD NovaPorSD5 (_sProduto, _sLote, _sAlmox, _sNumSeq, _nQtDesta, _nQtGrupo, _nSeqNoGrp) Class ClsEtiq
	local _aAreaAnt := U_ML_SRArea ()
	local _nRegSD5  := 0
	local _lRetNSD5 := .T.

//	U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Tentando criar etiqueta para produto/lote/almox/numseq ' + _sProduto + '/' + _sLote + '/' + _sAlmox + '/' + _sNumSeq)
	_nRegSD5 = _AchaSD5 (_sProduto, _sNumSeq)
	if _nRegSD5 == 0
		::SomaMsg ("Nao encontrei registro com origem MAN para o produto/lote/almox/NumSeq informados. Geracao de etiquetas cancelada.")
		u_help (::UltMsg,, .t.)
		_lRetNSD5 = .F.
	else
		sd5 -> (dbgoto (_nRegSD5))
		::AlmDest     = sd5 -> d5_local
		::AlmOrig     = sd5 -> d5_local
		::D5_NUMSEQ   = sd5 -> d5_numseq
		::DtEmis      = date ()
		::Filial      = xfilial ("ZA1")
		::LoteProduto = sd5 -> d5_lotectl
		::Produto     = sd5 -> d5_produto
		::Quantidade  = _nQtDesta  //sd5 -> d5_quant
		::QtEtqGrupo  = _nQtGrupo  // contagem total de etiq.gerada para este registro do SD5. Ex.: "eiqueta 1 de 5"
		::SeqNoGrupo  = _nSeqNoGrp
		::ValidLote   = sd5 -> d5_dtvalid
		if ! ::Grava ()
			::SomaMsg ("Nao foi possivel gravar a etiqueta.")
			u_help (::UltMsg,, .t.)
			_lRetNSD5 = .F.
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRetNSD5


// --------------------------------------------------------------------------
// Verifica se pode ser feito apontamento de producao da etiqueta.
METHOD PodeApont (_nQtApont, _nQtPerda) Class ClsEtiq
	Local _aAreaAnt  := U_ML_SRArea ()
	local _lContinua := .T.
	local _nQtTot    := 0
	local _oSQL      := NIL
	local _aSemSaldo := {}
	local _nSemSaldo := 0
	local _sMsgSaldo := ''

	if _lContinua .and. empty (::OP)
		::SomaMsg ("Etiq.'" + ::Codigo + "' nao vinculada a nenhuma OP.")
		_lContinua = .f.
	endif
	if _lContinua .and. ::Inutilizada
		::SomaMsg ("Etiq.'" + ::Codigo + "' inutilizada.")
		_lContinua := .F.
	endif
	if _lContinua .and. ::Impressa != 'S'
		::SomaMsg ("Etiq.'" + ::Codigo + "' ainda nao impressa.")
		_lContinua = .f.
	endif
	if _lContinua .and. (::QtApontada + ::QtPerdida) > 0
		::SomaMsg ("Etiq.'" + ::Codigo + "' ja gerou apontamento de producao.")
		_lContinua = .f.
	endif
	if _lContinua .and. ::QtEstornada > 0
		::SomaMsg ("Etiq.'" + ::Codigo + "' ja foi apontada e ESTORNADA. Gere nova etiqueta.")
		_lContinua = .F.
	endif
	if _lContinua .and. empty (::CBEmbCol)
		::SomaMsg ("Cod.barras p/embalagem coletiva nao informado na OP. Verifique campo C2_VABARCX ('" + alltrim (RetTitle ("C2_VABARCX")) + "')")
		_lContinua = .F.
	endif
	if _lContinua
		_nQtTot = ::QtApontada + ::QtPerdida + _nQtApont + _nQtPerda
		if _nQtTot != ::Quantidade
			::SomaMsg ("Erro etiq.'" + ::Codigo + "':Qt.produzida+perdida (" + cvaltochar (_nQtTot) + ") nao pode ser diferente da quantidade prevista da etiqueta (" + cvaltochar (::Quantidade) + ").")
			_lContinua = .F.
		endif
	endif

	// Verifica disponibilidade de saldo dos empenhos.
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " WITH C AS ("
		_oSQL:_sQuery += " SELECT D4_COD"
		_oSQL:_sQuery +=        ",B1_DESC"
		_oSQL:_sQuery +=        ",CASE WHEN SUM (D4_QUANT) = 0"
		_oSQL:_sQuery +=             " THEN 0"
		_oSQL:_sQuery +=             " ELSE (SUM(D4_QTDEORI) * " + cvaltochar (_nQtApont + _nQtPerda) + ") / C2_QUANT"
		_oSQL:_sQuery +=        " END AS QT_A_REQ"
		_oSQL:_sQuery +=        ",ISNULL (SB2.B2_QATU, 0) AS ESTQ"
		_oSQL:_sQuery +=        ",B1_UM"
		_oSQL:_sQuery +=        ",D4_LOCAL"
		_oSQL:_sQuery += " FROM " + RetSQLName ("SC2") + " SC2"
		_oSQL:_sQuery +=      "," + RetSQLName ("SB1") + " SB1"
		_oSQL:_sQuery +=      "," + RetSQLName ("SD4") + " SD4"
		_oSQL:_sQuery +=     " LEFT JOIN " + RetSQLName ("SB2") + " SB2"
		_oSQL:_sQuery +=          " ON (SB2.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=          " AND SB2.B2_FILIAL  = SD4.D4_FILIAL"
		_oSQL:_sQuery +=          " AND SB2.B2_COD     = SD4.D4_COD"
		_oSQL:_sQuery +=          " AND SB2.B2_LOCAL   = SD4.D4_LOCAL)"
		_oSQL:_sQuery += " WHERE SD4.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SD4.D4_FILIAL  = '" + xfilial ("SD4") + "'"
		_oSQL:_sQuery +=   " AND SD4.D4_OP      = '" + ::OP + "'"
		_oSQL:_sQuery +=   " AND SC2.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SC2.C2_FILIAL  = SD4.D4_FILIAL"
		_oSQL:_sQuery +=   " AND SC2.C2_NUM     = SUBSTRING (SD4.D4_OP, 1, 6)"
		_oSQL:_sQuery +=   " AND SC2.C2_ITEM    = SUBSTRING (SD4.D4_OP, 7, 2)"
		_oSQL:_sQuery +=   " AND SC2.C2_SEQUEN  = SUBSTRING (SD4.D4_OP, 9, 3)"
		_oSQL:_sQuery +=   " AND SC2.C2_ITEMGRD = SUBSTRING (SD4.D4_OP, 12, 2)"
		_oSQL:_sQuery +=   " AND SB1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
		_oSQL:_sQuery +=   " AND SB1.B1_COD     = SD4.D4_COD"
		_oSQL:_sQuery +=   " AND SB1.B1_TIPO    NOT IN ('MO')"
		_oSQL:_sQuery += " GROUP BY D4_COD"
		_oSQL:_sQuery +=       ",D4_LOCAL"
		_oSQL:_sQuery +=       ",SC2.C2_QUANT"
		_oSQL:_sQuery +=       ",SB2.B2_QATU"
		_oSQL:_sQuery +=       ",B1_DESC"
		_oSQL:_sQuery +=       ",B1_UM"
		_oSQL:_sQuery += ")"
		_oSQL:_sQuery += " SELECT *"
		_oSQL:_sQuery +=   " FROM C"
		_oSQL:_sQuery +=  " WHERE QT_A_REQ > ESTQ""
//		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_aSemSaldo := aclone (_oSQL:Qry2Array (.F., .F.))
//		U_Log2 ('debug', '[' + procname () + ']_aSemSaldo:')
//		U_Log2 ('debug', _aSemSaldo)
		if len (_aSemSaldo) > 0
			_sMsgSaldo := "Sem saldo:"
			for _nSemSaldo = 1 to len (_aSemSaldo)
				_sMsgSaldo += alltrim (_aSemSaldo [_nSemSaldo, 1]) + '-' + alltrim (_aSemSaldo [_nSemSaldo, 2])
				_sMsgSaldo += ' Qt.necessaria: ' + cvaltochar (_aSemSaldo [_nSemSaldo, 3])
				_sMsgSaldo += ' Qt.disponivel: ' + cvaltochar (_aSemSaldo [_nSemSaldo, 4])
				_sMsgSaldo += ' ' + _aSemSaldo [_nSemSaldo, 5]
				_sMsgSaldo += ' (almox.' + _aSemSaldo [_nSemSaldo, 6] + ')'
				if _nSemSaldo < len (_aSemSaldo)
					_sMsgSaldo += '; '
				endif
			next
			::SomaMsg (_sMsgSaldo)
			_lContinua = .F.
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua



// --------------------------------------------------------------------------
// Verifica se a etiqueta pode ser enviada para o FullWMS (quando tratar-se de integracao)
METHOD PodeEnvFul (_lMsg) Class ClsEtiq
	local _lContinua := .T.
	Local _aAreaAnt  := U_ML_SRArea ()
	local _sMsg      := ''

	if _lContinua .and. ::Filial != '01'
		_sMsg = "Etiqueta '" + ::Codigo + "' nao deve ser enviada para o FullWMS, pois esta filial nao usa FullWMS."
		if _lMsg
			u_help (_sMsg,, .t.)
		else
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sMsg)
		endif
		_lContinua = .f.
	endif

	if _lContinua .and. ::AlmDest != '01'
		_sMsg = "Etiqueta '" + ::Codigo + "' nao deve ser enviada para o FullWMS, pois destina-se ao almox." + ::AlmDest
		if _lMsg
			u_help (_sMsg,, .t.)
		else
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sMsg)
		endif
		_lContinua = .f.
	endif

	if _lContinua .and. left (::Codigo, 1) == '0'
		_sMsg = "Impossivel enviar etiqueta '" + ::Codigo + "' para o FullWMS: Etiquetas iniciadas por '0' sao geradas diretamente pelo FullWMS."
		if _lMsg
			u_help (_sMsg,, .t.)
		else
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sMsg)
		endif
		_lContinua = .F.
	endif
	if _lContinua .and. ::Impressa != 'S'
		_sMsg = "Etiqueta '" + ::Codigo + "' nao deve ser enviada para o FullWMS antes de estar impressa."
		if _lMsg
			u_help (_sMsg,, .t.)
		else
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sMsg)
		endif
		_lContinua = .f.
	endif
	if _lContinua .and. ::Inutilizada
		_sMsg = "Etiqueta '" + ::Codigo + "' inutilizada. Nao deve ser enviada para o FullWMS."
		if _lMsg
			u_help (_sMsg,, .t.)
		else
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sMsg)
		endif
		_lContinua = .f.
	endif
	if _lContinua .and. empty (::LoteProduto)
		_sMsg = "Etiqueta '" + ::Codigo + "' nao pode ser enviada para o FullWMS pois nao tem lote informado."
		if _lMsg
			u_help (_sMsg,, .t.)
		else
			U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']' + _sMsg)
		endif
		_lContinua = .f.
	endif

	// Se o produto nao pode ser enviado para o FullWMS, nem adianta enviar a etiqueta.
	if _lContinua
		if ! empty (::OP)
			if _lContinua .and. ::QtEstornada > 0
				U_Log2 ('info', "Etiqueta '" + ::Codigo + "' teve sua quantidade estornada (" + cvaltochar (::QtEstornada) + "), entao nao ha utilidade em envia-la para o FullWMS.",, .t.)
				_lContinua = .F.
			endif
			if _lContinua .and. (::QtApontada + ::QtPerdida) == 0
				U_Log2 ('info', "Etiqueta '" + ::Codigo + "' refere-se a uma OP e, portanto, deve ser enviada somente depois que tiver producao/perda apontada.",, .t.)
				_lContinua = .F.
			endif
		else
			if ! empty (::IdZAG)
				if ::AlmDest == '01' .and. ! U_SB1PEF (::Produto)
					u_log2 ('erro', 'Envio da etiqueta ' + ::Codigo + ' para o FullWMS nao vai ser permitido por que o produto da etiqueta nao encontra-se em condicoes de ser enviado para o FullWMS.')
					_lContinua = .F.
				endif
			endif
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Verifica se pode excluir a etiqueta.
METHOD PodeExcluir (_lComTela) Class ClsEtiq
	local _lContinua := .T.
	Local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _sMsgNaoEx := ''
	local _sLinkSrv  := ""

	if ::QtApontada + ::QtPerdida + ::QtEstornada > 0
		_sMsgNaoEx += "Etiqueta '" + ::Codigo + "' ja foi apontada e/ou estornada. Exclusao nao permitida."
		_lContinua = .F.
	endif
	if ::Inutilizada
		_sMsgNaoEx += "Etiqueta '" + ::Codigo + "' ja foi inutilizada. Exclusao nao permitida."
		_lContinua = .F.
	endif
	if ! empty (::DocEntrNum)
		_sMsgNaoEx += "A etiqueta '" + ::Codigo + "' nao pode ser excluida, pois trata-se de uma etiqueta de nota fiscal (rastreabilidade). Use opcao de 'inutilizar'."
		_lContinua := .F.
	endif

	// Etiqueta nao deve esistir no FullWMS
	if _lContinua
	
		// Busca o caminho do banco de dados do FullWMS
		_sLinkSrv = U_LkServer ('FULLWMS_AX01')
	
		if empty (_sLinkSrv)
			_sMsgNaoEx += "Impossivel verificar existencia da etiqueta '" + ::Codigo + "' no sistema FullWMS. Verifique parametrizacao para que o Protheus acesse o banco de dados do FullWMS."
			_lContinua = .F.
		else
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT CONTAGEM"
			_oSQL:_sQuery += " FROM openquery (" + _sLinkSrv + ","
			_oSQL:_sQuery += " 'select count (*) as CONTAGEM"
			_oSQL:_sQuery +=  " from wms_etiquetas"
			_oSQL:_sQuery += " where wms_etiqueta_id = " + ::Codigo
			_oSQL:_sQuery += " ')"
			_oSQL:Log ('[' + procname () + ']')
			if _oSQL:RetQry (1, .f.) > 0
				_sMsgNaoEx += "Etiqueta '" + ::Codigo + "' encontrada no banco de dados do sistema FullWMS. Verifique (no FullWMS) a tela WF0101 - Consulta de etiquetas de producao."
				_lContinua = .F.
			endif
		endif
	endif

	if ! empty (_sMsgNaoEx)
		if _lComTela
			u_help (_sMsgNaoEx, iif (valtype (_oSQL) == 'O', _oSQL:_sQuery, ''), .t.)
		else
			U_Log2 ('aviso', '[' + procname () + ']' + _sMsgNaoEx)
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Verifica se pode incluir a etiqueta.
METHOD PodeIncl () Class ClsEtiq
	local _lContinua := .T.
	local _oSQL      := NIL
	local _nEtqJaTem := 0

	if _lContinua .and. empty (::Produto)
		::SomaMsg ("Produto nao informado. Gravacao de etiqueta nao permitida.")
		_lContinua = .F.
	endif
	if _lContinua .and. empty (::DtEmis)
		::SomaMsg ("Data emissao etiq.nao informada. Gravacao de etiqueta nao permitida.")
		_lContinua = .F.
	endif
	if _lContinua .and. empty (::OP) .and. empty (::DocEntrNum) .and. empty (::IdZAG) .and. empty (::D5_NUMSEQ)
		::SomaMsg ("Origem (OP, NF, sol.transf. ou D5_NUMSEQ) nao informada. Gravacao de etiqueta nao permitida.")
		_lContinua = .F.
	endif
	if _lContinua .and. ::Quantidade <= 0
		::SomaMsg ("Quantidade nao informada. Gravacao de etiqueta nao permitida.")
		_lContinua = .F.
	endif
	if _lContinua .and. ! empty (::DocEntrNum) .and. (empty (::DocEntrSerie) .or. empty (::DocEntrItem) .or. empty (::DocEntrForn) .or. empty (::DocEntrLoja))
		::SomaMsg ("Para NF entrada, devem ser informadas tambem serie, fornecedor, loja e item da nota. Gravacao de etiqueta nao permitida.")
		_lContinua = .F.
	endif
	if _lContinua .and. ! empty (::OP)
		sc2 -> (dbsetorder (1))
		if ! sc2 -> (dbseek (xfilial ("SC2") + ::OP, .f.))
			::SomaMsg ("OP '" + ::OP + "' nao encontrada.")
			_lContinua = .F.
		endif
		if _lContinua .and. sc2 -> c2_produto != ::Produto
			::SomaMsg ("Prod.da etiq.(" + alltrim (::Produto) + ") deve ser o mesmo da OP (" + alltrim (sc2 -> c2_produto) + ").")
			_lContinua = .F.
		endif
		if _lContinua
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += "SELECT SUM (ZA1_QUANT)"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZA1") + " ZA1"
			_oSQL:_sQuery += " WHERE ZA1.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZA1.ZA1_FILIAL = '" + xfilial ("ZA1") + "'"
			_oSQL:_sQuery +=   " AND ZA1.ZA1_OP     = '" + ::OP + "'"
			_oSQL:_sQuery +=   " AND ZA1.ZA1_APONT != 'I'"  // Inutilizadas nao contam
			_oSQL:_sQuery +=   " AND ZA1.ZA1_APONT != 'E'"  // Estornadas nao podem mais ser apontadas, entao nao contam
		//	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			_nEtqJaTem = _oSQL:RetQry (1, .f.)
			if (_nEtqJaTem + ::Quantidade) > sc2 -> c2_quant
				::SomaMsg ("Soma das qt.das etiq.ja existentes (" + cvaltochar (_nEtqJaTem) + ") + qt.desta etiq.(" + cvaltochar (::Quantidade) + ") ficaria maior que a qt.da OP (" + cvaltochar (sc2 -> c2_quant) + ").")
				_lContinua = .F.
			endif
		endif
	endif
	//U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']retornando ' + cvaltochar (_lContinua))
return _lContinua


// --------------------------------------------------------------------------
// Recebe etiquetas de terceiros (as etiq.sao nossas, mas o produto foi envasado em 3os).
METHOD Recebe3 () Class ClsEtiq
	local _lRetR3  := .T.
	local _oEvento := NIL

	if _lRetR3 .and. ::AlmOrig != '31'
		::SomaMsg ("Recebto. 3os destina-se a etiq. apontadas no ax.31")
		_lRetR3 = .F.
	endif
	if _lRetR3 .and. ::Apontada != 'S'
		::SomaMsg ("Recebto. 3os disponivel apenas p/etiq.ja apontadas.")
		_lRetR3 = .F.
	endif
	if _lRetR3 .and. ::IntegraFull == '1'
		::SomaMsg ("Etiq.ja disponibilizada para o FullWMS.")
		_lRetR3 = .F.
	endif
	if _lRetR3 .and. ::IntegraFull == '2'
		::SomaMsg ("Etiq.ja recebida pelo FullWMS.")
		_lRetR3 = .F.
	endif
	if _lRetR3
		_lRetR3 = ::PodeEnvFul (.t.)
	endif
	if _lRetR3
		// Atualiza campo que vai ser lido pela view v_wms_entrada
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Atualizando campo ZA1_FULLW=1 da etiqueta ' + ::Codigo)
		za1 -> (dbgoto (::RegZA1))
		reclock ("ZA1", .f.)
		za1 -> za1_fullw = '1'  // 1=disponibilizar na v_wms_entrada;2=jah recebido (nao precisa mais ficar na view)
		msunlock ()
		::IntegraFull = za1 -> za1_fullw

		// Atualmente nao tenho amarracao com nada (nem NF de remessa, nem de retorno...)
		// entao vou gravar, pelo menos, um evento.
		_oEvento := ClsEvent():new ()
		_oEvento:CodEven    = 'ZA1003'
		_oEvento:Texto      = 'Confirmacao recebimento etiqueta envasada em terceiros'
		_oEvento:Recno      = ZA1 -> (recno ())
		_oEvento:OP         = ::OP
		_oEvento:Etiqueta   = ::Codigo
		_oEvento:Produto    = ::Produto
		_oEvento:DiasValid  = 999
		_oEvento:Grava ()

	endif
return _lRetR3


// --------------------------------------------------------------------------
// Adiciona (sempre no inicio, para que a mensagem mais recente seja vusta
// antes) uma mensagem na string ::UltMsg
METHOD SomaMsg (_sMsg) Class ClsEtiq
//	if ! alltrim (_sMsg) $ ::UltMsg
//		::UltMsg = alltrim (_sMsg) + '; ' + ::UltMsg
//	endif
	local _sMsgAux := alltrim (cvaltochar (_sMsg))
	if ! alltrim (_sMsgAux) $ ::UltMsg
		::UltMsg = alltrim (_sMsgAux) + '; ' + ::UltMsg
	endif
return


// --------------------------------------------------------------------------
METHOD ValCBEmb (_sCBEmbCol) Class ClsEtiq
	local _lRetVCBE := .T.

	if _sCBEmbCol != ::CBEmbCol
		::SomaMsg ("Barras embalagem coletiva nao conferem com campo C2_VABARCX da OP.")
		_lRetVCBE = .F.
	endif
return _lRetVCBE

/*
// --------------------------------------------------------------------------
// Atualiza dados para integracao com Fullsoft.
static function _AtuFull (_sEtiq, _sQueFazer)
	local _oSQL      := NIL

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	if _sQueFazer == 'E'
		_oSQL:_sQuery += " delete tb_wms_etiquetas"
		_oSQL:_sQuery += " where id = " + cvaltochar (_sEtiq)
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_oSQL:Exec ()
	endif
return
*/

// --------------------------------------------------------------------------
// Localiza registro na tabela SD5, para alimentar dados de nova etiqueta.
static function _AchaSD5 (_sProduto, _sNumSeq)
	local _oSQL    := NIL
	local _nRetSD5 := 0

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += "SELECT TOP 1 R_E_C_N_O_"  // Nao espero encontrar mais de 1, mas, para garantir...
	_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD5") + " SD5"
	_oSQL:_sQuery += " WHERE SD5.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=   " AND SD5.D5_FILIAL  = '" + xfilial ("SD5") + "'"
	_oSQL:_sQuery +=   " AND SD5.D5_PRODUTO = '" + _sProduto + "'"
	//_oSQL:_sQuery +=   " AND SD5.D5_LOTECTL = '" + _sLote    + "'"
	//_oSQL:_sQuery +=   " AND SD5.D5_LOCAL   = '" + _sAlmox   + "'"
	_oSQL:_sQuery +=   " AND SD5.D5_NUMSEQ  = '" + _sNumSeq  + "'"
	_oSQL:_sQuery +=   " AND SD5.D5_ORIGLAN = 'MAN'"  // Soh vou aceitar (por enqto) lotes criados manualmente.
	_oSQL:_sQuery += " ORDER BY SD5.D5_DATA, SD5.D5_NUMSEQ"
	_oSQL:Log ('[' + procname () + ']')
	_nRetSD5 = _oSQL:RetQry (1, .f.)
return _nRetSD5


// --------------------------------------------------------------------------
// Formatacao da etiqueta quando destina-se a OP
static function _FmtOP (_nModelImp, _sMsgObj, _lBarProdu)
	local _nMargEsq   := 0
	local _nMargSup   := 0
	local _sFmtOP     := ''

//	U_Log2 ('debug', '[' + procname () + ']iniciando')
	if _nModelImp == 1  // Impressora Sato
		if _lBarProdu
			_sFmtOP += _Esc + 'H0050' + _Esc + 'V0440'  // Coordenadas
			_sFmtOP += _Esc + 'BG02070'  // Define codigo de barras (tipo, tamanho, altura) ou fonte (espacamento, largura, altura e tipo)
			_sFmtOP += '>G' + _sCBarProd + _Enter  // Informacao a ser impressa no codigo de barras (estilo, dado)
		endif
		_sFmtOP += _Esc + 'H0130' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sDProImp1 + _Enter
		_sFmtOP += _Esc + 'H0155' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sDProImp2 + _Enter
		_sFmtOP += _Esc + 'H0180' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sDProImp3 + _Enter
		_sFmtOP += _Esc + 'H0310' + _Esc + 'V0220' + _Esc + '$B,032,045,0' + _Esc + '$=' + '______' + _Enter
		_sFmtOP += _Esc + 'H0350' + _Esc + 'V0180' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'OK' + _Enter
		_sFmtOP += _Esc + 'H0310' + _Esc + 'V0440' + _Esc + '$A,035,055,0' + _Esc + '$=' + 'Qtd: ' + _sQtdImp + ' ' + _sUMImp + _Enter
		_sFmtOP += _Esc + 'H0410' + _Esc + 'V0440' + _Esc + 'BG02110' + '>G' + _sEtqImp + _Enter
		_sFmtOP += _Esc + 'H0520' + _Esc + 'V0440' + _Esc + '$A,035,055,0' + _Esc + '$=' + 'Etq: ' + _sEtqImp + _Enter
		_sFmtOP += _Esc + 'H0540' + _Esc + 'V0170' + _Esc + '$A,025,028,0' + _Esc + '$=' + _sSeqImp + _Enter
		if ! empty (_sLoteImp)
			_sFmtOP += _Esc + 'H0600' + _Esc + 'V0440' + _Esc + 'BG02070' + '>G' + _sLoteImp + _Enter
			_sFmtOP += _Esc + 'H0670' + _Esc + 'V0440' + _Esc + '$A,035,045,0' + _Esc + '$=' + 'Lote: ' + _sLoteImp + _Enter
		endif
		_sFmtOP += _Esc + 'H0740' + _Esc + 'V0440' + _Esc + '$A,030,042,0' + _Esc + '$=' + _sDImpImp + _Enter
		_sFmtOP += _Esc + '%2' + _Enter // Rotacao (imprime numero da OP 'deitado' na margem direita)
		_sFmtOP += _Esc + 'H0760' + _Esc + 'V00070' + _Esc + '$A,032,045,0' + _Esc + '$=' + 'OP: ' + _sOPImp + '  ' + 'P. Bruto: ' + _sPesoBImp + _Enter
		_sFmtOP += _Esc + '%1' + _Enter // Rotacao (volta para rotacao normal)
		
	elseif _nModelImp == 2  // Impressora Datamax

		_nMargEsq = 15 //7
		_nMargSup = 30
		if _lBarProdu
			_sFmtOP += '4e72' + '000' + strzero (_nMargEsq, 4)       + strzero (_nMargSup +  10, 4) + _sCBarProd + _Enter // cdigo de barra do produto
		endif
		_sFmtOP += '4211' + '000' + strzero (_nMargEsq, 4)       + strzero (_nMargSup +  30, 4) + _sDProImp1    + _Enter 	// descrio 
		_sFmtOP += '4211' + '000' + strzero (_nMargEsq, 4)       + strzero (_nMargSup +  45, 4) + _sDProImp2    + _Enter
		_sFmtOP += '4211' + '000' + strzero (_nMargEsq, 4)       + strzero (_nMargSup +  50, 4) + _sDProImp3    + _Enter
		_sFmtOP += '4311' + '000' + strzero (_nMargEsq, 4)       + strzero (_nMargSup + 120, 4) + 'QTD: ' + _sQtdImp + ' ' + _sUMImp + _Enter // quantidade
		_sFmtOP += '4211' + '000' + strzero (_nMargEsq + 120, 4) + strzero (_nMargSup + 135, 4) + '--------'    + _Enter // pontilhado
		_sFmtOP += '4211' + '000' + strzero (_nMargEsq + 120, 4) + strzero (_nMargSup + 145, 4) + '   OK'      + _Enter // OK
		_sFmtOP += '4e52' + '000' + strzero (_nMargEsq, 4)       + strzero (_nMargSup + 200, 4) + _sEtqImp    + _Enter // Cdigo de barra etiqueta
		_sFmtOP += '4311' + '000' + strzero (_nMargEsq, 4)       + strzero (_nMargSup + 220, 4) + 'Etiq:' + _sEtqImp    + _Enter // Etiqueta
		_sFmtOP += '4211' + '000' + strzero (_nMargEsq + 140, 4) + strzero (_nMargSup + 225, 4) + _sSeqImp    + _Enter // Sequencia da etiqueta
		_sFmtOP += '4e52' + '000' + strzero (_nMargEsq, 4)       + strzero (_nMargSup + 280, 4) + _sLoteImp   + _Enter // Cdigo de barras do lote
		_sFmtOP += '4311' + '000' + strzero (_nMargEsq, 4)       + strzero (_nMargSup + 300, 4) + 'LOTE:' + _sLoteImp + _Enter // Lote
		_sFmtOP += '4211' + '000' + strzero (_nMargEsq, 4)       + strzero (_nMargSup + 325, 4) + _sDImpImp + _Enter // Impressa em:
		_sFmtOP += '3311' + '000' + strzero (_nMargEsq + 210, 4) + strzero (_nMargSup + 335, 4) + _sOPImp + '  ' + 'Peso Bruto: ' + _sPesoBImp + _Enter // OP

	elseif _nModelImp == 4  // Impressora Elgin L42 (BPLA)

		// Formatacao BPLA:
		// A: rotacao (1 a 4)
		// B: 0-9=fonte(letras); A-T=cod.barras com linha legivel;a-t=sem linha legivel; X=grafico; Y-imagem
		// C: multiplicador de largura
		// D: multiplicador de altura
		// E: seletor de fonte / altura cod.barras
		// F: posicionamento (eixo X ou 'colunas')
		// G: posicionamento (eixo Y ou 'linhas')
		// H: dados (texto ou numeros para cod. barra)
		//           RBCDEEEFFFFGGGGH...
		_sFmtOP += '421100000150005posicao 15,5' + _Enter
		//_sFmtOP += '421100000150100posicao 15,100' + _Enter
		_sFmtOP += '421100000150200posicao 15,200' + _Enter
		_sFmtOP += '421100000150300posicao 15,300' + _Enter
		_sFmtOP += '421100000150350posicao 15,350' + _Enter
		_sFmtOP += '4E1204000150100' + _sEtqImp + _Enter // E=code128
		_sFmtOP += '4e1204000150250' + _sEtqImp + _Enter  // 4=rotacao;E=code128;1=unavailable;2=narrow bar width
		U_Log2 ('debug', _sFmtOP)
	endif

	if empty (_sFmtOP)
		U_Log2 ('debug', '[' + procname () + ']terminou vazio')
		_sMsgObj += "Sem tratamento para formatacao de impressao para este tipo de etiqueta no programa " + procname ()
		_lRetImpr = .F.
	endif
	//U_Log2 ('debug', '[' + procname () + ']terminei com: ' + _sFmtOP)
return _sFmtOP


// --------------------------------------------------------------------------
// Formatacao da etiqueta quando destina-se a uma transferencia da tabela ZAG
static function _FmtZAG (_nModelImp, _sMsgObj)
	local _nMargEsq   := 0
	local _nMargSup   := 0
	local _sFmtZAG    := ''

	if _nModelImp == 1  // Impressora Sato
		_sFmtZAG += _Esc + 'H0050' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sDProImp1 + _Enter
		_sFmtZAG += _Esc + 'H0075' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sDProImp2 + _Enter
		_sFmtZAG += _Esc + 'H0100' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sDProImp3 + _Enter
		_sFmtZAG += _Esc + 'H0150' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + Alltrim(_sDocImp) + _Enter
		_sFmtZAG += _Esc + 'H0200' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sObsImp1 + _Enter
		_sFmtZAG += _Esc + 'H0225' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sObsImp2 + _Enter
		_sFmtZAG += _Esc + 'H0300' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'Lote: ' + AllTrim(_sLoteImp) + _Enter
		_sFmtZAG += _Esc + 'H0335' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'Qtd: ' + Alltrim(_sQtdImp) + ' ' + AllTrim(_sUMImp) + _Enter
		_sFmtZAG += _Esc + 'H0400' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'Validade: ' + AllTrim(_sVldLtImp) + _Enter
		_sFmtZAG += _Esc + 'H0455' + _Esc + 'V0440' + _Esc + 'BG02110' + '>G' + AllTrim(_sEtqImp) + _Enter
		_sFmtZAG += _Esc + 'H0575' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'Etq: ' + AllTrim(_sEtqImp) + _Enter
		_sFmtZAG += _Esc + 'H0650' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'DATA: ____________________' + _Enter
		_sFmtZAG += _Esc + 'H0700' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'RESP: ____________________' + _Enter
		_sFmtZAG += _Esc + 'H0750' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'ASS.: ____________________' + _Enter

	elseif _nModelImp == 2  // Impressora Argox/Datamax
		_nMargEsq = 15 //7
		_nMargSup = 0
		_sFmtZAG += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup +  50, 4) + _sDProImp1 + _Enter
		_sFmtZAG += '4211' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup +  65, 4) + _sDProImp2 + _Enter
		_sFmtZAG += '4211' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup +  80, 4) + _sDProImp3 + _Enter
		_sFmtZAG += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 105, 4) + _sDocImp   + _Enter
		_sFmtZAG += '4211' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 120, 4) + _sObsImp1  + _Enter
		_sFmtZAG += '4211' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 135, 4) + _sObsImp2  + _Enter
		_sFmtZAG += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 160, 4) + 'Lote:' + _sLoteImp + _Enter
		_sFmtZAG += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 185, 4) + 'Qtd:' + _sQtdImp + ' ' + _sUMImp + _Enter
		_sFmtZAG += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 210, 4) + 'Validade:   ' + _sVldLtImp + _Enter
		_sFmtZAG += '4e52' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 260, 4) + _sEtqImp + _Enter  // Cod.barras
		_sFmtZAG += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 280, 4) + 'Etiqueta:   ' + _sEtqImp + _Enter
		_sFmtZAG += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 310, 4) + 'DATA: _______________' + _Enter
		_sFmtZAG += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 335, 4) + 'RESP: _______________' + _Enter
		_sFmtZAG += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 360, 4) + 'ASS.: _______________' + _Enter

	elseif _nModelImp == 4  // Impressora Elgin L42 (BPLA)
//			_sTxtEtiq += '1A3104000200020' + ::Codigo + _Enter  // SOH - inicio de header

		// Formatacao BPLA:
		// R: rotacao (1 a 4)
		// B: 0-9=fonte(letras); A-T=cod.barras com linha legivel;a-t=sem linga legivel; X=grafico; Y-imagem
		// C: multiplicador de largura
		// D: multiplicador de altura
		// E: seletor de fonte / altura cod.barras
		// F: posicionamento (eixo X ou 'colunas')
		// G: posicionamento (eixo Y ou 'linhas')
		// H: dados (texto ou numeros para cod. barra)
		//           RBCDEEEFFFFGGGGH...
		_sFmtZAG += '421100000150005posicao 15,5' + _Enter
		_sFmtZAG += '421100000150200posicao 15,200' + _Enter
		_sFmtZAG += '421100000150300posicao 15,300' + _Enter
		_sFmtZAG += '421100000150350posicao 15,350' + _Enter
		_sFmtZAG += '4E1204000150100' + _sEtqImp + _Enter // E=code128
		_sFmtZAG += '4e1204000150250' + _sEtqImp + _Enter  // 4=rotacao;E=code128;1=unavailable;2=narrow bar width
	endif

	if empty (_sFmtZAG)
		_sMsgObj += "Sem tratamento para formatacao de impressao para este tipo de etiqueta no programa " + procname ()
		_lRetImpr = .F.
	endif
return _sFmtZAG


// --------------------------------------------------------------------------
// Formatacao da etiqueta quando originada por NF de entrada.
static function _FmtNF (_nModelImp, _sMsgObj)
	local _nMargEsq   := 0
	local _nMargSup   := 0
	local _sFmtNF     := ''

	if _nModelImp == 1  // Impressora Sato
		_sFmtNF += _Esc + 'H0050' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sDProImp1 + _Enter
		_sFmtNF += _Esc + 'H0075' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sDProImp2 + _Enter
		_sFmtNF += _Esc + 'H0100' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sDProImp3 + _Enter
		_sFmtNF += _Esc + 'H0150' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + Alltrim(_sDocImp) + _Enter
		_sFmtNF += _Esc + 'H0200' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sFornImp1 + _Enter
		_sFmtNF += _Esc + 'H0225' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + _sFornImp2 + _Enter
		if ! empty (_sLtForImp)
			_sFmtNF += _Esc + 'H0275' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'LOTE FORN: ' + AllTrim(_sLtForImp) + _Enter
		endif
		_sFmtNF += _Esc + 'H0300' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'LOTE INT: ' + AllTrim(_sLoteImp) + _Enter
		_sFmtNF += _Esc + 'H0325' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'QTD: ' + Alltrim(_sQtdImp) + ' ' + AllTrim(_sUMImp) + _Enter
		_sFmtNF += _Esc + 'H0375' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'FABRICACAO: ' + AllTrim(_sDtFabImp) + _Enter
		_sFmtNF += _Esc + 'H0400' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'VALIDADE: ' + AllTrim(_sVldLtImp) + _Enter
		_sFmtNF += _Esc + 'H0470' + _Esc + 'V0440' + _Esc + 'BG02110' + '>G' + AllTrim(_sEtqImp) + _Enter
		_sFmtNF += _Esc + 'H0600' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'ETQ: ' + AllTrim(_sEtqImp) + _Enter
		_sFmtNF += _Esc + 'H0650' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'DATA: ____________________' + _Enter
		_sFmtNF += _Esc + 'H0700' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'RESP: ____________________' + _Enter
		_sFmtNF += _Esc + 'H0750' + _Esc + 'V0440' + _Esc + '$B,025,028,0' + _Esc + '$=' + 'ASS.: ____________________' + _Enter

	elseif _nModelImp == 2  // Impressora Argox/Datamax
		_nMargEsq = 15 //7
		_nMargSup = 0
		_sFmtNF += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup +  50, 4) + _sDProImp1 + _Enter
		_sFmtNF += '4211' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup +  65, 4) + _sDProImp2 + _Enter
		_sFmtNF += '4211' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup +  80, 4) + _sDProImp3 + _Enter
		_sFmtNF += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 105, 4) + _sDocImp   + _Enter
		_sFmtNF += '4211' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 120, 4) + _sFornImp1 + _Enter
		_sFmtNF += '4211' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 135, 4) + _sFornImp2 + _Enter
		if ! empty (_sLtForImp)
			_sFmtNF += '4211' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 155, 4) + 'Lt.forn:' + _sLtForImp + _Enter
		endif
		_sFmtNF += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 175, 4) + 'Lt.int:' + _sLoteImp + _Enter
		_sFmtNF += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 200, 4) + 'Qtd:' + _sQtdImp + ' ' + _sUMImp + _Enter
		_sFmtNF += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 220, 4) + 'FABRICACAO: ' + _sDtFabImp + _Enter
		_sFmtNF += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 240, 4) + 'VALIDADE:   ' + _sVldLtImp + _Enter
		_sFmtNF += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 267, 4) + 'ETIQUETA:   ' + _sEtqImp + _Enter
		_sFmtNF += '4e52' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 310, 4) + _sEtqImp + _Enter  // cod barras
		_sFmtNF += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 330, 4) + 'DATA: _______________' + _Enter
		_sFmtNF += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 350, 4) + 'RESP: _______________' + _Enter
		_sFmtNF += '4311' + '000' + strzero (_nMargEsq, 4) + strzero (_nMargSup + 370, 4) + 'ASS.: _______________' + _Enter
	endif
	if empty (_sFmtNF)
		_sMsgObj += "Sem tratamento para formatacao de impressao para este tipo de etiqueta no programa " + procname ()
		_lRetImpr = .F.
	endif
return _sFmtNF

