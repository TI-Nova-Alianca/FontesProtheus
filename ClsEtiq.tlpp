// Programa:  ClsEtiq
// Autor:     Robert Koch
// Data:      28/03/2022
// Descricao: Declaracao de classe de representacao de etiquetas usadas na producao.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa etiquetas usadas para identificacao de produtos e movimentacoes de estoque / integracoes com FullWMS.
// #PalavasChave      #etiquetas #integracao #FullWMS #producao
// #TabelasPrincipais #ZA1
// #Modulos           #EST #PCP

// Historico de alteracoes:
// 28/03/2022 - Robert - Criada a classe e iniciada migracao de diversos outros fontes para ca.
// 13/06/2022 - Robert - Ajuste leitura filial ZAG na impressao.
// 15/06/2022 - Robert - Ao instanciar etiqueta jah existente, tentava sempre buscar
//                       dados de lote, mesmo quando b1_rastro!='L' (GLPI 12220)
//                     - Impede exclusao de etiqueta de NF (migrado do VA_ETQPLL.PRW)
// 16/06/2022 - Robert - Verif.se a etiq.existe no FullWMS antes excluir (GLPI 12220).
// 26/07/2022 - Robert - Implementada verif.disponib.estq no metodo PodeApont() - GLPI 11994
// 29/07/2022 - Robert - Verif.saldo empenhos desconsiderava empenhos zerados.
// 01/08/2022 - Robert - Ajuste formula verif.saldo empenhos (GLPI 11994)
// 11/08/2022 - Robert - Criado metodo :Imprime (por enquanto, ainda chamando rotina externa)
//                     - Criado atributo :UltMsg
// 12/08/2022 - Robert - Criado atributo :AlmDest (GLPI 12474)
//                     - Melhorias leitura lote origem (ZAG e SD1)
// 25/08/2022 - Robert - Criado metodo :ApontaOP
// 23/09/2022 - Robert - Criado atributo :CBEmbCol e metodo :ValCBEmb - GLPI 11994
// 26/09/2022 - Robert - Funcao de inutilizacao migrada do fonte ZA1IN para metodo :Inutiliza()
// 05/10/2022 - Robert - Iniciado tratamento para etiquetas geradas a partir do SD5 (GLPI 12651)
// 24/10/2022 - Robert - Criado atributo :FinalidOP
//

#Include "Protheus.ch"
#Include "RwMake.ch"
#Include "TbiConn.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsEtiq ()
return


// ==========================================================================
CLASS ClsEtiq

	// Declaracao das propriedades da Classe
	public  data AlmDest      // Almox.destino, quando transferencia (ZAG) ou apontamento de OP
	public  data AlmOrig      // Almox.origem, quando transferencia (ZAG) ou gerada com base no SD5 (lotes iniciais).
	public  data Apontada     // ZA1_APONT - Apontamento de producao ja executado (quando etiq. para OP)
	public  data Codigo       // ZA1_CODIGO - Numero da etiqueta
	private data CBEmbCol     // C2_VABARCX - Cod.barras embalagem coletiva - Para validacao no momento de apontar a producao.
	public  data D5_NUMSEQ    // D5_NUMSEQ - Quando etiq. gerada a partir de um registro de origem MAN do SD5.
	public  data DocEntrForn  // ZA1_FORNEC - Quando refere-se a NF de entrada
	public  data DocEntrItem  // ZA1_ITEM - Quando refere-se a NF de entrada
	public  data DocEntrLoja  // ZA1_LOJAF - Quando refere-se a NF de entrada
	public  data DocEntrNum   // ZA1_DOCE - Quando refere-se a NF de entrada
	public  data DocEntrSerie // ZA1_SERIEE - Quando refere-se a NF de entrada
	public  data DtEmis       // ZA1_DATA
	public  data Filial       // ZA1_FILIAL
	public  data FinalidOP    // C2_vaOpEsp: N=Normal;R=Reprocesso;E=externa (em 3os);T=Terceirizacao (para 3os);F=Filtracao
	public  data IdZAG        // ZA1_IDZAG - Identificador de registro da tabela ZAG
	public  data Impressa     // ZA1_IMPRES - Jah impressa
	public  data Inutilizada  // ZA1_APONT='I' - Indica que foi inutilizada manualmente
	public  data LoteProduto
	public  data OP           // ZA1_OP
	public  data Produto      // ZA1_PROD
	public  data QtApontada   // Quando relacionada a uma OP
	public  data QtEstornada  // Quando relacionada a uma OP
	public  data QtPerdida    // Quando relacionada a uma OP
	public  data Quantidade   // ZA1_QUANT
	private data RegZA1       // Numero registro (RECNO) no ZA1.
	public  data SeqNoGrupo   // ZA1_SEQ - Sequencia dentro do grupo, geralmente de OP. Ex.: 1 de 10, 2 de 10, ...
	public  data UltMsg       // Ultima mensagem gerada.
	public  data UsrIncl      // ZA1_USRINC - Usuario que incluiu/gerou a etiqueta
	public  data ValidLote    // Validade do lote

	// Declaracao dos Metodos da classe
	public METHOD New ()
	public METHOD ApontaOP ()
	public METHOD EnviaFull ()
	public METHOD Exclui ()
	public METHOD Imprime ()
	public METHOD Inutiliza ()
	public METHOD GeraAtrib ()
	public METHOD Grava ()
	public METHOD NovaPorSD5 ()
	public METHOD PodeEnvFul ()
	public METHOD PodeExcluir ()
	public METHOD PodeApont ()
	public METHOD ValCBEmb ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor.
METHOD New (_xChave) Class ClsEtiq

	// Alimenta atributos com valores default de uma etiqueta nova.
	::GeraAtrib ("")
	
	// Se receber numerico, eh por que se trata do numero de registro do ZA1.
	if valtype (_xChave) == "N"
		ZA1 -> (dbgoto (_xChave))
		::GeraAtrib ("ZA1")

	// Se receber caracter, eh por que se trata do codigo da etiqueta.
	elseif valtype (_xChave) == "C"
		//U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + '] >>' + xfilial ("ZA1") + _xChave + '<<')
		za1 -> (dbsetorder (1))  // ZA1_FILIAL+ZA1_CODIGO+ZA1_DATA+ZA1_OP
		if za1 -> (dbseek (xfilial ("ZA1") + _xChave, .F.))
			::GeraAtrib ("ZA1")
		else
			::UltMsg += "Problema ao instanciar etiqueta: Nao localizei codigo de etiqueta '" + _xChave + "' para a filial atual na tabela ZA1."
			U_help (::UltMsg,, .t.)
		endif
	endif
Return ::self


// --------------------------------------------------------------------------
// Gera apontamento de producao
METHOD ApontaOP (_dDtProd, _sTnoProd) Class ClsEtiq
	local _lRetAp    := .T.
	local _aAutoSD3  := {}

	if ! ::PodeApont (::Quantidade, 0)
		_lRetAp = .F.
	else
//		U_PerfMon ("I", "ClsEtiqApontaOP")  // Medicao de tempos de execucao
		aadd (_aAutoSD3, {"D3_OP",      ::OP,       NIL})
		aadd (_aAutoSD3, {"D3_VAETIQ",  ::Codigo,   NIL})
		aadd (_aAutoSD3, {"D3_VADTPRD", _dDtProd,   NIL})
		aadd (_aAutoSD3, {"D3_VATURNO", _sTnoProd,  NIL})
		aadd (_aAutoSD3, {"D3_VAMOTIV", 'PRODUCAO', NIL})
		aadd (_aAutoSD3, {"ATUEMP",     "T",        NIL})  // Para que sempre seja feita a baixa dos empenhos.
		_aAutoSD3 := aclone (U_OrdAuto (_aAutoSD3))
		//U_Log2 ('debug', _aAutoSD3)
		lMsErroAuto  := .F.
		_sErroAuto := ''
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Apontando etiq. ' + ::Codigo)
		//U_Log2 ('info', 'Executando MATA250')
		dbselectarea ("SD3")
		dbsetorder (1)
		MATA250 (_aAutoSD3, 3)
		If lMsErroAuto
			_lRetAp = .F.
			if ! empty (_sErroAuto)
				::UltMsg += _sErroAuto + '; '
			elseif ! empty (NomeAutoLog ())
				::UltMsg += U_LeErro (memoread (NomeAutoLog ())) + '; '
			endif
			u_help ('Erro rot.aut:' + alltrim (::UltMsg),, .t.)
		else
			::UltMsg += "Etiq." + ::Codigo + " apontada com sucesso (d3_numseq = " + sd3 -> d3_numseq + ")"
		endif
//		U_PerfMon ("F", "ClsEtiqApontaOP")  // Medicao de tempos de execucao
	endif
return _lRetAp


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sOrigem) Class ClsEtiq
	local _aAreaAnt := U_ML_SRArea ()
	local _oSQL     := NIL
	local _aLoteVal := {}
	local _aRetSD3  := {}
	local _nRegSD5  := 0

	// Defaults
	::AlmDest      = ''
	::AlmOrig      = ''
	::Apontada     = 'N'
	::Codigo       = ''
	::CBEmbCol     = ''
	::D5_NUMSEQ    = ''
	::DocEntrForn  = ''
	::DocEntrItem  = ''
	::DocEntrLoja  = ''
	::DocEntrNum   = ''
	::DocEntrSerie = ''
	::DtEmis       = ctod ('')
	::Filial       = xfilial ("ZA1")
	::FinalidOP    = ''
	::IdZAG        = ''
	::Impressa     = 'N'
	::Inutilizada  = .F.
	::LoteProduto  = ''
	::OP           = ''
	::Produto      = ''
	::QtApontada   = 0
	::QtEstornada  = 0
	::QtPerdida    = 0
	::Quantidade   = 0
	::RegZA1       = 0
	::SeqNoGrupo   = ''
	::UltMsg       = ''
	::UsrIncl      = cUserName
	::ValidLote    = ctod ('')

	do case
	case _sOrigem == 'M'  // Variaveis M->
		::Apontada     = m->ZA1_APONT
		::Codigo       = m->ZA1_CODIGO
		::D5_NUMSEQ    = m->ZA1_D5NSEQ
		::DocEntrForn  = m->ZA1_FORNEC
		::DocEntrItem  = m->ZA1_ITEM
		::DocEntrLoja  = m->ZA1_LOJAF
		::DocEntrNum   = m->ZA1_DOCE
		::DocEntrSerie = m->ZA1_SERIEE
		::DtEmis       = m->ZA1_DATA
		::Filial       = xfilial ("SZI")
		::IdZAG        = m->ZA1_IDZAG
		::Impressa     = m->ZA1_IMPRES
		::Inutilizada  = (m->za1_apont == 'I')
		::OP           = m->ZA1_OP
		::Produto      = m->ZA1_PROD
		::Quantidade   = m->ZA1_QUANT
		::SeqNoGrupo   = m->ZA1_SEQ
		::UsrIncl      = m->ZA1_USRINC

	case _sOrigem == "ZA1"

		::Apontada     = za1 -> ZA1_APONT
		::Codigo       = za1 -> ZA1_CODIGO
		::D5_NUMSEQ    = za1 -> ZA1_D5NSEQ
		::DocEntrForn  = za1 -> ZA1_FORNEC
		::DocEntrItem  = za1 -> ZA1_ITEM
		::DocEntrLoja  = za1 -> ZA1_LOJAF
		::DocEntrNum   = za1 -> ZA1_DOCE
		::DocEntrSerie = za1 -> ZA1_SERIEE
		::DtEmis       = za1 -> ZA1_DATA
		::Filial       = za1 -> za1_filial
		::IdZAG        = za1 -> ZA1_IDZAG
		::Impressa     = za1 -> ZA1_IMPRES
		::Inutilizada  = (za1 -> za1_apont == 'I')
		::OP           = za1 -> ZA1_OP
		::Produto      = za1 -> ZA1_PROD
		::Quantidade   = za1 -> ZA1_QUANT
		::RegZA1       = za1 -> (recno ())
		::SeqNoGrupo   = za1 -> ZA1_SEQ
		::UsrIncl      = za1 -> ZA1_USRINC
	otherwise
		if ! empty (_sOrigem)  // Se origem vazia, eh por que estou apenas instanciando um objeto vazio.
			::UltMsg += "Impossivel gerar atributos. Origem '" + _sOrigem + "' desconhecida."
			u_help (::UltMsg,, .t.)
		endif
	endcase

	// Alimenta dados adicionais conforme a origem da etiqueta.
	if _sOrigem == 'M' .or. _sOrigem == "ZA1"
		sb1 -> (dbsetorder (1))
		if ! sb1 -> (dbseek (xfilial ("SB1") + ::Produto, .f.))
			u_help ('[' + GetClassName (::Self) + '.' + procname () + "]Nao localizado cadastro do produto '" + ::Produto + "' relacionado `a etiqueta '" + ::Codigo + "'.",, .t.)
		else
			do case
			case ! empty (::OP)
				::LoteProduto = substring (::OP, 1, 8)
				::AlmDest = sb1 -> b1_locpad
				sc2 -> (dbsetorder (1))
				if ! sc2 -> (dbseek (xfilial ("SC2") + ::OP, .f.))
					u_help ('[' + GetClassName (::Self) + '.' + procname () + "]Impossivel encontrar a OP '" + ::OP + "' relacionada `a etiqueta '" + ::Codigo + "'. Validade nao pode ser determinada.",, .t.)
				else
					::AlmOrig   = sc2 -> c2_local
					::CBEmbCol  = sc2 -> c2_vaBarCx
					::FinalidOP = sc2 -> c2_vaOpEsp
					if sc2 -> c2_vaopesp == 'R'  // OP de reprocesso assume dt valid do lote original, cfe informada pelo usuario.
						if empty (sc2 -> c2_vadvori)
							u_help ('[' + GetClassName (::Self) + '.' + procname () + "]Impossivel buscar a data de validade do lote  da etiqueta '" + ::Codigo + "': a OP referenciada (" + ::OP + ") eh uma OP de reprocesso, e nao foi informada a data de validade do lote original no campo C2_VADVORI (" + alltrim (rettitle ("C2_VADVORI")) + ").",, .t.)
						else
							::ValidLote = sc2 -> c2_vadvori
						endif
					else
						::ValidLote = sc2 -> c2_datprf + sb1 -> b1_prvalid
					endif

					// Busca quantidades apontadas e perdidas
					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := ""
					_oSQL:_sQuery += "SELECT ISNULL (SUM (CASE WHEN D3_ESTORNO != 'S' AND D3_CF LIKE 'PR%' THEN D3_QUANT ELSE 0 END), 0) AS APONTAM"
					_oSQL:_sQuery +=      ", ISNULL (SUM (CASE WHEN D3_ESTORNO != 'S' AND D3_CF LIKE 'PR%' THEN D3_PERDA ELSE 0 END), 0) AS PERDA"
					_oSQL:_sQuery +=      ", ISNULL (SUM (CASE WHEN D3_ESTORNO  = 'S' AND D3_CF LIKE 'ER%' THEN D3_QUANT ELSE 0 END), 0) AS ESTORNO"
					_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD3") + " SD3"
					_oSQL:_sQuery += " WHERE SD3.D_E_L_E_T_ = ''"
					_oSQL:_sQuery +=   " AND SD3.D3_FILIAL  = '" + xfilial ("SD3") + "'"
					_oSQL:_sQuery +=   " AND SD3.D3_VAETIQ  = '" + ::Codigo + "'"
					//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
					_aRetSD3 := aclone (_oSQL:Qry2Array (.f., .f.))
					::QtApontada  = _aRetSD3 [1 , 1]
					::QtPerdida   = _aRetSD3 [1 , 2]
					::QtEstornada = _aRetSD3 [1 , 3]
				endif

			case ! empty (::DocEntrNum)  // Etiqueta gerada por NF de entrada
				sd1 -> (dbsetorder (1))  // D1_FILIAL, D1_DOC, D1_SERIE, D1_FORNECE, D1_LOJA, D1_COD, D1_ITEM, R_E_C_N_O_, D_E_L_E_T_
				if ! sd1 -> (dbseek (::Filial + ::DocEntrNum + ::DocEntrSerie + ::DocEntrForn + ::DocEntrLoja + ::Produto + ::DocEntrItem, .F.))
					u_help ("NF/fornecedor/produto/item '" + ::DocEntrNum + '/' + ::DocEntrForn + '/' + ::Produto + '/' +::DocEntrItem + "' referenciada pela etiqueta '" + ::Codigo + "' nao foi localizada na tabela SD1.",, .t.)
				else
					::AlmDest = sd1 -> d1_local
					if sb1 -> b1_rastro == 'L'
						_oSQL := ClsSQL ():New ()
						_oSQL:_sQuery := "SELECT B8_LOTECTL, B8_DTVALID"
						_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB8") + " SB8 "
						_oSQL:_sQuery += " WHERE SB8.D_E_L_E_T_ = ''"
						_oSQL:_sQuery +=   " AND SB8.B8_FILIAL  = '" + sd1 -> d1_filial  + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOTECTL = '" + sd1 -> d1_lotectl + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_PRODUTO = '" + sd1 -> d1_cod     + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOCAL   = '" + sd1 -> d1_local   + "'"
						//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
						_aLoteVal = aclone (_oSQL:RetFixo (1, "ao consultar lote do produto da etiqueta '" + ::Codigo + "' na NF de entrada '" + ::DocEntrNum + "'.", .T.))
						if len (_aLoteVal) == 1
							::LoteProduto = _aLoteVal [1, 1]
							::ValidLote   = _aLoteVal [1, 2]
						endif
					endif
				endif

			case ! empty (::IdZAG)
				zag -> (dbsetorder (1))  // ZAG_FILIAL, ZAG_DOC, R_E_C_N_O_, D_E_L_E_T_
			//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Pesquisando ZAG com >>' + xfilial ("ZAG") + ::IdZAG + '<< para buscar lote e validade.')
				if ! zag -> (dbseek (xfilial ("ZAG") + ::IdZAG, .F.))
					u_help ("Solicitacao de transferencia '" + ::IdZAG + "' referenciada pela etiqueta '" + ::Codigo + "' nao foi localizada na tabela ZAG.",, .t.)
				else
					::AlmDest = zag -> zag_almdst
					if sb1 -> b1_rastro == 'L'
						_oSQL := ClsSQL ():New ()
						_oSQL:_sQuery := "SELECT B8_LOTECTL, B8_DTVALID"
						_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB8") + " SB8 "
						_oSQL:_sQuery += " WHERE SB8.D_E_L_E_T_ = ''"
						_oSQL:_sQuery +=   " AND SB8.B8_FILIAL  = '" + zag -> zag_filori + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOTECTL = '" + zag -> zag_lotori + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_PRODUTO = '" + zag -> zag_prdori + "'"
						_oSQL:_sQuery +=   " AND SB8.B8_LOCAL   = '" + zag -> zag_almori + "'"
						//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
						_aLoteVal = aclone (_oSQL:RetFixo (1, "ao consultar lote do produto da etiqueta '" + ::Codigo + "' na solicitacao de transferencia numero '" + ::IdZAG + "'.", .T.))
						if len (_aLoteVal) == 1
							::LoteProduto = _aLoteVal [1, 1]
							::ValidLote   = _aLoteVal [1, 2]
						endif
					endif
					
					// Se quero enviar para o FullWMS, tenho que ter algum lote.
					// Enquanto eu nao tiver (seja por que o produto nao controla
					// lote no Protheus, ou por que ainda nao implementamos uma
					// maneira de informar na solicitacao de transferencia), vou
					// ter que gerar algum lote fajuto.
					// OBS: Manter consistencia com a view v_wms_entrada !!!
					if ::AlmDest == '01' .and. empty (::LoteProduto)
						U_Log2 ('aviso', '[' + GetClassName (::Self) + '.' + procname () + ']Gerando lote e validade fajutos para ver se o Full aceita.')
						::LoteProduto = '000001'
						::ValidLote   = date () + sb1 -> b1_prvalid
					endif
				endif
			case ! empty (::D5_NUMSEQ)
				_nRegSD5 = _AchaSD5 (::Produto, ::D5_NUMSEQ)
				if _nRegSD5 > 0
					sd5 -> (dbgoto (_nRegSD5))
					::AlmDest     = sd5 -> d5_local
					::AlmOrig     = sd5 -> d5_local
					::LoteProduto = sd5 -> d5_lotectl
					::ValidLote   = sd5 -> d5_dtvalid
				endif
			otherwise
				::UltMsg += "Impossivel determinar atributos adicionais. Origem de etiqueta desconhecida."
				u_help (::UltMsg,, .t.)
			endcase
		endif
	endif
	
	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Grava nova etiqueta na tabela ZA1.
// Minha intencao eh migrar a funcao U_IncEtqPll para este metodo.
METHOD Grava () Class ClsEtiq
	local _lGravou := .F.
	local _aAreaAnt := U_ML_SRArea ()
	local _sNextNum := ''
	local _nSeqEtq  := 0

	// Gera sequencial da etiqueta dentro do grupo (OP ou NF) a que pertence.
	if ! empty (::OP) .or. ! empty (::DocEntrNum)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " SELECT COUNT (*)"
		_oSQL:_sQuery +=   " FROM " + RetSQLName ("ZA1")
		_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=    " AND ZA1_OP     = '" + ::OP + "'"
		_oSQL:_sQuery +=    " AND ZA1_DOCE   = '" + ::DocEntrNum + "'"
		_oSQL:_sQuery +=    " AND ZA1_SERIEE = '" + ::DocEntrSerie + "'"
		_oSQL:_sQuery +=    " AND ZA1_ITEM = '"   + ::DocEntrItem + "'"
		_oSQL:_sQuery +=    " AND ZA1_FORNEC = '" + ::DocEntrForn + "'"
		_oSQL:_sQuery +=    " AND ZA1_LOJAF  = '" + ::DocEntrLoja + "'"
		_nSeqEtq = _oSQL:RetQry () + 1
	endif

	begin transaction
		_sNextNum = U_NxtZA1 (::Produto)
		reclock ("ZA1",.T.)
		ZA1 -> ZA1_FILIAL = ::Filial
		ZA1 -> ZA1_CODIGO = _sNextNum
		ZA1 -> ZA1_DATA   = ::DtEmis
		ZA1 -> ZA1_OP     = ::OP
		ZA1 -> ZA1_PROD   = ::Produto
		ZA1 -> ZA1_QUANT  = ::Quantidade
		za1 -> za1_doce   = ::DocEntrNum
		za1 -> za1_seriee = ::DocEntrSerie
		za1 -> za1_item   = ::DocEntrItem
		za1 -> za1_fornec = ::DocEntrForn
		za1 -> za1_lojaf  = ::DocEntrLoja
		za1 -> za1_seq    = _nSeqEtq
		za1 -> za1_usrinc = cUserName
		za1 -> za1_idZAG  = ::IdZAG
		za1 -> ZA1_D5NSEQ = ::D5_NUMSEQ
		msunlock()
		::Codigo     = za1 -> za1_codigo
		::SeqNoGrupo = za1 -> za1_seq
		::RegZA1     = za1 -> (recno ())
		_lGravou = .T.
	end transaction
	u_log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Etiqueta ' + za1 -> za1_codigo + ' gravada. Produto: ' + alltrim (za1 -> za1_prod) + ' OP: ' + alltrim (za1 -> za1_op) + ' NF: ' + alltrim (za1 -> za1_doce) + ' D5NSEQ: ' + alltrim (za1 -> ZA1_D5NSEQ))

	do while __lSX8
		ConfirmSX8 ()
	enddo

	U_ML_SRArea (_aAreaAnt)
return _lGravou


// --------------------------------------------------------------------------
// Gera etiqueta para lote jah existente no estoque. A intencao desta operacao
// eh poder etiquetar lotes jah existentes no estoque quando a rastreabilidade
// for habilitada para um produto, pois esses 'lotes iniciais' nao terao sua
// origem a partir de um movimento de estoque (lotes posteriores serao criados
// atraves de um apontamento de OP, ou uma nota de compra, etc.)
METHOD NovaPorSD5 (_sProduto, _sLote, _sAlmox, _sNumSeq) Class ClsEtiq
	local _aAreaAnt := U_ML_SRArea ()
	local _nRegSD5  := 0
	local _oSQL     := NIL

	U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Tentando criar etiqueta para produto/lote/almox/numseq ' + _sProduto + '/' + _sLote + '/' + _sAlmox + '/' + _sNumSeq)
	
	// Nao vou permitir duas etiquetas para o mesmo lote.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += "SELECT ZA1_CODIGO"
	_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZA1") + " ZA1"
	_oSQL:_sQuery += " WHERE ZA1.D_E_L_E_T_  = ''"
	_oSQL:_sQuery +=   " AND ZA1.ZA1_FILIAL  = '" + xfilial ("ZA1") + "'"
	_oSQL:_sQuery +=   " AND ZA1.ZA1_PROD    = '" + _sProduto + "'"
	_oSQL:_sQuery +=   " AND ZA1.ZA1_D5NSEQ  = '" + _sNumSeq  + "'"
	_oSQL:_sQuery +=   " AND ZA1.ZA1_APONT  != 'I'"  // Se estiver inutilizada, ok
	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
	_sJahTem = _oSQL:RetQry (1, .f.)
	if ! empty (_sJahTem)
		::UltMsg += "Ja existe a etiqueta '" + _sJahTem + "' para este produto/lote. Inutilize-a antes de gerar uma nova."
		u_help (::UltMsg,, .t.)
	else
		_nRegSD5 = _AchaSD5 (_sProduto, _sNumSeq)
		if _nRegSD5 == 0
			::UltMsg += "Nao encontrei registro com origem MAN para o produto/lote/almox/NumSeq informados. Geracao de etiquetas cancelada."
			u_help (::UltMsg,, .t.)
		else
			sd5 -> (dbgoto (_nRegSD5))
			::AlmDest     = sd5 -> d5_local
			::AlmOrig     = sd5 -> d5_local
			::D5_NUMSEQ   = sd5 -> d5_numseq
			::DtEmis      = date ()
			::Filial      = xfilial ("ZA1")
			::LoteProduto = sd5 -> d5_lotectl
			::Produto     = sd5 -> d5_produto
			::Quantidade  = sd5 -> d5_quant
			::ValidLote   = sd5 -> d5_dtvalid
			if ! ::Grava ()
				::UltMsg += "Nao foi possivel gravar a etiqueta."
				u_help (::UltMsg,, .t.)
			endif
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Verifica se pode ser feito apontamento de producao da etiqueta.
METHOD PodeApont (_nQtApont, _nQtPerda) Class ClsEtiq
	Local _aAreaAnt  := U_ML_SRArea ()
	local _lContinua := .T.
	local _nQtTot    := 0
	local _oSQL      := NIL
	local _aSemSaldo := {}
	local _nSemSaldo := 0
	local _sMsgSaldo := ''

	if _lContinua .and. empty (::OP)
		u_help ("Etiq.'" + ::Codigo + "' nao vinculada a nenhuma OP.",, .t.)
		_lContinua = .f.
	endif
	if _lContinua .and. ::Impressa != 'S'
		u_help ("Etiq.'" + ::Codigo + "' ainda nao impressa.",, .t.)
		_lContinua = .f.
	endif
	if _lContinua .and. (::QtApontada + ::QtPerdida) > 0
		u_help ("Etiq.'" + ::Codigo + "' ja gerou apontamento de producao.",, .t.)
		_lContinua = .f.
	endif
	if _lContinua .and. ::QtEstornada > 0
		U_help ("Etiq.'" + ::Codigo + "' ja foi apontada e ESTORNADA. Gere nova etiqueta.",, .t.)
		_lContinua = .F.
	endif
	if _lContinua .and. empty (::CBEmbCol)
		U_help ("Cod.barras p/embalagem coletiva nao informado na OP.",, .t.)
		_lContinua = .F.
	endif
	if _lContinua
		_nQtTot = ::QtApontada + ::QtPerdida + _nQtApont + _nQtPerda
		if _nQtTot != ::Quantidade
			u_help ("Erro etiq.'" + ::Codigo + "':Qt.produzida+perdida (" + cvaltochar (_nQtTot) + ") nao pode ser diferente da quantidade prevista da etiqueta (" + cvaltochar (::Quantidade) + ").",, .t.)
			_lContinua = .F.
		endif
	endif

	// Verifica disponibilidade de saldo dos empenhos.
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " WITH C AS ("
		_oSQL:_sQuery += " SELECT D4_COD"
		_oSQL:_sQuery +=        ",B1_DESC"
	//	_oSQL:_sQuery +=        ",(SUM (D4_QTDEORI) * " + cvaltochar (_nQtApont + _nQtPerda) + ") / C2_QUANT AS QT_A_REQ"
		_oSQL:_sQuery +=        ",CASE WHEN SUM (D4_QUANT) = 0"
		_oSQL:_sQuery +=             " THEN 0"
		_oSQL:_sQuery +=             " ELSE (SUM(D4_QTDEORI) * " + cvaltochar (_nQtApont + _nQtPerda) + ") / C2_QUANT"
		_oSQL:_sQuery +=        " END AS QT_A_REQ"
		_oSQL:_sQuery +=        ",ISNULL (SB2.B2_QATU, 0) AS ESTQ"
		_oSQL:_sQuery +=        ",B1_UM"
		_oSQL:_sQuery +=        ",D4_LOCAL"
		_oSQL:_sQuery += " FROM " + RetSQLName ("SC2") + " SC2"
		_oSQL:_sQuery +=      "," + RetSQLName ("SB1") + " SB1"
		_oSQL:_sQuery +=      "," + RetSQLName ("SD4") + " SD4"
		_oSQL:_sQuery +=     " LEFT JOIN " + RetSQLName ("SB2") + " SB2"
		_oSQL:_sQuery +=          " ON (SB2.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=          " AND SB2.B2_FILIAL  = SD4.D4_FILIAL"
		_oSQL:_sQuery +=          " AND SB2.B2_COD     = SD4.D4_COD"
		_oSQL:_sQuery +=          " AND SB2.B2_LOCAL   = SD4.D4_LOCAL)"
		_oSQL:_sQuery += " WHERE SD4.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SD4.D4_FILIAL  = '" + xfilial ("SD4") + "'"
		_oSQL:_sQuery +=   " AND SD4.D4_OP      = '" + ::OP + "'"
		_oSQL:_sQuery +=   " AND SC2.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SC2.C2_FILIAL  = SD4.D4_FILIAL"
		_oSQL:_sQuery +=   " AND SC2.C2_NUM     = SUBSTRING (SD4.D4_OP, 1, 6)"
		_oSQL:_sQuery +=   " AND SC2.C2_ITEM    = SUBSTRING (SD4.D4_OP, 7, 2)"
		_oSQL:_sQuery +=   " AND SC2.C2_SEQUEN  = SUBSTRING (SD4.D4_OP, 9, 3)"
		_oSQL:_sQuery +=   " AND SC2.C2_ITEMGRD = SUBSTRING (SD4.D4_OP, 12, 2)"
		_oSQL:_sQuery +=   " AND SB1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
		_oSQL:_sQuery +=   " AND SB1.B1_COD     = SD4.D4_COD"
		_oSQL:_sQuery +=   " AND SB1.B1_TIPO    NOT IN ('MO')"
		_oSQL:_sQuery += " GROUP BY D4_COD"
		_oSQL:_sQuery +=       ",D4_LOCAL"
		_oSQL:_sQuery +=       ",SC2.C2_QUANT"
		_oSQL:_sQuery +=       ",SB2.B2_QATU"
		_oSQL:_sQuery +=       ",B1_DESC"
		_oSQL:_sQuery +=       ",B1_UM"
		_oSQL:_sQuery += ")"
		_oSQL:_sQuery += " SELECT *"
		_oSQL:_sQuery +=   " FROM C"
		_oSQL:_sQuery +=  " WHERE QT_A_REQ > ESTQ""
		//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_aSemSaldo := aclone (_oSQL:Qry2Array (.F., .F.))
		//U_Log2 ('debug', _aSemSaldo)
		if len (_aSemSaldo) > 0
			_sMsgSaldo := "Sem saldo:"
			for _nSemSaldo = 1 to len (_aSemSaldo)
				_sMsgSaldo += alltrim (_aSemSaldo [_nSemSaldo, 1]) + '-' + alltrim (_aSemSaldo [_nSemSaldo, 2])
				_sMsgSaldo += ' Qt.necessaria: ' + cvaltochar (_aSemSaldo [_nSemSaldo, 3])
				_sMsgSaldo += ' Qt.disponivel: ' + cvaltochar (_aSemSaldo [_nSemSaldo, 4])
				_sMsgSaldo += ' ' + _aSemSaldo [_nSemSaldo, 5]
				_sMsgSaldo += ' (almox.' + _aSemSaldo [_nSemSaldo, 6] + ')'
				if _nSemSaldo < len (_aSemSaldo)
					_sMsgSaldo += '; '
				endif
			next
			u_help (_sMsgSaldo,, .t.)
			_lContinua = .F.
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Verifica se a etiqueta pode ser enviada para o FullWMS (quando tratar-se de integracao)
METHOD PodeEnvFul () Class ClsEtiq
	local _lContinua := .T.
	Local _aAreaAnt  := U_ML_SRArea ()

	if _lContinua .and. ::AlmDest != '01'
		u_help ("Etiqueta '" + ::Codigo + "' nao deve ser enviada para o FullWMS, pois destina-se ao almox." + ::AlmDest,, .t.)
		_lContinua = .f.
	endif

	if _lContinua .and. left (::Codigo, 1) == '0'
		u_Help ("Impossivel enviar etiqueta '" + ::Codigo + "' para o FullWMS: Etiquetas iniciadas por '0' sao geradas diretamente pelo FullWMS.",, .t.)
		_lContinua = .F.
	endif
	if _lContinua .and. ::Impressa != 'S'
		u_help ("Etiqueta '" + ::Codigo + "' nao deve ser enviada para o FullWMS antes de estar impressa.",, .t.)
		_lContinua = .f.
	endif

	// Se o produto nao pode ser enviado para o FulLWMS, nem adianta enviar a etiqueta.
	if _lContinua
		if ! empty (::OP)
			if _lContinua .and. ::QtEstornada > 0
				U_Log2 ('info', "Etiqueta '" + ::Codigo + "' teve sua quantidade estornada (" + cvaltochar (::QtEstornada) + "), entao nao ha utilidade em envia-la para o FullWMS.",, .t.)
				_lContinua = .F.
			endif
			if _lContinua .and. (::QtApontada + ::QtPerdida) == 0
				U_Log2 ('info', "Etiqueta '" + ::Codigo + "' refere-se a uma OP e, portanto, deve ser enviada somente depois que tiver producao/perda apontada.",, .t.)
				_lContinua = .F.
			endif
		else
			if ! empty (::IdZAG)
				if ::AlmDest == '01' .and. ! U_SB1PEF (::Produto)
					u_log2 ('erro', 'Envio da etiqueta ' + ::Codigo + ' para o FullWMS nao vai ser permitido por que o produto da etiqueta nao encontra-se em condicoes de ser enviado para o FullWMS.')
					_lContinua = .F.
				endif
			endif
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Verifica se pode excluir a etiqueta.
METHOD PodeExcluir (_lComTela) Class ClsEtiq
	local _lContinua := .T.
	Local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _sMsgNaoEx := ''
	local _sLinkSrv  := ""

	if ::QtApontada + ::QtPerdida + ::QtEstornada > 0
		_sMsgNaoEx += "Etiqueta '" + ::Codigo + "' ja foi apontada e/ou estornada. Exclusao nao permitida."
		_lContinua = .F.
	endif
	if ::Inutilizada
		_sMsgNaoEx += "Etiqueta '" + ::Codigo + "' ja foi inutilizada. Exclusao nao permitida."
		_lContinua = .F.
	endif
	if ! empty (::DocEntrNum)
		_sMsgNaoEx += "A etiqueta '" + ::Codigo + "' nao pode ser excluida, pois trata-se de uma etiqueta de nota fiscal (rastreabilidade). Use opcao de 'inutilizar'."
		_lContinua := .F.
	endif

	// Etiqueta nao deve esistir no FullWMS
	if _lContinua
	
		// Busca o caminho do banco de dados do FullWMS
		_sLinkSrv = U_LkServer ('FULLWMS_AX01')
	
		if empty (_sLinkSrv)
			_sMsgNaoEx += "Impossivel verificar existencia da etiqueta '" + ::Codigo + "' no sistema FullWMS. Verifique parametrizacao para que o Protheus acesse o banco de dados do FullWMS."
			_lContinua = .F.
		else
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT CONTAGEM"
			_oSQL:_sQuery += " FROM openquery (" + _sLinkSrv + ","
			_oSQL:_sQuery += " 'select count (*) as CONTAGEM"
			_oSQL:_sQuery +=  " from wms_etiquetas"
			_oSQL:_sQuery += " where wms_etiqueta_id = " + ::Codigo
			_oSQL:_sQuery += " ')"
			_oSQL:Log ('[' + procname () + ']')
			if _oSQL:RetQry (1, .f.) > 0
				_sMsgNaoEx += "Etiqueta '" + ::Codigo + "' encontrada no banco de dados do sistema FullWMS. Verifique (no FullWMS) a tela WF0101 - Consulta de etiquetas de producao."
				_lContinua = .F.
			endif
		endif
	endif

	if ! empty (_sMsgNaoEx)
		if _lComTela
			u_help (_sMsgNaoEx, iif (valtype (_oSQL) == 'O', _oSQL:_sQuery, ''), .t.)
		else
			U_Log2 ('aviso', '[' + procname () + ']' + _sMsgNaoEx)
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Disponibiliza ('envia') a etiqueta para o FullWMS.
METHOD EnviaFull (_lMsg) Class ClsEtiq
	Local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _lContinua := .T.

	_lMsg := iif (_lMsg == NIL, .T., _lMsg)

	if _lContinua
		_lContinua = ::PodeEnvFul ()
	endif

	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "select count (*)"
		_oSQL:_sQuery +=  " from tb_wms_etiquetas"
		_oSQL:_sQuery += " where id = '" + cvaltochar (::Codigo) + "'"
		//_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		if _oSQL:RetQry () > 0
			if _lMsg
				u_help ("Impossivel enviar etiqueta '" + ::Codigo + "' para o FullWMS: Etiqueta jah existe na tabela tb_wms_etiquetas.", _oSQL:_sQuery, .t.)
			else
				U_Log2 ('aviso', '[' + procname () + "]Impossivel enviar etiqueta '" + ::Codigo + "' para o FullWMS: Etiqueta jah existe na tabela tb_wms_etiquetas.")
			endif
			_lContinua = .F.
		endif
	endif

	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " insert into tb_wms_etiquetas (id, coditem, lote, qtde, validade, empresa, cd, status)"
		_oSQL:_sQuery += " values (" + cvaltochar (::Codigo) + ","
		_oSQL:_sQuery +=          "'" + alltrim (::Produto) + "',"
		_oSQL:_sQuery +=          "'" + ::LoteProduto + "',"
		_oSQL:_sQuery +=          cvaltochar (::Quantidade) + ","
		_oSQL:_sQuery +=          "'" + dtos (::ValidLote) + "',"
		_oSQL:_sQuery +=          "'01',"
		_oSQL:_sQuery +=          "'" + ::Filial + "',"
		_oSQL:_sQuery +=          "'N')"  // N=ainda nao lida pelo Full
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		if ! _oSQL:Exec ()
			U_help ("Erro ao enviar etiqueta para FullWMS: " + _oSQL:_sQuery,, .t.)
			_lRetEnv = .F.
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Exclusao da etiqueta.
METHOD Exclui () Class ClsEtiq
	Local _aAreaAnt  := U_ML_SRArea ()
	local _lContinua := .T.

	if _lContinua

		// Se a chamada for feita para um registro jah deletado, eh por que a
		// exclusao deve estar sendo feita pela tela de manutencao (usuario)
		// e o registro do SZI jah foi deletado pela funcao AxDeleta().
		// Faltaria, no caso, fazer as exclusoes de dados relacionados.
		if ! za1 -> (deleted ())
			U_Log2 ('debug', '[' + procname () + ']Deletando registro no ZA1')
			reclock ("ZA1", .F.)
			za1 -> (dbdelete ())
			msunlock ()
		else
			U_Log2 ('debug', '[' + procname () + ']Registro jah encontra-se deletado no ZA1')
		endif

		// Verifica necessidade de enviar algum dado para FullWMS.
		_AtuFull (::Codigo, 'E')
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Envia para impressora (ou porta relacionada a esta)
METHOD Imprime (_sCodImpr) Class ClsEtiq
	local _lContinua := .T.
	_lContinua = U_ImpZA1 (::Codigo, _sCodImpr, ::Self)
return _lContinua


// --------------------------------------------------------------------------
// Inutiliza a etiqueta.
METHOD Inutiliza (_lMsg) Class ClsEtiq
	local _lContinua := .T.
	local _oEvento   := NIL
	local _oSQL      := NIL
	local _aAreaAnt  := U_ML_SRArea ()

	_lMsg := iif (_lMsg == NIL, .F., _lMsg)
	if _lContinua .and. (::Inutilizada)
		::UltMsg += "A etiqueta '" + ::Codigo + "' ja encontra-se inutilizada."
		_lContinua := .F.
	endif

	// Verifica se o usuario tem liberacao.
	if ! empty (::OP) .and. ! U_ZZUVL ('073', __cUserID, .T.)
		::UltMsg += "Usuario sem acesso para initilizar etiquetas de OP."
		_lContinua = .F.
	endif
	if ! empty (::DocEntrNum) .and. ! U_ZZUVL ('074', __cUserID, .T.)
		::UltMsg += "Usuario sem acesso para inutilizar etiquetas de NF."
		_lContinua = .F.
	endif
	if _lContinua .and. ! empty (::OP)
		::UltMsg := "A etiqueta '" + ::Codigo + "' nao pode ser inutilizada por ser uma etiqueta de ordem de producao."
		_lContinua := .F.
	endif


	// Se foi gerada por solicitacao de transf.estoque, vou ver do que se trata.
	if _lContinua .and. ! empty (::IdZAG) .and. ::AlmDest == '01'
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " select status_protheus"
		_oSQL:_sQuery +=   " from tb_wms_entrada"
		_oSQL:_sQuery +=  " where entrada_id = 'ZA1" + ::Filial + ::Codigo + "'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_sStatWMS = _oSQL:RetQry (1, .F.)
		if ! empty (_sStatWMS) .and. ! _sStatWMS $ 'C'
			::UltMsg += "A etiqueta '" + ::Codigo + "' ja foi enviada para o FullWMS"
			::UltMsg += " e nao pode ser inutilizada por que encontra-se com status '" + _sStatWMS + "'"
			::UltMsg += " na tabela de integracao tb_wms_entrada."
			::UltMsg += "Essa entrada deve ser excluida, antes, no FullWMS"
			::UltMsg += "(ou sua 'guarda' deve ser cancelada manualmente nesta tabela)"
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. _lMsg
		_lContinua = U_MsgNoYes ("Confirma a inutilização da etiqueta?")
	endif
		
	if _lContinua
		za1 -> (dbgoto (::RegZA1))
		begin transaction
			reclock ("ZA1", .f.)
			za1 -> za1_apont = 'I'
			msunlock ()

			// Grava evento para posterior rastreamento
			_oEvento := ClsEvent():new ()
			_oEvento:CodEven   = "ZA1002"
			_oEvento:Texto     = "Inutilizacao etiqueta " + ::Codigo
			_oEvento:Recno     = ::RegZA1
			_oEvento:Alias     = 'ZA1'
			_oEvento:CodAlias  = ::Codigo
			_oEvento:Etiqueta  = ::Codigo
			_oEvento:Produto   = ::Produto
			_oEvento:OP        = ::OP
			_oEvento:NFEntrada = ::DocEntrNum
			_oEvento:SerieEntr = ::DocEntrSerie
			_oEvento:Fornece   = ::DocEntrForn
			_oEvento:LojaFor   = ::DocEntrLoja
			_oEvento:Grava ()
		end transaction
		::Inutilizada = .T.

		::UltMsg += "Etiqueta '" + ::Codigo + "' inutilizada (Remover do Recipiente)"
		if _lMsg
			u_help (::UltMsg)
		endif
	else
		u_help (::UltMsg)
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
METHOD ValCBEmb () Class ClsEtiq
	local _lRetVCBE := .T.

	if _sCBEmbCol != _oEtiq:CBEmbCol
		::UltMsg += "Barras embalagem coletiva nao conferem com campo C2_VABARCX da OP."
		_lRetVCBE = .F.
	endif
return _lRetVCBE


// --------------------------------------------------------------------------
// Atualiza dados para integracao com Fullsoft.
static function _AtuFull (_sEtiq, _sQueFazer)
	local _oSQL      := NIL

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	if _sQueFazer == 'E'
		_oSQL:_sQuery += " delete tb_wms_etiquetas"
		_oSQL:_sQuery += " where id = " + cvaltochar (_sEtiq)
		_oSQL:Exec ()
	endif
return


// --------------------------------------------------------------------------
// Localiza registro na tabela SD5, para alimentar dados de nova etiqueta.
static function _AchaSD5 (_sProduto, _sNumSeq)
	local _oSQL    := NIL
	local _nRetSD5 := 0

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += "SELECT TOP 1 R_E_C_N_O_"  // Nao espero encontrar mais de 1, mas, para garantir...
	_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD5") + " SD5"
	_oSQL:_sQuery += " WHERE SD5.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=   " AND SD5.D5_FILIAL  = '" + xfilial ("SD5") + "'"
	_oSQL:_sQuery +=   " AND SD5.D5_PRODUTO = '" + _sProduto + "'"
	//_oSQL:_sQuery +=   " AND SD5.D5_LOTECTL = '" + _sLote    + "'"
	//_oSQL:_sQuery +=   " AND SD5.D5_LOCAL   = '" + _sAlmox   + "'"
	_oSQL:_sQuery +=   " AND SD5.D5_NUMSEQ  = '" + _sNumSeq  + "'"
	_oSQL:_sQuery +=   " AND SD5.D5_ORIGLAN = 'MAN'"  // Soh vou aceitar (por enqto) lotes criados manualmente.
	_oSQL:_sQuery += " ORDER BY SD5.D5_DATA, SD5.D5_NUMSEQ"
	_oSQL:Log ('[' + procname () + ']')
	_nRetSD5 = _oSQL:RetQry (1, .f.)
return _nRetSD5
