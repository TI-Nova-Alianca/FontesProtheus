// Programa:  ClsTbUva
// Autor:     Robert Koch
// Data:      22/05/2023 (inicio)
// Descricao: Declaracao de classe de representacao de tabelas de preco de uvas para safra.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa tabelas de precos de uvas para compra de safra.
// #PalavasChave      #safra #uva #tabela_preco
// #TabelasPrincipais #ZX5 SB1
// #Modulos           #COOP

// Historico de alteracoes:
// 12/11/2023 - Robert - Gravacao de agios em array interna e inicio de definicao de formulas para calculo de precos.
//

#Include "Protheus.ch"
#include "VA_INCLU.prw"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsTbUva ()
return


// ==========================================================================
CLASS ClsTbUva from ClsBase

	// Declaracao das propriedades da Classe
	private data AgiosGraus  // Array contendo os agios a serem aplicados a partir do grau base
	public  data CodTabela   // Pode existir mais de uma tabela para cada safra (simulacoes, etc)
	public  data Conducao    // [E]spaldeira, [L]atada
	public  data GrauDecimal // [D]ecimais, [I]nteiros
	private data GrauIniTab  // Grau inicial a ser gerado
	private data GrauFimTab  // Grau final a ser gerado
	private data Grupos     // Grupos de uvas cfe. tabela 13 do ZX5
	public  data SubGrupos   // Subgrupos de uvas cfe. tabela 13 do ZX5
	public  data TipoPreco   // [E]ntrada, [C]ompra, [M]oc(CONAB)
	public  data TipoUva     // [C]omum, [F]ina
	public  data UltMsg      // Mensagens (geralmente de erro)

	// Declaracao dos Metodos da classe
	public  METHOD New ()
	private METHOD DefPAgio ()
	private METHOD DistrAgios ()
	public  METHOD GeraAtrib ()
	public  METHOD GeraHTM ()
	public  METHOD GeraPrecos ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor.
METHOD New () Class ClsTbUva

	// Valores default
	::CodTabela   = ''
	::Conducao    = ''
	::GrauDecimal = ''
	::Grupos     = JsonObject():New()
	::SubGrupos   = {}
	::TipoPreco   = ''
	::TipoUva     = ''
	::UltMsg      = ''

	// Aumentar ou diminuir aqui a faixa de graus se necessario.
	// Uso essa faixa tem uns 10 anos e nao me faltou nada ainda...
	::GrauIniTab  = 6
	::GrauFimTab  = 26
Return ::self


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sCodTab, _sTipoPrc, _sTipoUva, _sConduc, _sGrauDec) Class ClsTbUva
	local _lContinua := .T.
	local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _aDados    := {}
	local _nDado     := 0
	local _sAliasQ   := ''
	local _nStepGrau := 0
	local _nGrau     := 0
	local _nPreco    := 0
	local _aGrausComAgio := {}
	local _aGrausDoGrupo := {}
	local _oGrauDeGrupo := NIL  // Pensando na impressao da tabela, seriam os dados de uma 'celula' (determinado grau de determinado grupo)
	local _oGrupoTbUva  := NIL
	local _aGrupos  := {}
	local _aListaDeGraus := {}

	if empty (_sCodTab)
		_Super:SomaMsg ("Codigo da tabela deve ser informado.")
		_lContinua = .F.
	else
		::CodTabela   = _sCodTab
	endif
	if empty (_sConduc)
		_Super:SomaMsg ("Sistema de conducao latada (L) ou espaldeira (E) deve ser informado.")
		_lContinua = .F.
	else
		::Conducao    = _sConduc
	endif
	if empty (_sGrauDec)
		_Super:SomaMsg ("Opcao para gerar graus decimais (D) ou inteiros (I) deve ser informada.")
		_lContinua = .F.
	else
		::GrauDecimal = _sGrauDec
		_nStepGrau = iif (::GrauDecimal == 'D', 0.1, 1)
	endif
	if empty (_sTipoPrc)
		_Super:SomaMsg ("Tipo de preco (C=compra; M=MOC) deve ser informada.")
		_lContinua = .F.
	else
		::TipoPreco   = _sTipoPrc
	endif
	if empty (_sTipoUva)
		_Super:SomaMsg ("Tipo de uva (C=comum;V=vinifera) deve ser informado.")
		_lContinua = .F.
	else
		::TipoUva     = _sTipoUva
	endif

	// Gera uma lista de grupos relacionados ao tipo de uvas solicitado.
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT ZX5_13SAFR, ZX5_13GRUP, ZX5_13DESC, ZX5_13GBAS, ZX5_13GMAG, ZX5_13PMIN"
		if ::TipoPreco == 'C'
			_oSQL:_sQuery += ", ZX5_13PBCO"
		else
			_oSQL:_sQuery += ", 0 as preco"  // Ainda tenho que ver de onde pegar
		endif
		_oSQL:_sQuery += ", ZX5_13AEPR, ZX5_13AEAA, ZX5_13AEA, ZX5_13AEB, ZX5_13AEC, ZX5_13AED, ZX5_13AEDS"  // Acrescimos cfe classificacao espaldeira
		_oSQL:_sQuery += ", ZX5_13ALA, ZX5_13ALB, ZX5_13ALD, ZX5_13ALDS"  // Acrescimos cfe classificacao latada
		_oSQL:_sQuery += ", ZX5_13PAOB, ZX5_13PAOE, ZX5_13PAOO"  // Acrescimos cfe bordadura/em conversao/organica
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5_13 "
		_oSQL:_sQuery += " WHERE ZX5_13.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_TABELA = '13'"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_13SAFR = '" + ::CodTabela + "'"
		_oSQL:_sQuery +=   " AND LEN (ZX5_13.ZX5_13GRUP) >= 3"  // Nao quero listar os 'grandes grupos'
		if ::TipoUva == 'C'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '1%'"  // Lista comuns
		elseif ::TipoUva == 'F' .and. ::Conducao == 'E'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '2%'"  // Lista finas espaldeira
		elseif ::TipoUva == 'F' .and. ::Conducao == 'L'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '3%'"  // Lista finas latadas
		else
			_Super:SomaMsg ("Sem tratamento para tipo de uva '" + ::TipoUva + "'.")
			_lContinua = .F.
		endif

		// Quero ignorar grupos que existem na tabela 13, mas que nao tenham
		// nenhuma variedade ligada a eles pela tabela 14.
		_oSQL:_sQuery += " AND EXISTS (SELECT *"
		_oSQL:_sQuery +=               " FROM " + RetSQLName ("ZX5") + " ZX5_14 "
		_oSQL:_sQuery +=              " WHERE ZX5_14.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_TABELA = '14'"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_14SAFR =  ZX5_13.ZX5_13SAFR"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_14GRUP =  ZX5_13.ZX5_13GRUP"
		_oSQL:_sQuery +=             ")"

		_oSQL:_sQuery += " ORDER BY ZX5_13GRUP"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		if len (_aDados) == 0
			_Super:SomaMsg ("Tabela de precos '" + ::CodTabela + "' nao existe, ou nao tem nenhum grupo de variedades informado.")
			_lContinua = .F.
		endif
	endif
	
	// Gera grupos de variedades
	if _lContinua
		_aGrupos = {}
		for _nDado = 1 to len (_aDados)

			// Pretendo migrar o formato array para formato JSON, mas tenho que
			// fazer isso com cuidado para nao me perder. Entao trabalharei com
			// os 2 formatos em paralelo por enquanto. Depois de ter tudo em JSON
			// pretendo eliminar a parte em array.
			_oGrupoTbUva = JsonObject():New()
			_oGrupoTbUva ['Codigo']                    = _aDados [_nDado, 2]
			_oGrupoTbUva ['Descricao']                 = _aDados [_nDado, 3]
			_oGrupoTbUva ['GrauBase']                  = _aDados [_nDado, 4]
			_oGrupoTbUva ['GrauMinimoParaAgio']        = _aDados [_nDado, 5]
			_oGrupoTbUva ['PrecoMinimo']               = _aDados [_nDado, 6]
			_oGrupoTbUva ['PrecoGrauBase']             = _aDados [_nDado, 7]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasPR'] = _aDados [_nDado, 8]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasAA'] = _aDados [_nDado, 9]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasA']  = _aDados [_nDado, 10]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasB']  = _aDados [_nDado, 11]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasC']  = _aDados [_nDado, 12]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasD']  = _aDados [_nDado, 13]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasDS'] = _aDados [_nDado, 14]
			_oGrupoTbUva ['AcrescimoLatadaClasA']      = _aDados [_nDado, 15]
			_oGrupoTbUva ['AcrescimoLatadaClasB']      = _aDados [_nDado, 16]
			_oGrupoTbUva ['AcrescimoLatadaClasD']      = _aDados [_nDado, 17]
			_oGrupoTbUva ['AcrescimoLatadaClasDS']     = _aDados [_nDado, 18]
			_oGrupoTbUva ['AgioOrganicaBordadura']     = _aDados [_nDado, 19]
			_oGrupoTbUva ['AgioOrganicaEmConversao']   = _aDados [_nDado, 20]
			_oGrupoTbUva ['AgioOrganicaOrganica']      = _aDados [_nDado, 21]
			_oGrupoTbUva ['ListaDeSubgrupos']          = {}
			_oGrupoTbUva ['ListaDeVariedades']         = {}
			_oGrupoTbUva ['ListaDeGraus']              = {}

			// Cria uma lista com as variedades de uvas deste grupo.
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT V.*"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5_14 "
			_oSQL:_sQuery +=      ", VA_VFAMILIAS_UVAS V "
			_oSQL:_sQuery += " WHERE ZX5_14.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_TABELA = '14'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14SAFR = '" + ::CodTabela + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + _aDados [_nDado, 2] + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14PROD = V.COD_BASE"
			_oSQL:_sQuery += " ORDER BY V.DESCR_BASE, V.COD_BASE"
			_sAliasQ := _oSQL:Qry2Trb (.F.)
			(_sAliasQ) -> (dbgotop ())
			do while ! (_sAliasQ) -> (eof ())
				_oVariedade := JsonObject():New()
				_oVariedade ['CodBase']            = (_sAliasQ) -> cod_base
				_oVariedade ['DescrBase']          = alltrim ((_sAliasQ) -> desc_resum)
				_oVariedade ['CodEmConversao']     = (_sAliasQ) -> cod_em_conversao
				_oVariedade ['DescrEmConversao']   = alltrim ((_sAliasQ) -> desc_resum_em_conversao)
				_oVariedade ['CodBordadura']       = (_sAliasQ) -> cod_bordadura
				_oVariedade ['DescrBordadura']     = alltrim ((_sAliasQ) -> desc_resum_bordadura)
				_oVariedade ['CodOrganica']        = (_sAliasQ) -> cod_organica
				_oVariedade ['DescrOrganica']      = alltrim ((_sAliasQ) -> desc_resum_organica)
				_oVariedade ['CodFinaClas_comum']  = (_sAliasQ) -> cod_fina_clas_comum
				_oVariedade ['DescrFinaClasComum'] = alltrim ((_sAliasQ) -> desc_resum_fina_clas_comum)
				_oVariedade ['CodParaEspumante']   = (_sAliasQ) -> cod_para_espumante
				_oVariedade ['DescrParaEspumante'] = alltrim ((_sAliasQ) -> desc_resum_para_espumante)
				_oVariedade ['FinaOuComum']        = (_sAliasQ) -> fina_comum
				_oVariedade ['Cor']                = (_sAliasQ) -> cor
				_oVariedade ['Tintorea']           = (_sAliasQ) -> tintorea
				aadd (_oGrupoTbUva ['ListaDeVariedades'], _oVariedade)
				(_sAliasQ) -> (dbskip ())
			enddo
			(_sAliasQ) -> (dbclosearea ())
			dbselectarea ("SB1")

			// Gera lista de graus e respectivos % de agio sobre o grau base.
			_aGrausDoGrupo = {}
			_aGrausComAgio = {}
			for _nGrau = ::GrauIniTab to ::GrauFimTab step _nStepGrau
				aadd (_aGrausComAgio, {_nGrau, 0})
			next

			// Define o % de agio (a ser aplicado sobre o grau base) para cada grau.
			_lContinua = ::DistrAgios (@_aGrausComAgio, _oGrupoTbUva ['GrauBase'])

			// Para cada grau, calcula seus precos e transforma-o em objeto.
			if _lContinua
				_aListaDeGraus = {}
				for _nGrau = 1 to len (_aGrausComAgio)

					// Abaixo de determinado grau, usa preco minimo.
					if _aGrausComAgio [_nGrau, 1] < _oGrupoTbUva ['GrauMinimoParaAgio']
						_nPreco = _oGrupoTbUva ['PrecoMinimo']
					else
						// Se for um grau 'normal', aplica regra de agio sobre o preco do grau base.
						_nPreco = _oGrupoTbUva ['PrecoGrauBase']
						_nPreco += _nPreco * _aGrausComAgio [_nGrau, 2] / 100
					endif

					_oGrauDeGrupo := JsonObject():New()
					_oGrauDeGrupo ['Grau']                = _aGrausComAgio [_nGrau, 1]
					_oGrauDeGrupo ['AgioSobreGrauBase']   = _aGrausComAgio [_nGrau, 2]
					_oGrauDeGrupo ['PrecoCodBase']        = _nPreco
					_oGrauDeGrupo ['PrecoCodOrganicaBordadura']   = _nPreco * (1 + _oGrupoTbUva ['AgioOrganicaBordadura']   / 100)
					_oGrauDeGrupo ['PrecoCodOrganicaEmConversao'] = _nPreco * (1 + _oGrupoTbUva ['AgioOrganicaEmConversao'] / 100)
					_oGrauDeGrupo ['PrecoCodOrganicaOrganica']    = _nPreco * (1 + _oGrupoTbUva ['AgioOrganicaOrganica']    / 100)

					// Alimenta array com um objeto representando dados de cada grau deste grupo
					aadd (_oGrupoTbUva ['ListaDeGraus'], _oGrauDeGrupo)
				next
			endif


			// Conforme o tipo de uva, pode haver diferentes subgrupos.
			// Uvas comuns: 4 subcolunas (convenc/bordadura/em conv/organ)
			if ::TipoUva == 'C'
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : 'Convencional', 'ObsSubgrupo' : '' })
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : 'Bordadura'   , 'ObsSubgrupo' : '+' + cvaltochar (_oGrupoTbUva ['AgioOrganicaBordadura']   ) + '%' })
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : 'Em conversão', 'ObsSubgrupo' : '+' + cvaltochar (_oGrupoTbUva ['AgioOrganicaEmConversao'] ) + '%' })
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : 'Orgânica'    , 'ObsSubgrupo' : '+' + cvaltochar (_oGrupoTbUva ['AgioOrganicaOrganica']    ) + '%' })
			elseif ::TipoUva == 'F' .and. ::Conducao == 'E'
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : '' , 'ObsSubgrupo' : 'falta fazer' })
			elseif ::TipoUva == 'F' .and. ::Conducao == 'L'
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : '' , 'ObsSubgrupo' : 'falta fazer' })
			endif

			// Pretendo migrar o formato array para formato JSON, mas tenho que
			// fazer isso com cuidado para nao me perder. Entao trabalharei com
			// os 2 formatos em paralelo por enquanto. Depois de ter tudo em JSON
			// pretendo eliminar a parte em array.
			aadd (_aGrupos, _oGrupoTbUva)
		next

		::Grupos:Set (_aGrupos)

		// Durante o desenvolvimento, achei interessante esportar o JSON
		// para arquivo, onde posso visualizar mais facilmente.
		_sArq := 'c:\temp\teste.json'
		if file (_sArq)
			delete file (_sArq)
		endif
		_nHdl = fcreate (_sArq, 0)
		fwrite (_nHdl, ::Grupos:ToJSON ())
		fclose (_nHdl)

	endif

	// Se deu algum problema, limpa os dados principais para inutilizar o objeto.
	if ! _lContinua
		::CodTabela = ''
		::Grupos   = NIL
	endif

	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Define os percentuais de agio entre os graus (% acrescido ou diminuido
// a partir do grau base cfe. muda o grau).
// Optei por usar uma funcao separada por que, em varios anos que estou
// aqui, vi isso mudar muito poucas vezes e nao vale a pena copiar ano a ano.
METHOD DefPAgio (_nEsteGrau as numeric, _nGrauBase as numeric) Class ClsTbUva
	local _nRetAgio := NIL  // Deixar NIL para poder testar mais tarde se deu erro.

	// As variacoes de agio da Alianca costumam ser diferentes da MOC
	if ::TipoPreco == 'C'  // Compra: usar nossos agios
		do case
		case _nEsteGrau == _nGrauBase -12 ; _nRetAgio = -165
		case _nEsteGrau == _nGrauBase -11 ; _nRetAgio = -150
		case _nEsteGrau == _nGrauBase -10 ; _nRetAgio = -135
		case _nEsteGrau == _nGrauBase -9  ; _nRetAgio = -120
		case _nEsteGrau == _nGrauBase -8  ; _nRetAgio = -105
		case _nEsteGrau == _nGrauBase -7  ; _nRetAgio = -90
		case _nEsteGrau == _nGrauBase -6  ; _nRetAgio = -75
		case _nEsteGrau == _nGrauBase -5  ; _nRetAgio = -60
		case _nEsteGrau == _nGrauBase -4  ; _nRetAgio = -45
		case _nEsteGrau == _nGrauBase -3  ; _nRetAgio = -30
		case _nEsteGrau == _nGrauBase -2  ; _nRetAgio = -15
		case _nEsteGrau == _nGrauBase -1  ; _nRetAgio = -5
		case _nEsteGrau == _nGrauBase +0  ; _nRetAgio = 0
		case _nEsteGrau == _nGrauBase +1  ; _nRetAgio = 5
		case _nEsteGrau == _nGrauBase +2  ; _nRetAgio = 15
		case _nEsteGrau == _nGrauBase +3  ; _nRetAgio = 25
		case _nEsteGrau == _nGrauBase +4  ; _nRetAgio = 35
		case _nEsteGrau == _nGrauBase +5  ; _nRetAgio = 45
		case _nEsteGrau == _nGrauBase +6  ; _nRetAgio = 55
		case _nEsteGrau == _nGrauBase +7  ; _nRetAgio = 65
		case _nEsteGrau == _nGrauBase +8  ; _nRetAgio = 75
		case _nEsteGrau == _nGrauBase +9  ; _nRetAgio = 85
		case _nEsteGrau == _nGrauBase +10 ; _nRetAgio = 95
		case _nEsteGrau == _nGrauBase +11 ; _nRetAgio = 105
		case _nEsteGrau == _nGrauBase +12 ; _nRetAgio = 115
		case _nEsteGrau == _nGrauBase +13 ; _nRetAgio = 125
		case _nEsteGrau == _nGrauBase +14 ; _nRetAgio = 135
		case _nEsteGrau == _nGrauBase +15 ; _nRetAgio = 145
		case _nEsteGrau == _nGrauBase +16 ; _nRetAgio = 155  // Se surgirem novos graus, acrescentar aqui.
		endcase
	elseif ::TipoPreco == 'M'  // MOC: usar agios cfe. MOC publicado a cada safra.
		do case
		case _nEsteGrau == _nGrauBase -12 ; _nRetAgio = -100  // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -11 ; _nRetAgio = -95   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -10 ; _nRetAgio = -90   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -9  ; _nRetAgio = -85   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -8  ; _nRetAgio = -80   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -7  ; _nRetAgio = -70   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -6  ; _nRetAgio = -60   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -5  ; _nRetAgio = -55   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -4  ; _nRetAgio = -50   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -3  ; _nRetAgio = -30
		case _nEsteGrau == _nGrauBase -2  ; _nRetAgio = -15
		case _nEsteGrau == _nGrauBase -1  ; _nRetAgio = -5
		case _nEsteGrau == _nGrauBase -0  ; _nRetAgio = 0
		case _nEsteGrau == _nGrauBase +1  ; _nRetAgio = 5
		case _nEsteGrau == _nGrauBase +2  ; _nRetAgio = 15
		case _nEsteGrau == _nGrauBase +3  ; _nRetAgio = 25
		case _nEsteGrau == _nGrauBase +4  ; _nRetAgio = 35
		case _nEsteGrau == _nGrauBase +5  ; _nRetAgio = 45
		case _nEsteGrau == _nGrauBase +6  ; _nRetAgio = 55
		case _nEsteGrau == _nGrauBase +7  ; _nRetAgio = 65
		case _nEsteGrau == _nGrauBase +8  ; _nRetAgio = 75
		case _nEsteGrau == _nGrauBase +9  ; _nRetAgio = 85
		case _nEsteGrau == _nGrauBase +10 ; _nRetAgio = 95
		case _nEsteGrau == _nGrauBase +11 ; _nRetAgio = 105  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase +12 ; _nRetAgio = 115  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase +13 ; _nRetAgio = 125  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase +14 ; _nRetAgio = 135  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		endcase
	else
		_Super:SomaMsg ("Sem definicao de agio entre graus para tipo de precos '" + ::TipoPreco + "'.")
	endif
return _nRetAgio


// --------------------------------------------------------------------------
// Distribui os percentuais de agio entre os graus. Basicamente, parte-se de
// um preco determinado no grau base e aumenta-se o % de agio conforme o grau
// vai se distanciando do grau base (desconta mais valor para graus menores
// que o grau base, e acrescenta valor aos graus maiores).
METHOD DistrAgios (_aGraus as array, _nGrauBase as numeric) Class ClsTbUva
	local _lContinua := .T.
	local _nAuxGrau  := 0
	local _nPosGrInt := 0
	local _nAgioAnt  := 0
	local _nAgioPos  := 0
	local _nEsteGrau := 0

	// Grava os agios entre graus inteiros.
	_nAuxGrau = 1
	do while _lContinua .and. _nAuxGrau <= len (_aGraus)
		_nEsteGrau = _aGraus [_nAuxGrau, 1]
		if _IsInt (_nEsteGrau)
			_aGraus [_nAuxGrau, 2] = ::DefPAgio (_nEsteGrau, _nGrauBase)
			if _aGraus [_nAuxGrau, 2] == NIL
				_Super:SomaMsg ("Sem definicao de agio para grau inteiro " + cvaltochar (_aGraus [_nAuxGrau, 1]))
				_lContinua = .F.
			endif
		endif
		_nAuxGrau ++
	enddo

	// Tendo os agios entre graus inteiros, vou calcular para os graus decimais (se existirem).
	_nAuxGrau = 1
	do while _lContinua .and. _nAuxGrau <= len (_aGraus)
		_nEsteGrau = _aGraus [_nAuxGrau, 1]
		if ! _IsInt (_nEsteGrau)  // Para os inteiros, jah tenho.

			// Encontra o agio do 'grau inteiro' anterior
			_nPosGrInt = _nAuxGrau
			do while _nPosGrInt > 0 .and. ! _IsInt (_aGraus [_nPosGrInt, 1])
				_nPosGrInt --
			enddo
			if _nPosGrInt > 0
				_nAgioAnt = _aGraus [_nPosGrInt, 2]  // Agora tenho o % de agio do grau inteiro anterior
			else
				_Super:SomaMsg ("Nao consegui encontrar grau inteiro menor para ler seu agio e calcular decimais.")
				_lContinua = .F.
			endif

			// Encontra o agio do 'grau inteiro' posterior
			_nPosGrInt = _nAuxGrau
			do while _nPosGrInt <= len (_aGraus) .and. ! _IsInt (_aGraus [_nPosGrInt, 1])
				_nPosGrInt ++
			enddo
			if _nPosGrInt <= len (_aGraus)
				_nAgioPos = _aGraus [_nPosGrInt, 2]  // Agora tenho o % de agio do grau inteiro posterior
			else
				_Super:SomaMsg ("Nao consegui encontrar grau inteiro maior para ler seu agio e calcular decimais.")
				_lContinua = .F.
			endif

			// Sabendo o agio inteiro anterior e o posterior, posso
			// calcular o agio para o grau decimal atual.
			_aGraus [_nAuxGrau, 2] = _nAgioAnt - (_nAgioAnt - _nAgioPos) * (_nEsteGrau - int (_nEsteGrau))

		endif
		_nAuxGrau ++
	enddo
return _lContinua


// --------------------------------------------------------------------------
// Gera tabela em formato HTML
METHOD GeraHTM () Class ClsTbUva
	local _sHTM       := ''
	local _nGrupo     := 0
//	local _aSubgrup   := {}
	local _nSubgrup   := 0
	local _aTitGrup   := {}
	local _aVarGrau   := {}
	local _nVarGrau   := 0
	local _aLinha     := {}
	local _lAdicionou := .F.
	local _sTag       := ''
	local _sTagICod   := ''
	local _sTagFCod   := ''
	local _nGrau      := 0
	local _sToolTip   := ''
	local _oGrauDeGrupo := NIL

	// Como a quantidade de celulas mescladas eh muito grande, achei melhor
	// preparar arrays com os dados (jah eh bastante complicado) e, num
	// passo seguinte, gerar HTML.

	// Passo 1: preparar arrays de dados para o HTML
	if empty (::CodTabela)
		_Super:SomaMsg ("Codigo de tabela nao definido. Impossivel gerar HTML.")
	else

//		// Uvas comuns: 4 subcolunas (convenc/bordadura/em conv/organ)
//		// Uvas viniferas em espaldeira: 2 subcolunas (para vinho/para espumante)
//		// Uvas viniferas latadas: nenhuma subcoluna
//		if ::TipoUva == 'C'
//			_aSubgrup = {'Convencional', 'Bordadura', 'Em conversão', 'Orgânica'}
//		elseif ::TipoUva == 'F' .and. ::Conducao == 'E'
//			_aSubGrup = {'Para vinho', 'Para espumante'}
//		else
//			_aSubGrup = {''}
//		endif

		// Prepara titulos dos grupos
		_aTitGrup = {}
		aadd (_aTitGrup, '<th> </th>')  // Esta coluna vai ser, posteriormente, usada para o grau.
		for _nGrupo = 1 to len (::Grupos)
			aadd (_aTitGrup, '<th class=' + iif (_nGrupo / 2 == int (_nGrupo / 2), '"TituloGrupoClaro"', '"TituloGrupoEscuro"') + ;
			                 ' colspan=' + cvaltochar (len (::Grupos [_nGrupo]['ListaDeSubgrupos'])) + ' align=center>' + ;
			                 'Grp.' + alltrim (::Grupos [_nGrupo]['Codigo']) + ;
			                 ' ' + alltrim (::Grupos [_nGrupo]['Descricao']) + ;
			                 '</th>')
		next

		// Prepara uma linha com titulos dos subgrupos
		_aVarGrau = {}
		_aLinha = {'<th class="TituloGrupoClaro">Grau</th>'}
		for _nGrupo = 1 to len (::Grupos)

			// Para facilitar a visualizacao, a cada troca de grupo, gero
			// as colunas com fundo escuro ou com fundo claro.
			if _nGrupo / 2 == int (_nGrupo / 2)
				_sTag = '<th class="TituloGrupoClaro">'
			else
				_sTag = '<th class="TituloGrupoEscuro">'
			endif

			for _nSubgrup = 1 to len (::Grupos [_nGrupo]['ListaDeSubgrupos'])
				aadd (_aLinha, _sTag + ::Grupos [_nGrupo]['ListaDeSubgrupos'][_nSubgrup]['DescSubgrupo'] + '</th>')
			next
		next
		aadd (_aVarGrau, aclone (_aLinha))

		// Para adicionar as linhas com as variedades, optei por fazer um loop
		// com WHILE para rodar ateh o momento em que nao adicionar mais nenhuma
		// linha (cada grupo tem uma quantidade diferente de variedades).
		_nVarGrau = 1
		do while .t.
			_aLinha = {'<td> </td>'}  // Primeira coluna vai ser usada pelo grau
			_lAdicionou = .F.

			// Para cada grupo, verifica se ainda tem variedades a adicionar
			for _nGrupo = 1 to len (::Grupos)

				// Para facilitar a visualizacao, a cada troca de grupo, gero
				// as colunas com fundo escuro ou com fundo claro.
				if _nGrupo / 2 == int (_nGrupo / 2)
					_sTag = '<td class="ColunaClaraDescri">'

					// Quero mostrar o codigo do item com uma fonte um pouco menor.
					_sTagICod = '<span class="ColunaClaraCodigo">('
					_sTagFCod = ')</span>'
				else
					_sTag = '<td class="ColunaEscuraDescri">'

					// Quero mostrar o codigo do item com uma fonte um pouco menor.
					_sTagICod = '<span class="ColunaEscuraCodigo">('
					_sTagFCod = ')</span>'
				endif

				// Se ainda tiver variedades neste grupo para serem adicionadas
				// ao HTM, entao devo gerar mais uma linha.
				if _nVarGrau <= len (::Grupos [_nGrupo]['ListaDeVariedades'])

					// Variedade base sempre deve existir, independente de tipo/conducao
					if ! empty (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['CodBase'])
						aadd (_aLinha, _sTag + ;
										alltrim (strtran (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['DescrBase'], '.', ' ')) + ;
										_sTagICod + ;
										alltrim (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['CodBase']) + ;
										_sTagFCod + ;
										'</td>')
					else
						aadd (_aLinha, ' </td>')
					endif

					// Estas colunas existem somente para uvas comuns
					if ::TipoUva == 'C'
						if ! empty (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['CodBordadura'])
							aadd (_aLinha, _sTag + ;
											alltrim (strtran (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['DescrBordadura'], '.', ' ')) + ;
											_sTagICod + ;
											alltrim (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['CodBordadura']) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
						if ! empty (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['CodEmConversao'])
							aadd (_aLinha, _sTag + ;
											alltrim (strtran (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['DescrEmConversao'], '.', ' ')) + ;
											_sTagICod + ;
											alltrim (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['CodEmConversao']) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
						if ! empty (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['CodOrganica'])
							aadd (_aLinha, _sTag + ;
											alltrim (strtran (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['DescrOrganica'], '.', ' ')) + ;
											_sTagICod + ;
											alltrim (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['CodOrganica']) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
					endif

					// Esta coluna existe somente para viniferas em espaldeira
					if ::TipoUva == 'F' .and. ::Conducao == 'E'
						if ! empty (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['CodParaEspumante'])
							aadd (_aLinha, _sTag + ;
											alltrim (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['DescrParaEspumante']) + ;
											_sTagICod + ;
											alltrim (::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]['CodParaEspumante']) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
					endif
					_lAdicionou = .T.
				else

					// Preciso colocar um espaco nestas posicoes para gerar uma celula vazia no HTML depois.
					for _nSubgrup = 1 to len (::Grupos [_nGrupo]['ListaDeSubgrupos'])
						aadd (_aLinha, _sTag + ' </td>')
					next
				endif
			next

			// Se nao adicionou mais nenhuma linha na array, eh por que terminou
			// de ler todas as variedades de todos os grupos. Posso sair do loop.
			if ! _lAdicionou
				exit
			endif
			aadd (_aVarGrau, aclone (_aLinha))
			_nVarGrau ++
		enddo


		// Prepara uma linha com dados adicionais dos subgrupos.
		// Geralmente sao os % de organicas (uvas comuns) ou de
		// acrescimos cfe.classificacao (uvas finas).
		_aLinha = {'<td> </td>'}  // Primeira coluna vai ser usada pelo grau
		for _nGrupo = 1 to len (::Grupos)

			// Para facilitar a visualizacao, a cada troca de grupo, gero
			// as colunas com fundo escuro ou com fundo claro.
			_sTag = '<td class="Coluna' + iif (_IsInt (_nGrupo/2), 'Clara', 'Escura') + 'Descri">'
		//	U_Log2 ('debug', '[' + procname () + ']_nGrupo = ' + cvaltochar (_nGrupo) + ' ---> ' + _sTag)
		//	U_Log2 ('debug', _IsInt (_nGrupo))

			for _nSubgrup = 1 to len (::Grupos [_nGrupo]['ListaDeSubgrupos'])
				aadd (_aLinha, _sTag + ::Grupos [_nGrupo]['ListaDeSubgrupos'][_nSubgrup]['ObsSubgrupo'] + '</td>')
			next
		next
		aadd (_aVarGrau, aclone (_aLinha))


		// Adiciona graus e respectivos precos. Como preciso montar uma matriz
		// contendo todas as colunas (de todos os grupos), preciso passar por
		// todos os graus e, dentro desses, cada grupo.
		for _nGrau = 1 to len (::Grupos [1]['ListaDeGraus'])  // Pode ser o primeiro grupo, pois todos devem ser iguais
			_aLinha = {}
			for _nGrupo = 1 to len (::Grupos)
				_oGrauDeGrupo = ::Grupos [_nGrupo]['ListaDeGraus'][_nGrau]

				if _nGrupo == 1
					aadd (_aLinha, '<th class="ColunaClaraDescri">' + transform (_oGrauDeGrupo ['Grau'], iif (_IsInt (_oGrauDeGrupo ['Grau']), "@E 99", "@E 99.9")) + '</th>')
				endif

				// Para facilitar a visualizacao, a cada troca de grupo, gero
				// as colunas com fundo escuro ou com fundo claro.
				if _oGrauDeGrupo ['Grau'] == ::Grupos [_nGrupo]['GrauBase']
					_sTag = '<th class="PrecoGrauBase">'
				else
					if _nGrupo / 2 == int (_nGrupo / 2)
						_sTag = '<th class="ColunaClaraPrecos">'
					else
						_sTag = '<th class="ColunaEscuraPrecos">'
					endif
				endif

				// Define tag para gerar 'tooltip'
				_sToolTip = '<abbr title="Agio a partir do grau base: ' + alltrim (transform (_oGrauDeGrupo ['AgioSobreGrauBase'], "@E 9999.99")) + '%">'

				// Como sempre existe codigo base de cada variedade, este sempre deverah ter preco
				aadd (_aLinha, _sTag + _sToolTip + transform (_oGrauDeGrupo ['PrecoCodBase'], "@E 999.9999") + '</th>')

				// Estas colunas existem somente para uvas comuns
				if ::TipoUva == 'C'
					aadd (_aLinha, _sTag + transform (_oGrauDeGrupo ['PrecoCodOrganicaBordadura'], "@E 999.9999") + '</th>')
					aadd (_aLinha, _sTag + transform (_oGrauDeGrupo ['PrecoCodOrganicaEmConversao'], "@E 999.9999") + '</th>')
					aadd (_aLinha, _sTag + transform (_oGrauDeGrupo ['PrecoCodOrganicaOrganica'], "@E 999.9999") + '</th>')
				endif

				// Esta coluna existe somente para viniferas em espaldeira
				if ::TipoUva == 'F' .and. ::Conducao == 'E'
					aadd (_aLinha, _sTag + transform (_oGrauDeGrupo ['PrecoCodParaEspumante'], "@E 999.9999") + '</th>')
				endif
			next
			aadd (_aVarGrau, aclone (_aLinha))
		next
	//	U_Log2 ('debug', '[' + procname () + ']_aVarGrau final:')
	//	U_Log2 ('debug', _aVarGrau)

	endif

	// Passo 2: montagem do HTML
	if len (_aVarGrau) == 0
		_Super:SomaMsg ("Sem variedades para esta tabela. Impossivel gerar HTML.")
	else
		// dicas em https://www.w3schools.com/css/css_text_align.asp

		_sHTM := '<!DOCTYPE html><html>'

		// Define classes de estilos CSS para os diferentes tipo de celulas
		_sHTM += '<style>'
		_sHTM +=    '.TituloTabela{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:11.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.SubTituloTabela{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.TituloGrupoClaro{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.TituloGrupoEscuro{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraDescri{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:left;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraDescri{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:left;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraPrecos{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraPrecos{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraCodigo{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:7.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraCodigo{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:7.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.PrecoGrauBase{'
	//	_sHTM +=       'background:#8497B0;'
		_sHTM +=       'background:#82868b;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM += '</style>'

		_sHTM += '<head>'
		_sHTM +=    '<title>Tabela preços uva</title>'
		_sHTM += '</head>'
		_sHTM += '<body>'
		_sHTM += '<table width="80%" border="1" cellspacing="0" cellpadding="0" align="center">'
		
		// Linhas iniciais da tabela (descricao, tipos de uvas, datas, etc.
		_sHTM += '<tr>'
		_sHTM +=    '<th class="TituloTabela" colspan=' + cvaltochar (len (_aVarGrau [1])) + '>'
		_sHTM +=    alltrim (sm0 -> m0_nomecom)
		_sHTM +=    ' - Tabela ' + ::CodTabela + ' (preço '
			if ::TipoPreco == 'E'
				_sHTM += 'de entrada'
			elseif ::TipoPreco == 'C'
				_sHTM += 'de compra'
			elseif ::TipoPreco == 'M'
				_sHTM += 'MOC'
			else
				_sHTM += '[OUTRAS NAO DEFINIDAS]'
			endif
			_sHTM += ')'
			_sHTM += ' - uvas ' + iif (::TipoUva == 'C', 'comuns', iif (::TipoUva == 'F', 'viniferas', '(SEM DEFINICAO)'))
			_sHTM += ' ' + iif (::Conducao == 'L', 'latadas', iif (::Conducao == 'E', 'espaldeira', '(SEM DEFINICAO)'))
			_sHTM += '</th>'
		_sHTM += '</tr>'
		_sHTM += '<tr>'
		_sHTM +=    '<th class="SubTituloTabela" colspan=' + cvaltochar (len (_aVarGrau [1])) + '>Gerada pelo ERP em ' + dtoc (date ()) + ' - ' + time () + '</th>'
		_sHTM += '</tr>'


		// Linhas de titulos das colunas (nomes dos grupos, grau base, etc)
	//	U_Log2 ('debug', '[' + procname () + ']Montando linha titulos grupos')
		_sHTM += '<tr>'
		for _nGrupo = 1 to len (_aTitGrup)
			_sHTM += _aTitGrup [_nGrupo]
		next
		_sHTM += '</tr>'

		// Adiciona as variedades ao grid
		for _nVarGrau = 1 to len (_aVarGrau)
			_sHTM += '<tr>'
			for _nGrupo = 1 to len (_aVarGrau [_nVarGrau])
				_sHTM += _aVarGrau [_nVarGrau, _nGrupo]
			next
			_sHTM += '</tr>
		next

		_sHTM += '</table>'
		_sHTM += '</body></html>'
	endif
return _sHTM


// --------------------------------------------------------------------------
static function _IsInt (_nValor as numeric)
return (_nValor == int (_nValor))
