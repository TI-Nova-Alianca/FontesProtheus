// Programa:  ClsTbUva
// Autor:     Robert Koch
// Data:      22/05/2023 (inicio)
// Descricao: Declaracao de classe de representacao de tabelas de preco de uvas para safra.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa tabelas de precos de uvas para compra de safra.
// #PalavasChave      #safra #uva #tabela_preco
// #TabelasPrincipais #ZX5 SB1
// #Modulos           #COOP

// Historico de alteracoes:
// 12/11/2023 - Robert - Gravacao de agios em array interna e inicio de definicao de formulas para calculo de precos.
// 18/01/2024 - Robert - Criada tag 'PrecoFinaLatadaClasDS' (antes havia 'PrecoFinaLatadaClasD')
// 25/01/2024 - Robert - Criada tag 'PrecoFinaLatadaClasC' (simplesmente esqueci quando criei a classe !!!)
// 26/01/2024 - Robert - Implementado tipo de agio '1' entre graus (campo ZA_TPAGIOG)
//                     - Melhorias na geracao do HTML
//

#Include "Protheus.ch"
#include "VA_INCLU.prw"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsTbUva ()
return


// ==========================================================================
CLASS ClsTbUva from ClsBase

	// Declaracao das propriedades da Classe
	private data AgiosGraus  // Array contendo os agios a serem aplicados a partir do grau base
	public  data CodTabela   // Pode existir mais de uma tabela para cada safra (simulacoes, etc)
	public  data Conducao    // [E]spaldeira, [L]atada
	public  data GrauDecimal // [D]ecimais, [I]nteiros
	private data GrauIniTab  // Grau inicial a ser gerado
	private data GrauFimTab  // Grau final a ser gerado
	public  data Grupos     // Grupos de uvas cfe. tabela 13 do ZX5
	private data MsgConfSeq  // Mensagem explicativa do erro encontrado na conferencia de sequenciamento de graus
	public  data NomeTabela  // Nome (descritivo) da tabela
	public  data SubGrupos   // Subgrupos de uvas cfe. tabela 13 do ZX5
	public  data TipoAgioEntreGraus  // Cfe.campo ZA_TPAGIOG: [A]lianca;[M]OC;...
	public  data TipoUva     // [C]omum, [F]ina
	public  data UltMsg      // Mensagens (geralmente de erro)

	// Declaracao dos Metodos da classe
	public  METHOD New ()
	private METHOD ConfSeq ()
	private METHOD DefPAgio ()
	private METHOD DistrAgios ()
	public  METHOD GeraAtrib ()
	public  METHOD GeraHTM ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor.
METHOD New () Class ClsTbUva

	// Valores default
	::CodTabela   = ''
	::Conducao    = ''
	::GrauDecimal = ''
	::Grupos      = JsonObject():New()
	::MsgConfSeq  = ''
	::NomeTabela  = ''
	::SubGrupos   = {}
	::TipoAgioEntreGraus = ''
	::TipoUva     = ''
	::UltMsg      = ''

	// Aumentar ou diminuir aqui a faixa de graus se necessario.
	// Uso essa faixa tem uns 10 anos e nao me faltou nada ainda...
	::GrauIniTab  = 6
	::GrauFimTab  = 26
Return ::self


// --------------------------------------------------------------------------
// Confere se a sequencia encontra-se ordenada (valor de cada grau sempre maior que o anterior)
METHOD ConfSeq (_aArray as array, _nColGrau as numeric, _nColValor as numeric) class ClsTbUva
	local _nInd1 := 0
	local _nInd2 := 0
	local _lRet  := .T.
	U_Log2 ('debug', '[' + procname () + ']Array para analisar:')
	U_Log2 ('debug', _aArray)
	for _nInd1 = 2 to len (_aArray)
		U_Log2 ('debug', '[' + procname () + ']Testando pos ' + cvaltochar (_nInd1))
		for _nInd2 = _nInd1 - 1 to 1 step -1
//			U_Log2 ('debug', '[' + procname () + ']Testando pos ' + cvaltochar (_nInd2) + ' contra ' + cvaltochar (_nInd1))
			if _aArray [_nInd2, _nColValor] >= _aArray [_nInd1, _nColValor]
				::MsgConfSeq += 'Grau ' + cvaltochar (_aArray [_nInd2, _nColGrau]) ;
					+ ' (' + cvaltochar (_aArray [_nInd2, _nColValor]) ;
					+ ') >= grau ' + cvaltochar (_aArray [_nInd1, _nColGrau]) ;
					+ '(' + cvaltochar (_aArray [_nInd1, _nColValor]) + ')' + chr (13) + chr (10)
				_lRet = .F.
				exit
			endif
		next
	next
return _lRet


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib ( ;
	  _sCodTab  as character ;  // Codigo da tabela. Deve existir no ZA_COD
	, _sTipoUva as character ;  // Tipo de uva: [C]omum;[F]ina
	, _sConduc  as character ;  // Forma ed conducao: [L]atada;[E]spaldeira
	, _sGrauDec as character ;  // Gerar todos os graus [D]ecimais ou somente graus [I]nteiros
	) Class ClsTbUva

	local _lContinua := .T.
	local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _sAliasQ   := ''
	local _nStepGrau := 0
	local _nGrau     := 0
	local _nPreco    := 0
	local _aGrausComAgio := {}
	local _aGrausDoGrupo := {}
	local _oGrauDeGrupo  := NIL  // Pensando na impressao da tabela, seriam os dados de uma 'celula' (determinado grau de determinado grupo)
	local _oGrupoTbUva   := NIL
	local _aGrupos       := {}
	local _aListaDeGraus := {}
	local _oVariedade    := NIL
	local _sObsSubgrupo  := ''
	local _sAlias13      := ''
	local _nPrcGrauAnt   := 0

	if empty (_sCodTab)
		_Super:SomaMsg ("Codigo da tabela deve ser informado.")
		_lContinua = .F.
	else
		::CodTabela   = _sCodTab
	endif
	if empty (_sConduc)
		_Super:SomaMsg ("Sistema de conducao latada (L) ou espaldeira (E) deve ser informado.")
		_lContinua = .F.
	else
		::Conducao    = _sConduc
	endif
	if empty (_sGrauDec)
		_Super:SomaMsg ("Opcao para gerar graus decimais (D) ou inteiros (I) deve ser informada.")
		_lContinua = .F.
	else
		::GrauDecimal = _sGrauDec
		_nStepGrau = iif (::GrauDecimal == 'D', 0.1, 1)
	endif
	if empty (_sTipoUva)
		_Super:SomaMsg ("Tipo de uva (C=comum;V=vinifera) deve ser informado.")
		_lContinua = .F.
	else
		::TipoUva     = _sTipoUva
	endif

	// Gera uma lista de grupos relacionados ao tipo de uvas solicitado.
	if _lContinua
		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Vou gerar array de grupos')
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT ZA_DESC, ZA_TPAGIOG"
		_oSQL:_sQuery += ", ZX5_13SAFR, ZX5_13GRUP, ZX5_13DESC, ZX5_13GBAS, ZX5_13GMAG, ZX5_13PMIN, ZX5_13PBCO"
		_oSQL:_sQuery += ", ZX5_13AEPR, ZX5_13AEAA, ZX5_13AEA, ZX5_13AEC, ZX5_13AED, ZX5_13AEDS"  // Acrescimos cfe classificacao espaldeira
		_oSQL:_sQuery += ", ZX5_13ALA, ZX5_13ALC, ZX5_13ALDS"  // Acrescimos cfe classificacao latada
		_oSQL:_sQuery += ", ZX5_13PAOB, ZX5_13PAOE, ZX5_13PAOO"  // Acrescimos cfe bordadura/em conversao/organica
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SZA") + " SZA "
		_oSQL:_sQuery +=      " ," + RetSQLName ("ZX5") + " ZX5_13 "
		_oSQL:_sQuery += " WHERE SZA.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SZA.ZA_FILIAL = '" + xfilial ("SZA") + "'"
		_oSQL:_sQuery +=   " AND SZA.ZA_COD    = '" + ::CodTabela + "'"
		_oSQL:_sQuery +=   " AND ZX5_13.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_TABELA = '13'"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_13SAFR = SZA.ZA_COD"  //'" + ::CodTabela + "'"
		_oSQL:_sQuery +=   " AND LEN (ZX5_13.ZX5_13GRUP) >= 3"  // Nao quero listar os 'grandes grupos'
		if ::TipoUva == 'C'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '1%'"  // Lista comuns
		elseif ::TipoUva == 'F' .and. ::Conducao == 'E'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '2%'"  // Lista finas espaldeira
		elseif ::TipoUva == 'F' .and. ::Conducao == 'L'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '3%'"  // Lista finas latadas
		else
			_Super:SomaMsg ("Sem tratamento para tipo de uva '" + ::TipoUva + "'.")
			_lContinua = .F.
		endif

		// Quero ignorar grupos que existem na tabela 13, mas que nao tenham
		// nenhuma variedade ligada a eles pela tabela 14.
		_oSQL:_sQuery += " AND EXISTS (SELECT *"
		_oSQL:_sQuery +=               " FROM " + RetSQLName ("ZX5") + " ZX5_14 "
		_oSQL:_sQuery +=              " WHERE ZX5_14.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_TABELA = '14'"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_14SAFR =  ZX5_13.ZX5_13SAFR"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_14GRUP =  ZX5_13.ZX5_13GRUP"
		_oSQL:_sQuery +=             ")"

		_oSQL:_sQuery += " ORDER BY ZX5_13GRUP"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
	//	_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		_sAlias13 = _oSQL:Qry2Trb (.F.)
	//	if len (_aDados) == 0
		if (_sAlias13) -> (eof ())
			_Super:SomaMsg ("Tabela de precos '" + ::CodTabela + "' nao existe, ou nao tem nenhum grupo de variedades informado.")
			_lContinua = .F.
		else
			if empty ((_sAlias13) -> za_tpagiog)
				_Super:SomaMsg ("Tipo de agio nao definido no campo ZA_TPAGIOG.")
				_lContinua = .F.
			else
				::NomeTabela         = (_sAlias13) -> za_desc
				::TipoAgioEntreGraus = (_sAlias13) -> za_tpagiog
			endif
		endif
	endif
	
	// Gera grupos de variedades
	if _lContinua
		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Vou gerar grupos')
		_aGrupos = {}
	//	for _nDado = 1 to len (_aDados)
		(_sAlias13) -> (dbgotop ())
		do while ! (_sAlias13) -> (eof ())

			// Pretendo migrar o formato array para formato JSON, mas tenho que
			// fazer isso com cuidado para nao me perder. Entao trabalharei com
			// os 2 formatos em paralelo por enquanto. Depois de ter tudo em JSON
			// pretendo eliminar a parte em array.
			_oGrupoTbUva = JsonObject():New()
			_oGrupoTbUva ['Codigo']                    = (_sAlias13) -> zx5_13grup  // _aDados [_nDado, 2]
			_oGrupoTbUva ['Descricao']                 = (_sAlias13) -> zx5_13desc  // _aDados [_nDado, 3]
			_oGrupoTbUva ['GrauBase']                  = (_sAlias13) -> zx5_13gbas  // _aDados [_nDado, 4]
			_oGrupoTbUva ['GrauMinimoParaAgio']        = (_sAlias13) -> zx5_13gmag  // _aDados [_nDado, 5]
			_oGrupoTbUva ['PrecoMinimo']               = (_sAlias13) -> zx5_13pmin  // _aDados [_nDado, 6]
			_oGrupoTbUva ['PrecoGrauBase']             = (_sAlias13) -> zx5_13pbco  // _aDados [_nDado, 7]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasPR'] = (_sAlias13) -> zx5_13aepr  // _aDados [_nDado, 8]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasAA'] = (_sAlias13) -> zx5_13aeaa  // _aDados [_nDado, 9]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasA']  = (_sAlias13) -> zx5_13aea   // _aDados [_nDado, 10]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasC']  = (_sAlias13) -> zx5_13aec   // _aDados [_nDado, 11]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasD']  = (_sAlias13) -> zx5_13aed   // _aDados [_nDado, 12]
			_oGrupoTbUva ['AcrescimoEspaldeiraClasDS'] = (_sAlias13) -> zx5_13aeds  // _aDados [_nDado, 13]
			_oGrupoTbUva ['AcrescimoLatadaClasA']      = (_sAlias13) -> zx5_13ala  // _aDados [_nDado, 14]
			_oGrupoTbUva ['AcrescimoLatadaClasC']      = (_sAlias13) -> zx5_13alc  // _aDados [_nDado, 15]  // Nao tenho campo (deveria ser ZX5_13ALC) na tabela ainda
		//	_oGrupoTbUva ['AcrescimoLatadaClasD']      = (_sAlias13) -> zx5_13al ? // _aDados [_nDado, 15]
			_oGrupoTbUva ['AcrescimoLatadaClasDS']     = (_sAlias13) -> zx5_13alds  // _aDados [_nDado, 15]  // Nao tenho um tratamento especifico para diferenciar D e DS (latada) quanto a precos.
			_oGrupoTbUva ['AgioOrganicaBordadura']     = (_sAlias13) -> zx5_13paob  // _aDados [_nDado, 16]
			_oGrupoTbUva ['AgioOrganicaEmConversao']   = (_sAlias13) -> zx5_13paoe  // _aDados [_nDado, 17]
			_oGrupoTbUva ['AgioOrganicaOrganica']      = (_sAlias13) -> zx5_13paoo  // _aDados [_nDado, 18]
			_oGrupoTbUva ['ListaDeSubgrupos']          = {}
			_oGrupoTbUva ['ListaDeVariedades']         = {}
			_oGrupoTbUva ['ListaDeGraus']              = {}

			// Cria uma lista com as variedades de uvas deste grupo.
			// Para uvas organicas, achei mais interessante cadastrar somente
			// o codigo base na tabela e depois, usando a view de familias de
			// uvas, buscar as variedades em conversao, bordadura e organica.
			// Uso a mesma view para as demais variedades para me obrigar a
			// mante-la sempre atualizada.
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT V.FINA_COMUM, V.COR, V.TINTOREA"
			_oSQL:_sQuery +=      ", V.COD_BASE, V.DESC_RESUM"
			_oSQL:_sQuery +=      ", V.COD_BORDADURA, V.DESC_RESUM_BORDADURA"
			_oSQL:_sQuery +=      ", V.COD_EM_CONVERSAO, V.DESC_RESUM_EM_CONVERSAO"
			_oSQL:_sQuery +=      ", V.COD_ORGANICA, V.DESC_RESUM_ORGANICA"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5_14 "
			_oSQL:_sQuery +=      ", VA_VFAMILIAS_UVAS V "
			_oSQL:_sQuery += " WHERE ZX5_14.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_TABELA = '14'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14SAFR = '" + ::CodTabela + "'"
//			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + _aDados [_nDado, 2] + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + (_sAlias13) -> zx5_13grup + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14PROD = V.COD_BASE"
			_oSQL:_sQuery +=   " AND V.FINA_COMUM = 'C'"
			_oSQL:_sQuery += " union all"
			_oSQL:_sQuery += " SELECT V.FINA_COMUM, V.COR, V.TINTOREA"
			_oSQL:_sQuery +=      ", COD_FINA_CLAS_COMUM, DESCR_FINA_CLAS_COMUM"
			_oSQL:_sQuery +=      ", '', ''"
			_oSQL:_sQuery +=      ", '', ''"
			_oSQL:_sQuery +=      ", '', ''"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5_14 "
			_oSQL:_sQuery +=      ", VA_VFAMILIAS_UVAS V "
			_oSQL:_sQuery += " WHERE ZX5_14.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_TABELA = '14'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14SAFR = '" + ::CodTabela + "'"
//			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + _aDados [_nDado, 2] + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + (_sAlias13) -> zx5_13grup + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14PROD = V.COD_FINA_CLAS_COMUM"
			_oSQL:_sQuery +=   " AND V.FINA_COMUM = 'F'"
			_oSQL:_sQuery += " union all"
			_oSQL:_sQuery += " SELECT V.FINA_COMUM, V.COR, V.TINTOREA"
			_oSQL:_sQuery +=      ", V.COD_BASE, V.DESC_RESUM"
			_oSQL:_sQuery +=      ", '', ''"
			_oSQL:_sQuery +=      ", '', ''"
			_oSQL:_sQuery +=      ", '', ''"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5_14 "
			_oSQL:_sQuery +=      ", VA_VFAMILIAS_UVAS V "
			_oSQL:_sQuery += " WHERE ZX5_14.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_TABELA = '14'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14SAFR = '" + ::CodTabela + "'"
//			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + _aDados [_nDado, 2] + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + (_sAlias13) -> zx5_13grup + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14PROD = V.COD_BASE"
			_oSQL:_sQuery +=   " AND V.FINA_COMUM = 'F'"
			_oSQL:_sQuery += " union all"
			_oSQL:_sQuery += " SELECT V.FINA_COMUM, V.COR, V.TINTOREA"
			_oSQL:_sQuery +=      ", V.COD_PARA_ESPUMANTE, V.DESC_RESUM_PARA_ESPUMANTE"
			_oSQL:_sQuery +=      ", '', ''"
			_oSQL:_sQuery +=      ", '', ''"
			_oSQL:_sQuery +=      ", '', ''"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5_14 "
			_oSQL:_sQuery +=      ", VA_VFAMILIAS_UVAS V "
			_oSQL:_sQuery += " WHERE ZX5_14.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_TABELA = '14'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14SAFR = '" + ::CodTabela + "'"
//			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + _aDados [_nDado, 2] + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + (_sAlias13) -> zx5_13grup + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14PROD = V.COD_PARA_ESPUMANTE"
			_oSQL:_sQuery +=   " AND V.FINA_COMUM = 'F'"
			_oSQL:_sQuery += " ORDER BY DESC_RESUM, COD_BASE"
		//	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			_sAliasQ := _oSQL:Qry2Trb (.F.)
			(_sAliasQ) -> (dbgotop ())
			do while ! (_sAliasQ) -> (eof ())
				_oVariedade := JsonObject():New()
				_oVariedade ['CodBase']            = (_sAliasQ) -> cod_base
				_oVariedade ['DescrBase']          = alltrim ((_sAliasQ) -> desc_resum)
				_oVariedade ['CodEmConversao']     = (_sAliasQ) -> cod_em_conversao
				_oVariedade ['DescrEmConversao']   = alltrim ((_sAliasQ) -> desc_resum_em_conversao)
				_oVariedade ['CodBordadura']       = (_sAliasQ) -> cod_bordadura
				_oVariedade ['DescrBordadura']     = alltrim ((_sAliasQ) -> desc_resum_bordadura)
				_oVariedade ['CodOrganica']        = (_sAliasQ) -> cod_organica
				_oVariedade ['DescrOrganica']      = alltrim ((_sAliasQ) -> desc_resum_organica)
				_oVariedade ['FinaOuComum']        = (_sAliasQ) -> fina_comum
				_oVariedade ['Cor']                = (_sAliasQ) -> cor
				_oVariedade ['Tintorea']           = (_sAliasQ) -> tintorea
				aadd (_oGrupoTbUva ['ListaDeVariedades'], _oVariedade)
				(_sAliasQ) -> (dbskip ())
			enddo
			(_sAliasQ) -> (dbclosearea ())
			dbselectarea ("SB1")

			// Gera lista de graus e respectivos % de agio sobre o grau base.
			_aGrausDoGrupo = {}
			_aGrausComAgio = {}
			for _nGrau = ::GrauIniTab to ::GrauFimTab step _nStepGrau
				aadd (_aGrausComAgio, {_nGrau, 0})
			next

			// Define o % de agio (a ser aplicado sobre o grau base) para cada grau.
			_lContinua = ::DistrAgios (@_aGrausComAgio, _oGrupoTbUva ['GrauBase'])
			U_Log2 ('debug', '[' + procname () + ']Agios distribuidos:')
			U_Log2 ('debug', _aGrausComAgio)

			// Confere se a sequencia de agios gerada encontra-se ordenada (cada grau sempre maior que o anterior)
			if ! ::ConfSeq (_aGrausComAgio, 1, 2)
				U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + ']A distribuicao de agios nao esta com sequenciamento correto')
				U_Log2 ('debug', '[' + procname () + ']' + ::MsgConfSeq)
			endif

			// Para cada grau, calcula seus precos e transforma-o em objeto.
			if _lContinua
				_aListaDeGraus = {}
				_nPrcGrauAnt = 0
				for _nGrau = 1 to len (_aGrausComAgio)
					_oGrauDeGrupo := JsonObject():New()
					_oGrauDeGrupo ['ObsGrauDeGrupo']      = ''
					_oGrauDeGrupo ['Grau']                = _aGrausComAgio [_nGrau, 1]
					_oGrauDeGrupo ['AgioSobreGrauBase']   = _aGrausComAgio [_nGrau, 2]

					// Aplica regra de agio sobre o preco do grau base.
					_nPreco = _oGrupoTbUva ['PrecoGrauBase']
					_nPreco += _nPreco * _aGrausComAgio [_nGrau, 2] / 100
					_oGrauDeGrupo ['PrecoCodBase'] = _nPreco
/*
					// Se foi definido um preco minimo para este grupo...
					if _oGrupoTbUva ['PrecoMinimo'] > 0
				//		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Preco minimo para este grupo: $ ' + cvaltochar (_oGrupoTbUva ['PrecoMinimo']))
					
						// Se foi definido um grau limite para preco minimo,
						// tudo que estiver abaixo desse grau vai usar preco minimo.
						if _oGrupoTbUva ['GrauMinimoParaAgio'] > 0
				//			U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Preco minimo aplicavel abaixo do grau ' + cvaltochar (_oGrupoTbUva ['GrauMinimoParaAgio']))
							if _aGrausComAgio [_nGrau, 1] < _oGrupoTbUva ['GrauMinimoParaAgio']
								_oGrauDeGrupo ['PrecoCodBase'] = _oGrupoTbUva ['PrecoMinimo']
								_oGrauDeGrupo ['ObsGrauDeGrupo'] += 'Preço mínimo (por grau).'
							endif
						else
				//			U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Preco minimo independe de grau.')
							if _oGrauDeGrupo ['PrecoCodBase'] < _oGrupoTbUva ['PrecoMinimo']
								_oGrauDeGrupo ['PrecoCodBase'] = _oGrupoTbUva ['PrecoMinimo']
								_oGrauDeGrupo ['ObsGrauDeGrupo'] += 'Preço mínimo (por grupo).'
							endif
						endif
					endif
*/
					// Deixa prontas tags de precos das possiveis variacoes,
					// como organicas e classificacoes de viniferas. Vou
					// deixar isto chumbado no programa por que, em 15 anos
					// de Cooperativa, soh vi serem criadas novas classes
					// quando unimos as 5 cooperativas...
					_oGrauDeGrupo ['PrecoCodOrganicaBordadura']   = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AgioOrganicaBordadura'] / 100)
					_oGrauDeGrupo ['PrecoCodOrganicaEmConversao'] = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AgioOrganicaEmConversao'] / 100)
					_oGrauDeGrupo ['PrecoCodOrganicaOrganica']    = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AgioOrganicaOrganica'] / 100)
					_oGrauDeGrupo ['PrecoFinaLatadaClasA']        = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AcrescimoLatadaClasA'] / 100)
					_oGrauDeGrupo ['PrecoFinaLatadaClasC']        = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AcrescimoLatadaClasC'] / 100)
					_oGrauDeGrupo ['PrecoFinaLatadaClasDS']       = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AcrescimoLatadaClasDS'] / 100)
					_oGrauDeGrupo ['PrecoFinaEspaldeiraClasPR']   = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AcrescimoEspaldeiraClasPR'] / 100)
					_oGrauDeGrupo ['PrecoFinaEspaldeiraClasAA']   = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AcrescimoEspaldeiraClasAA'] / 100)
					_oGrauDeGrupo ['PrecoFinaEspaldeiraClasA']    = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AcrescimoEspaldeiraClasA'] / 100)
					_oGrauDeGrupo ['PrecoFinaEspaldeiraClasC']    = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AcrescimoEspaldeiraClasC'] / 100)
					_oGrauDeGrupo ['PrecoFinaEspaldeiraClasD']    = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AcrescimoEspaldeiraClasD'] / 100)
					_oGrauDeGrupo ['PrecoFinaEspaldeiraClasDS']   = _oGrauDeGrupo ['PrecoCodBase'] * (1 + _oGrupoTbUva ['AcrescimoEspaldeiraClasDS'] / 100)

					// Validacao extra: cada preco deve sempre ser maior que o preco do grau anterior
					if _nPrcGrauAnt != 0 .and. _oGrauDeGrupo ['PrecoCodBase'] < _nPrcGrauAnt
						_Super:SomaMsg ("Problemas na geracao de precos! Preco do grau " ;
							+ cvaltochar (_oGrauDeGrupo ['Grau']) + " = " + cvaltochar (_oGrauDeGrupo ['PrecoCodBase']) ;
							+ ' contra ' + cvaltochar (_nPrcGrauAnt) + ' do grau anterior.')
//						_lContinua = .F.
						U_Log2 ('debug', '[' + procname () + "]Problemas na geracao de precos! Preco do grau " ;
							+ cvaltochar (_oGrauDeGrupo ['Grau']) + " = " + cvaltochar (_oGrauDeGrupo ['PrecoCodBase']) ;
							+ ' contra ' + cvaltochar (_nPrcGrauAnt) + ' do grau anterior.')
					endif
					_nPrcGrauAnt = _oGrauDeGrupo ['PrecoCodBase']

					// Alimenta array com um objeto representando dados de cada grau deste grupo
					aadd (_oGrupoTbUva ['ListaDeGraus'], _oGrauDeGrupo)

				next
			endif


			// Conforme o tipo de uva, pode haver diferentes subgrupos.
			// Uvas comuns: 4 subcolunas (convenc/bordadura/em conv/organ)
			_sObsSubgrupo = ''
			if ::TipoUva == 'C'
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : 'Convencional', 'ObsSubgrupo' : '' })
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : 'Bordadura'   , 'ObsSubgrupo' : '+' + cvaltochar (_oGrupoTbUva ['AgioOrganicaBordadura']   ) + '%' })
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : 'Em conversão', 'ObsSubgrupo' : '+' + cvaltochar (_oGrupoTbUva ['AgioOrganicaEmConversao'] ) + '%' })
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : 'Orgânica'    , 'ObsSubgrupo' : '+' + cvaltochar (_oGrupoTbUva ['AgioOrganicaOrganica']    ) + '%' })

			elseif ::TipoUva == 'F' .and. ::Conducao == 'E'
				_sObsSubgrupo :=     'Clas.PR: ' + cvaltochar (_oGrupoTbUva ['AcrescimoEspaldeiraClasPR']) + '%'
				_sObsSubgrupo += '<br>Clas.AA: ' + cvaltochar (_oGrupoTbUva ['AcrescimoEspaldeiraClasAA']) + '%'
				_sObsSubgrupo += '<br>Clas.A:  ' + cvaltochar (_oGrupoTbUva ['AcrescimoEspaldeiraClasA']) + '%'
				_sObsSubgrupo += '<br>Clas.B: base'
				_sObsSubgrupo += '<br>Clas.C:  ' + cvaltochar (_oGrupoTbUva ['AcrescimoEspaldeiraClasC']) + '%'
				_sObsSubgrupo += '<br>Clas.D:  ' + cvaltochar (_oGrupoTbUva ['AcrescimoEspaldeiraClasD']) + '%'
				_sObsSubgrupo += '<br>Clas.DS: ' + cvaltochar (_oGrupoTbUva ['AcrescimoEspaldeiraClasDS']) + '%'
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : '' , 'ObsSubgrupo' : _sObsSubgrupo})

			elseif ::TipoUva == 'F' .and. ::Conducao == 'L'
				_sObsSubgrupo := 'Clas.A: +' + cvaltochar (_oGrupoTbUva ['AcrescimoLatadaClasA']) + '%'
				_sObsSubgrupo += '<br>Clas.B: base'
				_sObsSubgrupo += '<br>Clas.C:  ' + cvaltochar (_oGrupoTbUva ['AcrescimoLatadaClasC']) + '%'
			//	_sObsSubgrupo += '<br>Clas.D:  ' + cvaltochar (_oGrupoTbUva ['AcrescimoLatadaClasD']) + '%'
				_sObsSubgrupo += '<br>Clas.DS: ' + cvaltochar (_oGrupoTbUva ['AcrescimoLatadaClasDS']) + '%'
				aadd (_oGrupoTbUva ['ListaDeSubgrupos'], {'DescSubgrupo' : '' , 'ObsSubgrupo' : _sObsSubgrupo})
			endif

			aadd (_aGrupos, _oGrupoTbUva)

			(_sAlias13) -> (dbskip ())
		enddo
		::Grupos:Set (_aGrupos)

		// Durante o desenvolvimento, achei interessante esportar o JSON
		// para arquivo, onde posso visualizar mais facilmente.
		_sArq := 'c:\temp\teste.json'
		if file (_sArq)
			delete file (_sArq)
		endif
		_nHdl = fcreate (_sArq, 0)
		fwrite (_nHdl, ::Grupos:ToJSON ())
		fclose (_nHdl)

	endif

	// Se deu algum problema, limpa os dados principais para inutilizar o objeto.
	if ! _lContinua
		::CodTabela = ''
		::Grupos    = NIL
	endif

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Define os percentuais de agio entre os graus (% acrescido ou diminuido
// a partir do grau base cfe. muda o grau).
// Optei por usar uma funcao separada por que, em varios anos que estou
// aqui, vi isso mudar muito poucas vezes e nao vale a pena copiar ano a ano.
METHOD DefPAgio (_nEsteGrau as numeric, _nGrauBase as numeric) Class ClsTbUva
	local _nRetAgio := NIL  // Deixar NIL para poder testar mais tarde se deu erro.

	// As variacoes de agio da Alianca costumam ser diferentes da MOC
	if ::TipoAgioEntreGraus == 'A'  // Padrao Alianca
		do case
		case _nEsteGrau == _nGrauBase -12 ; _nRetAgio = -165
		case _nEsteGrau == _nGrauBase -11 ; _nRetAgio = -150
		case _nEsteGrau == _nGrauBase -10 ; _nRetAgio = -135
		case _nEsteGrau == _nGrauBase -9  ; _nRetAgio = -120
		case _nEsteGrau == _nGrauBase -8  ; _nRetAgio = -105
		case _nEsteGrau == _nGrauBase -7  ; _nRetAgio = -90
		case _nEsteGrau == _nGrauBase -6  ; _nRetAgio = -75
		case _nEsteGrau == _nGrauBase -5  ; _nRetAgio = -60
		case _nEsteGrau == _nGrauBase -4  ; _nRetAgio = -45
		case _nEsteGrau == _nGrauBase -3  ; _nRetAgio = -30
		case _nEsteGrau == _nGrauBase -2  ; _nRetAgio = -15
		case _nEsteGrau == _nGrauBase -1  ; _nRetAgio = -5
		case _nEsteGrau == _nGrauBase +0  ; _nRetAgio = 0
		case _nEsteGrau == _nGrauBase +1  ; _nRetAgio = 5
		case _nEsteGrau == _nGrauBase +2  ; _nRetAgio = 15
		case _nEsteGrau == _nGrauBase +3  ; _nRetAgio = 25
		case _nEsteGrau == _nGrauBase +4  ; _nRetAgio = 35
		case _nEsteGrau == _nGrauBase +5  ; _nRetAgio = 45
		case _nEsteGrau == _nGrauBase +6  ; _nRetAgio = 55
		case _nEsteGrau == _nGrauBase +7  ; _nRetAgio = 65
		case _nEsteGrau == _nGrauBase +8  ; _nRetAgio = 75
		case _nEsteGrau == _nGrauBase +9  ; _nRetAgio = 85
		case _nEsteGrau == _nGrauBase +10 ; _nRetAgio = 95
		case _nEsteGrau == _nGrauBase +11 ; _nRetAgio = 105
		case _nEsteGrau == _nGrauBase +12 ; _nRetAgio = 115
		case _nEsteGrau == _nGrauBase +13 ; _nRetAgio = 125
		case _nEsteGrau == _nGrauBase +14 ; _nRetAgio = 135
		case _nEsteGrau == _nGrauBase +15 ; _nRetAgio = 145
		case _nEsteGrau == _nGrauBase +16 ; _nRetAgio = 155  // Se surgirem novos graus, acrescentar aqui.
		endcase
	elseif ::TipoAgioEntreGraus == '1'  // Simulacao 2024
		do case
		case _nEsteGrau == _nGrauBase -12 ; _nRetAgio = -110 //-165
		case _nEsteGrau == _nGrauBase -11 ; _nRetAgio = -100 //-150
		case _nEsteGrau == _nGrauBase -10 ; _nRetAgio = -90 //-135
		case _nEsteGrau == _nGrauBase -9  ; _nRetAgio = -80 //-120
		case _nEsteGrau == _nGrauBase -8  ; _nRetAgio = -70 //-105
		case _nEsteGrau == _nGrauBase -7  ; _nRetAgio = -60 //-90
		case _nEsteGrau == _nGrauBase -6  ; _nRetAgio = -50 //-75
		case _nEsteGrau == _nGrauBase -5  ; _nRetAgio = -40 //-60
		case _nEsteGrau == _nGrauBase -4  ; _nRetAgio = -30 //-45
		case _nEsteGrau == _nGrauBase -3  ; _nRetAgio = -20 //-30
		case _nEsteGrau == _nGrauBase -2  ; _nRetAgio = -10 //-15
		case _nEsteGrau == _nGrauBase -1  ; _nRetAgio = -5
		case _nEsteGrau == _nGrauBase +0  ; _nRetAgio = 0
		case _nEsteGrau == _nGrauBase +1  ; _nRetAgio = 5
		case _nEsteGrau == _nGrauBase +2  ; _nRetAgio = 15
		case _nEsteGrau == _nGrauBase +3  ; _nRetAgio = 25
		case _nEsteGrau == _nGrauBase +4  ; _nRetAgio = 35
		case _nEsteGrau == _nGrauBase +5  ; _nRetAgio = 45
		case _nEsteGrau == _nGrauBase +6  ; _nRetAgio = 55
		case _nEsteGrau == _nGrauBase +7  ; _nRetAgio = 65
		case _nEsteGrau == _nGrauBase +8  ; _nRetAgio = 75
		case _nEsteGrau == _nGrauBase +9  ; _nRetAgio = 85
		case _nEsteGrau == _nGrauBase +10 ; _nRetAgio = 95
		case _nEsteGrau == _nGrauBase +11 ; _nRetAgio = 105
		case _nEsteGrau == _nGrauBase +12 ; _nRetAgio = 115
		case _nEsteGrau == _nGrauBase +13 ; _nRetAgio = 125
		case _nEsteGrau == _nGrauBase +14 ; _nRetAgio = 135
		case _nEsteGrau == _nGrauBase +15 ; _nRetAgio = 145
		case _nEsteGrau == _nGrauBase +16 ; _nRetAgio = 155  // Se surgirem novos graus, acrescentar aqui.
		endcase
	elseif ::TipoAgioEntreGraus == 'M'  // Padrao MOC (CONAB)
		do case
		case _nEsteGrau == _nGrauBase -12 ; _nRetAgio = -100  // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -11 ; _nRetAgio = -95   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -10 ; _nRetAgio = -90   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -9  ; _nRetAgio = -85   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -8  ; _nRetAgio = -80   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -7  ; _nRetAgio = -70   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -6  ; _nRetAgio = -60   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -5  ; _nRetAgio = -55   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -4  ; _nRetAgio = -50   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase -3  ; _nRetAgio = -30
		case _nEsteGrau == _nGrauBase -2  ; _nRetAgio = -15
		case _nEsteGrau == _nGrauBase -1  ; _nRetAgio = -5
		case _nEsteGrau == _nGrauBase -0  ; _nRetAgio = 0
		case _nEsteGrau == _nGrauBase +1  ; _nRetAgio = 5
		case _nEsteGrau == _nGrauBase +2  ; _nRetAgio = 15
		case _nEsteGrau == _nGrauBase +3  ; _nRetAgio = 25
		case _nEsteGrau == _nGrauBase +4  ; _nRetAgio = 35
		case _nEsteGrau == _nGrauBase +5  ; _nRetAgio = 45
		case _nEsteGrau == _nGrauBase +6  ; _nRetAgio = 55
		case _nEsteGrau == _nGrauBase +7  ; _nRetAgio = 65
		case _nEsteGrau == _nGrauBase +8  ; _nRetAgio = 75
		case _nEsteGrau == _nGrauBase +9  ; _nRetAgio = 85
		case _nEsteGrau == _nGrauBase +10 ; _nRetAgio = 95
		case _nEsteGrau == _nGrauBase +11 ; _nRetAgio = 105  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase +12 ; _nRetAgio = 115  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase +13 ; _nRetAgio = 125  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		case _nEsteGrau == _nGrauBase +14 ; _nRetAgio = 135  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
		endcase
	else
		_Super:SomaMsg ("Sem definicao de agio entre graus para tipo '" + ::TipoAgioEntreGraus + "'.")
	endif
return _nRetAgio


// --------------------------------------------------------------------------
// Distribui os percentuais de agio entre os graus. Basicamente, parte-se de
// um preco determinado no grau base e aumenta-se o % de agio conforme o grau
// vai se distanciando do grau base (desconta mais valor para graus menores
// que o grau base, e acrescenta valor aos graus maiores).
METHOD DistrAgios (_aGraus as array, _nGrauBase as numeric) Class ClsTbUva
	local _lContinua := .T.
	local _nAuxGrau  := 0
	local _nPosGrInt := 0
	local _nAgioAnt  := 0
	local _nAgioPos  := 0
	local _nEsteGrau := 0

	// Grava os agios entre graus inteiros.
	_nAuxGrau = 1
	do while _lContinua .and. _nAuxGrau <= len (_aGraus)
		_nEsteGrau = _aGraus [_nAuxGrau, 1]
		if _IsInt (_nEsteGrau)
			_aGraus [_nAuxGrau, 2] = ::DefPAgio (_nEsteGrau, _nGrauBase)
			if _aGraus [_nAuxGrau, 2] == NIL
				_Super:SomaMsg ("Sem definicao de agio para grau inteiro " + cvaltochar (_aGraus [_nAuxGrau, 1]))
				_lContinua = .F.
			endif
		endif
		_nAuxGrau ++
	enddo

	// Tendo os agios entre graus inteiros, vou calcular para os graus decimais (se existirem).
	_nAuxGrau = 1
	do while _lContinua .and. _nAuxGrau <= len (_aGraus)
		_nEsteGrau = _aGraus [_nAuxGrau, 1]
		if ! _IsInt (_nEsteGrau)  // Para os inteiros, jah tenho.

			// Encontra o agio do 'grau inteiro' anterior
			_nPosGrInt = _nAuxGrau
			do while _nPosGrInt > 0 .and. ! _IsInt (_aGraus [_nPosGrInt, 1])
				_nPosGrInt --
			enddo
			if _nPosGrInt > 0
				_nAgioAnt = _aGraus [_nPosGrInt, 2]  // Agora tenho o % de agio do grau inteiro anterior
			else
				_Super:SomaMsg ("Nao consegui encontrar grau inteiro menor para ler seu agio e calcular decimais.")
				_lContinua = .F.
			endif

			// Encontra o agio do 'grau inteiro' posterior
			_nPosGrInt = _nAuxGrau
			do while _nPosGrInt <= len (_aGraus) .and. ! _IsInt (_aGraus [_nPosGrInt, 1])
				_nPosGrInt ++
			enddo
			if _nPosGrInt <= len (_aGraus)
				_nAgioPos = _aGraus [_nPosGrInt, 2]  // Agora tenho o % de agio do grau inteiro posterior
			else
				_Super:SomaMsg ("Nao consegui encontrar grau inteiro maior para ler seu agio e calcular decimais.")
				_lContinua = .F.
			endif

			// Sabendo o agio inteiro anterior e o posterior, posso
			// calcular o agio para o grau decimal atual.
			_aGraus [_nAuxGrau, 2] = _nAgioAnt - (_nAgioAnt - _nAgioPos) * (_nEsteGrau - int (_nEsteGrau))

		endif
		_nAuxGrau ++
	enddo
return _lContinua


// --------------------------------------------------------------------------
// Gera tabela em formato HTML
METHOD GeraHTM () Class ClsTbUva
	local _sHTM       := ''
	local _nGrupo     := 0
	local _nSubgrup   := 0
	local _aTitGrup   := {}
	local _aVarGrau   := {}
	local _nVarGrau   := 0
	local _aLinha     := {}
	local _lAdicionou := .F.
	local _sTag       := ''
	local _sTagICod   := ''
	local _sTagFCod   := ''
	local _nGrau      := 0
	local _sToolTip   := ''
	local _oGrauDeGrupo := NIL
	local _oVariedade := NIL
	local _lTemDescSubgrupo := .F.
	local _nQtColHora := 0

	// Como a quantidade de celulas mescladas eh muito grande, achei melhor
	// preparar arrays com os dados (jah eh bastante complicado) e, num
	// passo seguinte, gerar HTML.

	// Passo 1: preparar arrays de dados para o HTML
	if empty (::CodTabela)
		_Super:SomaMsg ("Codigo de tabela nao definido. Impossivel gerar HTML.")
	else

		// Prepara titulos dos grupos
		_aTitGrup = {}
		aadd (_aTitGrup, '<th> </th>')  // Esta coluna vai ser, posteriormente, usada para o grau.
		for _nGrupo = 1 to len (::Grupos)
			aadd (_aTitGrup, '<th class=' + iif (_nGrupo / 2 == int (_nGrupo / 2), '"TituloGrupoClaro"', '"TituloGrupoEscuro"') + ;
			                 ' colspan=' + cvaltochar (len (::Grupos [_nGrupo]['ListaDeSubgrupos'])) + ' align=center>' + ;
			                 'Gr.' + alltrim (::Grupos [_nGrupo]['Codigo']) + ;
			                 ' ' + alltrim (::Grupos [_nGrupo]['Descricao']) + ;
			                 '</th>')
		next

		_aVarGrau = {}

		// Prepara uma linha com titulos dos subgrupos. Mas, antes, verifica se
		// algum deles tem dados a mostrar, de movo a evitar gerar uma linha
		// vazia no HTML.
		_lTemDescSubgrupo = .F.
		for _nGrupo = 1 to len (::Grupos)
			for _nSubgrup = 1 to len (::Grupos [_nGrupo]['ListaDeSubgrupos'])
				if ! empty (::Grupos [_nGrupo]['ListaDeSubgrupos'][_nSubgrup]['DescSubgrupo'])
					_lTemDescSubgrupo = .T.
					exit
				endif
			next
		next
		if _lTemDescSubgrupo
			//_aLinha = {'<th class="TituloGrupoClaro">Grau</th>'}
			_aLinha = {'<th </th>'}
			for _nGrupo = 1 to len (::Grupos)

				// Para facilitar a visualizacao, a cada troca de grupo, gero
				// as colunas com fundo escuro ou com fundo claro.
				_sTag = '<td class="TituloGrupo' + iif (_IsInt (_nGrupo/2), 'Claro', 'Escuro') + '">'

				for _nSubgrup = 1 to len (::Grupos [_nGrupo]['ListaDeSubgrupos'])
					aadd (_aLinha, _sTag + ::Grupos [_nGrupo]['ListaDeSubgrupos'][_nSubgrup]['DescSubgrupo'] + '</th>')
				next
			next
			aadd (_aVarGrau, aclone (_aLinha))
		endif


		// Para adicionar as linhas com as variedades, optei por fazer um loop
		// com WHILE para rodar ateh o momento em que nao adicionar mais nenhuma
		// linha (cada grupo tem uma quantidade diferente de variedades).
		_nVarGrau = 1
		do while .t.
			_aLinha = {'<td> </td>'}  // Primeira coluna vai ser usada pelo grau
			_lAdicionou = .F.

			// Para cada grupo, verifica se ainda tem variedades a adicionar
			for _nGrupo = 1 to len (::Grupos)

				// Para facilitar a visualizacao, a cada troca de grupo, gero
				// as colunas com fundo escuro ou com fundo claro.
				if _IsInt (_nGrupo / 2)
					_sTag = '<td class="ColunaClaraDescri">'

					// Quero mostrar o codigo do item com uma fonte um pouco menor.
					_sTagICod = '<span class="ColunaClaraCodigo">('
					_sTagFCod = ')</span>'
				else
					_sTag = '<td class="ColunaEscuraDescri">'

					// Quero mostrar o codigo do item com uma fonte um pouco menor.
					_sTagICod = '<span class="ColunaEscuraCodigo">('
					_sTagFCod = ')</span>'
				endif

				// Se ainda tiver variedades neste grupo para serem adicionadas
				// ao HTM, entao devo gerar mais uma linha.
				if _nVarGrau <= len (::Grupos [_nGrupo]['ListaDeVariedades'])
					_oVariedade = ::Grupos [_nGrupo]['ListaDeVariedades'][_nVarGrau]

					// Variedade base sempre vai existir, independente de tipo/conducao
					aadd (_aLinha, _TagVariedade (_oVariedade, 'Base', _sTag, _sTagICod, _sTagFCod))

					// Estas colunas existem somente para uvas comuns
					if ::TipoUva == 'C'
						aadd (_aLinha, _TagVariedade (_oVariedade, 'Bordadura', _sTag, _sTagICod, _sTagFCod))
						aadd (_aLinha, _TagVariedade (_oVariedade, 'Conversao', _sTag, _sTagICod, _sTagFCod))
						aadd (_aLinha, _TagVariedade (_oVariedade, 'Organica', _sTag, _sTagICod, _sTagFCod))
					endif

					_lAdicionou = .T.
				else

					// Preciso colocar um espaco nestas posicoes para gerar uma celula vazia no HTML depois.
					for _nSubgrup = 1 to len (::Grupos [_nGrupo]['ListaDeSubgrupos'])
						aadd (_aLinha, _sTag + ' </td>')
					next
				endif
			next

			// Se nao adicionou mais nenhuma linha na array, eh por que terminou
			// de ler todas as variedades de todos os grupos. Posso sair do loop.
			if ! _lAdicionou
				exit
			endif
			aadd (_aVarGrau, aclone (_aLinha))
			_nVarGrau ++
		enddo


		// Prepara uma linha com dados adicionais dos subgrupos.
		// Geralmente sao os % de organicas (uvas comuns) ou de
		// acrescimos cfe.classificacao (uvas finas).
//		_aLinha = {'<td> </td>'}  // Primeira coluna vai ser usada pelo grau
		_aLinha = {'<th class="TituloGrupoClaro">Grau</th>'}
		for _nGrupo = 1 to len (::Grupos)

			// Para facilitar a visualizacao, a cada troca de grupo, gero
			// as colunas com fundo escuro ou com fundo claro.
			_sTag = '<td class="Coluna' + iif (_IsInt (_nGrupo/2), 'Clara', 'Escura') + 'Descri">'

			for _nSubgrup = 1 to len (::Grupos [_nGrupo]['ListaDeSubgrupos'])
				aadd (_aLinha, _sTag + ::Grupos [_nGrupo]['ListaDeSubgrupos'][_nSubgrup]['ObsSubgrupo'] + '</td>')
			next
		next
		aadd (_aVarGrau, aclone (_aLinha))


		// Adiciona graus e respectivos precos. Como preciso montar uma matriz
		// contendo todas as colunas (de todos os grupos), preciso passar por
		// todos os graus e, dentro desses, cada grupo.
		for _nGrau = 1 to len (::Grupos [1]['ListaDeGraus'])  // Pode ser o primeiro grupo, pois todos devem ser iguais
			_aLinha = {}
			for _nGrupo = 1 to len (::Grupos)
				_oGrauDeGrupo = ::Grupos [_nGrupo]['ListaDeGraus'][_nGrau]

				if _nGrupo == 1
					aadd (_aLinha, '<th class="ColunaClaraDescri">' + transform (_oGrauDeGrupo ['Grau'], iif (_IsInt (_oGrauDeGrupo ['Grau']), "@E 99", "@E 99.9")) + '</th>')
				endif

				// Para facilitar a visualizacao, a cada troca de grupo, gero
				// as colunas com fundo escuro ou com fundo claro.
				if _oGrauDeGrupo ['Grau'] == ::Grupos [_nGrupo]['GrauBase']
					_sTag = '<th class="PrecoGrauBase">'
				else
					if _nGrupo / 2 == int (_nGrupo / 2)
						_sTag = '<th class="ColunaClaraPrecos">'
					else
						_sTag = '<th class="ColunaEscuraPrecos">'
					endif
				endif

				// Define tag para gerar 'tooltip'
				_sToolTip := '<abbr title="'
				_sToolTip += 'Agio a partir do grau base: ' + alltrim (transform (_oGrauDeGrupo ['AgioSobreGrauBase'], "@E 9999.99")) + '%'
				_sToolTip += '&#013;' + alltrim (_oGrauDeGrupo ['ObsGrauDeGrupo'])
				_sToolTip += '">'
			//	U_Log2 ('debug', '[' + procname () + ']' + _sToolTip)

				// Como sempre existe codigo base de cada variedade, este sempre deverah ter preco
				aadd (_aLinha, _sTag + _sToolTip + transform (_oGrauDeGrupo ['PrecoCodBase'], "@E 999.9999") + '</th>')

				// Estas colunas existem somente para uvas comuns
				if ::TipoUva == 'C'
					aadd (_aLinha, _sTag + transform (_oGrauDeGrupo ['PrecoCodOrganicaBordadura'], "@E 999.9999") + '</th>')
					aadd (_aLinha, _sTag + transform (_oGrauDeGrupo ['PrecoCodOrganicaEmConversao'], "@E 999.9999") + '</th>')
					aadd (_aLinha, _sTag + transform (_oGrauDeGrupo ['PrecoCodOrganicaOrganica'], "@E 999.9999") + '</th>')
				endif

			next
			aadd (_aVarGrau, aclone (_aLinha))
		next
	//	U_Log2 ('debug', '[' + procname () + ']_aVarGrau final:')
	//	U_Log2 ('debug', _aVarGrau)

	endif

	// Passo 2: montagem do HTML
	if len (_aVarGrau) == 0
		_Super:SomaMsg ("Sem variedades para esta tabela. Impossivel gerar HTML.")
	else
		// dicas em https://www.w3schools.com/css/css_text_align.asp

		_sHTM := '<!DOCTYPE html><html>'

		// Define classes de estilos CSS para os diferentes tipo de celulas
		_sHTM += '<style>'
		_sHTM +=    '.TituloTabela{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:11.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=       'border-right:none;'  // Para nao aparecer borda entre o titulo e a hora
		_sHTM +=       'height: 30px;'
		_sHTM +=    '}'
		_sHTM +=    '.HoraGeracaoTabela{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=       'border-left:none;'  // Para nao aparecer borda entre o titulo e a hora
		_sHTM +=    '}'
		_sHTM +=    '.TituloGrupoClaro{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.TituloGrupoEscuro{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraDescri{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:left;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraDescri{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:left;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraPrecos{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraPrecos{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraCodigo{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:7.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraCodigo{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:7.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.PrecoGrauBase{'
	//	_sHTM +=       'background:#8497B0;'
		_sHTM +=       'background:#82868b;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM += '</style>'

		_sHTM += '<head>'
		_sHTM +=    '<title>Tabela preços uva</title>'
		_sHTM += '</head>'
		_sHTM += '<body>'
		_sHTM += '<table width="80%" border="1" cellspacing="0" cellpadding="0" align="center">'
		
		// Linhas iniciais da tabela (descricao, tipos de uvas, datas, etc.
		//
		// Reserva colunas (colspan) para data e hora proporcionalmente a qt. total de colunas
		_nQtColHora = round (len (_aVarGrau [1]) / 5, 0)
		//
		_sHTM += '<tr>'
		_sHTM +=    '<th class="TituloTabela" colspan=' + cvaltochar (len (_aVarGrau [1]) - _nQtColHora) + '>'
		_sHTM +=    alltrim (sm0 -> m0_nomecom)
		_sHTM +=    ' - Tabela ' + ::CodTabela + ' (' + alltrim (::NomeTabela) + ')'
		_sHTM +=    ' - uvas <b>' + iif (::TipoUva == 'C', 'comuns', iif (::TipoUva == 'F', 'viniferas', '(SEM DEFINICAO)'))
		_sHTM +=    ' ' + iif (::Conducao == 'L', 'latadas', iif (::Conducao == 'E', 'espaldeira', '(SEM DEFINICAO)')) + '</b>'
		_sHTM +=    '</th>'
		_sHTM +=    '<th class="HoraGeracaoTabela" colspan=' + cvaltochar (_nQtColHora) + '>Gerada pelo ERP em ' + dtoc (date ()) + ' - ' + time () + '</th>'
		_sHTM += '</tr>'
//		_sHTM += '<tr>'
//		_sHTM +=    '<th class="SubTituloTabela" colspan=' + cvaltochar (len (_aVarGrau [1])) + '>Gerada pelo ERP em ' + dtoc (date ()) + ' - ' + time () + '</th>'
//		_sHTM += '</tr>'


		// Linhas de titulos das colunas (nomes dos grupos, grau base, etc)
	//	U_Log2 ('debug', '[' + procname () + ']Montando linha titulos grupos')
		_sHTM += '<tr>'
		for _nGrupo = 1 to len (_aTitGrup)
			_sHTM += _aTitGrup [_nGrupo]
		next
		_sHTM += '</tr>'

		// Adiciona as variedades ao grid
		for _nVarGrau = 1 to len (_aVarGrau)
			_sHTM += '<tr>'
			for _nGrupo = 1 to len (_aVarGrau [_nVarGrau])
				_sHTM += _aVarGrau [_nVarGrau, _nGrupo]
			next
			_sHTM += '</tr>
		next

		_sHTM += '</table>'
		_sHTM += '</body></html>'
	endif
return _sHTM


// --------------------------------------------------------------------------
static function _IsInt (_nValor as numeric)
return (_nValor == int (_nValor))


// --------------------------------------------------------------------------
static function _TagVariedade (_oVariedade as JSON, _sQualCodigo as character, _sTag as character, _sTagICod as character, _sTagFCod as character)
	local _sRet := ''
	local _sCodigoVariedade := ''
	local _sDescrVariedade := ''
	local _sToolTip := ''
	do case
		case _sQualCodigo == 'Base'
			_sCodigoVariedade = _oVariedade ['CodBase']
			_sDescrVariedade  = _oVariedade ['DescrBase']
		case _sQualCodigo == 'Bordadura'
			_sCodigoVariedade = _oVariedade ['CodBordadura']
			_sDescrVariedade  = _oVariedade ['DescrBordadura']
		case _sQualCodigo == 'Conversao'
			_sCodigoVariedade = _oVariedade ['CodEmConversao']
			_sDescrVariedade  = _oVariedade ['DescrEmConversao']
		case _sQualCodigo == 'Organica'
			_sCodigoVariedade = _oVariedade ['CodOrganica']
			_sDescrVariedade  = _oVariedade ['DescrOrganica']
	endcase

	// Define tag para 'tooltip'
	_sToolTip += '<abbr title="
	_sToolTip += _sDescrVariedade
	_sToolTip += '&#10;Cor: ' + iif (_oVariedade ['Cor'] == 'T', 'Tinta', iif (_oVariedade ['Cor'] == 'B', 'Branca', 'Rosada'))
	if _oVariedade ['Cor'] == 'T'
		_sToolTip += iif (_oVariedade ['Tintorea'] == 'S', ' (tintórea)', ' (não tintórea)')
	endif
	//_sToolTip += '&#10;Grau médio safra 2023:'
	//_sToolTip += '&#10;Kg recebidos safra 2023:'
	_sToolTip += '">'

	_sRet += _sTag
	if ! empty (_sCodigoVariedade)
		_sRet += alltrim (strtran (_sDescrVariedade, '.', ' '))
		_sRet += _sTagICod
		_sRet += _sToolTip
		_sRet += alltrim (_sCodigoVariedade)
		_sRet += _sTagFCod
		_sRet += '</td>'
	else
		_sRet += ' </td>'
	endif
return _sRet

