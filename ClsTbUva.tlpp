// Programa:  ClsTbUva
// Autor:     Robert Koch
// Data:      22/05/2023 (inicio)
// Descricao: Declaracao de classe de representacao de tabelas de preco de uvas para safra.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa tabelas de precos de uvas para compra de safra.
// #PalavasChave      #safra #uva #tabela_preco
// #TabelasPrincipais #ZX5 SB1
// #Modulos           #COOP

// Historico de alteracoes:
//

#Include "Protheus.ch"
#include "VA_INCLU.prw"
//#Include "TbiConn.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsTbUva ()
return


// ==========================================================================
CLASS ClsTbUva

	// Declaracao das propriedades da Classe
	public data CodTabela   // Pode existir mais de uma tabela para cada safra (simulacoes, etc)
	public data Conducao    // [E]spaldeira, [L]atada
	public data GrauDecimal // [D]ecimais, [I]nteiros
	public data Grupos      // Grupos de uvas cfe. tabela 13 do ZX5
	public data SubGrupos   // Subgrupos de uvas cfe. tabela 13 do ZX5
	public data Safra
	public data TipoPreco   // [E]ntrada, [C]ompra, [M]oc(CONAB)
	public data TipoUva     // [C]omum, [F]ina
	public data UltMsg      // Mensagens (geralmente de erro)
//	public data Varied      // Array de atributos de cada variedade (para encontrar rapidamente)

	// Declaracao dos Metodos da classe
	public METHOD New ()
	public METHOD GeraAtrib ()
	public METHOD GeraHTM ()
	public METHOD GeraPrecos ()
	private METHOD Prc2023 ()
	private METHOD SomaMsg ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor.
METHOD New () Class ClsTbUva

	// Valores default
	::CodTabela   = ''
	::Conducao    = ''
	::GrauDecimal = ''
	::Grupos      = {}
	::SubGrupos   = {}
	::Safra       = ''
	::TipoPreco   = ''
	::TipoUva     = ''
	::UltMsg      = ''
//	::Varied      = {}
Return ::self


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sCodTab, _sTipoPrc, _sTipoUva, _sConduc, _sGrauDec) Class ClsTbUva
	local _lContinua := .T.
	local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _nGrupo    := 0
	local _aDados    := {}
	local _nDado     := 0
	local _sAliasQ   := ''
	local _aAux      := {}
	local _nGrau     := 0
	local _nStepGrau := 0

	if empty (_sCodTab)
		::SomaMsg ("Codigo da tabela deve ser informado.")
		_lContinua = .F.
	else
		::CodTabela   = _sCodTab
	endif
	if empty (_sConduc)
		::SomaMsg ("Sistema de conducao latada (L) ou espaldeira (E) deve ser informado.")
		_lContinua = .F.
	else
		::Conducao    = _sConduc
	endif
	if empty (_sGrauDec)
		::SomaMsg ("Opcao para gerar graus decimais (D) ou inteiros (I) deve ser informada.")
		_lContinua = .F.
	else
		::GrauDecimal = _sGrauDec
	endif
	if empty (_sTipoPrc)
		::SomaMsg ("Tipo de preco (C=compra; M=MOC) deve ser informada.")
		_lContinua = .F.
	else
		::TipoPreco   = _sTipoPrc
	endif
	if empty (_sTipoUva)
		::SomaMsg ("Tipo de uva (C=comum;V=vinifera) deve ser informado.")
		_lContinua = .F.
	else
		::TipoUva     = _sTipoUva
	endif

	// Gera uma lista de grupos relacionados ao tipo de uvas solicitado.
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT ZX5_13SAFR, ZX5_13GRUP, ZX5_13DESC, ZX5_13GBAS"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5_13 "
		_oSQL:_sQuery += " WHERE ZX5_13.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_TABELA = '13'"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_13SAFR = '" + ::CodTabela + "'"
		_oSQL:_sQuery +=   " AND LEN (ZX5_13.ZX5_13GRUP) >= 3"  // Nao quero listar os 'grandes grupos'
		if ::TipoUva == 'C'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '1%'"  // Lista comuns
		elseif ::TipoUva == 'F' .and. ::Conducao == 'E'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '2%'"  // Lista finas espaldeira
		elseif ::TipoUva == 'F' .and. ::Conducao == 'L'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '3%'"  // Lista finas latadas
		else
			::SomaMsg ("Sem tratamento para tipo de uva '" + ::TipoUva + "'.")
			_lContinua = .F.
		endif
		_oSQL:_sQuery += " ORDER BY ZX5_13GRUP"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
	//	U_Log2 ('debug', '[' + procname () + ']_aDados:')
	//	u_log (_aDados)
		if len (_aDados) == 0
			::SomaMsg ("Tabela de precos '" + ::CodTabela + "' nao existe, ou nao tem nenhum grupo de variedades informado.")
			_lContinua = .F.
		endif
	endif
	if _lContinua
		::Safra = _aDados [1, 1]
		if empty (::Safra)
			::SomaMsg ("Safra nao definida.")
			_lContinua = .F.
		endif
	endif
	
	// Alimenta array de grupos
	if _lContinua
		::Grupos = {}
		for _nDado = 1 to len (_aDados)
			aadd (::Grupos, array (.TbUvaGruposQtColunas))
			::Grupos [len (::Grupos), .TbUvaGruposCodigo]    = _aDados [_nDado, 2]
			::Grupos [len (::Grupos), .TbUvaGruposDescricao] = _aDados [_nDado, 3]
			::Grupos [len (::Grupos), .TbUvaGruposGrauBase]  = _aDados [_nDado, 4]
			::Grupos [len (::Grupos), .TbUvaGruposListaUvas] = {}
	//		U_Log2 ('debug', '[' + procname () + ']::Grupo adicionado:')
			U_Log2 ('debug', ::Grupos [len (::Grupos)])
		next
	endif

	// Para cada grupo criado, cria uma lista com as suas variedades.
	if _lContinua
		for _nGrupo = 1 to len (::Grupos)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT V.*"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5_14 "
			_oSQL:_sQuery +=      ", VA_VFAMILIAS_UVAS V "
			_oSQL:_sQuery += " WHERE ZX5_14.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_TABELA = '14'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14SAFR = '" + ::CodTabela + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + ::Grupos [_nGrupo, .TbUvaGruposCodigo] + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14PROD = V.COD_BASE"
			_oSQL:_sQuery += " ORDER BY V.DESCR_BASE, V.COD_BASE"
	//		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			_sAliasQ := _oSQL:Qry2Trb (.F.)
			(_sAliasQ) -> (dbgotop ())
			_aAux = {}
			do while ! (_sAliasQ) -> (eof ())
				aadd (_aAux, array (.TbUvaGruposListaUvasQtColunas))
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodBase]            = (_sAliasQ) -> cod_base
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrBase]          = (_sAliasQ) -> desc_resum
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodEmConversao]     = (_sAliasQ) -> cod_em_conversao
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrEmConversao]   = (_sAliasQ) -> desc_resum_em_conversao
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodBordadura]       = (_sAliasQ) -> cod_bordadura
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrBordadura]     = (_sAliasQ) -> desc_resum_bordadura
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodOrganica]        = (_sAliasQ) -> cod_organica
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrOrganica]      = (_sAliasQ) -> desc_resum_organica
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodFinaClas_comum]  = (_sAliasQ) -> cod_fina_clas_comum
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrFinaClasComum] = (_sAliasQ) -> desc_resum_fina_clas_comum
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodParaEspumante]   = (_sAliasQ) -> cod_para_espumante
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrParaEspumante] = (_sAliasQ) -> desc_resum_para_espumante
				_aAux [len (_aAux), .TbUvaGruposListaUvasFinaOuComum]        = (_sAliasQ) -> fina_comum
				_aAux [len (_aAux), .TbUvaGruposListaUvasCor]                = (_sAliasQ) -> cor
				_aAux [len (_aAux), .TbUvaGruposListaUvasTintorea]           = (_sAliasQ) -> tintorea
				(_sAliasQ) -> (dbskip ())
			enddo
			::Grupos [_nGrupo, .TbUvaGruposListaUvas] = aclone (_aAux)
	//		U_Log2 ('debug', '[' + procname () + ']::Grupo com variedades:')
	//		U_Log2 ('debug', ::Grupos [_nGrupo])
	//		U_Log2 ('debug', ::Grupos [_nGrupo, .TbUvaGruposListaUvas])
		next
	endif

	// Para cada grupo criado, cria uma lista com graus e respectivos precos.
	if _lContinua
		U_Log2 ('debug', '[' + procname () + ']::GrauDecimal = ' + ::GrauDecimal)
		_nStepGrau = iif (::GrauDecimal == 'D', 0.1, 1)
		U_Log2 ('debug', '[' + procname () + ']StepGrau = ' + cvaltochar (_nStepGrau))
		for _nGrupo = 1 to len (::Grupos)
			
			// Aumentar ou diminuir aqui a faixa de graus se necessario.
			// Uso essa faixa tem uns 10 anos e nao me faltou nada ainda...
			_aAux = {}
			for _nGrau = 14 to 17 step _nStepGrau  // iif (::GrauDecimal == 'N', 1, 0.1)  //6 to 26 step 0.1
				aadd (_aAux, afill (array (.TbUvaGruposPrcQtColunas), 0))
				_aAux [len (_aAux), .TbUvaGruposPrcGrau]                    = _nGrau
				_aAux [len (_aAux), .TbUvaGruposPrcCompraCodBase]           = 1  // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcCompraCodBordadura]      = 1.1  // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcCompraCodEmConversao]    = 1.2  // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcCompraCodOrganica]       = 1.3  // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcCompraCodFinaClas_comum] = 2.1  // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcCompraCodParaEspumante]  = 2.2  // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcMOCCodBase]              = 3  // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcMOCCodBordadura]         = 3.1 // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcMOCCodEmConversao]       = 3.2  // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcMOCCodOrganica]          = 3.3  // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcMOCCodFinaClas_comum]    = 4.1  // Ainda nao sei como vou fazer aqui
				_aAux [len (_aAux), .TbUvaGruposPrcMOCCodParaEspumante]     = 4.2  // Ainda nao sei como vou fazer aqui
			next
//			U_Log2 ('debug', _aAux)
			::Grupos [_nGrupo, .TbUvaGruposPrecos] = aclone (_aAux)
		next
	endif

	// Gera os precos
	if _lContinua
		do case
		case ::Safra == '2023'
			if ! ::Prc2023 ()
				::SomaMsg ("Erro ao gerar os precos.")
				_lContinua = .F.
			endif
		otherwise
			::SomaMsg ("Sem definicao para geracao de precos para esta safra.")
			_lContinua = .F.
		endcase
	endif

	// Se deu algum problema, limpa os dados principais para inutilizar o objeto.
	if ! _lContinua
		::CodTabela = ''
		::Grupos    = {}
		::Safra     = ''
	endif

	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Nao vou fazer a geracao dos precos dentro do metodo GeraAtrib() por que a
// cada safra temos novas regras.
// Penso em chamar uma static function (ou metodo) para cada safra.
METHOD Prc2023 () Class ClsTbUva
	local _lRetGPrc := .T.
return _lRetGPrc


// --------------------------------------------------------------------------
// Gera tabela em formato HTML
METHOD GeraHTM () Class ClsTbUva
	local _sHTM       := ''
	local _nGrupo     := 0
	local _aSubgrup   := {}
	local _nSubgrup   := 0
	local _aTitGrup   := {}
	local _aVarGrau   := {}
	local _nVarGrau   := 0
	local _aLinha     := {}
	local _aAux       := {}
	local _lAdicionou := .F.
	local _sTag       := ''
	local _sTagICod   := ''
	local _sTagFCod   := ''
	local _nGrau      := 0
	local _nCPCBas    := 0
	local _nCPCBord   := 0
	local _nCPEmConv  := 0
	local _nCPOrg     := 0
	local _nCPEspum   := 0
	local _nCPFinaCC  := 0

	// Como a quantidade de celulas mescladas eh muito grande, achei melhor
	// preparar arrays com os dados (jah eh bastante complicado) e, num
	// passo seguinte, gerar HTML.

	// Passo 1: preparar arrays de dados para o HTML
	if empty (::CodTabela)
		::SomaMsg ("Codigo de tabela nao definido. Impossivel gerar HTML.")
	else

		// Uvas comuns: 4 subcolunas (convenc/bordadura/em conv/organ)
		// Uvas viniferas em espaldeira: 2 subcolunas (para vinho/para espumante)
		// Uvas viniferas latadas: nenhuma subcoluna
		if ::TipoUva == 'C'
			_aSubgrup = {'Convencional', 'Bordadura', 'Em conversão', 'Orgânica'}
		elseif ::TipoUva == 'F' .and. ::Conducao == 'E'
			_aSubGrup = {'Para vinho', 'Para espumante'}
		else
			_aSubGrup = {''}
		endif
		U_Log2 ('debug', '[' + procname () + ']_aSubGrup:')
		U_Log2 ('debug', _aSubGrup)

		// Prepara titulos dos grupos
		_aTitGrup = {}
		aadd (_aTitGrup, '<th> </th>')  // Esta coluna vai ser, posteriormente, usada para o grau.
		for _nGrupo = 1 to len (::Grupos)
			aadd (_aTitGrup, '<th class=' + iif (_nGrupo / 2 == int (_nGrupo / 2), '"TituloGrupoClaro"', '"TituloGrupoEscuro"') + ;
			                 ' colspan=' + cvaltochar (len (_aSubGrup)) + ' align=center>' + ;
			                 'Grp.' + alltrim (::Grupos [_nGrupo, .TbUvaGruposCodigo]) + ;
			                 ' ' + alltrim (::Grupos [_nGrupo, .TbUvaGruposDescricao]) + ;  // ' (gb ' + cvaltochar (::Grupos [_nGrupo, .TbUvaGruposGrauBase]) + ')' + ;
			                 '</th>')
		next

		// Prepara titulos dos subgrupos
		_aVarGrau = {}
		_aLinha = {'<th class="TituloGrupoClaro">Grau</th>'}
		for _nGrupo = 1 to len (::Grupos)

			// Para facilitar a visualizacao, a cada troca de grupo, gero
			// as colunas com fundo escuro ou com fundo claro.
			if _nGrupo / 2 == int (_nGrupo / 2)
				_sTag = '<th class="TituloGrupoClaro">'
			else
				_sTag = '<th class="TituloGrupoEscuro">'
			endif

			for _nSubgrup = 1 to len (_aSubgrup)
				aadd (_aLinha, _sTag + _aSubgrup [_nSubgrup] + '</th>')
			next
		next
		aadd (_aVarGrau, aclone (_aLinha))
		U_Log2 ('debug', '[' + procname () + ']_aVarGrau depois de incluir os subgrupos:')
		U_Log2 ('debug', _aVarGrau)

		// Para adicionar as linhas com as variedades, optei por fazer um loop
		// com WHILE para rodar ateh o momento em que nao adicionar mais nenhuma
		// linha (cada grupo tem uma quantidade diferente de linhas).
		_nVarGrau = 1
		do while .t.
		//	U_Log2 ('debug', '[' + procname () + ']_nVarGrau=' + cvaltochar (_nVarGrau))
			_aLinha = {'<td> </td>'}  // Primeira coluna vai ser usada pelo grau
			_lAdicionou = .F.
			// Para cada grupo, verifica se ainda tem variedades a adicionar
			for _nGrupo = 1 to len (::Grupos)
		//		U_Log2 ('debug', '[' + procname () + ']_nGrupo=' + cvaltochar (_nGrupo))

				// Para facilitar a visualizacao, a cada troca de grupo, gero
				// as colunas com fundo escuro ou com fundo claro.
				if _nGrupo / 2 == int (_nGrupo / 2)
					_sTag = '<td class="ColunaClaraDescri">'

					// Quero mostrar o codigo do item com uma fonte um pouco menor.
					_sTagICod = '<span class="ColunaClaraCodigo">('
					_sTagFCod = ')</span>'
				else
					_sTag = '<td class="ColunaEscuraDescri">'

					// Quero mostrar o codigo do item com uma fonte um pouco menor.
					_sTagICod = '<span class="ColunaEscuraCodigo">('
					_sTagFCod = ')</span>'
				endif
				_aAux = aclone (::Grupos [_nGrupo, .TbUvaGruposListaUvas])
				if _nVarGrau <= len (_aAux)

					// Variedade base sempre deve existir, independente de tipo/conducao
					if ! empty (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodBase])
						aadd (_aLinha, _sTag + ;
										alltrim (strtran (_aAux [_nVarGrau, .TbUvaGruposListaUvasDescrBase], '.', ' ')) + ;
										_sTagICod + ;
										alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodBase]) + ;
										_sTagFCod + ;
										'</td>')
					else
						aadd (_aLinha, ' </td>')
					endif

					// Estas colunas existem somente para uvas comuns
					if ::TipoUva == 'C'
						if ! empty (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodBordadura])
							aadd (_aLinha, _sTag + ;
											alltrim (strtran (_aAux [_nVarGrau, .TbUvaGruposListaUvasDescrBordadura], '.', ' ')) + ;
											_sTagICod + ;
											alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodBordadura]) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
						if ! empty (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodEmConversao])
							aadd (_aLinha, _sTag + ;
											alltrim (strtran (_aAux [_nVarGrau, .TbUvaGruposListaUvasDescrEmConversao], '.', ' ')) + ;
											_sTagICod + ;
											alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodEmConversao]) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
						if ! empty (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodOrganica])
							aadd (_aLinha, _sTag + ;
											alltrim (strtran (_aAux [_nVarGrau, .TbUvaGruposListaUvasDescrOrganica], '.', ' ')) + ;
											_sTagICod + ;
											alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodOrganica]) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
					endif

					// Esta coluna existe somente para viniferas em espaldeira
					if ::TipoUva == 'F' .and. ::Conducao == 'E'
						if ! empty (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodParaEspumante])
							aadd (_aLinha, _sTag + ;
											alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasDescrParaEspumante]) + ;
											_sTagICod + ;
											alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodParaEspumante]) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
					endif
					_lAdicionou = .T.
		//			U_Log2 ('debug', '[' + procname () + ']Adicionei variedades e ficou assim:')
		//			U_Log2 ('debug', _aLinha)
				else
		//			U_Log2 ('debug', '[' + procname () + ']Este grupo nao tem mais variedades.')
					// Preciso colocar um espaco nestas posicoes para gerar uma celula vazia no HTML depois.
					for _nSubgrup = 1 to len (_aSubgrup)
						aadd (_aLinha, _sTag + ' </td>')
					next
		//			U_Log2 ('debug', '[' + procname () + ']Adicionei vazios e ficou assim:')
		//			U_Log2 ('debug', _aLinha)
				endif
			next

			// Se nao adicionou mais nenhuma linha na array, eh por que terminou
			// de ler todas as variedades de todos os grupos. Posso sair do loop.
			if ! _lAdicionou
				exit
			endif
			aadd (_aVarGrau, aclone (_aLinha))
			_nVarGrau ++
		enddo
//		U_Log2 ('debug', _aVarGrau)

		// Insere a palavra 'Grau' na ultima linha das variedades.
		//_aVarGrau [len (_aVarGrau), 1] = '<th class="ColunaClaraDescri">Grau</th>'


		// Define variaveis para ter de forma um pouco mais pratica as colunas de onde buscar os precos.
		if ::TipoPreco == 'C'
			_nCPCBas   = .TbUvaGruposPrcCompraCodBase
			_nCPCBord  = .TbUvaGruposPrcCompraCodBordadura
			_nCPEmConv = .TbUvaGruposPrcCompraCodEmConversao
			_nCPOrg    = .TbUvaGruposPrcCompraCodOrganica
			_nCPFinaCC = .TbUvaGruposPrcCompraCodFinaClas_comum
			_nCPEspum  = .TbUvaGruposPrcCompraCodParaEspumante
		elseif ::TipoPreco == 'M'
			_nCPCBas   = .TbUvaGruposPrcMOCCodBase
			_nCPCBord  = .TbUvaGruposPrcMOCCodBordadura
			_nCPEmConv = .TbUvaGruposPrcMOCCodEmConversao
			_nCPOrg    = .TbUvaGruposPrcMOCCodOrganica
			_nCPFinaCC = .TbUvaGruposPrcMOCCodFinaClas_comum
			_nCPEspum  = .TbUvaGruposPrcMOCCodParaEspumante
		endif

		// Adiciona graus e respectivos precos. Como preciso montar uma matriz
		// contendo todas as colunas (de todos os grupos), preciso passar por
		// todos os graus e, dentro desses, cada grupo.
		for _nGrau = 1 to len (::Grupos [1, .TbUvaGruposPrecos])  // Pode ser o primeiro grupo, pois todos devem ser iguais
			_aLinha = {}
			for _nGrupo = 1 to len (::Grupos)
				_aAux = aclone (::Grupos [_nGrupo, .TbUvaGruposPrecos])

				if _nGrupo == 1
					if _aAux [_nGrau, .TbUvaGruposPrcGrau] == int (_aAux [_nGrau, .TbUvaGruposPrcGrau])
						aadd (_aLinha, '<th class="ColunaClaraDescri">' + transform (_aAux [_nGrau, .TbUvaGruposPrcGrau], "@E 99") + '</th>')
					else
						aadd (_aLinha, '<th class="ColunaClaraDescri">' + transform (_aAux [_nGrau, .TbUvaGruposPrcGrau], "@E 99.9") + '</th>')
					endif
				endif

				// Para facilitar a visualizacao, a cada troca de grupo, gero
				// as colunas com fundo escuro ou com fundo claro.
				if _aAux [_nGrau, .TbUvaGruposPrcGrau] == ::Grupos [_nGrupo, .TbUvaGruposGrauBase]
					_sTag = '<th class="PrecoGrauBase">'
				else
					if _nGrupo / 2 == int (_nGrupo / 2)
						_sTag = '<th class="ColunaClaraPrecos">'
					else
						_sTag = '<th class="ColunaEscuraPrecos">'
					endif
				endif
			//	U_Log2 ('debug', '[' + procname () + ']Grupo ' + cvaltochar (_nGrupo) + ' _aAux:')
			//	U_Log2 ('debug', _aAux)

				// O codigo base sempre deve ter preco
				aadd (_aLinha, _sTag + transform (_aAux [_nGrau, _nCPCBas], "@E 999.9999") + '</th>')

				// Estas colunas existem somente para uvas comuns
				if ::TipoUva == 'C'
					aadd (_aLinha, _sTag + transform (_aAux [_nGrau, _nCPCBord ], "@E 999.9999") + '</th>')
					aadd (_aLinha, _sTag + transform (_aAux [_nGrau, _nCPEmConv], "@E 999.9999") + '</th>')
					aadd (_aLinha, _sTag + transform (_aAux [_nGrau, _nCPOrg   ], "@E 999.9999") + '</th>')
				endif

				// Esta coluna existe somente para viniferas em espaldeira
				if ::TipoUva == 'F' .and. ::Conducao == 'E'
					aadd (_aLinha, _sTag + transform (_aAux [_nGrau, _nCPEspum], "@E 999.9999") + '</th>')
				endif
			next
		//	U_Log2 ('debug', _aLinha)
			aadd (_aVarGrau, aclone (_aLinha))
		next
		U_Log2 ('debug', '[' + procname () + ']_aVarGrau final:')
		U_Log2 ('debug', _aVarGrau)





	//	for _nVarGrau = 1 to len (_aVarGrau)
	//		U_Log2 ('debug', '[' + procname () + ']Linha ' + cvaltochar (_nVarGrau) + ' tam = ' + cvaltochar (len (_aVarGrau [_nVarGrau])))
	//	next
	endif

	// Passo 2: montagem do HTML
	if len (_aVarGrau) == 0
		::SomaMsg ("Sem variedades para esta tabela. Impossivel gerar HTML.")
	else
		// dicas em https://www.w3schools.com/css/css_text_align.asp

		_sHTM := '<!DOCTYPE html><html>'

		// Define classes de estilos CSS para os diferentes tipo de celulas
		_sHTM += '<style>'
		_sHTM +=    '.TituloTabela{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:11.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.SubTituloTabela{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.TituloGrupoClaro{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.TituloGrupoEscuro{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraDescri{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:left;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraPrecos{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraCodigo{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:7.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraDescri{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:left;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraPrecos{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraCodigo{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:7.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.PrecoGrauBase{'
	//	_sHTM +=       'background:#8497B0;'
		_sHTM +=       'background:#82868b;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM += '</style>'

		_sHTM += '<head>'
		_sHTM +=    '<title>Tabela uva safra</title>'
		_sHTM += '</head>'
		_sHTM += '<body>'
		_sHTM += '<table width="80%" border="1" cellspacing="0" cellpadding="0" align="center">'
		
		// Linhas iniciais da tabela (descricao, tipos de uvas, datas, etc.
		_sHTM += '<tr>'
		_sHTM +=    '<th class="TituloTabela" colspan=' + cvaltochar (len (_aVarGrau [1])) + '>'
		_sHTM +=    alltrim (sm0 -> m0_nomecom)
		_sHTM +=    ' - Tabela ' + ::CodTabela + ' (preço '
			if ::TipoPreco == 'E'
				_sHTM += 'de entrada'
			elseif ::TipoPreco == 'C'
				_sHTM += 'de compra'
			elseif ::TipoPreco == 'M'
				_sHTM += 'MOC'
			else
				_sHTM += '[OUTRAS NAO DEFINIDAS]'
			endif
			_sHTM += ')'
			_sHTM += ' - uvas ' + iif (::TipoUva == 'C', 'comuns', iif (::TipoUva == 'F', 'viniferas', '(SEM DEFINICAO)'))
			_sHTM += ' ' + iif (::Conducao == 'L', 'latadas', iif (::Conducao == 'E', 'espaldeira', '(SEM DEFINICAO)'))
			_sHTM += ' - safra ' + ::Safra
			_sHTM += '</th>'
		_sHTM += '</tr>'
		_sHTM += '<tr>'
		_sHTM +=    '<th class="SubTituloTabela" colspan=' + cvaltochar (len (_aVarGrau [1])) + '>Gerada pelo ERP em ' + dtoc (date ()) + ' - ' + time () + '</th>'
		_sHTM += '</tr>'


		// Linhas de titulos das colunas (nomes dos grupos, grau base, etc)
		U_Log2 ('debug', '[' + procname () + ']Montando linha titulos grupos')
		_sHTM += '<tr>'
		for _nGrupo = 1 to len (_aTitGrup)
			_sHTM += _aTitGrup [_nGrupo]
		next
		_sHTM += '</tr>'

		// Adiciona as variedades ao grid
		for _nVarGrau = 1 to len (_aVarGrau)
			_sHTM += '<tr>'
			for _nGrupo = 1 to len (_aVarGrau [_nVarGrau])
				_sHTM += _aVarGrau [_nVarGrau, _nGrupo]
			next
			_sHTM += '</tr>
		next

		_sHTM += '</table>'
		_sHTM += '</body></html>'
	endif
return _sHTM


// --------------------------------------------------------------------------
// Adiciona (sempre no inicio, para que a mensagem mais recente seja vista
// antes) uma mensagem na string ::UltMsg
METHOD SomaMsg (_sMsg) Class ClsTbUva
	local _sMsgAux := alltrim (cvaltochar (_sMsg))
	if ! alltrim (_sMsgAux) $ ::UltMsg
		::UltMsg = alltrim (_sMsgAux) + '; ' + ::UltMsg
	endif
return
