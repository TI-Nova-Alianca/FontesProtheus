// Programa:  ClsTbUva
// Autor:     Robert Koch
// Data:      22/05/2023 (inicio)
// Descricao: Declaracao de classe de representacao de tabelas de preco de uvas para safra.
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Classe
// #Descricao         #Representa tabelas de precos de uvas para compra de safra.
// #PalavasChave      #safra #uva #tabela_preco
// #TabelasPrincipais #ZX5 SB1
// #Modulos           #COOP

// Historico de alteracoes:
// 12/11/2023 - Robert - Gravacao de agios em array interna e inicio de definicao de formulas para calculo de precos.
//

#Include "Protheus.ch"
#include "VA_INCLU.prw"
//#Include "TbiConn.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsTbUva ()
return


// ==========================================================================
CLASS ClsTbUva

	// Declaracao das propriedades da Classe
	private data AgiosGraus  // Array contendo os agios a serem aplicados a partir do grau base
	public  data CodTabela   // Pode existir mais de uma tabela para cada safra (simulacoes, etc)
	public  data Conducao    // [E]spaldeira, [L]atada
	public  data GrauDecimal // [D]ecimais, [I]nteiros
	private data GrauIniTab  // Grau inicial a ser gerado
	private data GrauFimTab  // Grau final a ser gerado
	public  data Grupos      // Grupos de uvas cfe. tabela 13 do ZX5
	public  data SubGrupos   // Subgrupos de uvas cfe. tabela 13 do ZX5
	public  data TipoPreco   // [E]ntrada, [C]ompra, [M]oc(CONAB)
	public  data TipoUva     // [C]omum, [F]ina
	public  data UltMsg      // Mensagens (geralmente de erro)

	// Declaracao dos Metodos da classe
	public  METHOD New ()
	private METHOD DefPAgio ()
	public  METHOD GeraAtrib ()
	public  METHOD GeraHTM ()
	public  METHOD GeraPrecos ()
	private METHOD Prc2023 ()
	private METHOD SomaMsg ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor.
METHOD New () Class ClsTbUva

	// Valores default
	::CodTabela   = ''
	::Conducao    = ''
	::GrauDecimal = ''

	// Aumentar ou diminuir aqui a faixa de graus se necessario.
	// Uso essa faixa tem uns 10 anos e nao me faltou nada ainda...
	::GrauIniTab  = 12  // 6
	::GrauFimTab  = 18  // 26

	::Grupos      = {}
	::SubGrupos   = {}
	::TipoPreco   = ''
	::TipoUva     = ''
	::UltMsg      = ''
Return ::self


// --------------------------------------------------------------------------
// Alimenta os atributos da classe.
METHOD GeraAtrib (_sCodTab, _sTipoPrc, _sTipoUva, _sConduc, _sGrauDec) Class ClsTbUva
	local _lContinua := .T.
	local _aAreaAnt  := U_ML_SRArea ()
	local _oSQL      := NIL
	local _nGrupo    := 0
	local _aDados    := {}
	local _nDado     := 0
	local _sAliasQ   := ''
	local _aAux      := {}

	if empty (_sCodTab)
		::SomaMsg ("Codigo da tabela deve ser informado.")
		_lContinua = .F.
	else
		::CodTabela   = _sCodTab
	endif
	if empty (_sConduc)
		::SomaMsg ("Sistema de conducao latada (L) ou espaldeira (E) deve ser informado.")
		_lContinua = .F.
	else
		::Conducao    = _sConduc
	endif
	if empty (_sGrauDec)
		::SomaMsg ("Opcao para gerar graus decimais (D) ou inteiros (I) deve ser informada.")
		_lContinua = .F.
	else
		::GrauDecimal = _sGrauDec
	endif
	if empty (_sTipoPrc)
		::SomaMsg ("Tipo de preco (C=compra; M=MOC) deve ser informada.")
		_lContinua = .F.
	else
		::TipoPreco   = _sTipoPrc
	endif
	if empty (_sTipoUva)
		::SomaMsg ("Tipo de uva (C=comum;V=vinifera) deve ser informado.")
		_lContinua = .F.
	else
		::TipoUva     = _sTipoUva
	endif

	// Gera uma lista de grupos relacionados ao tipo de uvas solicitado.
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT ZX5_13SAFR, ZX5_13GRUP, ZX5_13DESC, ZX5_13GBAS, ZX5_13GMAG, ZX5_13PMIN"
		if ::TipoPreco == 'C'
			_oSQL:_sQuery += ", ZX5_13PBCO"
		else
			_oSQL:_sQuery += ", 0 as preco"  // Ainda tenho que ver de onde pegar
		endif
		_oSQL:_sQuery += ", ZX5_13AEPR, ZX5_13AEAA, ZX5_13AEA, ZX5_13AEB, ZX5_13AEC, ZX5_13AED, ZX5_13AEDS, ZX5_13ALA, ZX5_13ALB, ZX5_13ALD, ZX5_13ALDS"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5_13 "
		_oSQL:_sQuery += " WHERE ZX5_13.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_TABELA = '13'"
		_oSQL:_sQuery +=   " AND ZX5_13.ZX5_13SAFR = '" + ::CodTabela + "'"
		_oSQL:_sQuery +=   " AND LEN (ZX5_13.ZX5_13GRUP) >= 3"  // Nao quero listar os 'grandes grupos'
		if ::TipoUva == 'C'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '1%'"  // Lista comuns
		elseif ::TipoUva == 'F' .and. ::Conducao == 'E'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '2%'"  // Lista finas espaldeira
		elseif ::TipoUva == 'F' .and. ::Conducao == 'L'
			_oSQL:_sQuery += " AND ZX5_13.ZX5_13GRUP like '3%'"  // Lista finas latadas
		else
			::SomaMsg ("Sem tratamento para tipo de uva '" + ::TipoUva + "'.")
			_lContinua = .F.
		endif

		// Quero ignorar grupos que existem na tabela 13, mas que nao tenham
		// nenhuma variedade ligada a eles pela tabela 14.
		_oSQL:_sQuery += " AND EXISTS (SELECT *"
		_oSQL:_sQuery +=               " FROM " + RetSQLName ("ZX5") + " ZX5_14 "
		_oSQL:_sQuery +=              " WHERE ZX5_14.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_TABELA = '14'"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_14SAFR =  ZX5_13.ZX5_13SAFR"
		_oSQL:_sQuery +=                " AND ZX5_14.ZX5_14GRUP =  ZX5_13.ZX5_13GRUP"
		_oSQL:_sQuery +=             ")"

		_oSQL:_sQuery += " ORDER BY ZX5_13GRUP"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
	//	U_Log2 ('debug', '[' + procname () + ']_aDados:')
	//	u_log (_aDados)
		if len (_aDados) == 0
			::SomaMsg ("Tabela de precos '" + ::CodTabela + "' nao existe, ou nao tem nenhum grupo de variedades informado.")
			_lContinua = .F.
		endif
	endif
	
	// Alimenta array de grupos
	if _lContinua
		::Grupos = {}
		for _nDado = 1 to len (_aDados)
			aadd (::Grupos, array (.TbUvaGruposQtColunas))
			::Grupos [len (::Grupos), .TbUvaGruposCodigo]          = _aDados [_nDado, 2]
			::Grupos [len (::Grupos), .TbUvaGruposDescricao]       = _aDados [_nDado, 3]
			::Grupos [len (::Grupos), .TbUvaGruposGrauBase]        = _aDados [_nDado, 4]
			::Grupos [len (::Grupos), .TbUvaGruposGrauMinParaAgio] = _aDados [_nDado, 5]
			::Grupos [len (::Grupos), .TbUvaGruposPrcMinimo]       = _aDados [_nDado, 6]
			::Grupos [len (::Grupos), .TbUvaGruposPrcGrauBase]     = _aDados [_nDado, 7]
			::Grupos [len (::Grupos), .TbUvaGruposAcrEspaldPR]     = _aDados [_nDado, 8]
			::Grupos [len (::Grupos), .TbUvaGruposAcrEspaldAA]     = _aDados [_nDado, 9]
			::Grupos [len (::Grupos), .TbUvaGruposAcrEspaldA]      = _aDados [_nDado, 10]
			::Grupos [len (::Grupos), .TbUvaGruposAcrEspaldB]      = _aDados [_nDado, 11]
			::Grupos [len (::Grupos), .TbUvaGruposAcrEspaldC]      = _aDados [_nDado, 12]
			::Grupos [len (::Grupos), .TbUvaGruposAcrEspaldD]      = _aDados [_nDado, 13]
			::Grupos [len (::Grupos), .TbUvaGruposAcrEspaldDS]     = _aDados [_nDado, 14]
			::Grupos [len (::Grupos), .TbUvaGruposAcrLatadaA]      = _aDados [_nDado, 15]
			::Grupos [len (::Grupos), .TbUvaGruposAcrLatadaB]      = _aDados [_nDado, 16]
			::Grupos [len (::Grupos), .TbUvaGruposAcrLatadaD]      = _aDados [_nDado, 17]
			::Grupos [len (::Grupos), .TbUvaGruposAcrLatadaDS]     = _aDados [_nDado, 18]
			::Grupos [len (::Grupos), .TbUvaGruposListaUvas]       = {}
			::Grupos [len (::Grupos), .TbUvaGruposAgiosGraus]      = {}
	//		U_Log2 ('debug', '[' + procname () + ']::Grupo adicionado:')
	//		U_Log2 ('debug', ::Grupos [len (::Grupos)])
		next
	endif

	// Para cada grupo criado, cria uma lista com as suas variedades.
	if _lContinua
		for _nGrupo = 1 to len (::Grupos)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT V.*"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5_14 "
			_oSQL:_sQuery +=      ", VA_VFAMILIAS_UVAS V "
			_oSQL:_sQuery += " WHERE ZX5_14.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_FILIAL = '" + xfilial ("ZX5") + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_TABELA = '14'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14SAFR = '" + ::CodTabela + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14GRUP = '" + ::Grupos [_nGrupo, .TbUvaGruposCodigo] + "'"
			_oSQL:_sQuery +=   " AND ZX5_14.ZX5_14PROD = V.COD_BASE"
			_oSQL:_sQuery += " ORDER BY V.DESCR_BASE, V.COD_BASE"
	//		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			_sAliasQ := _oSQL:Qry2Trb (.F.)
			(_sAliasQ) -> (dbgotop ())
			_aAux = {}
			do while ! (_sAliasQ) -> (eof ())
				aadd (_aAux, array (.TbUvaGruposListaUvasQtColunas))
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodBase]            = (_sAliasQ) -> cod_base
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrBase]          = (_sAliasQ) -> desc_resum
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodEmConversao]     = (_sAliasQ) -> cod_em_conversao
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrEmConversao]   = (_sAliasQ) -> desc_resum_em_conversao
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodBordadura]       = (_sAliasQ) -> cod_bordadura
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrBordadura]     = (_sAliasQ) -> desc_resum_bordadura
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodOrganica]        = (_sAliasQ) -> cod_organica
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrOrganica]      = (_sAliasQ) -> desc_resum_organica
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodFinaClas_comum]  = (_sAliasQ) -> cod_fina_clas_comum
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrFinaClasComum] = (_sAliasQ) -> desc_resum_fina_clas_comum
				_aAux [len (_aAux), .TbUvaGruposListaUvasCodParaEspumante]   = (_sAliasQ) -> cod_para_espumante
				_aAux [len (_aAux), .TbUvaGruposListaUvasDescrParaEspumante] = (_sAliasQ) -> desc_resum_para_espumante
				_aAux [len (_aAux), .TbUvaGruposListaUvasFinaOuComum]        = (_sAliasQ) -> fina_comum
				_aAux [len (_aAux), .TbUvaGruposListaUvasCor]                = (_sAliasQ) -> cor
				_aAux [len (_aAux), .TbUvaGruposListaUvasTintorea]           = (_sAliasQ) -> tintorea
				(_sAliasQ) -> (dbskip ())
			enddo
			::Grupos [_nGrupo, .TbUvaGruposListaUvas] = aclone (_aAux)
	//		U_Log2 ('debug', '[' + procname () + ']::Grupo com variedades:')
	//		U_Log2 ('debug', ::Grupos [_nGrupo])
	//		U_Log2 ('debug', ::Grupos [_nGrupo, .TbUvaGruposListaUvas])
		next
	endif

	// Gera os precos
	if _lContinua
		do case
		case ::CodTabela $ '2023/S23A'
			if ! ::Prc2023 ()
				::SomaMsg ("Erro ao gerar os precos.")
				_lContinua = .F.
			endif
		otherwise
			::SomaMsg ("Sem definicao para geracao de precos para esta tabela.")
			_lContinua = .F.
		endcase
	endif

	// Se deu algum problema, limpa os dados principais para inutilizar o objeto.
	if ! _lContinua
		::CodTabela = ''
		::Grupos    = {}
	endif

	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Nao vou fazer a geracao dos precos dentro do metodo GeraAtrib() por que a
// cada safra temos novas regras.
// Penso em chamar uma static function (ou metodo) para cada safra.
METHOD Prc2023 () Class ClsTbUva
	local _lContinua := .T.
	local _aAreaAnt  := U_ML_SRArea ()
	local _nGrupo    := 0
	local _aAux      := {}
	local _nGrau     := 0
	local _nAuxGrau  := 0
	local _nStepGrau := 0
	local _nPosGrInt := 0
	local _nAgioAnt  := 0
	local _nAgioPos  := 0
	local _nEsteGrau := 0

	// Cria a lista de graus de cada grupo.
	_nStepGrau = iif (::GrauDecimal == 'D', 0.1, 1)
	_nGrupo = 1
	do while _lContinua .and. _nGrupo <= len (::Grupos)
		_aAux = {}
		for _nGrau = ::GrauIniTab to ::GrauFimTab step _nStepGrau
			aadd (_aAux, afill (array (.TbUvaGruposGrausQtColunas), 0))
			_aAux [len (_aAux), .TbUvaGruposGrausGrau]                    = _nGrau

			// Grava os agios entre graus inteiros (cada grupo tem sua lista
			// por que cada grupo pode ter grau base diferente).
			if _IsInt (_nGrau)
				_aAux [len (_aAux), .TbUvaGruposGrausAgioSobreGrauBase] = ::DefPAgio (_nGrau, ::Grupos [_nGrupo, .TbUvaGruposGrauBase])
			endif
		next
	//	U_Log2 ('debug', '[' + procname () + ']Graus e agios (inteiros) para grupo ' + ::Grupos [_nGrupo, .TbUvaGruposCodigo])
	//	U_Log2 ('debug', _aAux)


		// Tendo os agios entre graus inteiros, vou calcular para os graus decimais (se existirem).
		// O mais certo seria jah fazer isso no metodo :DefPAgio, mas a formula jah me deu trabalho
		// na versao original, entao vou reaproveitar.
		_nAuxGrau = 1
		do while _lContinua .and. _nAuxGrau <= len (_aAux)
			_nEsteGrau = _aAux [_nAuxGrau, .TbUvaGruposGrausGrau]
			if ! _IsInt (_nEsteGrau)  // Para os inteiros, jah tenho.

				// Encontra o agio do 'grau inteiro' anterior
				_nPosGrInt = _nAuxGrau
				do while _nPosGrInt > 0 .and. ! _IsInt (_aAux [_nPosGrInt, .TbUvaGruposGrausGrau])
					_nPosGrInt --
				enddo
				if _nPosGrInt > 0
					_nAgioAnt = _aAux [_nPosGrInt, .TbUvaGruposGrausAgioSobreGrauBase]  // Agora tenho o % de agio do grau inteiro anterior
				else
					::SomaMsg ("Nao consegui encontrar grau inteiro menor para ler seu agio e calcular decimais.")
					_lContinua = .F.
				endif

				// Encontra o agio do 'grau inteiro' posterior
				_nPosGrInt = _nAuxGrau
				do while _nPosGrInt <= len (_aAux) .and. ! _IsInt (_aAux [_nPosGrInt, .TbUvaGruposGrausGrau])
					_nPosGrInt ++
				enddo
				if _nPosGrInt <= len (_aAux)
					_nAgioPos = _aAux [_nPosGrInt, .TbUvaGruposGrausAgioSobreGrauBase]  // Agora tenho o % de agio do grau inteiro posterior
				else
					::SomaMsg ("Nao consegui encontrar grau inteiro maior para ler seu agio e calcular decimais.")
					_lContinua = .F.
				endif

				// Sabendo o agio inteiro anterior e o posterior, posso
				// calcular o agio para o grau decimal atual.
				_aAux [_nAuxGrau, .TbUvaGruposGrausAgioSobreGrauBase] = _nAgioAnt - ;
					(_nAgioAnt - _nAgioPos) * ;
					(_nEsteGrau - int (_nEsteGrau))

			endif
			_nAuxGrau ++
		enddo
	//	U_Log2 ('debug', '[' + procname () + ']Graus e agios (com decimais) para grupo ' + ::Grupos [_nGrupo, .TbUvaGruposCodigo])
	//	U_Log2 ('debug', _aAux)

		// Gera precos a partir de aplicacao de agio / desagio sobre o preco do grau base.
		_nAuxGrau = 1
		do while _lContinua .and. _nAuxGrau <= len (_aAux)
			_aAux [_nAuxGrau, .TbUvaGruposGrausPrCompraCodBase] = ::Grupos [_nGrupo, .TbUvaGruposPrcGrauBase] + ::Grupos [_nGrupo, .TbUvaGruposPrcGrauBase] * _aAux [_nAuxGrau, .TbUvaGruposGrausAgioSobreGrauBase] / 100

			// Abaixo de determinado grau, usa preco minimo.
			if _aAux [_nAuxGrau, .TbUvaGruposGrausGrau] < ::Grupos [_nGrupo, .TbUvaGruposGrauMinParaAgio]
				::Grupos [_nGrupo, .TbUvaGruposPrcGrauBase] = ::Grupos [_nGrupo, .TbUvaGruposPrcMinimo]
			endif
			_nAuxGrau ++
		enddo

		::Grupos [_nGrupo, .TbUvaGruposPrecos] = aclone (_aAux)
		_nGrupo ++
	enddo

	U_ML_SRArea (_aAreaAnt)
return _lContinua


// --------------------------------------------------------------------------
// Define os percentuais de agio entre os graus (% acrescido ou diminuido
// a partir do grau base cfe. muda o grau).
// Optei por usar uma funcao separada por que, em varios anos que estou
// aqui, vi isso mudar muito poucas vezes e nao vale a pena copiar ano a ano.
METHOD DefPAgio (_nEsteGrau, _nGrauBase) Class ClsTbUva
	local _nRetAgio := NIL  // Criar como NIL para dar erro se receber algum grau nao previsto.

	if ::CodTabela $ '2023/S23A'
		// As variacoes de agio da Alianca costumam ser diferentes da MOC
		if ::TipoPreco == 'C'  // Compra: usar nossos agios
			do case
			case _nEsteGrau == _nGrauBase -12 ; _nRetAgio = -165
			case _nEsteGrau == _nGrauBase -11 ; _nRetAgio = -150
			case _nEsteGrau == _nGrauBase -10 ; _nRetAgio = -135
			case _nEsteGrau == _nGrauBase -9  ; _nRetAgio = -120
			case _nEsteGrau == _nGrauBase -8  ; _nRetAgio = -105
			case _nEsteGrau == _nGrauBase -7  ; _nRetAgio = -90
			case _nEsteGrau == _nGrauBase -6  ; _nRetAgio = -75
			case _nEsteGrau == _nGrauBase -5  ; _nRetAgio = -60
			case _nEsteGrau == _nGrauBase -4  ; _nRetAgio = -45
			case _nEsteGrau == _nGrauBase -3  ; _nRetAgio = -30
			case _nEsteGrau == _nGrauBase -2  ; _nRetAgio = -15
			case _nEsteGrau == _nGrauBase -1  ; _nRetAgio = -5
			case _nEsteGrau == _nGrauBase +0  ; _nRetAgio = 0
			case _nEsteGrau == _nGrauBase +1  ; _nRetAgio = 5
			case _nEsteGrau == _nGrauBase +2  ; _nRetAgio = 15
			case _nEsteGrau == _nGrauBase +3  ; _nRetAgio = 25
			case _nEsteGrau == _nGrauBase +4  ; _nRetAgio = 35
			case _nEsteGrau == _nGrauBase +5  ; _nRetAgio = 45
			case _nEsteGrau == _nGrauBase +6  ; _nRetAgio = 55
			case _nEsteGrau == _nGrauBase +7  ; _nRetAgio = 65
			case _nEsteGrau == _nGrauBase +8  ; _nRetAgio = 75
			case _nEsteGrau == _nGrauBase +9  ; _nRetAgio = 85
			case _nEsteGrau == _nGrauBase +10 ; _nRetAgio = 95
			case _nEsteGrau == _nGrauBase +11 ; _nRetAgio = 105
			case _nEsteGrau == _nGrauBase +12 ; _nRetAgio = 115
			case _nEsteGrau == _nGrauBase +13 ; _nRetAgio = 125
			case _nEsteGrau == _nGrauBase +14 ; _nRetAgio = 135
			case _nEsteGrau == _nGrauBase +15 ; _nRetAgio = 145
			case _nEsteGrau == _nGrauBase +16 ; _nRetAgio = 155  // Se surgirem novos graus, acrescentar aqui.
			endcase
		elseif ::TipoPreco == 'M'  // MOC: usar agios cfe. MOC publicado a cada safra.
			do case
			case _nEsteGrau == _nGrauBase -12 ; _nRetAgio = -100  // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase -11 ; _nRetAgio = -95   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase -10 ; _nRetAgio = -90   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase -9  ; _nRetAgio = -85   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase -8  ; _nRetAgio = -80   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase -7  ; _nRetAgio = -70   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase -6  ; _nRetAgio = -60   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase -5  ; _nRetAgio = -55   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase -4  ; _nRetAgio = -50   // Este % nao constam no MOC por que a CONAB nao considera graus aceitaveis para vinificacao, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase -3  ; _nRetAgio = -30
			case _nEsteGrau == _nGrauBase -2  ; _nRetAgio = -15
			case _nEsteGrau == _nGrauBase -1  ; _nRetAgio = -5
			case _nEsteGrau == _nGrauBase -0  ; _nRetAgio = 0
			case _nEsteGrau == _nGrauBase +1  ; _nRetAgio = 5
			case _nEsteGrau == _nGrauBase +2  ; _nRetAgio = 15
			case _nEsteGrau == _nGrauBase +3  ; _nRetAgio = 25
			case _nEsteGrau == _nGrauBase +4  ; _nRetAgio = 35
			case _nEsteGrau == _nGrauBase +5  ; _nRetAgio = 45
			case _nEsteGrau == _nGrauBase +6  ; _nRetAgio = 55
			case _nEsteGrau == _nGrauBase +7  ; _nRetAgio = 65
			case _nEsteGrau == _nGrauBase +8  ; _nRetAgio = 75
			case _nEsteGrau == _nGrauBase +9  ; _nRetAgio = 85
			case _nEsteGrau == _nGrauBase +10 ; _nRetAgio = 95
			case _nEsteGrau == _nGrauBase +11 ; _nRetAgio = 105  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase +12 ; _nRetAgio = 115  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase +13 ; _nRetAgio = 125  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			case _nEsteGrau == _nGrauBase +14 ; _nRetAgio = 135  // Este % nao constam no MOC, mas eu preciso ter tratamento para receber uva fora dessa faixa de graus. Robert, 22/01/2020.
			endcase
		else
			::SomaMsg ("Sem definicao de agio entre graus para tipo de precos '" + ::TipoPreco + "'.")
		endif
	else
		::SomaMsg ("Sem definicao de agio entre graus para tabela '" + ::CodTabela)
	endif
return _nRetAgio


// --------------------------------------------------------------------------
// Gera tabela em formato HTML
METHOD GeraHTM () Class ClsTbUva
	local _sHTM       := ''
	local _nGrupo     := 0
	local _aSubgrup   := {}
	local _nSubgrup   := 0
	local _aTitGrup   := {}
	local _aVarGrau   := {}
	local _nVarGrau   := 0
	local _aLinha     := {}
	local _aAux       := {}
	local _lAdicionou := .F.
	local _sTag       := ''
	local _sTagICod   := ''
	local _sTagFCod   := ''
	local _nGrau      := 0
	local _nCPCBas    := 0
	local _nCPCBord   := 0
	local _nCPEmConv  := 0
	local _nCPOrg     := 0
	local _nCPEspum   := 0
	local _nCPFinaCC  := 0
	local _sToolTip   := ''

	// Como a quantidade de celulas mescladas eh muito grande, achei melhor
	// preparar arrays com os dados (jah eh bastante complicado) e, num
	// passo seguinte, gerar HTML.

	// Passo 1: preparar arrays de dados para o HTML
	if empty (::CodTabela)
		::SomaMsg ("Codigo de tabela nao definido. Impossivel gerar HTML.")
	else

		// Uvas comuns: 4 subcolunas (convenc/bordadura/em conv/organ)
		// Uvas viniferas em espaldeira: 2 subcolunas (para vinho/para espumante)
		// Uvas viniferas latadas: nenhuma subcoluna
		if ::TipoUva == 'C'
			_aSubgrup = {'Convencional', 'Bordadura', 'Em conversão', 'Orgânica'}
		elseif ::TipoUva == 'F' .and. ::Conducao == 'E'
			_aSubGrup = {'Para vinho', 'Para espumante'}
		else
			_aSubGrup = {''}
		endif
	//	U_Log2 ('debug', '[' + procname () + ']_aSubGrup:')
	//	U_Log2 ('debug', _aSubGrup)

		// Prepara titulos dos grupos
		_aTitGrup = {}
		aadd (_aTitGrup, '<th> </th>')  // Esta coluna vai ser, posteriormente, usada para o grau.
		for _nGrupo = 1 to len (::Grupos)
			aadd (_aTitGrup, '<th class=' + iif (_nGrupo / 2 == int (_nGrupo / 2), '"TituloGrupoClaro"', '"TituloGrupoEscuro"') + ;
			                 ' colspan=' + cvaltochar (len (_aSubGrup)) + ' align=center>' + ;
			                 'Grp.' + alltrim (::Grupos [_nGrupo, .TbUvaGruposCodigo]) + ;
			                 ' ' + alltrim (::Grupos [_nGrupo, .TbUvaGruposDescricao]) + ;  // ' (gb ' + cvaltochar (::Grupos [_nGrupo, .TbUvaGruposGrauBase]) + ')' + ;
			                 '</th>')
		next

		// Prepara titulos dos subgrupos
		_aVarGrau = {}
		_aLinha = {'<th class="TituloGrupoClaro">Grau</th>'}
		for _nGrupo = 1 to len (::Grupos)

			// Para facilitar a visualizacao, a cada troca de grupo, gero
			// as colunas com fundo escuro ou com fundo claro.
			if _nGrupo / 2 == int (_nGrupo / 2)
				_sTag = '<th class="TituloGrupoClaro">'
			else
				_sTag = '<th class="TituloGrupoEscuro">'
			endif

			for _nSubgrup = 1 to len (_aSubgrup)
				aadd (_aLinha, _sTag + _aSubgrup [_nSubgrup] + '</th>')
			next
		next
		aadd (_aVarGrau, aclone (_aLinha))
		U_Log2 ('debug', '[' + procname () + ']_aVarGrau depois de incluir os subgrupos:')
		U_Log2 ('debug', _aVarGrau)

		// Para adicionar as linhas com as variedades, optei por fazer um loop
		// com WHILE para rodar ateh o momento em que nao adicionar mais nenhuma
		// linha (cada grupo tem uma quantidade diferente de linhas).
		_nVarGrau = 1
		do while .t.
		//	U_Log2 ('debug', '[' + procname () + ']_nVarGrau=' + cvaltochar (_nVarGrau))
			_aLinha = {'<td> </td>'}  // Primeira coluna vai ser usada pelo grau
			_lAdicionou = .F.
			// Para cada grupo, verifica se ainda tem variedades a adicionar
			for _nGrupo = 1 to len (::Grupos)
		//		U_Log2 ('debug', '[' + procname () + ']_nGrupo=' + cvaltochar (_nGrupo))

				// Para facilitar a visualizacao, a cada troca de grupo, gero
				// as colunas com fundo escuro ou com fundo claro.
				if _nGrupo / 2 == int (_nGrupo / 2)
					_sTag = '<td class="ColunaClaraDescri">'

					// Quero mostrar o codigo do item com uma fonte um pouco menor.
					_sTagICod = '<span class="ColunaClaraCodigo">('
					_sTagFCod = ')</span>'
				else
					_sTag = '<td class="ColunaEscuraDescri">'

					// Quero mostrar o codigo do item com uma fonte um pouco menor.
					_sTagICod = '<span class="ColunaEscuraCodigo">('
					_sTagFCod = ')</span>'
				endif
				_aAux = aclone (::Grupos [_nGrupo, .TbUvaGruposListaUvas])
				if _nVarGrau <= len (_aAux)

					// Variedade base sempre deve existir, independente de tipo/conducao
					if ! empty (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodBase])
						aadd (_aLinha, _sTag + ;
										alltrim (strtran (_aAux [_nVarGrau, .TbUvaGruposListaUvasDescrBase], '.', ' ')) + ;
										_sTagICod + ;
										alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodBase]) + ;
										_sTagFCod + ;
										'</td>')
					else
						aadd (_aLinha, ' </td>')
					endif

					// Estas colunas existem somente para uvas comuns
					if ::TipoUva == 'C'
						if ! empty (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodBordadura])
							aadd (_aLinha, _sTag + ;
											alltrim (strtran (_aAux [_nVarGrau, .TbUvaGruposListaUvasDescrBordadura], '.', ' ')) + ;
											_sTagICod + ;
											alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodBordadura]) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
						if ! empty (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodEmConversao])
							aadd (_aLinha, _sTag + ;
											alltrim (strtran (_aAux [_nVarGrau, .TbUvaGruposListaUvasDescrEmConversao], '.', ' ')) + ;
											_sTagICod + ;
											alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodEmConversao]) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
						if ! empty (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodOrganica])
							aadd (_aLinha, _sTag + ;
											alltrim (strtran (_aAux [_nVarGrau, .TbUvaGruposListaUvasDescrOrganica], '.', ' ')) + ;
											_sTagICod + ;
											alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodOrganica]) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
					endif

					// Esta coluna existe somente para viniferas em espaldeira
					if ::TipoUva == 'F' .and. ::Conducao == 'E'
						if ! empty (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodParaEspumante])
							aadd (_aLinha, _sTag + ;
											alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasDescrParaEspumante]) + ;
											_sTagICod + ;
											alltrim (_aAux [_nVarGrau, .TbUvaGruposListaUvasCodParaEspumante]) + ;
											_sTagFCod + ;
											'</td>')
						else
							aadd (_aLinha, _sTag + ' </td>')
						endif
					endif
					_lAdicionou = .T.
		//			U_Log2 ('debug', '[' + procname () + ']Adicionei variedades e ficou assim:')
		//			U_Log2 ('debug', _aLinha)
				else
		//			U_Log2 ('debug', '[' + procname () + ']Este grupo nao tem mais variedades.')
					// Preciso colocar um espaco nestas posicoes para gerar uma celula vazia no HTML depois.
					for _nSubgrup = 1 to len (_aSubgrup)
						aadd (_aLinha, _sTag + ' </td>')
					next
		//			U_Log2 ('debug', '[' + procname () + ']Adicionei vazios e ficou assim:')
		//			U_Log2 ('debug', _aLinha)
				endif
			next

			// Se nao adicionou mais nenhuma linha na array, eh por que terminou
			// de ler todas as variedades de todos os grupos. Posso sair do loop.
			if ! _lAdicionou
				exit
			endif
			aadd (_aVarGrau, aclone (_aLinha))
			_nVarGrau ++
		enddo
//		U_Log2 ('debug', _aVarGrau)

		// Insere a palavra 'Grau' na ultima linha das variedades.
		//_aVarGrau [len (_aVarGrau), 1] = '<th class="ColunaClaraDescri">Grau</th>'


		// Define variaveis para ter de forma um pouco mais pratica as colunas de onde buscar os precos.
		if ::TipoPreco == 'C'
			_nCPCBas   = .TbUvaGruposGrausPrCompraCodBase
			_nCPCBord  = .TbUvaGruposGrausPrCompraCodBordadura
			_nCPEmConv = .TbUvaGruposGrausPrCompraCodEmConversao
			_nCPOrg    = .TbUvaGruposGrausPrCompraCodOrganica
			_nCPFinaCC = .TbUvaGruposGrausPrCompraCodFinaClas_comum
			_nCPEspum  = .TbUvaGruposGrausPrCompraCodParaEspumante
		elseif ::TipoPreco == 'M'
			_nCPCBas   = .TbUvaGruposGrausPrMOCCodBase
			_nCPCBord  = .TbUvaGruposGrausPrMOCCodBordadura
			_nCPEmConv = .TbUvaGruposGrausPrMOCCodEmConversao
			_nCPOrg    = .TbUvaGruposGrausPrMOCCodOrganica
			_nCPFinaCC = .TbUvaGruposGrausPrMOCCodFinaClas_comum
			_nCPEspum  = .TbUvaGruposGrausPrMOCCodParaEspumante
		endif

		// Adiciona graus e respectivos precos. Como preciso montar uma matriz
		// contendo todas as colunas (de todos os grupos), preciso passar por
		// todos os graus e, dentro desses, cada grupo.
		for _nGrau = 1 to len (::Grupos [1, .TbUvaGruposPrecos])  // Pode ser o primeiro grupo, pois todos devem ser iguais
			_aLinha = {}
			for _nGrupo = 1 to len (::Grupos)
				_aAux = aclone (::Grupos [_nGrupo, .TbUvaGruposPrecos])

				if _nGrupo == 1
					if _aAux [_nGrau, .TbUvaGruposGrausGrau] == int (_aAux [_nGrau, .TbUvaGruposGrausGrau])
						aadd (_aLinha, '<th class="ColunaClaraDescri">' + transform (_aAux [_nGrau, .TbUvaGruposGrausGrau], "@E 99") + '</th>')
					else
						aadd (_aLinha, '<th class="ColunaClaraDescri">' + transform (_aAux [_nGrau, .TbUvaGruposGrausGrau], "@E 99.9") + '</th>')
					endif
				endif

				// Para facilitar a visualizacao, a cada troca de grupo, gero
				// as colunas com fundo escuro ou com fundo claro.
				if _aAux [_nGrau, .TbUvaGruposGrausGrau] == ::Grupos [_nGrupo, .TbUvaGruposGrauBase]
					_sTag = '<th class="PrecoGrauBase">'
				else
					if _nGrupo / 2 == int (_nGrupo / 2)
						_sTag = '<th class="ColunaClaraPrecos">'
					else
						_sTag = '<th class="ColunaEscuraPrecos">'
					endif
				endif
			//	U_Log2 ('debug', '[' + procname () + ']Grupo ' + cvaltochar (_nGrupo) + ' _aAux:')
			//	U_Log2 ('debug', _aAux)

				// Define tag para gerar 'tooltip'
				_sToolTip = '<abbr title="Agio a partir do grau base: ' + alltrim (transform (_aAux [_nGrau, .TbUvaGruposGrausAgioSobreGrauBase], "@E 9999.99")) + '%">'

				// O codigo base sempre deve ter preco
				aadd (_aLinha, _sTag + _sToolTip + transform (_aAux [_nGrau, _nCPCBas], "@E 999.9999") + '</th>')

				// Estas colunas existem somente para uvas comuns
				if ::TipoUva == 'C'
					aadd (_aLinha, _sTag + transform (_aAux [_nGrau, _nCPCBord ], "@E 999.9999") + '</th>')
					aadd (_aLinha, _sTag + transform (_aAux [_nGrau, _nCPEmConv], "@E 999.9999") + '</th>')
					aadd (_aLinha, _sTag + transform (_aAux [_nGrau, _nCPOrg   ], "@E 999.9999") + '</th>')
				endif

				// Esta coluna existe somente para viniferas em espaldeira
				if ::TipoUva == 'F' .and. ::Conducao == 'E'
					aadd (_aLinha, _sTag + transform (_aAux [_nGrau, _nCPEspum], "@E 999.9999") + '</th>')
				endif
			next
		//	U_Log2 ('debug', _aLinha)
			aadd (_aVarGrau, aclone (_aLinha))
		next
		U_Log2 ('debug', '[' + procname () + ']_aVarGrau final:')
		U_Log2 ('debug', _aVarGrau)





	//	for _nVarGrau = 1 to len (_aVarGrau)
	//		U_Log2 ('debug', '[' + procname () + ']Linha ' + cvaltochar (_nVarGrau) + ' tam = ' + cvaltochar (len (_aVarGrau [_nVarGrau])))
	//	next
	endif

	// Passo 2: montagem do HTML
	if len (_aVarGrau) == 0
		::SomaMsg ("Sem variedades para esta tabela. Impossivel gerar HTML.")
	else
		// dicas em https://www.w3schools.com/css/css_text_align.asp

		_sHTM := '<!DOCTYPE html><html>'

		// Define classes de estilos CSS para os diferentes tipo de celulas
		_sHTM += '<style>'
		_sHTM +=    '.TituloTabela{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:11.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.SubTituloTabela{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.TituloGrupoClaro{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.TituloGrupoEscuro{'
		_sHTM +=       'color:#000000;'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Arial;'
		_sHTM +=       'text-align:center;'
		_sHTM +=       'font-size:9.0pt;'
		_sHTM +=       'font-weight:700;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraDescri{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:left;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraDescri{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:left;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraPrecos{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraPrecos{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaClaraCodigo{'
		_sHTM +=       'background:#FFFFFF;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:7.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.ColunaEscuraCodigo{'
		_sHTM +=       'background:#D6DCE4;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:7.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM +=    '.PrecoGrauBase{'
	//	_sHTM +=       'background:#8497B0;'
		_sHTM +=       'background:#82868b;'
		_sHTM +=       'font-family:Tahoma;'
		_sHTM +=       'font-size:8.0pt;'
		_sHTM +=       'text-align:right;'
		_sHTM +=       'padding: 2px;'
		_sHTM +=    '}'
		_sHTM += '</style>'

		_sHTM += '<head>'
		_sHTM +=    '<title>Tabela preços uva</title>'
		_sHTM += '</head>'
		_sHTM += '<body>'
		_sHTM += '<table width="80%" border="1" cellspacing="0" cellpadding="0" align="center">'
		
		// Linhas iniciais da tabela (descricao, tipos de uvas, datas, etc.
		_sHTM += '<tr>'
		_sHTM +=    '<th class="TituloTabela" colspan=' + cvaltochar (len (_aVarGrau [1])) + '>'
		_sHTM +=    alltrim (sm0 -> m0_nomecom)
		_sHTM +=    ' - Tabela ' + ::CodTabela + ' (preço '
			if ::TipoPreco == 'E'
				_sHTM += 'de entrada'
			elseif ::TipoPreco == 'C'
				_sHTM += 'de compra'
			elseif ::TipoPreco == 'M'
				_sHTM += 'MOC'
			else
				_sHTM += '[OUTRAS NAO DEFINIDAS]'
			endif
			_sHTM += ')'
			_sHTM += ' - uvas ' + iif (::TipoUva == 'C', 'comuns', iif (::TipoUva == 'F', 'viniferas', '(SEM DEFINICAO)'))
			_sHTM += ' ' + iif (::Conducao == 'L', 'latadas', iif (::Conducao == 'E', 'espaldeira', '(SEM DEFINICAO)'))
			_sHTM += '</th>'
		_sHTM += '</tr>'
		_sHTM += '<tr>'
		_sHTM +=    '<th class="SubTituloTabela" colspan=' + cvaltochar (len (_aVarGrau [1])) + '>Gerada pelo ERP em ' + dtoc (date ()) + ' - ' + time () + '</th>'
		_sHTM += '</tr>'


		// Linhas de titulos das colunas (nomes dos grupos, grau base, etc)
		U_Log2 ('debug', '[' + procname () + ']Montando linha titulos grupos')
		_sHTM += '<tr>'
		for _nGrupo = 1 to len (_aTitGrup)
			_sHTM += _aTitGrup [_nGrupo]
		next
		_sHTM += '</tr>'

		// Adiciona as variedades ao grid
		for _nVarGrau = 1 to len (_aVarGrau)
			_sHTM += '<tr>'
			for _nGrupo = 1 to len (_aVarGrau [_nVarGrau])
				_sHTM += _aVarGrau [_nVarGrau, _nGrupo]
			next
			_sHTM += '</tr>
		next

		_sHTM += '</table>'
		_sHTM += '</body></html>'
	endif
return _sHTM


// --------------------------------------------------------------------------
static function _IsInt (_nValor)
return (_nValor == int (_nValor))


// --------------------------------------------------------------------------
// Adiciona (sempre no inicio, para que a mensagem mais recente seja vista
// antes) uma mensagem na string ::UltMsg
METHOD SomaMsg (_sMsg) Class ClsTbUva
	local _sMsgAux := alltrim (cvaltochar (_sMsg))
	if ! alltrim (_sMsgAux) $ ::UltMsg
		::UltMsg = alltrim (_sMsgAux) + '; ' + ::UltMsg
	endif
return
