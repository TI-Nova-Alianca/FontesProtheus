// Programa:  ClsTrEstq
// Autor:     Robert Koch
// Data:      29/07/2018
// Descricao: Declaracao de classe de representacao de solicitacoes de transferencia de estoque.
//            Criada com base no programa VAFPCP01 de Daniel Scheeren (Proccdata)
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.
//
// Historico de alteracoes:
// 08/04/2019 - Catia   - include TbiConn.ch 
// 12/04/2019 - Robert  - Deixa variavel _lClsTrEst declarada para posterior uso em pontos de entrada.
// 25/09/2019 - Robert  - Quando o produto tiver controle via FullWMS, libera somente para usuarios do grupo 029.
//                      - Criado atributo LibNaIncl.
// 26/09/2019 - Cláudia - Incluída validação de lote mínimo.
// 27/11/2020 - Robert  - Quando existir etiqueta relacionada, tenta inutiliza-la automaticamente.
//                      - Transf. envolvendo o AX01 (FullWMS) liberadas, momentaneamente, para aceitar liberacao manual (sem ser o Full).
// 04/12/2020 - Robert  - Criado tratamento para produto destino diferente do produto origem.
// 18/10/2021 - Sandra  - Ajuste da mensagem "Transferencia ainda nao gravada na tabela ZZG" para "Transferencia ainda nao gravada na tabela ZAG"
// 25/01/2022 - Robert  - Gera etiqueta quando o prod.controla lote, mesmo nao tendo integracao com FullWMS.
// 06/04/2022 - Robert  - Criado metodo :AlmUsaEtiq() e passa a ser validado antes de gerar etiqueta.
// 22/04/2022 - Robert  - Considerar usr 'FULLW' e nao mais 'FULLWMS' (para caber no campo ZZU_USR) - GLPI 8194
// 27/04/2022 - Robert  - Voltado nome de usuario 'FULLW' para 'FULLWMS' pois optei por criar um usuario com esse nome no Protheus.
// 05/05/2022 - Robert  - Ateh definirmos melhor as integracoes, fica liberado transf.manualmente p/alm que usa Full.
// 06/05/2022 - Robert  - Se a solicitacao foi gerada por integracao com FullWMS, limpa tambem da tabela de integracao (GLPI 8914).
// 15/06/2022 - Robert  - Nao gerava etiqueta se o produto nao controlasse lotes (GLPI 12220)
// 02/08/2022 - Robert  - Para gravar, precisa ser dono de pelo menos um dos almox. (GLPI 12404)
// 02/08/2022 - Robert  - Para gravar, testa possibilidade do destino ser igual a origem (GLPI 12427).
// 13/09/2022 - Robert  - Criados atributos CtrLocOrig, CtrLocDest, CtrLotOrig, CtrLotDest.
// 23/09/2022 - Robert  - Tratamentos para envio para o FullWMS (GLPI 12220).
// 13/10/2022 - Robert  - Melhoria envio etiq. para o FullWMS.
// 19/10/2022 - Robert  - Impedir exclusao se gerou solic.separacao no FullWMS (GLPI 12724)
// 31/10/2022 - Robert  - Classe renomeada de PRW para TLPP
//                      - Tratamentos para permitir lote origem quando destino for FullWMS.
// 09/11/2022 - Robert  - Nao alimentava numero da etiqueta no metodo GeraAtrib.
// 12/12/2022 - Robert  - Implementados metodos SomaMsg e GravaErro.
// 14/12/2022 - RObert  - Gravacao campo ZAG_EREXEC e melhoria mensagens de log.
// 19/01/2023 - Robert  - Metodo Libera() nao tenta mais executar a transferencia no final.
// 27/01/2023 - Robert  - Metodo New passa a aceitar R_E_C_N_O_ ou chave de pesquisa.
//                      - Mensagens, quando for o caso, passam a ser todas persistidas no campo ZAG_ULTMSG.
// 02/02/2023 - Robert  - Quando alm.destino usa FullWMS, exige lote destino, pois o FullWMS vai exigir depois.
// 11/03/2023 - Robert  - Tratamentos para novo campo ZAG_SEQ
//                      - Criado metodo PodeIncl().
//                      - Eliminados campos ZAG_UAUTP e ZAG_UAUTQ (Autorizadores PCP e qualidade).
// 15/03/2023 - Robert  - Para considerar almox.controlado pelo FullWMS, deve estar na filial 01.
// 15/03/2023 - Robert  - Para considerar almox.controlado pelo FullWMS, deve estar na filial 01.
// 20/04/2023 - Robert  - Criado atributo CodMotivo
// 12/06/2023 - Robert  - Melhorado teste de gravacao do SD3 no metodo GeraSD3() - GLPI 13677
// 25/07/2023 - Robert  - Verifica se tem saldo e se tem inconsistencia entre tabelas antes de gravar a solicitacao.
// 05/09/2023 - Robert  - Melhorados testes de ter/nao ter lotes quando envolve FullWMS
// 15/09/2023 - Robert  - Quando :CodMotivo=08 chama a validacao de estoques com outros parametros.
// 25/09/2023 - Robert  - Verifica se o produto pode ser transformado, antes de permitir a inclusao da solicitacao.
// 14/12/2023 - Robert  - Passa a herdar da classe ClsBase
//                      - Permite gerar etiquetas para o ax.02 quando produto controla lote (GLPI 14600)
// 27/12/2023 - Robert  - Criado atributo CodRetorno.
// 28/02/2024 - Robert  - Metodo :AlmUsaFull passa a receber parametro 'filial' (GLPI 14785)
//                      - Criado tratamento para desfazimento de guarda de pallets na logistica (atributo :EtqReferenciada) - GLPI 14999
// 08/03/2024 - Robert  - Desconsiderar mensagem "Ja existe uma movimentacao com este numero de documento" como um erro, pois basta tentar novamente.
// 21/03/2024 - Robert  - Nao permitia transf.para ax.11 com motivo 04 (bloqueio criado em 28/02 para desfazimento de guarda de pallet) - GLPI 15121
// 25/04/2024 - Robert  - Ajustes validacoes desfazimento guarda pallets (GLPI 14965)
// 29/04/2024 - Robert  - Metodo AlmUsaEtiq nao considerava a filial.
//

// ------------------------------------------------------------------------------------
#Include "Protheus.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsTrEstq ()
return


// ==========================================================================
CLASS ClsTrEstq FROM ClsBase

	// Declaracao das propriedades da Classe
	public data Filial     // Filial onde foi incluido o registro (campo ZAG_FILIAL)
	public data FilOrig    // Filial origem.
	public data FilDest    // Filial destino.
	public data Docto      // Numero docto na tabela ZAG.
	public data Seq        // Sequencia dentro do documento.
	public data IdGrid     // ID da linha do grid (usado na chamada web service pelo NaWeb)
	public data DtEmis     // Data emissao (inclusao) do ZAG. Nao obrigatoriamente a mesma da geracao do movto.
	public data RegZAG     // Numero registro (RECNO) no ZAG.
	public data OP         // Numero da OP, quando a solic. for gerada por OP.
	public data Motivo     // Descricao do motivo da transferencia. 
	public data ProdOrig   // Codigo do produto origem a transferir.
	public data ProdDest   // Codigo do produto destino (inicilmente a ideia eh sempre transferir para o msmo produto)
	public data AlmOrig    // Almox (local) origem
	public data AlmDest    // Almox (local) destino
	public data CtrLocOrig // Indica se o produto de origem controla enderecamento (campo B1_LOCALIZ)
	public data CtrLocDest // Indica se o produto destino controla enderecamento (campo B1_LOCALIZ)
	public data CtrLotOrig // Indica se o produto de origem controla lote (campo B1_RASTRO)
	public data CtrLotDest // Indica se o produto destino controla lote (campo B1_RASTRO)
	public data CodMotivo  // Codigo do motivo da transferencia.
	public data CodRetorno // Codigo de retorno (de erro ou de sucesso)
	public data EndOrig    // Endereco origem (quando produto tiver controle de localizacao)
	public data EndDest    // Endereco destino  (quando produto tiver controle de localizacao)
	public data Etiqueta   // Numero da etiqueta gerada na tabela ZA1, quando aplicavel.
	public data EtqRef     // Numero da etiqueta referenciada (inicialmente aplicavel a operacao de desfazimento de guarda de pallet na logistica)
	public data Executado  // Indica se jah foi executado (se gerou alguma movimentacao) S=Executado;E=Erro na execucao;X=Estornado
	public data FWProdOrig // Indica se o produto origem eh controlado pelo FullWMS
	public data FWProdDest // Indica se o produto destino eh controlado pelo FullWMS
	public data ImprEtq    // ID da immpressora (caso seja necessario gerar e imprimir etiqueta) 
	public data LibNaIncl  // Indica se, no momento da inclusao do registro no ZAG, jah deve tentar fazer as liberacoes.
	public data LoteOrig   // Lote origem (quando produto tiver controle de lote)
	public data LoteDest   // Lote destino (quando produto tiver controle de lote)
	public data MotNac     // Motivo de nao aceite da solicitacao.
	public data QtdSolic   // Quantidade solicitada (inicial a ser transferida) 
	public data UltMsg     // Ultima mensagem gerada.
	public data UsrIncl    // Usuario que fez a inclusao do registro
	public data UsrAutOri  // Usuario que autorizou pelo almox origem
	public data UsrAutDst  // Usuario que autorizou pelo almox destino

	// Declaracao dos Metodos da classe
	public  METHOD New ()
	public  METHOD AlmUsaEtiq ()
	public  METHOD AlmUsaFull ()
	private METHOD AtuZAG ()
	public  METHOD Estorna ()
	public  METHOD Exclui ()
	public  METHOD Executa ()
	public  METHOD Inclui ()
	public  METHOD GeraAtrib ()
	public  METHOD GeraEtiq ()
	private METHOD GeraSD3 ()
	public  METHOD Grava ()
//	private METHOD GravaErro ()
	private METHOD LeSB1 ()
	public  METHOD Libera ()
	public  METHOD Negar ()
	public  METHOD NovoEndDst ()
	public  METHOD PodeIncl ()
	private METHOD SetCodRetorno ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor.
METHOD New (_xChave) Class ClsTrEstq

	// Alimenta atributos com valores default de uma solicitacao nova.
	::GeraAtrib ("")

	// Se receber numerico, eh por que se trata do numero de registro
	// jah existente no ZAG e preciso atualizar o objeto.
	if valtype (_xChave) == "N"
		ZAG -> (dbgoto (_xChave))
		::GeraAtrib ("ZAG")

	// Se receber caracter, eh por que se trata de um codigo jah
	// existente nas tabelas, e preciso atualizar o objeto.
	elseif valtype (_xChave) == "C"
		zag -> (dbsetorder (1))  // ZAG_FILIAL, ZAG_DOC, ZAG_SEQ, R_E_C_N_O_, D_E_L_E_T_
		if ! zag -> (dbseek (_xChave, .F.))
			u_help ("Erro ao instanciar solicitacao de transferencia. Nao foi possivel localizar registro na tabela ZAG com chave '" + _xChave + "'.",, .t.)
		else
			::GeraAtrib ("ZAG")
		endif
	endif

	// Nao vejo necessidade de gerar log ao instanciar um objeto vazio.
	if ! empty (_xChave)
		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Instanciado ' + ;
			' ZAG_DOC ' + ::Docto + '/' + ::Seq + ;
			' ax.' + ::AlmOrig + '->' + ::AlmDest + ;
			' item ' + alltrim (::ProdOrig) + ;
			' qt=' + cvaltochar (::QtdSolic) + ;
			' recno=' + cvaltochar (zag -> (recno ())))
	endif
Return ::self



// --------------------------------------------------------------------------
// Verifica se o almoxarifado usa etiquetas para entrada de material.
METHOD AlmUsaEtiq (_sAlm) Class ClsTrEstq
	local _lRet := .F.
	if ::FilDest == '01' .and. (_sAlm $ '01/02')
		_lRet = .T.
	endif
//return (_sAlm $ '01/02')
return _lRet



// --------------------------------------------------------------------------
// Verifica se o almoxarifado eh controlado via FullWMS.
METHOD AlmUsaFull (_sFilial as character, _sAlm as character) Class ClsTrEstq
return (_sFilial == '01' .and. _sAlm == '01')



// --------------------------------------------------------------------------
// Atualiza (no arquivo) determinado atributo.
METHOD AtuZAG (_sCampo, _xValor) Class ClsTrEstq
	local _lRet := .F.
	local _aAreaAnt  := U_ML_SRArea ()

	if ::RegZAG > 0
		zag -> (dbgoto (::RegZAG))
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Gravando campo ' + _sCampo + ' com conteudo ' + cvaltochar (_xValor))
		reclock ("ZAG", .F.)
		zag -> &(_sCampo) = _xValor
		msunlock ()
		_lRet = .T.
	else
		U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + "]Registro ainda nao gravado na tabela ZAG. Atualizacao do campo '" + _sCampo + "' nao pode ser feita.")
		_lRet = .F.
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRet



// --------------------------------------------------------------------------
// Estorna movimento (transf. foi excluida pela tela padrao, preciso mudar o status).
METHOD Estorna () Class ClsTrEstq
	::Executado = 'X'
	::AtuZAG ("zag_exec", ::Executado)
return



// --------------------------------------------------------------------------
// Exclui movimento.
METHOD Exclui () Class ClsTrEstq
	local _lContinua := .T.
	local _oSQL      := NIL
	local _sEtiq     := ''
	local _oEtiq     := NIL

	u_log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Iniciando exclusao do ZAG docto ' + ::Docto)
	::UltMsg = ""

	if _lContinua .and. ::Executado == 'S'
		_Super:SomaMsg ("Este lancamento ja gerou movimentacao. Estorne, antes, o movimento gerado.")
		_lContinua = .F.
	endif
	if _lContinua
		zag -> (dbgoto (::RegZAG))
		if zag -> (recno ()) != ::RegZAG
			_Super:SomaMsg ("Nao foi possivel localizar o registro correspondente no arquivo ZAG. Exclusao nao sera' efetuada.")
			_lContinua = .F.
		else
			::Docto = zag -> zag_doc
			::Seq   = zag -> zag_seq
		endif
	endif
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT TOP 1 ZA1_CODIGO"
		_oSQL:_sQuery += " FROM " + RetSQLName ("ZA1")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery += " AND ZA1_FILIAL  = '" + xfilial ("ZA1") + "'"
		_oSQL:_sQuery += " AND ZA1_IDZAG   = '" + ::Docto + ::Seq + "'"
		_oSQL:_sQuery += " AND ZA1_APONT  != 'I'"
		_sEtiq = _oSQL:RetQry (1, .F.)
		if ! empty (_sEtiq)
			
			// Tenta inutilizar a etiqueta
			_oEtiq := ClsEtiq():New(_sEtiq)
			if ! _oEtiq:Inutiliza ()
				_Super:SomaMsg ("Existe a etiqueta " + _sEtiq + " gerada para esta solicitacao. Inutilize, antes, a etiqueta.")
				_lContinua = .F.
			endif
		endif
	endif

	// Se esta sol.transf. gerou tarefa de separacao no FullWMS, verifica se
	// a mesma jah foi excluida do Full.
	if _lContinua .and. ::FWProdOrig .and. ::AlmUsaFull (::FilOrig, ::AlmOrig)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "select count (*)"
		_oSQL:_sQuery +=  " from tb_wms_pedidos"
//		_oSQL:_sQuery += " where saida_id = 'ZAG" + xfilial ("ZAG") + ::Docto + "'"  // Manter consistencia com a view v_wms_pedido !!!
		_oSQL:_sQuery += " where saida_id = 'ZAG" + xfilial ("ZAG") + ::Docto + ::Seq + "'"  // Manter consistencia com a view v_wms_pedido !!!
		_oSQL:_sQuery +=   " and status  != '9'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		if _oSQL:RetQry (1, .f.) > 0
			_Super:SomaMsg ("Esta solic.gerou o pedido de separacao " + ::Docto + " para o FullWMS, que encontra-se ainda pendente. Esse pedido deve ser excluido do FullWMS antes de poder excluir esta solicitacao de transferencia.")
			_lContinua = .F.
		endif
	endif

	// Esta solicitacao pode ter sido gerada a partir de uma 'avaria' pelo FullWMS.
	// Varre tabela de integracao e limpa o campo, caso encontre.
	if _lContinua .and. ::FWProdOrig .and. ::AlmUsaFull (::FilOrig, ::AlmOrig)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "update tb_wms_movimentacoes"
		_oSQL:_sQuery +=   " set status_protheus = ' '"
		_oSQL:_sQuery +=      ", IdZAG = ''"
		_oSQL:_sQuery += " where IdZAG = '" + ::Docto + ::Seq + "'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lContinua = _oSQL:Exec ()
	endif

	if _lContinua
		reclock ("ZAG", .F.)
		zag -> (dbdelete ())
		msunlock ()
		_Super:SomaMsg ("Solicitacao " + ::Docto + '/' + ::Seq + " excluida.")
	endif

	if ! _lContinua
		u_help (::UltMsg)

		// Persiste ultimas mensagens na tabela ZAG, para ajudar pessoal de suporte.
		::AtuZAG ("zag_UltMsg", ::UltMsg)
	endif

return _lContinua



// --------------------------------------------------------------------------
// Executa a movimentacao necessaria para a transferencia.
METHOD Executa (_lMensagem) Class ClsTrEstq
	local _lContinua := .T.
	local _sMsgInt   := ''

	_lMensagem := iif (_lMensagem == NIL, .T., _lMensagem)

	if _lContinua .and. ::RegZAG == 0
		_sMsgInt += "Transferencia ainda nao gravada na tabela ZAG"
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'S'
		_sMsgInt += "Transferencia ja executada."
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'X'
		_sMsgInt += "Transf.estornada. Nao pode ser refeita."
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'N'
		_sMsgInt += "Transf.com nao aceite."
		_lContinua = .F.
	endif
	if _lContinua .and. ::FilOrig != cFilAnt
		_sMsgInt += "Esta transf.deve ser executada na filial '" + ::FilOrig + "'."
		_lContinua = .F.
	endif
	if _lContinua .and. empty (::UsrAutOri)
		_sMsgInt += "Falta liberacao do responsavel pelo almox origem"
		_lContinua = .F.
	endif
	if _lContinua .and. empty (::UsrAutDst)
		_sMsgInt += "Falta liberacao do responsavel pelo almox destino"
		_lContinua = .F.
	endif
//	if _lContinua .and. empty (::UsrAutPCP)
//		_sMsgInt += "Falta liberacao do responsavel pelo PCP"
//		_lContinua = .F.
//	endif
//	if _lContinua .and. empty (::UsrAutQld)
//		_sMsgInt += "Falta liberacao do responsavel pela qualidade"
//		_lContinua = .F.
//	endif

	if ! _lContinua
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Ainda nao tem condicoes de executar. Msg.interna: ' + _sMsgInt)
	endif

	// Concatena a mensagem interna somente se a rotina chamadora quiser ve-la.
	if _lMensagem
		_Super:SomaMsg (_sMsgInt)
	endif
	if _lContinua .and. ::FilDest == ::FilOrig
		_lContinua = ::GeraSD3 ()
	endif
	if _lContinua .and. ::FilDest != ::FilOrig
		_lContinua = ::GeraSC5 ()
	endif

	if ! _lContinua .and. ! empty (::UltMsg)
		u_help (::UltMsg)

		// Persiste ultimas mensagens na tabela ZAG, para ajudar pessoal de suporte.
		::AtuZAG ("zag_UltMsg", ::UltMsg)
	endif

	// Gera novamente os atributos, para atualizar caso tenha gerado movimento.
	::GeraAtrib ("ZAG")

return _lContinua


// --------------------------------------------------------------------------
// Gera / atualiza atributos para o objeto.
METHOD GeraAtrib (_sOrigem) class ClsTrEstq
	local _oSQL := NIL

	// Defaults
	::Filial     = ''
	::FilOrig    = ''
	::FilDest    = ''
	::Docto      = ''
	::Seq        = ''
	::IdGrid     = ''
	::DtEmis     = ''
	::RegZAG     = 0
	::OP         = ''
	::Motivo     = ''
	::ProdOrig   = ''
	::ProdDest   = ''
	::AlmOrig    = ''
	::AlmDest    = ''
	::CtrLocOrig = .f.
	::CtrLocDest = .f.
	::CtrLotOrig = .f.
	::CtrLotDest = .f.
	::CodMotivo  = ''
	::EndOrig    = ''
	::EndDest    = ''
	::Etiqueta   = ''
	::EtqRef     = ''
	::Executado  = ''
	::FWProdOrig = .F.
	::FWProdDest = .F.
	::ImprEtq    = ''
	::LibNaIncl  = .T.
	::LoteOrig   = ''
	::LoteDest   = ''
	::MotNac     = ''
	::QtdSolic   = 0
	::UltMsg     = iif (valtype (::UltMsg) == 'U', '', ::UltMsg)  // Posso estar atualizando apos alguma operacao e nao quero perder o historico.
	::UsrIncl    = ''
	::UsrAutOri  = ''
	::UsrAutDst  = ''

	if _sOrigem == 'ZAG'
		::Filial    = zag -> zag_filial
		::FilOrig   = zag -> zag_FilOri
		::FilDest   = zag -> zag_FilDst
		::RegZAG    = zag -> (recno ())
		::Docto     = zag -> zag_doc
		::Seq       = zag -> zag_seq
		::DtEmis    = zag -> zag_emis
		::UsrIncl   = zag -> zag_usrinc
		::OP        = zag -> zag_op
		::CodMotivo = zag -> zag_codmot
		::Motivo    = alltrim (zag -> zag_Motivo)
		::ProdOrig  = zag -> zag_PrdOri
		::ProdDest  = zag -> zag_PrdDst
		::AlmOrig   = zag -> zag_AlmOri
		::AlmDest   = zag -> zag_AlmDst
		::EndOrig   = zag -> zag_EndOri
		::EndDest   = zag -> zag_EndDst
		::Executado = zag -> zag_exec
		::LoteOrig  = zag -> zag_LotOri
		::LoteDest  = zag -> zag_LotDst
		::MotNac    = alltrim (zag -> zag_MotNac)
		::QtdSolic  = zag -> zag_QtdSol
		::UsrAutOri = zag -> zag_UAutO
		::UsrAutDst = zag -> zag_UAutD

		// Busca dados adicionais dos produtos origem e destino (podem nao ser iguais)
		::LeSB1 ()

		// Busca etiqueta gerada para este registro, se existir.
		if empty (::Etiqueta)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += "SELECT ZA1_CODIGO"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZA1") + " ZA1"
			_oSQL:_sQuery += " WHERE ZA1.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZA1.ZA1_FILIAL = '" + xfilial ("ZA1") + "'"
			_oSQL:_sQuery +=   " AND ZA1.ZA1_IDZAG  = '" + ::Docto + ::Seq + "'"
			_oSQL:_sQuery +=   " AND ZA1_APONT     != 'I'"  // Nao inutilizada.
		//	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			::Etiqueta = _oSQL:RetQry (1, .f.)
		endif

	endif
return


// --------------------------------------------------------------------------
// Verifica necessidade e gera etiqueta para esta transferencia.
METHOD GeraEtiq (_lMsg as logical) Class ClsTrEstq
	local _lContinua := .T.
	local _sMsg      := ''
	local _oEtiq     := NIL

	if ! empty (::Etiqueta)
		_sMsg += "Jah existe a etiqueta '" + ::Etiqueta + "' gerada para esta transferencia."
		_lContinua = .F.
	endif
	if empty (::RegZAG)
		_sMsg += "Registro ainda nao gravado na tabela ZAG. Etiqueta nao vai ser gerada."
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'X'
		_sMsg += "Transf.estornada. Nao pode mais gerar etiqueta."
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'N'
		_sMsg += "Transf.com nao aceite. Etiqueta nao pode mais ser gerada."
		_lContinua = .F.
	endif
	if _lContinua .and. ! ::AlmUsaEtiq (::AlmDest)
		_sMsg += "Almoxarifado destino nao faz entrada com etiqueta."
		_lContinua = .F.
	else
		// Nem todos os tipos de produto geram etiqueta no ax.02
	//	if ::AlmDest == '02' .and. fBuscaCpo ("SB1", 1, xfilial ("SB1") + ::ProdDest, "B1_TIPO") != 'PS'
		if ::AlmDest == '02' .and. empty (::LoteDest) .and. fBuscaCpo ("SB1", 1, xfilial ("SB1") + ::ProdDest, "B1_TIPO") != 'PS'
			U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Almoxarifado destino (' + ::AlmDest + ') faz entrada com etiqueta somente se produto controlar lotes ou for do tipo PS.')
			_sMsg += 'Almoxarifado destino (' + ::AlmDest + ') faz entrada com etiqueta somente se produto controlar lotes ou for do tipo PS.'
			_lContinua = .F.
		endif
	endif

	if _lContinua
		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + '] Vou gerar etiqueta.')

		_oEtiq := ClsEtiq():New()
		_oEtiq:Produto     = ::ProdDest
		_oEtiq:DtEmis      = ::DtEmis
		_oEtiq:IdZAG       = ::Docto + ::Seq
		_oEtiq:Quantidade  = ::QtdSolic
		_oEtiq:AlmDest     = ::AlmDest
		_oEtiq:AlmOrig     = ::AlmOrig
		_oEtiq:LoteProduto = alltrim (::LoteDest)
		
		if _oEtiq:Grava ()

			// Faz uma releitura dos atributos da etiqueta para popular
			// campos adicionais como por exemplo a data de validade.
			_oEtiq:GeraAtrib ("ZA1")
			::Etiqueta = _oEtiq:Codigo
			_Super:SomaMsg ('Etiqueta gerada:' + ::Etiqueta)

			// Se tem impressora informada, jah faz a impressao da etiqueta.
			if ! empty (::ImprEtq)
				_oEtiq:Imprime (::ImprEtq)
			else
				_Super:SomaMsg ('Atributo ::ImprEtq nao definido para impressao da etiqueta.')
			endif

			if ::AlmUsaFull (::FilDest, ::AlmDest)
				U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Criei uma etiq. para alm.destino que usa Full. Vou enviar a etiq. para o Full.')
				_oEtiq:EnviaFull ()
			endif
		else
			_sMsg += 'Nao foi gerada etiqueta.'
			U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + ']Nao foi gerada etiqueta.' + _oEtiq:UltMsg)
		endif

	endif
	_Super:SomaMsg (_sMsg)
	if _lMsg .and. ! empty (_sMsg)
		u_help (_sMsg,, .T.)
	endif
return _lContinua


// --------------------------------------------------------------------------
// Gera movimentacao interna de transferencia.
METHOD GeraSD3 () class ClsTrEstq
	local _lContinua := .T.
	local _sDoc      := ""
	local _aAuto261  := {}
	local _aItens    := {}
	local _sChaveEx  := 'ZAG' + ::Docto + ::Seq
	local _aRegsSD3  := {}

	u_log2 ('info', 'Iniciando ' + GetClassName (::Self) + '.' + procname ())

	// Se o produto ainda nao existe no almoxarifado destino, cria-o, para nao bloquear a transferencia de estoque.
	if _lContinua
		sb2 -> (dbsetorder (1))
		if ! sb2 -> (dbseek (xfilial ("SB2") + ::ProdDest + ::AlmDest))
			CriaSB2 (::ProdDest, ::AlmDest)
		endif
	endif

	if _lContinua
		
		// Variavel publica usada para retornad erros na funcao U_Help().
		if type ("_sErroAuto") != 'C'
			//u_log2 ('debug', 'Criando variavel _sErroAuto')
			private _sErroAuto := ""
		endif
	
		// Deixar private por que pode vir a ser testada nos pontos de entrada.
		private _lClsTrEst := .T.

		_sDoc := CriaVar ("D3_DOC")
		aadd(_aAuto261,{_sDoc,dDataBase})
		aadd(_aItens, ::ProdOrig)  // Produto origem
		aadd(_aItens,'')           //D3_DESCRI				DescriÁo do Produto Origem
		aadd(_aItens,'')           //D3_UM					Unidade de Medida Origem
		aadd(_aItens,::AlmOrig)    //Almox origem
		aadd(_aItens,::EndOrig)    //Endereco origem
		aadd(_aItens,iif (empty (::ProdDest), ::ProdOrig, ::ProdDest))   //Codigo do produto destino
		aadd(_aItens,'')           //D3_DESCRI				DescriÁo do Produto de Destino
		aadd(_aItens,'')           //D3_UM					Unidade de Medida de Destino
		aadd(_aItens,::AlmDest)    //Almox destino
		aadd(_aItens,::EndDest)    //Endereco destino
		aadd(_aItens,"")           //D3_NUMSERI				Numero de Serie
		aadd(_aItens,::LoteOrig)   //Lote origem
		aadd(_aItens,"")           //D3_NUMLOTE				Numero do lote
		aadd(_aItens,ctod(""))     //D3_DTVALID				Validade Origem
		aadd(_aItens,0)            //D3_POTENCI				PotÍncia
		aadd(_aItens,::QtdSolic)   // Quantidade
		aadd(_aItens,0)            //D3_QTSEGUM				Segunda Quantidade
		aadd(_aItens,criavar("D3_ESTORNO"))  // D3_ESTORNO			Estorno
		aadd(_aItens,criavar("D3_NUMSEQ"))   // D3_NUMSEQ 			Numero de Sequencia
		aadd(_aItens,::LoteDest)             // Lote destino
		aadd(_aItens,ctod(""))               // D3_DTVALID			Validade de Destino
		aadd(_aItens,criavar("D3_ITEMGRD"))  // D3_ITEMGRD			Item Grade
		//aadd(_aItens,0)                    // Per.Imp. D3_PERIMP
		aadd(_aItens,::Motivo)               // D3_OBSERVA
		aadd(_aItens,::Motivo)               // motivo
		aadd(_aItens,ctod (''))              // dt digit (vai ser gravado pelo SQL)
		aadd(_aItens,'')                     // hr digit (vai ser gravado pelo SQL)
		//aadd(_aItens,'')                   // laudo laboratorial (tabela ZAF)
		aadd(_aItens,::Etiqueta)             // D3_VAETIQ Etiqueta
		aadd(_aItens,_sChaveEx)              // Chave externa D3_VACHVEX
	//	u_log2 ('debug', _aItens)
		aadd(_aAuto261, aclone (_aItens))

		lMsErroAuto := .F.
		MSExecAuto({|x,y| mata261(x,y)},_aAuto261,3) //INCLUSAO

		// Ja tive casos de nao gravar e tambem nao setar a variavel lMsErroAuto. Por isso vou conferir a gravacao.
//		if ! lMsErroAuto
		// Nao estou mais confiando muito no retorno da variavel lMsErroAuto.
		// Peguei alguns casos inconsistentes. Vou conferir por minha conta. Robert, 12/06/2023.
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := " SELECT R_E_C_N_O_"
			_oSQL:_sQuery +=   " FROM " + RetSQLName ("SD3")
			_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=    " AND D3_FILIAL  = '" + xfilial ("SD3") + "'"
			_oSQL:_sQuery +=    " AND D3_VACHVEX = '" + _sChaveEx + "'"
			_aRegsSD3 := aclone (_oSQL:RetFixo (2, "ao procurar os 2 registros que deveriam ter sido gravados na tabela SD3.", .F.))
			if len (_aRegsSD3) != 2
				U_Log2 ('erro', '[' + procname () + ']Setando lMsErroAuto para .T. por que nao achei os 2 registros esperados no SD3. Query para conferencia: ' + _oSQL:_sQuery)
				_Super:SomaMsg ("Problemas na gravacao da transferencia. Nao encontrei os dois registros que deveriam ter sido gravados. Query para conferencia: " + _oSQL:_sQuery)
				lMsErroAuto = .T.
			else
				lMsErroAuto = .F.
			endif
//		endif

		If lMsErroAuto
			if ! empty (_sErroAuto)
				_Super:SomaMsg (_sErroAuto)
			endif
			if ! empty (NomeAutoLog ())
				_Super:SomaMsg (U_LeErro (memoread (NomeAutoLog ())))
			endif
			if empty (::UltMsg)
				_Super:SomaMsg ('[Sem descricao do erro]')
			endif
			::UltMsg = "Erro interno na rotina de transferencia: " + ::UltMsg

			// Esta mensagem se resolve tentando novamente, entao nao marcarei o registro como 'erro'
			if ! "ja existe uma movimentacao com este numero de documento" $ lower (strtran (::UltMsg, '  ', ' '))
				U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Nao vou marcar como ERRO por que trata-se da putrida mensagem de que o documento jah existe...')
				::Executado = 'E'
				::AtuZAG ("zag_exec", ::Executado)
			endif
			_lContinua = .F.
			u_log2 ('erro', ::UltMsg)
		else
			::Executado = 'S'
			::AtuZAG ("zag_exec", ::Executado)
			_Super:SomaMsg ("Movto.gerado no Protheus com DOC=" + _sDoc)
			u_log2 ('info', ::UltMsg)
		endif
	endif
return _lContinua


// --------------------------------------------------------------------------
// Grava novo registro.
METHOD Grava () Class ClsTrEstq
	local _lContinua := .T.
	local _lRet      := .F.
	local _sMsgLog   := ''
	local _nLock     := 0
	local _nTenta    := 0

	if ::RegZAG != 0
		_Super:SomaMsg ("Registro ja existe na tabela ZAG (recno " + cvaltochar (::RegZAG) + ") e nao vai ser regravado.")
		_lContinua = .F.
	endif

	// Verifica se pode gravar
	if _lContinua
		_lContinua = ::PodeIncl ()
	endif

	// Vou gravar usando semaforo, por que preciso ter numero de documento exclusivo, inclusive entre filiais.
	if _lContinua
		// Faz algumas tentativas antes de cuspir erro para o usuario.
		_nTenta = 0
		do while _nTenta++ <= 10
			U_Log2 ('debug', '[' + GetClassName (::Self) + '_' + procname () + ']Tentativa ' + cvaltochar (_nTenta) + ' de criar semaforo')
			_nLock := U_Semaforo (GetClassName (::Self) + '.' + procname ())
			if _nLock != 0
				exit
			endif
			sleep (1000)
		enddo
		if _nLock == 0
			u_help ("Nao foi possivel obter acesso exclusivo para gravacao desta solicitacao.",, .t.)
			_lContinua = .F.
		endif
	endif

	if _lContinua
		BEGIN TRANSACTION

		// Se ainda nao tenho numero de documento, procuro o proximo livre.
		// Posso estar desmembrando uma solicitacao. Nesses casos, jah terei o
		// numero de documento, seguido de um sequencial.
		if empty (::Docto)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += " SELECT MAX (ZAG_DOC)"
			_oSQL:_sQuery +=   " FROM " + RetSQLName ("ZAG") + " ZAG "
			// QUERO considerar os deletados tambem ---> _oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=  " WHERE ZAG_FILIAL = '" + xfilial ("ZAG") + "'"
		//	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			::Docto = _oSQL:RetQry (1, .f.)
			if empty (::Docto)
				::Docto = strzero (0, tamsx3 ("ZAG_DOC")[1])
			endif
			::Docto = soma1 (::Docto)
			::Seq   = strzero (1, tamsx3 ("ZAG_SEQ")[1])
		endif

		// Prepara mensagem bem 'cuti-cuti' para arquivo de log.
		_sMsgLog := ''
		_sMsgLog += '[' + GetClassName (::Self) + '.' + procname () + "]Gravando ZAG_DOC/SEQ:" + ::Docto + '/' + ::Seq
		_sMsgLog += " Prd:" + alltrim (::ProdOrig)
		if ::ProdDest != ::ProdOrig
			_sMsgLog += '->' + alltrim (::ProdDest)
		endif
		_sMsgLog += " ax:" + ::AlmOrig + '->' + ::AlmDest
		if ! empty (::EndOrig) .or. ! empty (::EndDest)
			_sMsgLog += " end:" + ::EndOrig + '->' + ::EndDest
		endif
		if ! empty (::LoteOrig) .or. ! empty (::LoteDest)
			_sMsgLog += " lote:" + ::LoteOrig + '->' + ::LoteDest
		endif
		_sMsgLog += " Qt:" + cvaltochar (::QtdSolic)
		u_log2 ('info', _sMsgLog)

		reclock ("ZAG", .T.)
		zag -> zag_filial = xfilial ("ZAG")
		zag -> zag_FilOri = ::FilOrig
		zag -> zag_filDst = ::FilDest
		zag -> zag_doc    = ::Docto
		zag -> zag_seq    = ::Seq
		zag -> zag_emis   = ::DtEmis
		zag -> zag_usrinc = ::UsrIncl
		zag -> zag_op     = ::OP
		zag -> zag_Motivo = U_NoAcento (::Motivo)
		zag -> zag_PrdOri = ::ProdOrig
		zag -> zag_PrdDst = ::ProdDest
		zag -> zag_AlmOri = ::AlmOrig
		zag -> zag_AlmDst = ::AlmDest
		zag -> zag_EndOri = ::EndOrig
		zag -> zag_EndDst = ::EndDest
		zag -> zag_LotOri = ::LoteOrig
		zag -> zag_LotDst = ::LoteDest
		zag -> zag_QtdSol = ::QtdSolic
		zag -> zag_CodMot = ::CodMotivo
		zag -> zag_EtqRef = ::EtqRef
		msunlock ()

		::RegZAG = zag -> (recno ())
		_Super:SomaMsg ("Solic.de transf.gravada: " + ::Docto + '/' + ::Seq + '.')
		_lRet = .T.
		END TRANSACTION
	endif

	// Libera semaforo
	U_Semaforo (_nLock)

	// Verifica necessidade de gerar etiqueta
	if _lRet
		::GeraEtiq (.F.)
	endif

	// Faz as liberacoes que forem possiveis
	if _lRet
		if ::LibNaIncl
			::Libera (.F.)
			::Executa ()  // Tenta executar, pois as liberacoes podem ter tido exito.
		endif
	endif

	if ! _lContinua .and. ! empty (::UltMsg)
		u_help (::UltMsg,, .t.)

		// Persiste ultimas mensagens na tabela ZAG, para ajudar pessoal de suporte.
		::AtuZAG ("zag_UltMsg", ::UltMsg)
	endif

return _lRet


// --------------------------------------------------------------------------
// Busca dados adicionais dos produtos origem e destino (podem nao ser iguais)
METHOD LeSB1 () class ClsTrEstq
	local _lRetSB1  := .T.
	local _aAreaAnt := U_ML_SRArea ()

	sb1 -> (dbsetorder (1))
	if ! sb1 -> (dbseek (xfilial ("SB1") + ::ProdOrig, .F.))
		_Super:SomaMsg ("Cadastro do produto origem (" + alltrim (::ProdOrig) + ") da transferencia nao localizado!")
		u_help (::UltMsg,, .t.)
		_lRetSB1 = .F.
	else
		::CtrLocOrig = (sb1 -> b1_localiz == 'S')
		::CtrLocDest = (sb1 -> b1_localiz == 'S')  // Presumindo que seja o mesmo produto.
		::CtrLotOrig = (sb1 -> b1_rastro  == 'L')
		::CtrLotDest = (sb1 -> b1_rastro  == 'L')  // Presumindo que seja o mesmo produto.
		::FWProdOrig = (sb1 -> b1_vafullw == 'S')
		::FWProdDest = (sb1 -> b1_vafullw == 'S')  // Presumindo que seja o mesmo produto.
		if sb1 -> b1_rastro == 'S'
			_Super:SomaMsg ("Produto origem controla sublote. Falta tratamento neste programa.")
			_lRetSB1 = .F.
		endif
	endif
	if ::ProdDest != ::ProdOrig
		if ! sb1 -> (dbseek (xfilial ("SB1") + ::ProdDest, .F.))
			_Super:SomaMsg ("Cadastro do produto destino (" + alltrim (::ProdDest) + ") da transferencia nao localizado!")
			u_help (::UltMsg,, .t.)
			_lRetSB1 = .F.
		else
			::CtrLocDest = (sb1 -> b1_localiz == 'S')
			::CtrLotDest = (sb1 -> b1_rastro  == 'L')
			::FWProdDest = (sb1 -> b1_vafullw == 'S')
			if sb1 -> b1_rastro == 'S'
				_Super:SomaMsg ("Produto destino controla sublote. Falta tratamento neste programa.")
				_lRetSB1 = .F.
			endif
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRetSB1


// --------------------------------------------------------------------------
// Grava as liberacoes para as quais o usuario corrente tem permissao.
METHOD Libera (_lMsg, _sUserName) Class ClsTrEstq
	local _lNenhuma := .T.
	local _oSQL     := NIL
	local _aLib     := {}

	_lMsg = iif (_lMsg == NIL, .T., _lMsg)
	_sUserName = iif (_sUserName == NIL, cUsername, _sUserName)

	// Se ainda tem alguma liberacao pendente...
	if empty (::UsrAutOri) .or. empty (::UsrAutDst)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT rtrim (LIBERADORES_ALMORI)    AS ORI,"
		_oSQL:_sQuery +=       " rtrim (LIBERADORES_ALMDST)    AS DST"
		_oSQL:_sQuery +=  " FROM VA_VSOL_TRANSF_ESTOQUE"
		_oSQL:_sQuery += " WHERE ZAG_FILIAL = '" + xfilial ("ZAG") + "'"
		_oSQL:_sQuery +=   " AND ZAG_DOC    = '" + ::Docto + "'"
		_oSQL:_sQuery +=   " AND ZAG_SEQ    = '" + ::Seq + "'"
		//_oSQL:Log ()
		_aLib := aclone (_oSQL:Qry2Array (.F., .F.))
		// u_log2 ('debug', 'Liberadores alm ' + ::AlmOrig + '(origem) :' + alltrim (_aLib [1, 1]))
		// u_log2 ('debug', 'Liberadores alm ' + ::AlmDest + '(destino):' + alltrim (_aLib [1, 2]))
		//u_log2 ('debug', 'Testando com usuario ' + _sUserName)
		if empty (::UsrAutOri) .and. alltrim (upper (_sUserName)) $ _aLib [1, 1]
			u_log2 ('info', 'Usuario ' + _sUserName + ' tem liberacao para o almox. origem')
			if ::FWProdOrig .and. ::AlmUsaFull (::FilOrig, ::AlmOrig) .and. _sUserName != 'FULLWMS'
				U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']... mas o produto usa Full e o AX origem eh controlado pelo FullWMS')
				_sMsg = "Produto '" + alltrim (::ProdOrig) + "' tem controle via FullWMS no AX '" + ::AlmOrig + "' e nao deve ser movimentado manualmente."
				_Super:SomaMsg (_sMsg)
				_lNenhuma = .F.
			else
				if ::AtuZAG ("zag_UAutO", _sUserName)
					::UsrAutOri = _sUserName
					_Super:SomaMsg (iif (_lMsg, "AX orig.liberado. ", ''))
					_lNenhuma = .F.
				endif
			endif
		endif

		if empty (::UsrAutDst) .and. alltrim (upper (_sUserName)) $ _aLib [1, 2]
			u_log2 ('info', 'Usuario ' + _sUserName + ' tem liberacao para o almox. destino')
			if ::FWProdDest .and. ::AlmUsaFull (::FilDest, ::AlmDest) .and. _sUserName != 'FULLWMS'
				U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']... mas o produto usa Full e o AX destino eh controlado pelo FullWMS')
				_sMsg = "Produto '" + alltrim (::ProdDest) + "' tem controle via FullWMS no AX '" + ::AlmDest + "' e nao deve ser movimentado manualmente."
				_Super:SomaMsg (_sMsg)
				_lNenhuma = .F.
			else

				if ::AtuZAG ("zag_UAutD", _sUserName)
					_Super:SomaMsg (iif (_lMsg, "AX dest.liberado. ", ''))
					::UsrAutDst = _sUserName
					_lNenhuma = .F.
				endif
			endif
		endif
		
	//	// Inicialmente a liberacao de PCP e qualidade vai ser automatica
	//	if empty (::UsrAutPCP) .and. ::AtuZAG ("zag_UAutP", 'Auto') // _sUserName)
	//		::UsrAutPCP = 'Auto' //_sUserName
	//		_lNenhuma = .F.
	//	endif
	//	if empty (::UsrAutQld) .and. ::AtuZAG ("zag_UAutQ", 'Auto') // _sUserName)
	//		::UsrAutQld = 'Auto' //_sUserName
	//		_lNenhuma = .F.
	//	endif
	endif

	if _lNenhuma
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Nada a liberar')
		_Super:SomaMsg (iif (_lMsg, "Nenhuma liberacao pendente para este usuario.", ''))
	endif

	// Atualiza atributos do objeto com base no conteudo do registro atual.
	::GeraAtrib ("ZAG")

return


// --------------------------------------------------------------------------
// Negar a solicitacao de transferencia (nao aceite).
METHOD Negar (_sMotivo) Class ClsTrEstq
	local _lContinua := .T.

	::UltMsg = ""

	if _lContinua .and. ::Executado == 'S'
		_Super:SomaMsg ("Transferencia ja executada.")
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'X'
		_Super:SomaMsg ("Transferencia ja estornada.")
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'N'
		_Super:SomaMsg ("Transferencia ja negada.")
		_lContinua = .F.
	endif
	if _lContinua .and. empty (_sMotivo)
		_Super:SomaMsg ("Deve ser informado motivo de nao aceite.")
		_lContinua = .F.
	endif

	// Usuario que estah gravando a solicitacao tem que ser dono de pelo menos um dos almoxarifados envolvidos.
	if _lContinua
		if ! U_ZZUVL ('A' + ::AlmOrig, __cUserId, .F.)
			U_Log2 ('debug', '[' + procname () + ']Usr atual nao eh dono do ax.origem (' + ::AlmOrig + ')')
			if ! U_ZZUVL ('A' + ::AlmDest, __cUserId, .F.)
				U_Log2 ('debug', '[' + procname () + ']Usr atual nao eh dono do ax.destino (' + ::AlmDest + ')')
				_Super:SomaMsg ("Para negar esta solicitacao, voce deve ser dono de pelo menos um dos almoxarifados envolvidos.")
				_lContinua = .F.
			endif
		endif
	endif

	if _lContinua
		::MotNac    = alltrim (cUserName) + ':' + _sMotivo
		::Executado = 'N'
		::AtuZAG ("zag_MotNac", ::MotNac)
		::AtuZAG ("zag_exec", ::Executado)
		_Super:SomaMsg ("Solicitacao negada por " + cUserName + ' em ' + dtoc (date ()))
	endif
	if ! _lContinua
		u_help (::UltMsg)

		// Persiste ultimas mensagens na tabela ZAG, para ajudar pessoal de suporte.
		::AtuZAG ("zag_UltMsg", ::UltMsg)
	endif
return _lContinua


// --------------------------------------------------------------------------
// Negar a solicitacao de transferencia (nao aceite).
METHOD NovoEndDst (_sNEndDst) Class ClsTrEstq
	local _lContinua := .T.

	::UltMsg = ""

	if _lContinua .and. ::Executado == 'S'
		_Super:SomaMsg ("Transferencia ja executada.")
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'X'
		_Super:SomaMsg ("Transferencia ja estornada.")
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'N'
		_Super:SomaMsg ("Transferencia ja negada.")
		_lContinua = .F.
	endif
	if _lContinua .and. empty (_sNEndDst)
		_Super:SomaMsg ("Deve ser informado um novo endereco destino.")
		_lContinua = .F.
	endif
	if _lContinua
		sbe -> (dbsetorder (1))  // BE_FILIAL, BE_LOCAL, BE_LOCALIZ, BE_ESTFIS, R_E_C_N_O_, D_E_L_E_T_
		if ! sbe -> (dbseek (xfilial ("SBE") + ::AlmDest + _sNEndDst, .F.))
			_Super:SomaMsg ("Endereco informado (" + _sNEndDst + ") nao existe no almoxarifado " + ::AlmDest)
			_lContinua = .F.
		else
			if sbe -> be_status $ '3/4/5/6'  // 1=Desocupado;2=Ocupado;3=Bloqueado;4=Bloqueio Entrada;5=Bloqueio Saída;6=Bloqueio Inventário
				_Super:SomaMsg ("Endereco informado (" + _sNEndDst + ") encontra-se bloqueado.")
				_lContinua = .F.
			else
				if sbe -> be_vasitua $ '2/3'  // 1=Instalado;2=Em instalacao;3=Desativado;4=Investimento
					_Super:SomaMsg ("Situacao do tanque " + _sNEndDst + " impede seu uso.")
					_lContinua = .F.
				endif
			endif
		endif
	endif

	// Usuario que estah gravando tem que ser dono do almoxarifado destino.
	if _lContinua
		if ! U_ZZUVL ('A' + ::AlmDest, __cUserId, .F.)
			U_Log2 ('debug', '[' + procname () + ']Usr atual nao eh dono do ax.destino (' + ::AlmDest + ')')
			_Super:SomaMsg ("Para alterar o endereço destino, voce deve ser dono do almoxarifado " + ::AlmDest)
			_lContinua = .F.
		endif
	endif

	if _lContinua
		_Super:SomaMsg ("Endereco destino alterado de " + ::EndDest + " para " + _sNEndDst + " por " + cUserName + ' em ' + dtoc (date ()))
		::EndDest = _sNEndDst
		::AtuZAG ("zag_enddst", ::EndDest)
	endif
	if ! _lContinua
		u_help (::UltMsg)

		// Persiste ultimas mensagens na tabela ZAG, para ajudar pessoal de suporte.
		::AtuZAG ("zag_UltMsg", ::UltMsg)
	endif
return _lContinua


// --------------------------------------------------------------------------
// Valida se a solicitacao pode ser incluida.
METHOD PodeIncl () Class ClsTrEstq
	local _lContinua := .T.
	local _sMsgEstq  := ''

	// Verifica campos obrigatorios, nao aceitos, tamanhos, tipos, etc.
	if _lContinua
		if empty (::Motivo) .and. ! empty (::CodMotivo)
			::Motivo = alltrim (U_RetZX5 ('56', ::CodMotivo, "ZX5_56DESC"))
		endif
		if empty (::FilOrig)
			_Super:SomaMsg ("Filial de origem deve ser informada.")
			_lContinua = .F.
		endif
		if empty (::FilDest)
			_Super:SomaMsg ("Filial destino deve ser informada.")
			_lContinua = .F.
		endif
		if empty (::AlmOrig)
			_Super:SomaMsg ("Almoxarifado de origem deve ser informado.")
			_lContinua = .F.
		endif
		if empty (::AlmDest)
			_Super:SomaMsg ("Almoxarifado destino deve ser informado.")
			_lContinua = .F.
		endif
		if empty (::DtEmis)
			_Super:SomaMsg ("Data de emissao deve ser informada.")
			_lContinua = .F.
		endif
		if empty (::UsrIncl)
			_Super:SomaMsg ("Nome solicitante deve ser informado.")
			_lContinua = .F.
		endif
		if empty (::Motivo)
			_Super:SomaMsg ("Motivo da transferencia deve ser informado.")
			_lContinua = .F.
		endif
		if empty (::ProdOrig)
			_Super:SomaMsg ("Produto deve ser informado.")
			_lContinua = .F.
		endif
		if empty (::QtdSolic)
			_Super:SomaMsg ("Quantidade solicitada deve ser informada.")
			_lContinua = .F.
		endif
		if ! empty (::Docto)
			_Super:SomaMsg ("Documento NAO deve ser informado na inclusao.")
			_lContinua = .F.
		endif
		if ! empty (::RegZAG)
			_Super:SomaMsg ("RECNO da tabela ZAG NAO deve ser informado na inclusao.")
			_lContinua = .F.
		endif
		if valtype (::QtdSolic) != 'N'
			_Super:SomaMsg ("Quantidade deve ser do tipo numerico.")
			_lContinua = .F.
		else
			if ::QtdSolic <= 0
				_Super:SomaMsg ("Quantidade solicitada zerada ou negativa.")
				_lContinua = .F.
			endif
		endif

		// Por enquanto, nao vou aceitar transferencia entre filiais. Robert, 11/04/2019
		if ::FilDest != ::FilOrig
			::UltMsg += "Transferencias entre filiais ainda nao sao permitidas nesta rotina.Filial origem deve ser igual a filial destino."
			_lContinua = .F.
		endif
		if ::FilOrig != cFilAnt .or. ::FilDest != cFilAnt
			::UltMsg += "Transferencias entre filiais ainda nao sao permitidas nesta rotina. Portanto, nao tente incluir solicitacoes envolvendo outras filiais."
			_lContinua = .F.
		endif

		// Verifica tamanhos de campos para evitar, por exemplo, uma chamada
		// passando o produto com tamanho != 15
		// Usa tamanhos fixos (nao busca no SX3) por questao de performance,
		// jah que sao campos chave e dificilmente mudarao de tamanho.  
		if _lContinua .and. len (::FilOrig) != 2
			_Super:SomaMsg ("Filial origem deve ter tamanho 2.")    
			_lContinua = .F.
		endif
		if _lContinua .and. len (::FilDest) != 2
			_Super:SomaMsg ("Filial destino deve ter tamanho 2.")   
			_lContinua = .F.
		endif
		if _lContinua .and. len (::ProdOrig) != 15
			_Super:SomaMsg ("Produto origem deve ter tamanho 15.")  
			_lContinua = .F.
		endif
		if _lContinua .and. len (::ProdDest) != 15
			_Super:SomaMsg ("Produto destino deve ter tamanho 15.") 
			_lContinua = .F.
		endif
		if _lContinua .and. len (::AlmOrig) != 2
			_Super:SomaMsg ("Alm.origem deve ter tamanho 2.")
			_lContinua = .F.
		endif
		if _lContinua .and. len (::AlmDest) != 2
			_Super:SomaMsg ("Alm.destino deve ter tamanho 2.")
			_lContinua = .F.
		endif
		if _lContinua .and. ! empty (::EndOrig) .and. len (::EndOrig) != 15
			_Super:SomaMsg ("Endereco origem deve ter tamanho 15.") 
			_lContinua = .F.
		endif
		if _lContinua .and. ! empty (::EndDest) .and. len (::EndDest) != 15
			_Super:SomaMsg ("Endereco destino deve ter tamanho 15.")
			_lContinua = .F.
		endif
		if _lContinua .and. ! empty (::LoteOrig) .and. len (::LoteOrig) != 10
			_Super:SomaMsg ("Lote origem deve ter tamanho 10.")
			_lContinua = .F.
		endif
		if _lContinua .and. ! empty (::loteDest) .and. len (::LoteDest) != 10
			_Super:SomaMsg ("Lote destino deve ter tamanho 10.")
			_lContinua = .F.
		endif
	endif

	// Testa possibilidade do destino ser igual a origem.
	if _lContinua
		if ::FilOrig == ::FilDest ;
		.and. ::ProdOrig == ::ProdDest ;
		.and. ::AlmOrig  == ::AlmDest ;
		.and. ::EndOrig  == ::EndDest ;
		.and. ::LoteOrig == ::LoteDest
			_Super:SomaMsg ("Nao ha sentido em transferir quando origem e destino sao iguais.")
			_lContinua = .F.
		endif
	endif

	// Codigo do motivo ainda nao eh obrigatorio por que nao tem em todas as telas.
	// Mas, se informado, deve existir.
	if _lContinua .and. ! empty (::CodMotivo)
		if ! U_ExistZX5 ('56', ::CodMotivo, .F.)
			_Super:SomaMsg ("Codigo motivo transf '" + ::CodMotivo + "' nao cadastrado.")
			_lContinua = .F.
		endif
	endif

	if _lContinua
		// Faz leitura de dados dos produtos a partir do SB1. Isso por que o
		// objeto pode ter sido instanciado e modificado pelo programa chamador
		// e agora eu estaria com dados de SB1 desatualizados.
		::LeSB1 ()

		if ::CtrLotOrig .and. empty (::LoteOrig) .and. ! ::AlmUsaFull (::FilOrig, ::AlmOrig)
			_Super:SomaMsg ("Produto origem controla lotes. Lote de origem deve ser informado.")
			_lContinua = .F.
		endif
		if ::CtrLocOrig .and. empty (::EndOrig) .and. ! ::AlmUsaFull (::FilOrig, ::AlmOrig)
			_Super:SomaMsg ("Produto origem controla localizacao. Endereco de origem deve ser informado.")
			_lContinua = .F.
		endif
		if ! empty (::LoteOrig) .and. ! ::CtrLotOrig
			
			// Se vai sair do FullWMS, posso especificar o lote
			if ::FWProdOrig .and. ::AlmUsaFull (::FilOrig, ::AlmOrig)
				// ok
			else
				_Super:SomaMsg ("Lote origem nao deve ser informado pois o produto '" + alltrim (::ProdOrig) + "' nao controla lote.")
				_lContinua = .F.
			endif
		endif
		if ! empty (::EndOrig) .and. ! ::CtrLocOrig
			_Super:SomaMsg ("Endereco origem nao deve ser informado pois o produto '" + alltrim (::ProdOrig) + "' nao controla localizacao.")
			_lContinua = .F.
		endif
		if ::CtrLotDest .and. empty (::LoteDest)
			_Super:SomaMsg ("Produto destino controla lotes. Lote destino deve ser informado.")
			_lContinua = .F.
		endif
		if ::CtrLocDest .and. empty (::EndDest)
			_Super:SomaMsg ("Produto destino controla localizacao. Endereco destino deve ser informado.")
			_lContinua = .F.
		endif
		if ! empty (::LoteDest) .and. ! ::CtrLotDest
			if ! (::FWProdDest .and. ::AlmUsaFull (::FilDest, ::AlmDest))  // Se vai para FullWMS, tenho que informar algum lote para ele.
				_Super:SomaMsg ("Lote destino nao deve ser informado pois o produto '" + alltrim (::ProdDest) + "' nao controla lote.")
				_lContinua = .F.
			endif
		endif
		if empty (::LoteDest) .and. ::AlmUsaFull (::FilDest, ::AlmDest)  // Se vai para FullWMS, tenho que informar algum lote para ele.
			_Super:SomaMsg ("Deve ser informado um lote de destino por que o FullWMS vai exigir.")
			_lContinua = .F.
		endif
		if ! empty (::EndDest) .and. ! ::CtrLocDest
			_Super:SomaMsg ("Endereco destino nao deve ser informado pois o produto '" + alltrim (::ProdDest) + "' nao controla localizacao.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ! empty (::AlmOrig)
		nnr -> (dbsetorder (1))  // NNR_FILIAL+NNR_CODIGO
		if ! nnr -> (dbseek (xfilial ("NNR") + ::AlmOrig, .F.))  // Nao pesquisa pela filial origem por que o NNR eh compartilhado.
			_Super:SomaMsg ("Almoxarifado origem '" + ::AlmOrig + "' nao cadastrado.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ! empty (::AlmDest)
		nnr -> (dbsetorder (1))
		if ! nnr -> (dbseek (xfilial ("NNR") + ::AlmDest, .F.))  // Nao pesquisa pela filial origem por que o NNR eh compartilhado.
			_Super:SomaMsg ("Almoxarifado destino '" + ::AlmDest + "' nao cadastrado.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ::CtrLotOrig .and. ! empty (::LoteOrig)
		sb8 -> (dbsetorder (5))  // B8_FILIAL+B8_PRODUTO+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
		if ! sb8 -> (dbseek (::FilOrig + ::ProdOrig + ::LoteOrig, .F.))
			_Super:SomaMsg ("Lote origem '" + ::LoteOrig + "' nao encontrado para o produto '" + ::ProdOrig + "' na filial '" + ::FilOrig + "'.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ::CtrLotDest .and. ! empty (::LoteDest)
		sb8 -> (dbsetorder (5))  // B8_FILIAL+B8_PRODUTO+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
		if ! sb8 -> (dbseek (::FilDest + ::ProdDest + ::LoteDest, .F.))
			_Super:SomaMsg ("Lote destino '" + ::LoteDest + "' ja existe para o produto '" + ::ProdDest + "' na filial '" + ::FilDest + "'.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ! empty (::EndOrig)
		sbe -> (dbsetorder (1))  // BE_FILIAL+BE_LOCAL+BE_LOCALIZ
		if ! sbe -> (dbseek (::FilOrig + ::AlmOrig + ::EndOrig, .F.))
			_Super:SomaMsg ("Endereco origem '" + ::EndOrig + "' nao encontrado no almoxarifado '" + ::AlmOrig + "' da filial '" + ::FilOrig + "'.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ! empty (::EndDest)
		sbe -> (dbsetorder (1))  // BE_FILIAL+BE_LOCAL+BE_LOCALIZ
		if ! sbe -> (dbseek (::FilDest + ::AlmDest + ::EndDest, .F.))
			_Super:SomaMsg ("Endereco destino '" + ::EndDest + "' nao encontrado no almoxarifado '" + ::AlmDest + "' da filial '" + ::FilDest + "'.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ! empty (::OP)
		sc2 -> (dbsetorder (1))
		if ! sc2 -> (dbseek (::FilOrig + ::OP, .F.))
			_Super:SomaMsg ("OP '" + ::OP + "' nao encontrada na filial '" + ::FilOrig + "'.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ::AlmUsaFull (::FilOrig, ::AlmOrig)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT MIN (A5_VAQSOLW)"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SA5") + " SA5 "
		_oSQL:_sQuery +=  " WHERE SA5.D_E_L_E_T_  = ''"
		_oSQL:_sQuery +=  " AND SA5.A5_FILIAL   = '" + xfilial ("SA5") + "'"
		_oSQL:_sQuery +=  " AND SA5.A5_PRODUTO  = '" + ::ProdOrig + "'"
		_oSQL:_sQuery +=  " AND SA5.A5_VAQSOLW != 0"
		_oSQL:Log ()
		_nTamLote = _oSQL:RetQry (1, .F.)
		_nResto = ::QtdSolic % _nTamLote
		if _nResto != 0
			_Super:SomaMsg ("Produto e almox. de origem operam com FullWMS, e o produto tem lote minimo de " + alltrim(str(_nTamLote)) + " (cfe. tabela SA5). Nao sera possivel gerar uma movimentacao.")
			_lContinua = .F.
		endif
	endif
	
	// Usuario que estah gravando a solicitacao tem que ser dono de pelo menos um dos almoxarifados envolvidos.
	if _lContinua
		if ! U_ZZUVL ('A' + ::AlmOrig, __cUserId, .F.)
			U_Log2 ('debug', '[' + procname () + ']Usr atual nao eh dono do ax.origem (' + ::AlmOrig + ')')
			if ! U_ZZUVL ('A' + ::AlmDest, __cUserId, .F.)
				U_Log2 ('debug', '[' + procname () + ']Usr atual nao eh dono do ax.destino (' + ::AlmDest + ')')
				_Super:SomaMsg ("Para gravar esta solicitacao, voce deve ser dono de pelo menos um dos almoxarifados envolvidos.")
				_lContinua = .F.
			endif
		endif
	endif

	// Verifica possiveis inconsistencias entre tabelas e disponibilidade de saldos 
	if _lContinua
		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Vou validar estoque')

		// Quando avarias recebidas do FullWMS, nao quero mais validar
		// o estoque do FullWMS por que lah jah foi dado baixa.
		if ::CodMotivo == '08'  // Quando avarias recebidas do FullWMS, nao quero
			_sMsgEstq = U_VerEstq ("6", ::ProdOrig, '', ::AlmOrig, ::QtdSolic, '', ::EndOrig, ::LoteOrig, '')
		else
			_sMsgEstq = U_VerEstq ("5", ::ProdOrig, '', ::AlmOrig, ::QtdSolic, '', ::EndOrig, ::LoteOrig, '')
		endif
		if ! empty (_sMsgEstq)
			::SetCodRetorno ('1')
			_Super:SomaMsg (_sMsgEstq)
			_lContinua = .F.
		else
			// Procura inconsistencias entre tabelas do estoque
			if ! U_ConsEstq (::FilOrig, ::ProdOrig, ::AlmOrig, '')
				_Super:SomaMsg ("Inconsistencia entre tabelas de estoque do produto " + ::ProdOrig)
				_lContinua = .F.
			endif
			if _lContinua
				// Se nao for uma simples transferencia entre enderecos (mesmo
				// produto/lote/almox), precisarei verificar tambem o destino.
				if ::FilDest != ::FilOrig .or. ::ProdDest != ::ProdOrig .or. ::AlmDest != ::AlmOrig
					if ! U_ConsEstq (::FilDest, ::ProdDest, ::AlmDest, '')
						_Super:SomaMsg ("Inconsistencia entre tabelas de estoque do produto " + ::ProdOrig)
						_lContinua = .F.
					endif
				endif
			endif
		endif
	endif

	// Verifica se o produto pode ser transformado
	if _lContinua .and. ::ProdDest != ::ProdOrig
		U_Log2 ('debug', '[' + procname () + ']Solicitacao de transformacao do item ' + ::ProdOrig + ' para ' + ::ProdDest)
		if posicione ("SB1", 1, xfilial("SB1") + ::ProdOrig, "B1_VATROUT") != "S"
			if ! U_ZZUVL ('119', __cUserId, .F.)
				_Super:SomaMsg ("Item origem configurado para nao aceitar transformacao para outros codigos.")
				_lContinua = .F.
			else
				U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Aceitando solicitacao de transformacoes por que o usuario ' + __cUserId + ' pertence ao grupo 119.')
			endif
		endif
	endif

	if _lContinua .and. ::AlmDest == '11' .and. ! ::CodMotivo $ '04/09'
		_Super:SomaMsg ("Transferencias para ax.11 sao permitidas somente com motivo 04 ou 09 (pallet reprocessado / desfazimento de guarda de pallet).")
		_lContinua = .F.
	endif


	// Validacoes para disponibilizar pallet reprocessado para logistica
	if _lContinua .and. ::CodMotivo == '04'
		if empty (::OP)
			_Super:SomaMsg ("Para disponibilizar pallet reprocessado para logistica, deve ser informada a OP.")
			_lContinua = .F.
		endif
		if _lContinua
			sc2 -> (dbsetorder (1))  // C2_FILIAL, C2_NUM, C2_ITEM, C2_SEQUEN, C2_ITEMGRD, R_E_C_N_O_, D_E_L_E_T_
			if ! sc2 -> (dbseek (::FilDest + ::OP, .F.))
				_Super:SomaMsg ("OP referenciada '" + ::OP + "' nao localizada na filial '" + ::FilDest + "'.")
				_lContinua = .F.
			endif
		endif
		if _lContinua .and. sc2 -> c2_produto != ::ProdDest
			_Super:SomaMsg ("OP referenciada '" + ::OP + "' atende o produto '" + alltrim (sc2 -> c2_produto) + "' enquanto a sua solicitacao de transferencia atenderia o produto '" + alltrim (::ProdDest) + "' (deveria ser o mesmo produto).")
			_lContinua = .F.
		endif

	endif


	// Validacoes para desfazimento de operacao de guarda de pallets na logistica/FullWMS
	if _lContinua .and. ::CodMotivo == '09'
		if _lContinua .and. (empty (::EtqRef) .or. empty (::OP))
			_Super:SomaMsg ("Para desfazimento de guarda de pallet, devem ser informadas OP e ETIQUETA (cuja guarda na logistica esta sendo desfeita).")
			_lContinua = .F.
		endif

		if _lContinua
			za1 -> (dbsetorder (1))  // ZA1_FILIAL, ZA1_CODIGO, R_E_C_N_O_, D_E_L_E_T_
			if ! za1 -> (dbseek (::FilDest + ::EtqRef, .F.))
				_Super:SomaMsg ("Etiqueta referenciada '" + ::EtqRef + "' nao localizada na filial '" + ::FilDest + "'.")
				_lContinua = .F.
			endif
		endif


		// No momento, nao temos outro motivo para desfazimento sem ser o estorno do apontamento.
		if _lContinua .and. za1 -> za1_quant != ::QtdSolic
			_Super:SomaMsg ("Quantidade original da etiqueta referenciada = " + cvaltochar (za1 -> za1_quant) + ".")
			_lContinua = .F.
		endif

		// No momento, nao temos outro motivo para desfazimento sem ser o estorno do apontamento.
		if _lContinua .and. za1 -> za1_apont == 'E'
			_Super:SomaMsg ("Etiqueta referenciada '" + ::EtqRef + "' ja encontra-se com apontamento estornado no Protheus.")
			_lContinua = .F.
		endif

		// Se uma etiqueta encontra-se inutilizada, nao poderia sequer ter gerado apontamento de producao. Quanto mais estar guardada na logistica!
		if _lContinua .and. za1 -> za1_apont == 'I'
			_Super:SomaMsg ("Etiqueta referenciada '" + ::EtqRef + "' encontra-se inutilizada no Protheus.")
			_lContinua = .F.
		endif

		if _lContinua .and. za1 -> za1_apont != 'S'
			_Super:SomaMsg ("Etiqueta referenciada '" + ::EtqRef + "' nao gerou apontamento de producao no Protheus.")
			_lContinua = .F.
		endif

		if _lContinua .and. za1 -> za1_op != ::OP
			_Super:SomaMsg ("Etiqueta referenciada '" + ::EtqRef + "' nao pertence a OP '" + ::OP + "' informada.")
			_lContinua = .F.
		endif

		// Localiza movimentos desta etiqueta no SD3 (apontamento / transferencias entre AX)
		if _lContinua
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := " SELECT MIN (D3_EMISSAO)"
			_oSQL:_sQuery +=   " FROM " + RetSQLName ("SD3")
			_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=    " AND D3_FILIAL  = '" + ::FilDest + "'"
			_oSQL:_sQuery +=    " AND D3_VAETIQ  = '" + ::EtqRef  + "'"
			_oSQL:_sQuery +=    " AND D3_ESTORNO = ''"
			if stod (_oSQL:RetQry (1, .f.)) < SuperGetMv ("MV_ULMES", .f., ctod (''), ::FilDest)
				_Super:SomaMsg ("Etiqueta referenciada foi apontada em mes ja encerrado no estoque.")
				_lContinua = .F.
			endif
		endif

		if _lContinua
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := " SELECT TOP 1 D3_LOCAL"
			_oSQL:_sQuery +=   " FROM " + RetSQLName ("SD3")
			_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=    " AND D3_FILIAL  = '" + ::FilDest + "'"
			_oSQL:_sQuery +=    " AND D3_VAETIQ  = '" + ::EtqRef  + "'"
			_oSQL:_sQuery +=    " AND D3_ESTORNO = ''"
			_oSQL:_sQuery +=    " AND D3_CF      LIKE 'PR%'"
			if _oSQL:RetQry (1, .f.) != ::AlmDest
				_Super:SomaMsg ("Alm. destino deve ser o mesmo onde a etiqueta referenciada foi apontada (" + _oSQL:RetQry (1, .f.) + ").")
				_lContinua = .F.
			endif
		endif

		if _lContinua
			sc2 -> (dbsetorder (1))  // C2_FILIAL, C2_NUM, C2_ITEM, C2_SEQUEN, C2_ITEMGRD, R_E_C_N_O_, D_E_L_E_T_
			if ! sc2 -> (dbseek (::FilDest + ::OP, .F.))
				_Super:SomaMsg ("OP referenciada '" + ::OP + "' nao localizada na filial '" + ::FilDest + "'.")
				_lContinua = .F.
			endif
		endif

		if _lContinua .and. ! empty (sc2 -> c2_datrf)
			_Super:SomaMsg ("OP referenciada '" + ::OP + "' ja encontra-se encerrada.")
			_lContinua = .F.
		endif

		// Nao permitir mais de uma solicitacao de desfazimento da mesma etiqueta.
		if _lContinua
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := " SELECT COUNT (*)"
			_oSQL:_sQuery +=   " FROM " + RetSQLName ("ZAG")
			_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=    " AND ZAG_FILIAL = '" + xfilial ("ZAG") + "'"
			_oSQL:_sQuery +=    " AND ZAG_CODMOT = '09'"
			_oSQL:_sQuery +=    " AND ZAG_ETQREF = '" + ::EtqRef  + "'"
			_oSQL:_sQuery +=    " AND ZAG_EXEC  != 'X'"  // Nao estornada
			if _oSQL:RetQry (1, .f.) > 0
				_Super:SomaMsg ("Ja existe solicitacao de desfazimento de guarda da etiqueta referenciada.")
				_lContinua = .F.
			endif
		endif

	endif

	if ! _lContinua .and. ! empty (::UltMsg)
		::SetCodRetorno ('6')
		u_help (::UltMsg,, .t.)
	endif

return _lContinua


// --------------------------------------------------------------------------
// Altera codigo (de erro ou de sucesso) para retorno
// AINDA TEM UUUUUITOS PONTOS DESTE PROGRAMA QUE DEVERIAM CHAMAR ESTE METODO!
METHOD SetCodRetorno (_sCod as character) Class ClsTrEstq
	local _aCodRet := {}
	local _nStat   := 0

	// Define os possiveis valores para o codigo de retorno.
	// Se possivel, seria interessante manter compatibilidade com as tabelas
	// de integracao com FullWMS (tb_wms_entrada e tb_wms_pedidos)
	aadd (_aCodRet, {'1', 'Estoque insuficiente'})
	aadd (_aCodRet, {'2', 'Outros erros'})
	aadd (_aCodRet, {'3', 'Transferencia executada'})
	aadd (_aCodRet, {'6', 'Solicitacao nao aceita'})
	aadd (_aCodRet, {'C', 'Solicitacao cancelada'})

	_nStat = ascan (_aCodRet, {|_aVal| _aVal [1] == _sCod})

	if _nStat == 0
		_Super:SomaMsg ('Tentativa de gravar codigo de retorno ' + cvaltochar (_sCod) + ' (invalido) na classe ' + GetClassName (::Self))
	else
		::CodRetorno = _sCod += '-' + _aCodRet [_nStat, 2]
	endif
return
