// Programa:  ClsTrEstq
// Autor:     Robert Koch
// Data:      29/07/2018
// Descricao: Declaracao de classe de representacao de solicitacoes de transferencia de estoque.
//            Criada com base no programa VAFPCP01 de Daniel Scheeren (Proccdata)
//            Poderia trabalhar como uma include, mas prefiro declarar uma funcao de usuario
//            apenas para poder incluir no projeto e manter na pasta dos fontes.
//
// Historico de alteracoes:
// 08/04/2019 - Catia   - include TbiConn.ch 
// 12/04/2019 - Robert  - Deixa variavel _lClsTrEst declarada para posterior uso em pontos de entrada.
// 25/09/2019 - Robert  - Quando o produto tiver controle via FullWMS, libera somente para usuarios do grupo 029.
//                      - Criado atributo LibNaIncl.
// 26/09/2019 - Cláudia - Incluída validação de lote mínimo.
// 27/11/2020 - Robert  - Quando existir etiqueta relacionada, tenta inutiliza-la automaticamente.
//                      - Transf. envolvendo o AX01 (FullWMS) liberadas, momentaneamente, para aceitar liberacao manual (sem ser o Full).
// 04/12/2020 - Robert  - Criado tratamento para produto destino diferente do produto origem.
// 18/10/2021 - Sandra  - Ajuste da mensagem "Transferencia ainda nao gravada na tabela ZZG" para "Transferencia ainda nao gravada na tabela ZAG"
// 25/01/2022 - Robert  - Gera etiqueta quando o prod.controla lote, mesmo nao tendo integracao com FullWMS.
// 06/04/2022 - Robert  - Criado metodo :AlmUsaEtiq() e passa a ser validado antes de gerar etiqueta.
// 22/04/2022 - Robert  - Considerar usr 'FULLW' e nao mais 'FULLWMS' (para caber no campo ZZU_USR) - GLPI 8194
// 27/04/2022 - Robert  - Voltado nome de usuario 'FULLW' para 'FULLWMS' pois optei por criar um usuario com esse nome no Protheus.
// 05/05/2022 - Robert  - Ateh definirmos melhor as integracoes, fica liberado transf.manualmente p/alm que usa Full.
// 06/05/2022 - Robert  - Se a solicitacao foi gerada por integracao com FullWMS, limpa tambem da tabela de integracao (GLPI 8914).
// 15/06/2022 - Robert  - Nao gerava etiqueta se o produto nao controlasse lotes (GLPI 12220)
// 02/08/2022 - Robert  - Para gravar, precisa ser dono de pelo menos um dos almox. (GLPI 12404)
// 02/08/2022 - Robert  - Para gravar, testa possibilidade do destino ser igual a origem (GLPI 12427).
// 13/09/2022 - Robert  - Criados atributos CtrLocOrig, CtrLocDest, CtrLotOrig, CtrLotDest.
// 23/09/2022 - Robert  - Tratamentos para envio para o FullWMS (GLPI 12220).
// 13/10/2022 - Robert  - Melhoria envio etiq. para o FullWMS.
// 19/10/2022 - Robert  - Impedir exclusao se gerou solic.separacao no FullWMS (GLPI 12724)
// 31/10/2022 - Robert  - Classe renomeada de PRW para TLPP
//                      - Tratamentos para permitir lote origem quando destino for FullWMS.
// 09/11/2022 - Robert  - Nao alimentava numero da etiqueta no metodo GeraAtrib.
// 12/12/2022 - Robert  - Implementados metodos SomaMsg e GravaErro.
// 14/12/2022 - RObert  - Gravacao campo ZAG_EREXEC e melhoria mensagens de log.
// 19/01/2023 - Robert  - Metodo Libera() nao tenta mais executar a transferencia no final.
// 27/01/2023 - Robert  - Metodo New passa a aceitar R_E_C_N_O_ ou chave de pesquisa.
//                      - Mensagens, quando for o caso, passam a ser todas persistidas no campo ZAG_ULTMSG.
// 02/02/2023 - Robert  - Quando alm.destino usa FullWMS, exige lote destino, pois o FullWMS vai exigir depois.
// 11/03/2023 - Robert  - Tratamentos para novo campo ZAG_SEQ
//                      - Criado metodo PodeIncl().
//                      - Eliminados campos ZAG_UAUTP e ZAG_UAUTQ (Autorizadores PCP e qualidade).
// 15/03/2023 - Robert  - Para considerar almox.controlado pelo FullWMS, deve estar na filial 01.
// 15/03/2023 - Robert  - Para considerar almox.controlado pelo FullWMS, deve estar na filial 01.
// 20/04/2023 - Robert  - Criado atributo CodMotivo
//

// ------------------------------------------------------------------------------------
#include "colors.ch"
#Include "Protheus.ch"
#Include "RwMake.ch"
#Include "TbiConn.ch"

// --------------------------------------------------------------------------
// Funcao declarada apenas para poder compilar este arquivo fonte.
user function ClsTrEstq ()
return


// ==========================================================================
CLASS ClsTrEstq

	// Declaracao das propriedades da Classe
	public data Filial     // Filial onde foi incluido o registro (campo ZAG_FILIAL)
	public data FilOrig    // Filial origem.
	public data FilDest    // Filial destino.
	public data Docto      // Numero docto na tabela ZAG.
	public data Seq        // Sequencia dentro do documento.
	public data IdGrid     // ID da linha do grid (usado na chamada web service pelo NaWeb)
	public data DtEmis     // Data emissao (inclusao) do ZAG. Nao obrigatoriamente a mesma da geracao do movto.
	public data RegZAG     // Numero registro (RECNO) no ZAG.
	public data OP         // Numero da OP, quando a solic. for gerada por OP.
	public data Motivo     // Descricao do motivo da transferencia. 
	public data ProdOrig   // Codigo do produto origem a transferir.
	public data ProdDest   // Codigo do produto destino (inicilmente a ideia eh sempre transferir para o msmo produto)
	public data AlmOrig    // Almox (local) origem
	public data AlmDest    // Almox (local) destino
	public data CtrLocOrig // Indica se o produto de origem controla enderecamento (campo B1_LOCALIZ)
	public data CtrLocDest // Indica se o produto destino controla enderecamento (campo B1_LOCALIZ)
	public data CtrLotOrig // Indica se o produto de origem controla lote (campo B1_RASTRO)
	public data CtrLotDest // Indica se o produto destino controla lote (campo B1_RASTRO)
	public data CodMotivo  // Codigo do motivo da transferencia.
	public data EndOrig    // Endereco origem (quando produto tiver controle de localizacao)
	public data EndDest    // Endereco destino  (quando produto tiver controle de localizacao)
	public data Etiqueta   // Numero da etiqueta (tabela ZA1), quando existir
	public data Executado  // Indica se jah foi executado (se gerou alguma movimentacao) S=Executado;E=Erro na execucao;X=Estornado
	public data FWProdOrig // Indica se o produto origem eh controlado pelo FullWMS
	public data FWProdDest // Indica se o produto destino eh controlado pelo FullWMS
	public data ImprEtq    // ID da immpressora (caso seja necessario gerar e imprimir etiqueta) 
	public data LibNaIncl  // Indica se, no momento da inclusao do registro no ZAG, jah deve tentar fazer as liberacoes.
	public data LoteOrig   // Lote origem (quando produto tiver controle de lote)
	public data LoteDest   // Lote destino (quando produto tiver controle de lote)
	public data MotNac     // Motivo de nao aceite da solicitacao.
	public data QtdSolic   // Quantidade solicitada (inicial a ser transferida) 
	public data UltMsg     // Ultima mensagem gerada.
	public data UsrIncl    // Usuario que fez a inclusao do registro
	public data UsrAutOri  // Usuario que autorizou pelo almox origem
	public data UsrAutDst  // Usuario que autorizou pelo almox destino

	// Declaracao dos Metodos da classe
	public  METHOD New ()
	public  METHOD AlmUsaEtiq ()
	public  METHOD AlmUsaFull ()
	private METHOD AtuZAG ()
	public  METHOD Estorna ()
	public  METHOD Exclui ()
	public  METHOD Executa ()
	public  METHOD Inclui ()
	public  METHOD GeraAtrib ()
	public  METHOD GeraEtiq ()
	public  METHOD GeraSD3 ()
	public  METHOD Grava ()
	private METHOD GravaErro ()
	private METHOD LeSB1 ()
	public  METHOD Libera ()
	public  METHOD Negar ()
	public  METHOD NovoEndDst ()
	public  METHOD PodeIncl ()
	private METHOD SomaMsg ()
ENDCLASS


// --------------------------------------------------------------------------
// Construtor.
METHOD New (_xChave) Class ClsTrEstq

	// Alimenta atributos com valores default de uma solicitacao nova.
	::GeraAtrib ("")

	// Se receber numerico, eh por que se trata do numero de registro
	// jah existente no ZAG e preciso atualizar o objeto.
	if valtype (_xChave) == "N"
		ZAG -> (dbgoto (_xChave))
		::GeraAtrib ("ZAG")

	// Se receber caracter, eh por que se trata de um codigo jah
	// existente nas tabelas, e preciso atualizar o objeto.
	elseif valtype (_xChave) == "C"
		zag -> (dbsetorder (1))  // ZAG_FILIAL, ZAG_DOC, ZAG_SEQ, R_E_C_N_O_, D_E_L_E_T_
		if ! zag -> (dbseek (_xChave, .F.))
			u_help ("Erro ao instanciar solicitacao de transferencia. Nao foi possivel localizar registro na tabela ZAG com chave '" + _xChave + "'.",, .t.)
		else
			::GeraAtrib ("ZAG")
		endif
	endif

	// Nao vejo necessidade de gerar log ao instanciar um objeto vazio.
	if ! empty (_xChave)
		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Instanciado ' + ;
			' ZAG_DOC ' + ::Docto + '/' + ::Seq + ;
			' ax.' + ::AlmOrig + '->' + ::AlmDest + ;
			' item ' + alltrim (::ProdOrig) + ;
			' qt=' + cvaltochar (::QtdSolic) + ;
			' recno=' + cvaltochar (zag -> (recno ())))
	endif
Return ::self



// --------------------------------------------------------------------------
// Verifica se o almoxarifado usa etiquetas para entrada de material.
METHOD AlmUsaEtiq (_sAlm) Class ClsTrEstq
return (_sAlm $ '01/02')



// --------------------------------------------------------------------------
// Verifica se o almoxarifado eh controlado via FullWMS.
METHOD AlmUsaFull (_sAlm) Class ClsTrEstq
return (::FilDest == '01' .and. _sAlm $ '01/')



// --------------------------------------------------------------------------
// Atualiza (no arquivo) determinado atributo.
METHOD AtuZAG (_sCampo, _xValor) Class ClsTrEstq
	local _lRet := .F.
	local _aAreaAnt  := U_ML_SRArea ()

	if ::RegZAG > 0
		zag -> (dbgoto (::RegZAG))
		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Gravando campo ' + _sCampo + ' com conteudo ' + cvaltochar (_xValor))
		reclock ("ZAG", .F.)
		zag -> &(_sCampo) = _xValor
		msunlock ()
		_lRet = .T.
	else
		//::SomaMsg ("Registro ainda nao gravado na tabela ZAG. Atualizacao do campo '" + _sCampo + "' nao pode ser feita na funcao " + procname ())
		U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + "]Registro ainda nao gravado na tabela ZAG. Atualizacao do campo '" + _sCampo + "' nao pode ser feita.")
		_lRet = .F.
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRet



// --------------------------------------------------------------------------
// Estorna movimento (transf. foi excluida pela tela padrao, preciso mudar o status).
METHOD Estorna () Class ClsTrEstq
	::Executado = 'X'
	::AtuZAG ("zag_exec", ::Executado)
return



// --------------------------------------------------------------------------
// Exclui movimento.
METHOD Exclui () Class ClsTrEstq
	local _lContinua := .T.
	local _oSQL      := NIL
	local _sEtiq     := ''
	local _oEtiq     := NIL

	u_log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Iniciando exclusao do ZAG docto ' + ::Docto)
	::UltMsg = ""

	if _lContinua .and. ::Executado == 'S'
		::SomaMsg ("Este lancamento ja gerou movimentacao. Estorne, antes, o movimento gerado.")
		_lContinua = .F.
	endif
	if _lContinua
		zag -> (dbgoto (::RegZAG))
		if zag -> (recno ()) != ::RegZAG
			::SomaMsg ("Nao foi possivel localizar o registro correspondente no arquivo ZAG. Exclusao nao sera' efetuada.")
			_lContinua = .F.
		else
			::Docto = zag -> zag_doc
			::Seq   = zag -> zag_seq
		endif
	endif
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT TOP 1 ZA1_CODIGO"
		_oSQL:_sQuery += " FROM " + RetSQLName ("ZA1")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery += " AND ZA1_FILIAL  = '" + xfilial ("ZA1") + "'"
		_oSQL:_sQuery += " AND ZA1_IDZAG   = '" + ::Docto + ::Seq + "'"
		_oSQL:_sQuery += " AND ZA1_APONT  != 'I'"
		_sEtiq = _oSQL:RetQry (1, .F.)
		if ! empty (_sEtiq)
			
			// Tenta inutilizar a etiqueta
			_oEtiq := ClsEtiq():New(_sEtiq)
			if ! _oEtiq:Inutiliza ()
				::SomaMsg ("Existe a etiqueta " + _sEtiq + " gerada para esta solicitacao. Inutilize, antes, a etiqueta.")
				_lContinua = .F.
			endif
		endif
	endif

	// Se esta sol.transf. gerou tarefa de separacao no FullWMS, verifica se
	// a mesma jah foi excluida do Full.
	if _lContinua .and. ::FWProdOrig .and. ::AlmUsaFull (::AlmOrig)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "select count (*)"
		_oSQL:_sQuery +=  " from tb_wms_pedidos"
		_oSQL:_sQuery += " where saida_id = 'ZAG" + xfilial ("ZAG") + ::Docto + "'"  // Manter consistencia com a view v_wms_pedido !!!
		_oSQL:_sQuery +=   " and status  != '9'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		if _oSQL:RetQry (1, .f.) > 0
			::SomaMsg ("Esta solic.gerou o pedido de separacao " + ::Docto + " para o FullWMS, que encontra-se ainda pendente. Esse pedido deve ser excluido do FullWMS antes de poder excluir esta solicitacao de transferencia.")
			_lContinua = .F.
		endif
	endif

	// Esta solicitacao pode ter sido gerada a partir de uma 'avaria' pelo FullWMS.
	// Varre tabela de integracao e limpa o campo, caso encontre.
	if _lContinua .and. ::FWProdOrig .and. ::AlmUsaFull (::AlmOrig)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "update tb_wms_movimentacoes"
		_oSQL:_sQuery +=   " set status_protheus = ' '"
		_oSQL:_sQuery +=      ", IdZAG = ''"
		_oSQL:_sQuery += " where IdZAG = '" + ::Docto + ::Seq + "'"
		_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
		_lContinua = _oSQL:Exec ()
	endif

	if _lContinua
		reclock ("ZAG", .F.)
		zag -> (dbdelete ())
		msunlock ()
		::SomaMsg ("Solicitacao " + ::Docto + '/' + ::Seq + " excluida.")
	endif

	if ! _lContinua
		u_help (::UltMsg)

		// Persiste ultimas mensagens na tabela ZAG, para ajudar pessoal de suporte.
		::AtuZAG ("zag_UltMsg", ::UltMsg)
	endif

return _lContinua



// --------------------------------------------------------------------------
// Executa a movimentacao necessaria para a transferencia.
METHOD Executa (_lMensagem) Class ClsTrEstq
	local _lContinua := .T.
	local _sMsgInt   := ''

	_lMensagem := iif (_lMensagem == NIL, .T., _lMensagem)

	if _lContinua .and. ::RegZAG == 0
		_sMsgInt += "Transferencia ainda nao gravada na tabela ZAG"
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'S'
		_sMsgInt += "Transferencia ja executada."
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'X'
		_sMsgInt += "Transf.estornada. Nao pode ser refeita."
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'N'
		_sMsgInt += "Transf.com nao aceite."
		_lContinua = .F.
	endif
	if _lContinua .and. ::FilOrig != cFilAnt
		_sMsgInt += "Esta transf.deve ser executada na filial '" + ::FilOrig + "'."
		_lContinua = .F.
	endif
	if _lContinua .and. empty (::UsrAutOri)
		_sMsgInt += "Falta liberacao do responsavel pelo almox origem"
		_lContinua = .F.
	endif
	if _lContinua .and. empty (::UsrAutDst)
		_sMsgInt += "Falta liberacao do responsavel pelo almox destino"
		_lContinua = .F.
	endif
//	if _lContinua .and. empty (::UsrAutPCP)
//		_sMsgInt += "Falta liberacao do responsavel pelo PCP"
//		_lContinua = .F.
//	endif
//	if _lContinua .and. empty (::UsrAutQld)
//		_sMsgInt += "Falta liberacao do responsavel pela qualidade"
//		_lContinua = .F.
//	endif

	if ! _lContinua
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Ainda nao tem condicoes de executar. Msg.interna: ' + _sMsgInt)
	endif

	// Concatena a mensagem interna somente se a rotina chamadora quiser ve-la.
	if _lMensagem
		//::UltMsg += _sMsgInt
		::SomaMsg (_sMsgInt)
	endif
	if _lContinua .and. ::FilDest == ::FilOrig
		_lContinua = ::GeraSD3 ()
	endif
	if _lContinua .and. ::FilDest != ::FilOrig
		_lContinua = ::GeraSC5 ()
	endif

//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']_lContinua=' + cvaltochar (_lContinua))
//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']::UltMsg=' + ::UltMsg)
	if ! _lContinua .and. ! empty (::UltMsg)
		u_help (::UltMsg)

		// Persiste ultimas mensagens na tabela ZAG, para ajudar pessoal de suporte.
		::AtuZAG ("zag_UltMsg", ::UltMsg)
	endif

	// Gera novamente os atributos, para atualizar caso tenha gerado movimento.
	::GeraAtrib ("ZAG")

return _lContinua


// --------------------------------------------------------------------------
// Gera / atualiza atributos para o objeto.
METHOD GeraAtrib (_sOrigem) class ClsTrEstq
	local _oSQL := NIL

	// Defaults
	::Filial     = ''
	::FilOrig    = ''
	::FilDest    = ''
	::Docto      = ''
	::Seq        = ''
	::IdGrid     = ''
	::DtEmis     = ''
	::RegZAG     = 0
	::OP         = ''
	::Motivo     = ''
	::ProdOrig   = ''
	::ProdDest   = ''
	::AlmOrig    = ''
	::AlmDest    = ''
	::CtrLocOrig = .f.
	::CtrLocDest = .f.
	::CtrLotOrig = .f.
	::CtrLotDest = .f.
	::CodMotivo  = ''
	::EndOrig    = ''
	::EndDest    = ''
	::Etiqueta   = ''
	::Executado  = ''
	::FWProdOrig = .F.
	::FWProdDest = .F.
	::ImprEtq    = ''
	::LibNaIncl  = .T.
	::LoteOrig   = ''
	::LoteDest   = ''
	::MotNac     = ''
	::QtdSolic   = 0
	::UltMsg     = iif (valtype (::UltMsg) == 'U', '', ::UltMsg)  // Posso estar atualizando apos alguma operacao e nao quero perder o historico.
	::UsrIncl    = ''
	::UsrAutOri  = ''
	::UsrAutDst  = ''

	if _sOrigem == 'ZAG'
		::Filial    = zag -> zag_filial
		::FilOrig   = zag -> zag_FilOri
		::FilDest   = zag -> zag_FilDst
		::RegZAG    = zag -> (recno ())
		::Docto     = zag -> zag_doc
		::Seq       = zag -> zag_seq
		::DtEmis    = zag -> zag_emis
		::UsrIncl   = zag -> zag_usrinc
		::OP        = zag -> zag_op
		::CodMotivo = zag -> zag_codmot
		::Motivo    = alltrim (zag -> zag_Motivo)
		::ProdOrig  = zag -> zag_PrdOri
		::ProdDest  = zag -> zag_PrdDst
		::AlmOrig   = zag -> zag_AlmOri
		::AlmDest   = zag -> zag_AlmDst
		::EndOrig   = zag -> zag_EndOri
		::EndDest   = zag -> zag_EndDst
		::Executado = zag -> zag_exec
		::LoteOrig  = zag -> zag_LotOri
		::LoteDest  = zag -> zag_LotDst
		::MotNac    = alltrim (zag -> zag_MotNac)
		::QtdSolic  = zag -> zag_QtdSol
		::UsrAutOri = zag -> zag_UAutO
		::UsrAutDst = zag -> zag_UAutD

		// Busca dados adicionais dos produtos origem e destino (podem nao ser iguais)
		::LeSB1 ()

		// Busca etiqueta gerada para este registro, se existir.
		if empty (::Etiqueta)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += "SELECT ZA1_CODIGO"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZA1") + " ZA1"
			_oSQL:_sQuery += " WHERE ZA1.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZA1.ZA1_FILIAL = '" + xfilial ("ZA1") + "'"
			_oSQL:_sQuery +=   " AND ZA1.ZA1_IDZAG  = '" + ::Docto + ::Seq + "'"
		//	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			::Etiqueta = _oSQL:RetQry (1, .f.)
		endif

	endif
return


// --------------------------------------------------------------------------
// Gera movimentacao interna de transferencia.
METHOD GeraSD3 () class ClsTrEstq
	local _lContinua := .T.
	local _sDoc      := ""
	local _aAuto261  := {}
	local _aItens    := {}
	local _sChaveEx  := 'ZAG' + ::Docto + ::Seq
	local _aRegsSD3  := {}

	u_log2 ('info', 'Iniciando ' + GetClassName (::Self) + '.' + procname ())

	// Se o produto ainda nao existe no almoxarifado destino, cria-o, para nao bloquear a transferencia de estoque.
	if _lContinua
		sb2 -> (dbsetorder (1))
		if ! sb2 -> (dbseek (xfilial ("SB2") + ::ProdDest + ::AlmDest))
			CriaSB2 (::ProdDest, ::AlmDest)
		endif
	endif

	if _lContinua
		
		// Variavel publica usada para retornad erros na funcao U_Help().
		if type ("_sErroAuto") != 'C'
			//u_log2 ('debug', 'Criando variavel _sErroAuto')
			private _sErroAuto := ""
		endif
	
		// Deixar private por que pode vir a ser testada nos pontos de entrada.
		private _lClsTrEst := .T.

		_sDoc := CriaVar ("D3_DOC")
		aadd(_aAuto261,{_sDoc,dDataBase})
		aadd(_aItens, ::ProdOrig)  // Produto origem
		aadd(_aItens,'')           //D3_DESCRI				DescriÁo do Produto Origem
		aadd(_aItens,'')           //D3_UM					Unidade de Medida Origem
		aadd(_aItens,::AlmOrig)    //Almox origem
		aadd(_aItens,::EndOrig)    //Endereco origem
		aadd(_aItens,iif (empty (::ProdDest), ::ProdOrig, ::ProdDest))   //Codigo do produto destino
		aadd(_aItens,'')           //D3_DESCRI				DescriÁo do Produto de Destino
		aadd(_aItens,'')           //D3_UM					Unidade de Medida de Destino
		aadd(_aItens,::AlmDest)    //Almox destino
		aadd(_aItens,::EndDest)    //Endereco destino
		aadd(_aItens,"")           //D3_NUMSERI				Numero de Serie
		aadd(_aItens,::LoteOrig)   //Lote origem
		aadd(_aItens,"")           //D3_NUMLOTE				Numero do lote
		aadd(_aItens,ctod(""))     //D3_DTVALID				Validade Origem
		aadd(_aItens,0)            //D3_POTENCI				PotÍncia
		aadd(_aItens,::QtdSolic)   // Quantidade
		aadd(_aItens,0)            //D3_QTSEGUM				Segunda Quantidade
		aadd(_aItens,criavar("D3_ESTORNO"))  // D3_ESTORNO			Estorno
		aadd(_aItens,criavar("D3_NUMSEQ"))   // D3_NUMSEQ 			Numero de Sequencia
		aadd(_aItens,::LoteDest)             // Lote destino
		aadd(_aItens,ctod(""))               // D3_DTVALID			Validade de Destino
		aadd(_aItens,criavar("D3_ITEMGRD"))  // D3_ITEMGRD			Item Grade
		//aadd(_aItens,0)                    // Per.Imp. D3_PERIMP
		aadd(_aItens,::Motivo)               // D3_OBSERVA
		aadd(_aItens,::Motivo)               // motivo
		aadd(_aItens,ctod (''))              // dt digit (vai ser gravado pelo SQL)
		aadd(_aItens,'')                     // hr digit (vai ser gravado pelo SQL)
		//aadd(_aItens,'')                   // laudo laboratorial (tabela ZAF)
		aadd(_aItens,::Etiqueta)             // D3_VAETIQ Etiqueta
		aadd(_aItens,_sChaveEx)              // Chave externa D3_VACHVEX
	//	u_log2 ('debug', _aItens)
		aadd(_aAuto261, aclone (_aItens))

		lMsErroAuto := .F.
		MSExecAuto({|x,y| mata261(x,y)},_aAuto261,3) //INCLUSAO

		// Ja tive casos de nao gravar e tambem nao setar a variavel lMsErroAuto. Por isso vou conferir a gravacao.
		if ! lMsErroAuto
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := " SELECT R_E_C_N_O_"
			_oSQL:_sQuery +=   " FROM " + RetSQLName ("SD3")
			_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=    " AND D3_FILIAL  = '" + xfilial ("SD3") + "'"
			_oSQL:_sQuery +=    " AND D3_VACHVEX = '" + _sChaveEx + "'"
			_aRegsSD3 := aclone (_oSQL:Qry2Array (.F., .F.))
			if len (_aRegsSD3) != 2
				::SomaMsg ("Problemas na gravacao da transferencia. Nao encontrei os dois registros que deveriam ter sido gravados. Query para conferencia: " + _oSQL:_sQuery)
				lMsErroAuto = .T.
			endif
		endif

		If lMsErroAuto
			if ! empty (_sErroAuto)
				::SomaMsg (_sErroAuto)
			endif
			if ! empty (NomeAutoLog ())
				::SomaMsg (U_LeErro (memoread (NomeAutoLog ())))
			endif
			if empty (::UltMsg)
				::SomaMsg ('[Sem descricao do erro]')
			endif
			::UltMsg = "Erro interno na rotina de transferencia: " + ::UltMsg
			::Executado = 'E'
			::AtuZAG ("zag_exec", ::Executado)
			_lContinua = .F.
			u_log2 ('erro', ::UltMsg)
		else
			::Executado = 'S'
			::AtuZAG ("zag_exec", ::Executado)
			::SomaMsg ("Movto.gerado no Protheus com DOC=" + _sDoc)
			u_log2 ('info', ::UltMsg)
		endif
	endif

return _lContinua



// --------------------------------------------------------------------------
// Verifica necessidade e gera etiqueta para esta transferencia.
METHOD GeraEtiq (_lMsg) Class ClsTrEstq
	local _lContinua := .T.
	local _sMsg      := ''
	local _oEtiq     := NIL

	if empty (::RegZAG)
		_sMsg += "Registro ainda nao gravado na tabela ZAG. Etiqueta nao vai ser gerada."
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'X'
		_sMsg += "Transf.estornada. Nao pode mais gerar etiqueta."
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'N'
		_sMsg += "Transf.com nao aceite. Etiqueta nao pode mais ser gerada."
		_lContinua = .F.
	endif
	if _lContinua .and. ! ::AlmUsaEtiq (::AlmDest)
		_sMsg += "Almoxarifado destino nao faz entrada com etiqueta."
		_lContinua = .F.
	else
		// Nem todos os tipos de produto geram etiqueta no ax.02
		if ::AlmDest == '02' .and. fBuscaCpo ("SB1", 1, xfilial ("SB1") + ::ProdDest, "B1_TIPO") != 'PS'
			U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Almoxarifado destino (' + ::AlmDest + ') nao faz entrada com etiqueta para esse tipo de produto.')
			_sMsg += 'Almoxarifado destino (' + ::AlmDest + ') nao faz entrada com etiqueta para esse tipo de produto.'
			_lContinua = .F.
		endif
	endif

	if _lContinua
		U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + '] Vou gerar etiqueta.')

		_oEtiq := ClsEtiq():New()
		_oEtiq:Produto     = ::ProdDest
		_oEtiq:DtEmis      = ::DtEmis
		_oEtiq:IdZAG       = ::Docto + ::Seq
		_oEtiq:Quantidade  = ::QtdSolic
		_oEtiq:AlmDest     = ::AlmDest
		_oEtiq:AlmOrig     = ::AlmOrig
		_oEtiq:LoteProduto = alltrim (::LoteDest)
		
	//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']_oEtiq:Codigo (antes do Grava):' + _oEtiq:Codigo)
		if _oEtiq:Grava ()

			// Faz uma releitura dos atributos da etiqueta para popular
			// campos adicionais como por exemplo a data de validade.
		//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']_oEtiq:Codigo (antes do GeraAtrib):' + _oEtiq:Codigo)
			_oEtiq:GeraAtrib ("ZA1")
		//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']_oEtiq:Codigo (depois do GeraAtrib):' + _oEtiq:Codigo)
			::Etiqueta = _oEtiq:Codigo
			::SomaMsg ('Etiqueta gerada:' + ::Etiqueta)
		//	U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']Etiqueta gerada:' + ::Etiqueta)

			// Se tem impressora informada, jah faz a impressao da etiqueta.
			if ! empty (::ImprEtq)
				_oEtiq:Imprime (::ImprEtq)
			endif

			if ::AlmUsaFull (::AlmDest)
				U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Criei uma etiq. para alm.destino que usa Full. Vou enviar a etiq. para o Full.')
				_oEtiq:EnviaFull ()
			endif
		else
			_sMsg += 'Nao foi gerada etiqueta.'
			U_Log2 ('erro', '[' + GetClassName (::Self) + '.' + procname () + ']Nao foi gerada etiqueta.' + _oEtiq:UltMsg)
		endif

	endif
	if _lMsg .and. ! empty (_sMsg)
		u_help (_sMsg,, .T.)
	endif
return _lContinua



// --------------------------------------------------------------------------
// Grava novo registro.
METHOD Grava () Class ClsTrEstq
	local _lContinua := .T.
	local _lRet      := .F.
	local _sMsgLog   := ''
	local _nLock     := 0
	local _nTenta    := 0

	if ::RegZAG != 0
		::SomaMsg ("Registro ja existe na tabela ZAG (recno " + cvaltochar (::RegZAG) + ") e nao vai ser regravado.")
		_lContinua = .F.
	endif

	// Verifica se pode gravar
	if _lContinua
		_lContinua = ::PodeIncl ()
	endif

	// Vou gravar usando semaforo, por que preciso ter numero de documento exclusivo, inclusive entre filiais.
	if _lContinua
		// Faz algumas tentativas antes de cuspir erro para o usuario.
		_nTenta = 0
		do while _nTenta++ <= 10
			U_Log2 ('debug', '[' + GetClassName (::Self) + '_' + procname () + ']Tentativa ' + cvaltochar (_nTenta) + ' de criar semaforo')
			_nLock := U_Semaforo (GetClassName (::Self) + '.' + procname ())
			if _nLock != 0
				exit
			endif
			sleep (1000)
		enddo
		if _nLock == 0
			u_help ("Nao foi possivel obter acesso exclusivo para gravacao desta solicitacao.",, .t.)
			_lContinua = .F.
		endif
	endif

	if _lContinua
		BEGIN TRANSACTION

		// Se ainda nao tenho numero de documento, procuro o proximo livre.
		// Posso estar desmembrando uma solicitacao. Nesses casos, jah terei o
		// numero de documento, seguido de um sequencial.
		if empty (::Docto)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += " SELECT MAX (ZAG_DOC)"
			_oSQL:_sQuery +=   " FROM " + RetSQLName ("ZAG") + " ZAG "
			// QUERO considerar os deletados tambem ---> _oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=  " WHERE ZAG_FILIAL = '" + xfilial ("ZAG") + "'"
		//	_oSQL:Log ('[' + GetClassName (::Self) + '.' + procname () + ']')
			::Docto = _oSQL:RetQry (1, .f.)
			if empty (::Docto)
				::Docto = strzero (0, tamsx3 ("ZAG_DOC")[1])
			endif
			::Docto = soma1 (::Docto)
			::Seq   = strzero (1, tamsx3 ("ZAG_SEQ")[1])
		endif

		// Prepara mensagem bem 'cuti-cuti' para arquivo de log.
		_sMsgLog := ''
		_sMsgLog += '[' + GetClassName (::Self) + '.' + procname () + "]Gravando ZAG_DOC/SEQ:" + ::Docto + '/' + ::Seq
		_sMsgLog += " Prd:" + alltrim (::ProdOrig)
		if ::ProdDest != ::ProdOrig
			_sMsgLog += '->' + alltrim (::ProdDest)
		endif
		_sMsgLog += " ax:" + ::AlmOrig + '->' + ::AlmDest
		if ! empty (::EndOrig) .or. ! empty (::EndDest)
			_sMsgLog += " end:" + ::EndOrig + '->' + ::EndDest
		endif
		if ! empty (::LoteOrig) .or. ! empty (::LoteDest)
			_sMsgLog += " lote:" + ::LoteOrig + '->' + ::LoteDest
		endif
		_sMsgLog += " Qt:" + cvaltochar (::QtdSolic)
		u_log2 ('info', _sMsgLog)

		reclock ("ZAG", .T.)
		zag -> zag_filial = xfilial ("ZAG")
		zag -> zag_FilOri = ::FilOrig
		zag -> zag_filDst = ::FilDest
		zag -> zag_doc    = ::Docto
		zag -> zag_seq    = ::Seq
		zag -> zag_emis   = ::DtEmis
		zag -> zag_usrinc = ::UsrIncl
		zag -> zag_op     = ::OP
		zag -> zag_Motivo = U_NoAcento (::Motivo)
		zag -> zag_PrdOri = ::ProdOrig
		zag -> zag_PrdDst = ::ProdDest
		zag -> zag_AlmOri = ::AlmOrig
		zag -> zag_AlmDst = ::AlmDest
		zag -> zag_EndOri = ::EndOrig
		zag -> zag_EndDst = ::EndDest
		zag -> zag_LotOri = ::LoteOrig
		zag -> zag_LotDst = ::LoteDest
		zag -> zag_QtdSol = ::QtdSolic
		zag -> zag_CodMot = ::CodMotivo
		msunlock ()

		::RegZAG = zag -> (recno ())
		::SomaMsg ("Solic.de transf.gravada: " + ::Docto + '/' + ::Seq + '.')
		_lRet = .T.
		END TRANSACTION
	endif

	// Libera semaforo
	U_Semaforo (_nLock)

	// Verifica necessidade de gerar etiqueta
	if _lRet
		::GeraEtiq (.F.)
	endif

	// Faz as liberacoes que forem possiveis
	if _lRet
		if ::LibNaIncl
			::Libera (.F.)
			::Executa ()  // Tenta executar, pois as liberacoes podem ter tido exito.
		endif
	endif

	if ! _lContinua .and. ! empty (::UltMsg)
		u_help (::UltMsg,, .t.)

		// Persiste ultimas mensagens na tabela ZAG, para ajudar pessoal de suporte.
		::AtuZAG ("zag_UltMsg", ::UltMsg)
	endif

return _lRet


// --------------------------------------------------------------------------
// Busca dados adicionais dos produtos origem e destino (podem nao ser iguais)
METHOD LeSB1 () class ClsTrEstq
	local _lRetSB1  := .T.
	local _aAreaAnt := U_ML_SRArea ()

	sb1 -> (dbsetorder (1))
	if ! sb1 -> (dbseek (xfilial ("SB1") + ::ProdOrig, .F.))
		::SomaMsg ("Cadastro do produto origem (" + alltrim (::ProdOrig) + ") da transferencia nao localizado!")
		u_help (::UltMsg,, .t.)
		_lRetSB1 = .F.
	else
		::CtrLocOrig = (sb1 -> b1_localiz == 'S')
		::CtrLocDest = (sb1 -> b1_localiz == 'S')  // Presumindo que seja o mesmo produto.
		::CtrLotOrig = (sb1 -> b1_rastro  == 'L')
		::CtrLotDest = (sb1 -> b1_rastro  == 'L')  // Presumindo que seja o mesmo produto.
		::FWProdOrig = (sb1 -> b1_vafullw == 'S')
		::FWProdDest = (sb1 -> b1_vafullw == 'S')  // Presumindo que seja o mesmo produto.
		if sb1 -> b1_rastro == 'S'
			::SomaMsg ("Produto origem controla sublote. Falta tratamento neste programa.")
			_lRetSB1 = .F.
		endif
	endif
	if ::ProdDest != ::ProdOrig
		if ! sb1 -> (dbseek (xfilial ("SB1") + ::ProdDest, .F.))
			::SomaMsg ("Cadastro do produto destino (" + alltrim (::ProdDest) + ") da transferencia nao localizado!")
			u_help (::UltMsg,, .t.)
			_lRetSB1 = .F.
		else
			::CtrLocDest = (sb1 -> b1_localiz == 'S')
			::CtrLotDest = (sb1 -> b1_rastro  == 'L')
			::FWProdDest = (sb1 -> b1_vafullw == 'S')
			if sb1 -> b1_rastro == 'S'
				::SomaMsg ("Produto destino controla sublote. Falta tratamento neste programa.")
				_lRetSB1 = .F.
			endif
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
return _lRetSB1


// --------------------------------------------------------------------------
// Grava as liberacoes para as quais o usuario corrente tem permissao.
METHOD Libera (_lMsg, _sUserName) Class ClsTrEstq
	local _lNenhuma := .T.
	local _oSQL     := NIL
	local _aLib     := {}

	_lMsg = iif (_lMsg == NIL, .T., _lMsg)
	_sUserName = iif (_sUserName == NIL, cUsername, _sUserName)

	// Se ainda tem alguma liberacao pendente...
//	if empty (::UsrAutOri) .or. empty (::UsrAutDst) .or. empty (::UsrAutPCP) .or. empty (::UsrAutQld)
	if empty (::UsrAutOri) .or. empty (::UsrAutDst) //.or. empty (::UsrAutPCP) .or. empty (::UsrAutQld)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT rtrim (LIBERADORES_ALMORI)    AS ORI,"
		_oSQL:_sQuery +=       " rtrim (LIBERADORES_ALMDST)    AS DST"
		_oSQL:_sQuery +=  " FROM VA_VSOL_TRANSF_ESTOQUE"
		_oSQL:_sQuery += " WHERE ZAG_FILIAL = '" + xfilial ("ZAG") + "'"
		_oSQL:_sQuery +=   " AND ZAG_DOC    = '" + ::Docto + "'"
		_oSQL:_sQuery +=   " AND ZAG_SEQ    = '" + ::Seq + "'"
		//_oSQL:Log ()
		_aLib := aclone (_oSQL:Qry2Array (.F., .F.))
		u_log2 ('debug', 'Liberadores alm ' + ::AlmOrig + '(origem) :' + alltrim (_aLib [1, 1]))
		u_log2 ('debug', 'Liberadores alm ' + ::AlmDest + '(destino):' + alltrim (_aLib [1, 2]))
		//u_log2 ('debug', 'Testando com usuario ' + _sUserName)
		if empty (::UsrAutOri) .and. alltrim (upper (_sUserName)) $ _aLib [1, 1]
			u_log2 ('info', 'Usuario ' + _sUserName + ' tem liberacao para o almox. origem')
			if ::FWProdOrig .and. ::AlmUsaFull (::AlmOrig) .and. _sUserName != 'FULLWMS'
				U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']... mas o produto usa Full e o AX origem eh controlado pelo FullWMS')
				_sMsg = "Produto '" + alltrim (::ProdOrig) + "' tem controle via FullWMS no AX '" + ::AlmOrig + "' e nao deve ser movimentado manualmente."
				::SomaMsg (_sMsg)
				_lNenhuma = .F.
			else
				if ::AtuZAG ("zag_UAutO", _sUserName)
					::UsrAutOri = _sUserName
					::SomaMsg (iif (_lMsg, "AX orig.liberado. ", ''))
					_lNenhuma = .F.
				endif
			endif
		endif

		if empty (::UsrAutDst) .and. alltrim (upper (_sUserName)) $ _aLib [1, 2]
			u_log2 ('info', 'Usuario ' + _sUserName + ' tem liberacao para o almox. destino')
			if ::FWProdDest .and. ::AlmUsaFull (::AlmDest) .and. _sUserName != 'FULLWMS'
				U_Log2 ('debug', '[' + GetClassName (::Self) + '.' + procname () + ']... mas o produto usa Full e o AX destino eh controlado pelo FullWMS')
				_sMsg = "Produto '" + alltrim (::ProdDest) + "' tem controle via FullWMS no AX '" + ::AlmDest + "' e nao deve ser movimentado manualmente."
				::SomaMsg (_sMsg)
				_lNenhuma = .F.
			else

				if ::AtuZAG ("zag_UAutD", _sUserName)
					::SomaMsg (iif (_lMsg, "AX dest.liberado. ", ''))
					::UsrAutDst = _sUserName
					_lNenhuma = .F.
				endif
			endif
		endif
		
	//	// Inicialmente a liberacao de PCP e qualidade vai ser automatica
	//	if empty (::UsrAutPCP) .and. ::AtuZAG ("zag_UAutP", 'Auto') // _sUserName)
	//		::UsrAutPCP = 'Auto' //_sUserName
	//		_lNenhuma = .F.
	//	endif
	//	if empty (::UsrAutQld) .and. ::AtuZAG ("zag_UAutQ", 'Auto') // _sUserName)
	//		::UsrAutQld = 'Auto' //_sUserName
	//		_lNenhuma = .F.
	//	endif
	endif

	if _lNenhuma
		U_Log2 ('info', '[' + GetClassName (::Self) + '.' + procname () + ']Nada a liberar')
		::SomaMsg (iif (_lMsg, "Nenhuma liberacao pendente para este usuario.", ''))
	endif

	// Atualiza atributos do objeto com base no conteudo do registro atual.
	::GeraAtrib ("ZAG")

return


// --------------------------------------------------------------------------
// Negar a solicitacao de transferencia (nao aceite).
METHOD Negar (_sMotivo) Class ClsTrEstq
	local _lContinua := .T.

	::UltMsg = ""

	if _lContinua .and. ::Executado == 'S'
		::SomaMsg ("Transferencia ja executada.")
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'X'
		::SomaMsg ("Transferencia ja estornada.")
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'N'
		::SomaMsg ("Transferencia ja negada.")
		_lContinua = .F.
	endif
	if _lContinua .and. empty (_sMotivo)
		::SomaMsg ("Deve ser informado motivo de nao aceite.")
		_lContinua = .F.
	endif

	// Usuario que estah gravando a solicitacao tem que ser dono de pelo menos um dos almoxarifados envolvidos.
	if _lContinua
		if ! U_ZZUVL ('A' + ::AlmOrig, __cUserId, .F.)
			U_Log2 ('debug', '[' + procname () + ']Usr atual nao eh dono do ax.origem (' + ::AlmOrig + ')')
			if ! U_ZZUVL ('A' + ::AlmDest, __cUserId, .F.)
				U_Log2 ('debug', '[' + procname () + ']Usr atual nao eh dono do ax.destino (' + ::AlmDest + ')')
				::SomaMsg ("Para negar esta solicitacao, voce deve ser dono de pelo menos um dos almoxarifados envolvidos.")
				_lContinua = .F.
			endif
		endif
	endif

	if _lContinua
		::MotNac    = alltrim (cUserName) + ':' + _sMotivo
		::Executado = 'N'
		::AtuZAG ("zag_MotNac", ::MotNac)
		::AtuZAG ("zag_exec", ::Executado)
		::SomaMsg ("Solicitacao negada por " + cUserName + ' em ' + dtoc (date ()))
	endif
	if ! _lContinua
		u_help (::UltMsg)

		// Persiste ultimas mensagens na tabela ZAG, para ajudar pessoal de suporte.
		::AtuZAG ("zag_UltMsg", ::UltMsg)
	endif
return _lContinua


// --------------------------------------------------------------------------
// Negar a solicitacao de transferencia (nao aceite).
METHOD NovoEndDst (_sNEndDst) Class ClsTrEstq
	local _lContinua := .T.

	::UltMsg = ""

	if _lContinua .and. ::Executado == 'S'
		::SomaMsg ("Transferencia ja executada.")
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'X'
		::SomaMsg ("Transferencia ja estornada.")
		_lContinua = .F.
	endif
	if _lContinua .and. ::Executado == 'N'
		::SomaMsg ("Transferencia ja negada.")
		_lContinua = .F.
	endif
	if _lContinua .and. empty (_sNEndDst)
		::SomaMsg ("Deve ser informado um novo endereco destino.")
		_lContinua = .F.
	endif
	if _lContinua
		sbe -> (dbsetorder (1))  // BE_FILIAL, BE_LOCAL, BE_LOCALIZ, BE_ESTFIS, R_E_C_N_O_, D_E_L_E_T_
		if ! sbe -> (dbseek (xfilial ("SBE") + ::AlmDest + _sNEndDst, .F.))
			::SomaMsg ("Endereco informado (" + _sNEndDst + ") nao existe no almoxarifado " + ::AlmDest)
			_lContinua = .F.
		else
			if sbe -> be_status $ '3/4/5/6'  // 1=Desocupado;2=Ocupado;3=Bloqueado;4=Bloqueio Entrada;5=Bloqueio Saída;6=Bloqueio Inventário
				::SomaMsg ("Endereco informado (" + _sNEndDst + ") encontra-se bloqueado.")
				_lContinua = .F.
			else
				if sbe -> be_vasitua $ '2/3'  // 1=Instalado;2=Em instalacao;3=Desativado;4=Investimento
					::SomaMsg ("Situacao do tanque " + _sNEndDst + " impede seu uso.")
					_lContinua = .F.
				endif
			endif
		endif
	endif

	// Usuario que estah gravando tem que ser dono do almoxarifado destino.
	if _lContinua
		if ! U_ZZUVL ('A' + ::AlmDest, __cUserId, .F.)
			U_Log2 ('debug', '[' + procname () + ']Usr atual nao eh dono do ax.destino (' + ::AlmDest + ')')
			::SomaMsg ("Para alterar o endereço destino, voce deve ser dono do almoxarifado " + ::AlmDest)
			_lContinua = .F.
		endif
	endif

	if _lContinua
		::SomaMsg ("Endereco destino alterado de " + ::EndDest + " para " + _sNEndDst + " por " + cUserName + ' em ' + dtoc (date ()))
		::EndDest = _sNEndDst
		::AtuZAG ("zag_enddst", ::EndDest)
	endif
	if ! _lContinua
		u_help (::UltMsg)

		// Persiste ultimas mensagens na tabela ZAG, para ajudar pessoal de suporte.
		::AtuZAG ("zag_UltMsg", ::UltMsg)
	endif
return _lContinua


// --------------------------------------------------------------------------
// Valida se a solicitacao pode ser incluida.
METHOD PodeIncl () Class ClsTrEstq
	local _lContinua := .T.

	// Verifica campos obrigatorios, nao aceitos, tamanhos, tipos, etc.
	if _lContinua
		if empty (::FilOrig) ; ::SomaMsg ("Filial de origem deve ser informada.")                   ; _lContinua = .F. ; endif
		if empty (::FilDest) ; ::SomaMsg ("Filial destino deve ser informada.")                     ; _lContinua = .F. ; endif
		if empty (::AlmOrig) ; ::SomaMsg ("Almoxarifado de origem deve ser informado.")             ; _lContinua = .F. ; endif
		if empty (::AlmDest) ; ::SomaMsg ("Almoxarifado destino deve ser informado.")               ; _lContinua = .F. ; endif
		if empty (::DtEmis)  ; ::SomaMsg ("Data de emissao deve ser informada.")                    ; _lContinua = .F. ; endif
		if empty (::UsrIncl) ; ::SomaMsg ("Nome solicitante deve ser informado.")                   ; _lContinua = .F. ; endif
		if empty (::Motivo)  ; ::SomaMsg ("Motivo da transferencia deve ser informado.")            ; _lContinua = .F. ; endif
		if empty (::ProdOrig); ::SomaMsg ("Produto deve ser informado.")                            ; _lContinua = .F. ; endif
		if empty (::QtdSolic); ::SomaMsg ("Quantidade solicitada deve ser informada.")              ; _lContinua = .F. ; endif
		if ! empty (::Docto) ; ::SomaMsg ("Documento NAO deve ser informado na inclusao.")          ; _lContinua = .F. ; endif
		if ! empty (::RegZAG); ::SomaMsg ("RECNO da tabela ZAG NAO deve ser informado na inclusao."); _lContinua = .F. ; endif
		if valtype (::QtdSolic) != 'N'
			::SomaMsg ("Quantidade deve ser do tipo numerico.")
			_lContinua = .F.
		else
			if ::QtdSolic <= 0
				::SomaMsg ("Quantidade solicitada zerada ou negativa.")
				_lContinua = .F.
			endif
		endif

		// Por enquanto, nao vou aceitar transferencia entre filiais. Robert, 11/04/2019
		if ::FilDest != ::FilOrig
			::UltMsg += "Transferencias entre filiais ainda nao sao permitidas nesta rotina.Filial origem deve ser igual a filial destino."
			_lContinua = .F.
		endif
		if ::FilOrig != cFilAnt .or. ::FilDest != cFilAnt
			::UltMsg += "Transferencias entre filiais ainda nao sao permitidas nesta rotina. Portanto, nao tente incluir solicitacoes envolvendo outras filiais."
			_lContinua = .F.
		endif

		// Verifica tamanhos de campos para evitar, por exemplo, uma chamada
		// passando o produto com tamanho != 15
		// Usa tamanhos fixos (nao busca no SX3) por questao de performance,
		// jah que sao campos chave e dificilmente mudarao de tamanho.  
		if _lContinua
			if len (::FilOrig)  !=  2                           ; ::SomaMsg ("Filial origem deve ter tamanho 2.")    ; _lContinua = .F.; endif
			if len (::FilDest)  !=  2                           ; ::SomaMsg ("Filial destino deve ter tamanho 2.")   ; _lContinua = .F.; endif
			if len (::ProdOrig) != 15                           ; ::SomaMsg ("Produto origem deve ter tamanho 15.")  ; _lContinua = .F.; endif
			if len (::ProdDest) != 15                           ; ::SomaMsg ("Produto destino deve ter tamanho 15.") ; _lContinua = .F.; endif
			if len (::AlmOrig)  !=  2                           ; ::SomaMsg ("Alm.origem deve ter tamanho 2.")       ; _lContinua = .F.; endif
			if len (::AlmDest)  !=  2                           ; ::SomaMsg ("Alm.destino deve ter tamanho 2.")      ; _lContinua = .F.; endif
			if ! empty (::EndOrig)  .and. len (::EndOrig)  != 15; ::SomaMsg ("Endereco origem deve ter tamanho 15.") ; _lContinua = .F.; endif
			if ! empty (::EndDest)  .and. len (::EndDest)  != 15; ::SomaMsg ("Endereco destino deve ter tamanho 15."); _lContinua = .F.; endif
			if ! empty (::LoteOrig) .and. len (::LoteOrig) != 10; ::SomaMsg ("Lote origem deve ter tamanho 10.")     ; _lContinua = .F.; endif
			if ! empty (::loteDest) .and. len (::LoteDest) != 10; ::SomaMsg ("Lote destino deve ter tamanho 10.")    ; _lContinua = .F.; endif
		endif
	endif

	// Testa possibilidade do destino ser igual a origem.
	if _lContinua
		if ::FilOrig == ::FilDest ;
		.and. ::ProdOrig == ::ProdDest ;
		.and. ::AlmOrig  == ::AlmDest ;
		.and. ::EndOrig  == ::EndDest ;
		.and. ::LoteOrig == ::LoteDest
			::SomaMsg ("Nao ha sentido em transferir quando origem e destino sao iguais.")
			_lContinua = .F.
		endif
	endif

	// Codigo do motivo ainda nao eh obrigatorio por que nao tem em todas as telas.
	// Mas, se informado, deve existir.
	if _lContinua .and. ! empty (::CodMotivo)
		if ! U_ExistZX5 ('56', ::CodMotivo, .F.)
			::SomaMsg ("Codigo motivo transf '" + ::CodMotivo + "' nao cadastrado.")
			_lContinua = .F.
		endif
	endif

	if _lContinua
		// Faz leitura de dados dos produtos a partir do SB1. Isso por que o
		// objeto pode ter sido instanciado e modificado pelo programa chamador
		// e agora eu estaria com dados de SB1 desatualizados.
		::LeSB1 ()

	//	U_Log2 ('debug', '[' + procname () + ']Situacao do objeto apos ::LeSB1')
	//	u_logObj (::Self, .t., .f.)

		if ::CtrLotOrig .and. empty (::LoteOrig) .and. ! ::AlmUsaFull (::AlmOrig)
			::SomaMsg ("Produto origem controla lotes. Lote de origem deve ser informado.")
			_lContinua = .F.
		endif
		if ::CtrLocOrig .and. empty (::EndOrig) .and. ! ::AlmUsaFull (::AlmOrig)
			::SomaMsg ("Produto origem controla localizacao. Endereco de origem deve ser informado.")
			_lContinua = .F.
		endif
		if ! empty (::LoteOrig) .and. ! ::CtrLotOrig
			if ! (::FWProdOrig .and. ::AlmUsaFull (::AlmDest))  // Se vai para FullWMS tenho que informar algm lote para ele.
				::SomaMsg ("Lote origem nao deve ser informado pois o produto '" + alltrim (::ProdOrig) + "' nao controla lote.")
				_lContinua = .F.
			else
				U_Log2 ('debug', '[' + procname () + ']Vou aceitar lote origem por que preciso ter algum lote para informar ao FullWMS.')
			endif
		endif
		if ! empty (::EndOrig) .and. ! ::CtrLocOrig
			::SomaMsg ("Endereco origem nao deve ser informado pois o produto '" + alltrim (::ProdOrig) + "' nao controla localizacao.")
			_lContinua = .F.
		endif
		if ::CtrLotDest .and. empty (::LoteDest)
			::SomaMsg ("Produto destino controla lotes. Lote destino deve ser informado.")
			_lContinua = .F.
		endif
		if ::CtrLocDest .and. empty (::EndDest)
			::SomaMsg ("Produto destino controla localizacao. Endereco destino deve ser informado.")
			_lContinua = .F.
		endif
		if ! empty (::LoteDest) .and. ! ::CtrLotDest
			if ! (::FWProdDest .and. ::AlmUsaFull (::AlmDest))  // Se vai para FullWMS, tenho que informar algm lote para ele.
				::SomaMsg ("Lote destino nao deve ser informado pois o produto '" + alltrim (::ProdDest) + "' nao controla lote.")
				_lContinua = .F.
			endif
		endif
		if empty (::LoteDest) .and. ::AlmUsaFull (::AlmDest)  // Se vai para FullWMS, tenho que informar algm lote para ele.
			::SomaMsg ("Deve ser informado um lote de destino por que o FullWMS vai exigir.")
			_lContinua = .F.
		endif
		if ! empty (::EndDest) .and. ! ::CtrLocDest
			::SomaMsg ("Endereco destino nao deve ser informado pois o produto '" + alltrim (::ProdDest) + "' nao controla localizacao.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ! empty (::AlmOrig)
		nnr -> (dbsetorder (1))  // NNR_FILIAL+NNR_CODIGO
		if ! nnr -> (dbseek (xfilial ("NNR") + ::AlmOrig, .F.))  // Nao pesquisa pela filial origem por que o NNR eh compartilhado.
			::SomaMsg ("Almoxarifado origem '" + ::AlmOrig + "' nao cadastrado.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ! empty (::AlmDest)
		nnr -> (dbsetorder (1))
		if ! nnr -> (dbseek (xfilial ("NNR") + ::AlmDest, .F.))  // Nao pesquisa pela filial origem por que o NNR eh compartilhado.
			::SomaMsg ("Almoxarifado destino '" + ::AlmDest + "' nao cadastrado.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ::CtrLotOrig .and. ! empty (::LoteOrig)
		sb8 -> (dbsetorder (5))  // B8_FILIAL+B8_PRODUTO+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
		if ! sb8 -> (dbseek (::FilOrig + ::ProdOrig + ::LoteOrig, .F.))
			::SomaMsg ("Lote origem '" + ::LoteOrig + "' nao encontrado para o produto '" + ::ProdOrig + "' na filial '" + ::FilOrig + "'.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ::CtrLotDest .and. ! empty (::LoteDest)
		sb8 -> (dbsetorder (5))  // B8_FILIAL+B8_PRODUTO+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
		if ! sb8 -> (dbseek (::FilDest + ::ProdDest + ::LoteDest, .F.))
			::SomaMsg ("Lote destino '" + ::LoteDest + "' ja existe para o produto '" + ::ProdDest + "' na filial '" + ::FilDest + "'.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ! empty (::EndOrig)
		sbe -> (dbsetorder (1))  // BE_FILIAL+BE_LOCAL+BE_LOCALIZ
		if ! sbe -> (dbseek (::FilOrig + ::AlmOrig + ::EndOrig, .F.))
			::SomaMsg ("Endereco origem '" + ::EndOrig + "' nao encontrado no almoxarifado '" + ::AlmOrig + "' da filial '" + ::FilOrig + "'.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ! empty (::EndDest)
		sbe -> (dbsetorder (1))  // BE_FILIAL+BE_LOCAL+BE_LOCALIZ
		if ! sbe -> (dbseek (::FilDest + ::AlmDest + ::EndDest, .F.))
			::SomaMsg ("Endereco destino '" + ::EndDest + "' nao encontrado no almoxarifado '" + ::AlmDest + "' da filial '" + ::FilDest + "'.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ! empty (::OP)
		sc2 -> (dbsetorder (1))
		if ! sc2 -> (dbseek (::FilOrig + ::OP, .F.))
			::SomaMsg ("OP '" + ::OP + "' nao encontrada na filial '" + ::FilOrig + "'.")
			_lContinua = .F.
		endif
	endif

	if _lContinua .and. ::AlmUsaFull (::AlmOrig)
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT MIN (A5_VAQSOLW)"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SA5") + " SA5 "
		_oSQL:_sQuery +=  " WHERE SA5.D_E_L_E_T_  = ''"
		_oSQL:_sQuery +=  " AND SA5.A5_FILIAL   = '" + xfilial ("SA5") + "'"
		_oSQL:_sQuery +=  " AND SA5.A5_PRODUTO  = '" + ::ProdOrig + "'"
		_oSQL:_sQuery +=  " AND SA5.A5_VAQSOLW != 0"
		_oSQL:Log ()
		_nTamLote = _oSQL:RetQry (1, .F.)
		_nResto = ::QtdSolic % _nTamLote
		if _nResto != 0
			::SomaMsg ("Produto e almox. de origem operam com FullWMS, e o produto tem lote minimo de "+ alltrim(str(_nTamLote)) + ". Nao sera possivel gerar uma movimentacao.")
			_lContinua = .F.
		endif
	endif
	
	// Usuario que estah gravando a solicitacao tem que ser dono de pelo menos um dos almoxarifados envolvidos.
	if _lContinua
		if ! U_ZZUVL ('A' + ::AlmOrig, __cUserId, .F.)
			U_Log2 ('debug', '[' + procname () + ']Usr atual nao eh dono do ax.origem (' + ::AlmOrig + ')')
			if ! U_ZZUVL ('A' + ::AlmDest, __cUserId, .F.)
				U_Log2 ('debug', '[' + procname () + ']Usr atual nao eh dono do ax.destino (' + ::AlmDest + ')')
				::SomaMsg ("Para gravar esta solicitacao, voce deve ser dono de pelo menos um dos almoxarifados envolvidos.")
				_lContinua = .F.
			endif
		endif
	endif

	if ! _lContinua .and. ! empty (::UltMsg)
		u_help (::UltMsg,, .t.)
	endif

return _lContinua


// --------------------------------------------------------------------------
// Concatena (sem repeticao) mensagens do objeto.
METHOD SomaMsg (_sMsg) Class ClsTrEstq
	local _sMsgAux := alltrim (cvaltochar (_sMsg))
//	if ! _sMsgAux $ ::UltMsg
//		::UltMsg += iif (empty (::UltMsg), '', '; ') + _sMsgAux
//	endif
	if ! alltrim (_sMsgAux) $ ::UltMsg
		::UltMsg = alltrim (_sMsgAux) + '; ' + ::UltMsg
	endif
return
