// Programa:  U_Robert
// Autor:     Robert Koch
// Data:      ??/??/????
// Descricao: Ajustes e testes diversos

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Generico
// #Descricao         #Testes e ajustes diversos / temporarios
// #PalavasChave      #generico
// #TabelasPrincipais #
// #Modulos           #Todos

// Para estudar...
// depurar mais de uma thread: https://devforum.totvs.com.br/1066-debugar-multiplas-threads-no-vscode
// Linguagem TL++: https://tdn.totvs.com/pages/viewpage.action?pageId=334340072
// local varJson := { "teste" : { "var1" : "oioi", "var2": "oioi2", "var3": "oioi3" }}  https://tdn.totvs.com/display/tec/Json
// Compilacao por linha de comando  https://tdn.totvs.com/pages/viewpage.action?pageId=528461210
// Artigos sobre customizacoes:  https://centraldeatendimento.totvs.com/hc/pt-br/sections/1500001533641-Customiza%C3%A7%C3%B5es-ADVPL-
// APIs da Totvs:  https://api.totvs.com.br/


// Campos a serem eliminados quando der no jeito:
// ZZU_EMP, d1_fim, f1_fim (?), A2_VACAVIS, A2_VALAVIS, A2_VANAVIS, 'A2_VA%DAP'
// Campos de DAP no SA2 (conferir os programas antes)
// adicionar tabelas SCD, DRE INDL, ... para compactacao
// Criar verificacao de campos que devem estar 'usados': 
//    D1_VALIRR, D1_VALPIS, D1_VALCOF, D1_VALCSL, D1_BASEIRR, D1_BASEPIS, D1_BASECOF, D1_BASECSL para evitar erro no MATA103REINF
// Aumentar o tamanho do ZN_DIASVLD
// Remover do projeto: ML_DOCTRANS, ZZXPEND


// Estala de Home Office:
// 			SEG	TER	QUA	QUI	SEX
// DAIANA	ho				ho
// CLAUDIA	ho			ho
// SANDRA			ho		ho
// ROBERT		ho		ho

#include "protheus.ch"
#include "rwmake.ch"
#include "VA_INCLU.prw"
#include "tbiconn.ch"
//#INCLUDE "XMLXFUN.CH"
//#INCLUDE "apvt100.ch"

user function robert ()
	local _lContinua := .T.
	local _sFuncao   := ''
	local _sHrIni    := time ()
	local _nLock     := 0

	// REMOVER DEPOIS DOS TESTES DE PERFORMANCE
//	u_perfmon ('I', 'Prep_env_' + cValToChar (GetServerPort ()))

	if type ('__cUserId') == 'U' .or. type ('cUserName') == 'U'
		prepare environment empresa '01' filial '01' modulo 'FIN'
		private cModulo   := 'FIN'
		private __cUserId := "000210"
		private cUserName := "robert.koch"
		private __RelDir  := "c:\temp\spool_protheus\"
		set century on
	endif

	// REMOVER DEPOIS DOS TESTES DE PERFORMANCE
//	u_perfmon ('F', 'Prep_env_' + cValToChar (GetServerPort ()))


	if ! alltrim(upper(cusername)) $ 'ROBERT.KOCH/ADMINISTRADOR/CLAUDIA.LIONCO'
		msgalert ('Nao te conheco, nao gosto de ti e nao vou te deixar continuar. Vai pra casa.', procname ())
		_lContinua = .F.
	endif

	if _lContinua
		_nLock = U_Semaforo (procname ())
		if _nLock == 0
			u_help ('Bloqueio de semaforo na funcao ' + procname (),, .t.)
			_lContinua = .F.
		endif
	endif
	if _lContinua
		PRIVATE _oBatch  := ClsBatch():New ()  // Deixar definido para quando testar rotinas em batch.
		private _sArqLog := procname () + "_" + alltrim (cUserName) + ".log"
		delete file ('\logs\' + _sArqLog)
		delete file ('\logs\' + _sArqLog + '001')
		delete file ('\logs\' + _sArqLog + '002')
		delete file ('\logs\' + _sArqLog + '003')
		delete file ('\logs\' + _sArqLog + '004')
		delete file ('\logs\' + _sArqLog + '005')
		delete file ('\logs\' + _sArqLog + '006')
		delete file ('\logs\' + _sArqLog + '007')
		delete file ('\logs\' + _sArqLog + '008')
		delete file ('\logs\' + _sArqLog + '009')
	endif
	if _lContinua .and. ! empty (GetSrvProfString ("IXBLOG", ""))
		u_help ("Parametro IXBLOG ativo no appserver.ini")
		_lContinua = .F.
	endif
	if _lContinua
		FWMonitorMsg (procname ())  // Substitui a funcao PTInternal()
		U_Log2 ('info', '[' + procname () + ']Iniciando execucao.')
		U_UsoRot ('I', procname (), '')

		_sFuncao := ''
		// _sFuncao += '_AjLoteEnd ()'
		// _sFuncao += '_AtuCR ()'
		// _sFuncao += '_AtuSB1 ()'
		// _sFuncao += '_aviso ()'
		// _sFuncao += '_batBlUsr ()'
		// _sFuncao += '_batFull ()'
		// _sFuncao += '_BatLimp ()'
		// _sFuncao += '_BatMerc ()'
		// _sFuncao += '_BatOcor ()'
		// _sFuncao += '_BatSafr ()'
		// _sFuncao += '_BatTrSZI ()'
		// _sFuncao += '_BatXML ()'
		// _sFuncao += '_batZBE ()'
		// _sFuncao += '_BlEstF ()'
		// _sFuncao += '_CargSaf ()'
		// _sFuncao += '_CplSaf23A ()'
		// _sFuncao += '_CplSaf23B ()'
		// _sFuncao += '_CplSaf23C ()'
		// _sFuncao += '_CorrMonSZI ()'
		// _sFuncao += '_ctbANC ()'
		// _sFuncao += '_cusPartes ()'
		// _sFuncao += '_DesabRast ()'
		// _sFuncao += '_elastic ()'
		// _sFuncao += '_EstFul()'
		// _sFuncao += '_Etiq ()'
		// _sFuncao += '_ESXEst ()'
		// _sFuncao += '_evtXML ()'
		// _sFuncao += '_exml ()'
		// _sFuncao += '_FtSafra ()'
		// _sFuncao += '_gerasze ()'
		// _sFuncao += '_GLPI13221 ()'
		// _sFuncao += '_GLPI13674 ()'
		// _sFuncao += '_GLPI13773 ()'
		// _sFuncao += '_GLPI14020 ()'
		// _sFuncao += '_GLPI14034 ()'
		// _sFuncao += '_GLPI14182 ()'
		// _sFuncao += '_GLPI14200 ()'
		// _sFuncao += '_GLPI14397 ()'
		// _sFuncao += '_GLPI14483 ()'
		// _sFuncao += '_GLPI14809 ()'
		// _sFuncao += '_GLPI15020 ()'
		// _sFuncao += '_GLPI15070 ()'
		// _sFuncao += '_GLPI15191 ()'
		//_sFuncao += '_GLPI15288 ()'
		// _sFuncao += '_ImpGPC ()'
		// _sFuncao += '_memoria ()'
		// _sFuncao += '_metaf ()'
		// _sFuncao += '_PerfMon ()'
		// _sFuncao += '_PreNF ()'
		// _sFuncao += '_Rast ()'
		// _sFuncao += '_regexp ()'
		// _sFuncao += '_reginv ()'
		// _sFuncao += '_recmail ()'
		// _sFuncao += '_RevCH ()'
		// _sFuncao += '_RelAssoc ()'
		// _sFuncao += '_SF1()'
		// _sFuncao += '_SimCtb ()'
		// _sFuncao += '_SimSafr23 ()'
		// _sFuncao += '_SimSafrGI ()'
		// _sFuncao += '_Sisdevin ()'
		// _sFuncao += '_ST_MG ()'
		// _sFuncao += '_SZI ()'
		// _sFuncao += '_TbUva ()'
		// _sFuncao += '_telnet ()'
		// _sFuncao += '_TesteAssoc ()'
		// _sFuncao += '_TrEstq ()'
		// _sFuncao += '_VACCR2 ()'
		// _sFuncao += '_VA_ACR ()'
		// _sFuncao += '_VA_VEF ()'
		// _sFuncao += '_VA_XLS ()'
		// _sFuncao += '_verif ()'

		// _sFuncao += '_GLPI15287 ()' // CONTRA NOTA SAFRAAAAAAAAAAAAAA

		//u_help("custo")
		//_sFuncao += '_GLPI15288()'

		if ! empty (_sFuncao)
			&(_sFuncao)
		else
			u_help ('Nada definido.')
		endif
		
		u_log2 ('info', 'Processo finalizado em ' + ElapTime (_sHrIni, time ()))
		U_UsoRot ('F', procname (), '')
	endif
	if _nLock > 0
		U_Semaforo (_nLock)
	endif
return


// --------------------------------------------------------------------------
// Atualiza custo standard cfe planilha (inclusive itens filhos (unitarios)
static function _GLPI15288 ()
    local _aDados    := {}
    local _nDado     := 0
    local _nCustD    := 0
    local _aCSV      := {}
    local _nCSV      := 0
    local _aFilhos   := {}
    local _nFilho    := 0
    local _oSQL      := NIL
    local _nDecCustD := tamsx3 ("B1_CUSTD")[2]

    _aCSV = U_LeCSV ('c:\temp\GLPI_15288.csv', ';')
    for _nCSV = 1 to len (_aCSV)
        _aCSV [_nCSV, 3] = round (val (strtran (strtran (_aCSV [_nCSV, 3], '"', ''), ',', '.')), _nDecCustD)
    next
    U_Log2 ('debug', _aCSV)

    // Usuario deseja atualizar tambem o cadastro das unidades. Para isso
    // vou procurar os filhos de cada item do arquivo CSV (que tem somente
    // as caixas) e acrescentar esses filhos na array de dados que vai ser
    // usada para alterar os cadastros.
    sb1 -> (dbsetorder (1))
    for _nCSV = 1 to len (_aCSV)

        if ! sb1 -> (dbseek (xfilial ("SB1") + U_TamFixo (_aCSV [_nCSV, 1], 15, ' '), .F.))
            U_Log2 ('erro', '[' + procname () + ']Nao encontrado no SB1: ' + _aCSV [_nCSV, 1])
        else

            // Adiciona o pai (que estava no CSV original)
            aadd (_aDados, {_aCSV [_nCSV, 1], _aCSV [_nCSV, 2], _aCSV [_nCSV, 3]})

            // Adiciona os (se existirem) filhos dele.
            _oSQL := ClsSQL ():New ()
            _oSQL:_sQuery := ""
            _oSQL:_sQuery += "SELECT B1_COD, B1_DESC"
            _oSQL:_sQuery +=  " FROM " + RetSQLName ("SB1") + " SB1"
            _oSQL:_sQuery += " WHERE SB1.D_E_L_E_T_ = ''"
            _oSQL:_sQuery +=   " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
            _oSQL:_sQuery +=   " AND SB1.B1_CODPAI  = '" + _aCSV [_nCSV, 1] + "'"
            _aFilhos := _oSQL:Qry2Array (.f., .f.)
            for _nFilho = 1 to len (_aFilhos)
                aadd (_aDados, {_aFilhos [_nFilho, 1], _aFilhos [_nFilho, 2], _aCSV [_nCSV, 3] / sb1 -> b1_qtdemb})
            next
        endif
    next
    U_Log2 ('debug', _aDados)

    sb1 -> (dbsetorder (1))
    sb5 -> (dbsetorder (1))
    for _nDado = 1 to len (_aDados)
        if len (_aDados [_nDado]) < 3
            U_Log2 ('erro', '[' + procname () + ']Sem custo para ' + _aDados [_nDado, 1] + ' ' + _aDados [_nDado, 2])
        else
            if ! sb1 -> (dbseek (xfilial ("SB1") + U_TamFixo (_aDados [_nDado, 1], 15, ' '), .F.))
                U_Log2 ('erro', '[' + procname () + ']Nao encontrado no SB1: ' + _aDados [_nDado, 1])
            else
                if ! sb5 -> (dbseek (xfilial ("SB5") + sb1 -> b1_cod, .F.))
                    u_log2 ('ERRO', 'Nao encontrei SB5 para o produto ' + sb1 -> b1_cod)
                else
                //  u_log2 ('info', 'Verificando item ' + sb1 -> b1_cod + SB1 -> B1_DESC)

                    _nCustD = _aDados [_nDado, 3]
                    if _nCustD == 0
                        U_Log2 ('aviso', '[' + procname () + ']'+ sb1 -> b1_cod + SB1 -> B1_DESC + ' custo zerado na planilha. Nao vou alterar.')
                    else
                        if sb1 -> b1_custd != _nCustD .or. sb1 -> B1_DATREF != date ()

                            u_log2 ('info', 'Alterando custo ' + sb1 -> b1_cod + SB1 -> B1_DESC + ' de ' + transform (sb1 -> b1_custd, '@E 999,999.9999') + ' para ' + transform (_nCustD, '@E 999,999.9999'))

                            // Cria variaveis para uso na gravacao do evento de alteracao
                            regtomemory ("SB1", .F., .F.)
                            //regtomemory ("SB5", .F., .F.)
                            //m->b5_vasisde = 'S'
                            m->b1_custd  = _nCustD
                            m->B1_DATREF = date ()

                            // Grava evento de alteracao
                            _oEvento := ClsEvent():new ()
                            _oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), 'GLPI 15288 - ajustar B1_CUSTD', .F.)
                            reclock ("SB1", .f.)
                            sb1 -> B1_custd  = m->b1_custd
                            SB1 -> B1_DATREF = m->B1_DATREF
                            msunlock ()
                            U_AtuMerc ("SB1", sb1 -> (recno ()))

                            // Cai fora no primeiro, para testes.
                        //  exit

                        else
                            U_Log2 ('debug', '[' + procname () + ']Dados jah estavam corretos')
                        endif
                    endif
                endif
            endif
        endif
    next
return
// --------------------------------------------------------------------------
// Ajusta saldo de lote / endereco
static function _AjLoteEnd ()
	// Deixo desabilitado pra me obrigar a revisar sempre ---> local _sFilial   := '01'
	local _sDocto    := 'robert'
	local _sProduto  := '2739'
	local _sAlmox    := '07'
	// local _nQuant    := 0.0003  // qt positiva=gerar entrada
	local _sEndereco := ''
	// local _sLote     := '09239801  '
	local _oSQL      := NIL

	if _sFilial != cFilAnt
		u_help ("Estou na filial errada",, .t.)
	else
		begin transaction
		if ! empty (_sLote)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT min (B8_DTVALID)"  // uso MIN pra evitar possivel azar de ter mais de 1 registro.
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB8") + " SB8 "
			_oSQL:_sQuery += " WHERE SB8.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND SB8.B8_FILIAL  = '" + _sFilial + "'"
			_oSQL:_sQuery +=   " AND SB8.B8_LOTECTL = '" + _sLote + "'"
			_oSQL:_sQuery +=   " AND SB8.B8_PRODUTO = '" + _sProduto + "'"
			_oSQL:_sQuery +=   " AND SB8.B8_LOCAL   = '" + _sAlmox + "'"
			if empty (_oSQL:RetQry (1, .f.))
				u_help ("Nao consegui buscar data de validade para o lote.",, .t.)
			else
				_dVldLote = stod (_oSQL:RetQry (1, .f.))
				reclock ("SD5", .t.)
				sd5 -> d5_filial  = _sFilial
				sd5 -> d5_produto = _sProduto
				sd5 -> d5_local   = _sAlmox
				sd5 -> d5_doc     = _sDocto
				sd5 -> d5_data    = date ()
				sd5 -> d5_origlan = iif (_nQuant > 0, '499', '999')
				sd5 -> d5_quant   = abs (_nQuant)
				sd5 -> d5_lotectl = _sLote
				sd5 -> d5_dtvalid = _dVldLote
				msunlock ()
				U_Log2 ('debug', '[' + procname () + ']Movimento gravado na tabela SD5:')
				U_Log2 ('debug', '[' + procname () + ']D5_FILIAL  = ' + sd5 -> d5_filial)
				U_Log2 ('debug', '[' + procname () + ']D5_DOC     = ' + sd5 -> d5_doc)
				U_Log2 ('debug', '[' + procname () + ']D5_PRODUTO = ' + sd5 -> d5_produto)
				U_Log2 ('debug', '[' + procname () + ']D5_LOTECTL = ' + sd5 -> d5_lotectl)
				U_Log2 ('debug', '[' + procname () + ']D5_LOCAL   = ' + sd5 -> d5_local)
				U_Log2 ('debug', '[' + procname () + ']D5_DATA    = ' + dtoc (sd5 -> d5_data))
				U_Log2 ('debug', '[' + procname () + ']D5_QUANT   = ' + cvaltochar (sd5 -> d5_quant))
			endif
		endif
		if ! empty (_sEndereco)
			reclock ("SDB", .t.)
			sdb -> db_filial  = _sFilial
			sdb -> db_item    = '0001'
			sdb -> db_produto = _sProduto
			sdb -> db_localiz = _sEndereco
			sdb -> db_doc     = _sDocto
			sdb -> db_TM      = iif (_nQuant > 0, '499', '999')
			sdb -> db_origem  = 'SD3'
			sdb -> db_quant   = abs (_nQuant)
			sdb -> db_data    = date ()
			sdb -> db_lotectl = _sLote
			sdb -> db_local   = _sAlmox
			sdb -> db_atuest  = 'S'
			sdb -> db_vauser  = cUserName
			msunlock ()
			U_Log2 ('debug', '[' + procname () + ']Movimento gravado na tabela SDB:')
			U_Log2 ('debug', '[' + procname () + ']DB_FILIAL  = ' + sdb -> db_filial)
			U_Log2 ('debug', '[' + procname () + ']DB_DOC     = ' + sdb -> db_doc)
			U_Log2 ('debug', '[' + procname () + ']DB_PRODUTO = ' + sdb -> db_produto)
			U_Log2 ('debug', '[' + procname () + ']DB_LOTECTL = ' + sdb -> db_lotectl)
			U_Log2 ('debug', '[' + procname () + ']DB_LOCAL   = ' + sdb -> db_local)
			U_Log2 ('debug', '[' + procname () + ']DB_LOCALIZ = ' + sdb -> db_localiz)
			U_Log2 ('debug', '[' + procname () + ']DB_DATA    = ' + dtoc (sdb -> db_data))
			U_Log2 ('debug', '[' + procname () + ']DB_QUANT   = ' + cvaltochar (sdb -> db_quant))
			U_Log2 ('debug', '[' + procname () + ']DB_TM      = ' + sdb -> db_tm)
		endif
		end transaction
		U__MATA300 (_sProduto, _sProduto, _sAlmox, _sAlmox)
	endif
return

// --------------------------------------------------------------------------
static function _aviso ()
	// u_batzab ()
	_oAviso := ClsAviso ():New ()
	_oAviso:Tipo       = 'I'
	_oAviso:DestinAvis = 'robert.koch'
	//_oAviso:DestinZZU  = {'122'}  // 122 = grupo da TI
	_oAviso:Titulo     = 'teste mensagem ' + time ()
	_oAviso:Texto      = 'Teste envio notificacao ' + time ()
	_oAviso:Origem     = procname ()
	_oAviso:InfoSessao = .T.
//	_oAviso:IntegNaWeb = .F.  // Nao tenta integrar neste momento (nao ha urgencia)
	_oAviso:Grava ()
return

/*
user function PEEXT006 ()
	local _nItem := 0
	local _sProduto := ''
	if U_AmbTeste ()
		u_showarray (paramixb)
	endif
	U_Log2 ('debug', '[' + procname () + ']')
	for _nItem = 1 to len (paramixb [1])
		U_Log2 ('debug', paramixb [1, _nItem])
		_sProduto = paramixb [1, _nItem, 1, 2]
		U_Log2 ('debug', '[' + procname () + ']B1_RASTRO para o item ' + _sProduto + ': ' + fBuscaCpo ("SB1", 1, xfilial ("SB1") + _sProduto, "B1_RASTRO"))
	next
return paramixb [1]
*/
// --------------------------------------------------------------------------
static function _PreNF ()
	Local _aAutoSF1 	:= {}											//ARRAY COM OS DADOS DO CABEÇALHO DA NOTA -SF1
	local _aAutoSD1  	:= {}											//ARRAY COM DADOS DOS ITENS DA NOTA - SD1
	private lMsHelpAuto := .F. 											//SE .T. DIRECIONA AS MENSAGENS DO HELP
	private lMsErroAuto := .F.

	AADD( _aAutoSF1, { "F1_DOC"      	, '555555561'	, NIL } ) 
	AADD( _aAutoSF1, { "F1_SERIE"    	, '  1'			, NIL } )
	AADD( _aAutoSF1, { "F1_TIPO"     	, 'N',			, NIL } )
	AADD( _aAutoSF1, { "F1_FORMUL"   	, "N"			, Nil } )
	AADD( _aAutoSF1, { "F1_EMISSAO"  	, date ()		, NIL } )
	AADD( _aAutoSF1, { "F1_FORNECE"  	, '000851'		, NIL } )
	AADD( _aAutoSF1, { "F1_LOJA"     	, '01'			, NIL } )
	AADD( _aAutoSF1, { "F1_ESPECIE"  	, "SPED"		, NIL } )

	_aLinha  := {}
	AADD(_aLinha , {"D1_COD"     , 	 '4438'				, NIL } )
	AADD(_aLinha , {"D1_DESCRI"  , 	 'teste'  			, NIL } )
	AADD(_aLinha , {"D1_QUANT"   ,  1					, NIL } )
	AADD(_aLinha , {"D1_VUNIT"   ,  10					, NIL } )
	AADD(_aLinha , {"D1_TOTAL"   ,  10					, NIL } )
	AADD(_aLinha , {"D1_DFABRIC"     , 	 DATE() - 10	, NIL } )
	AADD(_aLinha , {"D1_LOTECTL"     , 	 '001'			, NIL } )
	AADD(_aLinha , {"D1_DTVALID"     , 	 DATE() + 10	, NIL } )
	AADD(_aLinha , {"D1_PEDIDO"  ,   '596223'			, Nil } )
	AADD(_aLinha , {"D1_ITEMPC"  ,   '0001'				, Nil } )
	_aLinha = aClone (U_OrdAuto (_aLinha))
	AADD(_aAutoSD1, aClone (_aLinha))
	MSExecAuto({|x,y,z| Mata140(x,y,z)},_aAutoSF1,_aAutoSD1,3)
	If lMsErroAuto
		if ! empty (NomeAutoLog ())
			u_log2 ('erro', U_LeErro (memoread (NomeAutoLog ())))
		endif
	else
		U_Log2 ('debug', '[' + procname () + ']sucesso')
	endif

return

// --------------------------------------------------------------------------
static function _ST_MG ()
	SF2 -> (dbgoto (636425))
	_TitSTMG ()  // static function do SF2460I
return

// --------------------------------------------------------------------------
// Gera pre-notas compra safra 2016
static function _CprSaf16 ()
	// Simulacao: Violeta + bordo + assoc. da JC que entregaram na 01 + organicas.
	// Bordo e violeta: paga 100%
	// 9822 BORDO DE BORDADURA                                          
	// 9925 BORDO (IVES)                                                
	// 9959 BORDO ORGANICO                                              
	// 9948 BORDO EM CONVERSAO P/ ORGANICA
	// 9976 BRS VIOLETA                                                                               
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2016') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', 6)      // Maximo itens por NF produtor
	U_GravaSX1 (cPerg, '10', 2)      // Geracao p/ DCO (so safra 2009) [S/N]
	U_GravaSX1 (cPerg, '11', '')     // Filial inicial
	U_GravaSX1 (cPerg, '12', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '13', 'A')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '14', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '15', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '16', '9822/9925/9948/9976')  // Apenas estas variedades.
	U_GravaSX1 (cPerg, '17', '')     // Exceto estas variedades.
	U_GravaSX1 (cPerg, '18', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '19', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '20', 'CEB') // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)

	// Associados da L. Jacinto que entregaram na matriz: paga 100%
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2016') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', 6)      // Maximo itens por NF produtor
	U_GravaSX1 (cPerg, '10', 2)      // Geracao p/ DCO (so safra 2009) [S/N]
	U_GravaSX1 (cPerg, '11', '01')   // Filial inicial
	U_GravaSX1 (cPerg, '12', '01')   // Filial final
	U_GravaSX1 (cPerg, '13', 'B')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '14', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '15', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '16', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '17', '9822/9925/9948/9976')    // Exceto estas variedades (bordo e violeta - ja pagas na primeira parcela)
	U_GravaSX1 (cPerg, '18', 'JC')   // Coop. origem.
	U_GravaSX1 (cPerg, '19', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '20', 'OCEB') // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)

	// Demais uvas organicas parte 1 (assoc. da Jacinto exceto os que entregaram na F.01)
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2016') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', 6)      // Maximo itens por NF produtor
	U_GravaSX1 (cPerg, '10', 2)      // Geracao p/ DCO (so safra 2009) [S/N]
	U_GravaSX1 (cPerg, '11', '02')   // Filial inicial
	U_GravaSX1 (cPerg, '12', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '13', 'C')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '14', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '15', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '16', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '17', '9822/9925/9948/9976')    // Exceto estas variedades (bordo e violeta - ja pagas na primeira parcela)
	U_GravaSX1 (cPerg, '18', 'JC')   // Coop. origem.
	U_GravaSX1 (cPerg, '19', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '20', 'O')    // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)

	// Demais uvas organicas parte 2 (exceto assoc. da Jacinto, pois jï¿½ entraram no lote anterior)
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2016') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', 6)      // Maximo itens por NF produtor
	U_GravaSX1 (cPerg, '10', 2)      // Geracao p/ DCO (so safra 2009) [S/N]
	U_GravaSX1 (cPerg, '11', '')     // Filial inicial
	U_GravaSX1 (cPerg, '12', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '13', 'D')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '14', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '15', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '16', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '17', '9822/9925/9948/9976')    // Exceto estas variedades (bordo e violeta - ja pagas na primeira parcela)
	U_GravaSX1 (cPerg, '18', 'AL/PO/SA/SP/SV')  // Coop. origem.
	U_GravaSX1 (cPerg, '19', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '20', 'O')    // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)

	// Demais uvas tintoreas parte 1 (assoc. da Jacinto exceto os que entregaram na F.01)
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2016') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', 6)      // Maximo itens por NF produtor
	U_GravaSX1 (cPerg, '10', 2)      // Geracao p/ DCO (so safra 2009) [S/N]
	U_GravaSX1 (cPerg, '11', '02')   // Filial inicial
	U_GravaSX1 (cPerg, '12', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '13', 'E')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '14', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '15', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '16', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '17', '9822/9925/9948/9976')    // Exceto estas variedades (bordo e violeta - ja pagas na primeira parcela)
	U_GravaSX1 (cPerg, '18', 'JC')   // Coop. origem.
	U_GravaSX1 (cPerg, '19', 1)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '20', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)

	// Demais uvas tintoreas parte 2 (exceto assoc. da Jacinto, pois jï¿½ entraram no lote anterior)
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2016') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', 6)      // Maximo itens por NF produtor
	U_GravaSX1 (cPerg, '10', 2)      // Geracao p/ DCO (so safra 2009) [S/N]
	U_GravaSX1 (cPerg, '11', '')     // Filial inicial
	U_GravaSX1 (cPerg, '12', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '13', 'F')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '14', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '15', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '16', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '17', '9822/9925/9948/9976')    // Exceto estas variedades (bordo e violeta - ja pagas na primeira parcela)
	U_GravaSX1 (cPerg, '18', 'AL/PO/SA/SP/SV')  // Coop. origem.
	U_GravaSX1 (cPerg, '19', 1)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '20', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)

	// O que sobrou vai ateh chegar a 50% do valor total da safra: parte 1 - o resto do pessoal da Jacinto.
	// Por enquanto vou apenas separar numa parcela para conferir quantidades.
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2016') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', 6)      // Maximo itens por NF produtor
	U_GravaSX1 (cPerg, '10', 2)      // Geracao p/ DCO (so safra 2009) [S/N]
	U_GravaSX1 (cPerg, '11', '02')   // Filial inicial
	U_GravaSX1 (cPerg, '12', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '13', 'G')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '14', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '15', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '16', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '17', '9822/9925/9948/9976')    // Exceto estas variedades (bordo e violeta - ja pagas na primeira parcela)
	U_GravaSX1 (cPerg, '18', 'JC')   // Coop. origem.
	U_GravaSX1 (cPerg, '19', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '20', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)

	// O que sobrou vai ateh chegar a 50% do valor total da safra: parte 2 - exceto o pessoal da Jacinto, pois jï¿½ entraram no lote anterior
	// Por enquanto vou apenas separar numa parcela para conferir quantidades.
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2016') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', 6)      // Maximo itens por NF produtor
	U_GravaSX1 (cPerg, '10', 2)      // Geracao p/ DCO (so safra 2009) [S/N]
	U_GravaSX1 (cPerg, '11', '')     // Filial inicial
	U_GravaSX1 (cPerg, '12', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '13', 'H')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '14', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '15', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '16', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '17', '9822/9925/9948/9976')    // Exceto estas variedades (bordo e violeta - ja pagas na primeira parcela)
	U_GravaSX1 (cPerg, '18', 'AL/PO/SA/SP/SV')  // Coop. origem.
	U_GravaSX1 (cPerg, '19', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '20', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)
return

// --------------------------------------------------------------------------
// Gera pre-notas compra safra 2018
static function _CprSaf18 ()
	// Geracao pre-notas compra safra 2018 - parcela A - bordo
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2018') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '11', 'A')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '9925/9822/9948/9959') // Apenas estas variedades (bordo, bordo de bordadura/em conversao/organico)
	U_GravaSX1 (cPerg, '15', '')     // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'OCEB') // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)
	// Geracao pre-notas compra safra 2018 - parcela A - organicas (exceto bordo, jah gerado anteriormente)
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2018') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '11', 'A')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'O')    // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)
	// Geracao pre-notas compra safra 2018 - parcela B - tintoreas (exceto bordo e organicas, jah geradas anteriormente)
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2018') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '11', 'B')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 1)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)
	// Geracao pre-notas compra safra 2018 - parcela B - viniferas Livr. (exceto tintoreas, bordo e organicas, jah geradas anteriormente)
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2018') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '03')   // Filial inicial
	U_GravaSX1 (cPerg, '10', '03')   // Filial final
	U_GravaSX1 (cPerg, '11', 'B')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 2)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)
	// Geracao pre-notas compra safra 2018 - parcela C F.01 - demais (exceto viniferas Livr, tintoreas, bordo e organicas, jah geradas anteriormente)
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2018') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '01')   // Filial inicial
	U_GravaSX1 (cPerg, '10', '01')   // Filial final
	U_GravaSX1 (cPerg, '11', 'C')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)
	// Geracao pre-notas compra safra 2018 - parcela C F.07 e 09 - demais (exceto viniferas Livr, tintoreas, bordo e organicas, jah geradas anteriormente)
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2018') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '07')   // Filial inicial
	U_GravaSX1 (cPerg, '10', '09')   // Filial final
	U_GravaSX1 (cPerg, '11', 'C')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_VA_GNF1 (.T.)
return

// --------------------------------------------------------------------------
// Geracao pre-notas compra safra 2019
static function _CprSaf19 ()
	// grupo A - bordo
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2019') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '11', 'G')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '9925/9822/9948/9959') // Apenas estas variedades (bordo, bordo de bordadura/em conversao/organico)
	U_GravaSX1 (cPerg, '15', '')     // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'OCEB') // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'A')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '3')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_VA_GNF1 (.T.)
	// 
	// grupo A - organicas
	// exceto bordo, jah gerado anteriormente
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2019') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '11', 'H')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'O')    // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'A')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '3')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_VA_GNF1 (.T.)
	// 
	// grupo B - tintoreas
	// exceto bordo e organicas, jah geradas anteriormente
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2019') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '11', 'I')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 1)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'B')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '3')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_VA_GNF1 (.T.)
	// 
	// grupo B - viniferas espaldeira
	// exceto tintoreas, bordo e organicas, jah geradas anteriormente
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2019') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'z')    // Filial final
	U_GravaSX1 (cPerg, '11', 'J')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 2)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'B')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '2')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_VA_GNF1 (.T.)
	// 
	// grupo C - viniferas latadas
	// exceto tintoreas, bordo e organicas, jah geradas anteriormente
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2019') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'z')    // Filial final
	U_GravaSX1 (cPerg, '11', 'K')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 2)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'C')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '1')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_VA_GNF1 (.T.)
	//
	// grupo C - demais
	// exceto tintoreas, bordo e organicas, viniferas jah geradas anteriormente
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2019') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'z')    // Filial final
	U_GravaSX1 (cPerg, '11', 'L')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 1)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'C')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '3')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_VA_GNF1 (.T.)
return

// --------------------------------------------------------------------------
// Geracao pre-notas compra safra 2020
static function _CprSaf20 ()
	// grupo A - bordo
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2020') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '11', 'A')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '9925/9822/9948/9959') // Apenas estas variedades (bordo, bordo de bordadura/em conversao/organico)
	U_GravaSX1 (cPerg, '15', '')     // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'OCEB') // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'A')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '3')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_GravaSX1 (cPerg, '21', '107')  // TES compra de associados
	U_GravaSX1 (cPerg, '22', '077')  // TES compra de nao associados
	U_VA_GNF1 (.T.)
	// 
	// grupo A - organicas
	// exceto bordo, jah gerado anteriormente
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2020') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '11', 'B')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'O')    // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'A')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '3')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_GravaSX1 (cPerg, '21', '107')  // TES compra de associados
	U_GravaSX1 (cPerg, '22', '077')  // TES compra de nao associados
	U_VA_GNF1 (.T.)
	// 
	// grupo B - tintorias
	// exceto bordo e organicas, jah geradas anteriormente
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2020') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '11', 'C')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 1)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'B')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '3')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_GravaSX1 (cPerg, '21', '107')  // TES compra de associados
	U_GravaSX1 (cPerg, '22', '077')  // TES compra de nao associados
	U_VA_GNF1 (.T.)
	// 
	// grupo B - viniferas espaldeira
	// exceto tintoreas, bordo e organicas, jah geradas anteriormente
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2020') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'z')    // Filial final
	U_GravaSX1 (cPerg, '11', 'D')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 2)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'B')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '2')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_GravaSX1 (cPerg, '21', '107')  // TES compra de associados
	U_GravaSX1 (cPerg, '22', '077')  // TES compra de nao associados
	U_VA_GNF1 (.T.)
	// 
	// grupo C - viniferas latadas
	// exceto tintoreas, bordo e organicas, jah geradas anteriormente
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2020') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'z')    // Filial final
	U_GravaSX1 (cPerg, '11', 'E')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 2)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'C')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '1')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_GravaSX1 (cPerg, '21', '107')  // TES compra de associados
	U_GravaSX1 (cPerg, '22', '077')  // TES compra de nao associados
	U_VA_GNF1 (.T.)
	//
	// grupo C - demais
	// exceto tintoreas, bordo e organicas, viniferas jah geradas anteriormente
	cPerg = "VAGNF1"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2020') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	U_GravaSX1 (cPerg, '09', '')     // Filial inicial
	U_GravaSX1 (cPerg, '10', 'z')    // Filial final
	U_GravaSX1 (cPerg, '11', 'F')    // Gerar com qual parcela
	U_GravaSX1 (cPerg, '12', 1)      // Variedade de uva [Comum/Fina/Todas]
	U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	U_GravaSX1 (cPerg, '14', '')     // Apenas estas variedades.
	U_GravaSX1 (cPerg, '15', '9925/9822/9948/9959') // Exceto estas variedades.
	U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	U_GravaSX1 (cPerg, '17', 2)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	U_GravaSX1 (cPerg, '18', 'CEB')  // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	U_GravaSX1 (cPerg, '19', 'C')    // Grupo para pagamento
	U_GravaSX1 (cPerg, '20', '3')    // 1=Latadas; 2=Espaldeira; 3=Todas
	U_GravaSX1 (cPerg, '21', '107')  // TES compra de associados
	U_GravaSX1 (cPerg, '22', '077')  // TES compra de nao associados
	U_VA_GNF1 (.T.)
return

// --------------------------------------------------------------------------
// Gera pre-notas complemento 2021
static function _CplSaf21 ()
	// Simulacoes precos para 2021
	// cPerg = "VAGNF1"
	// U_GravaSX1 (cPerg, '01', '012373')     // Produtor inicial
	// U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	// U_GravaSX1 (cPerg, '03', '012373')    // Produtor final
	// U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	// U_GravaSX1 (cPerg, '05', '2020') // Safra referencia
	// U_GravaSX1 (cPerg, '06', '')     // Contranota entrada uva inicial
	// U_GravaSX1 (cPerg, '07', 'z')    // Contranota entrada uva final
	// U_GravaSX1 (cPerg, '08', '30 ')  // Serie das NF de entrada de uva
	// U_GravaSX1 (cPerg, '09', '03')     // Filial inicial
	// U_GravaSX1 (cPerg, '10', '03')   // Filial final
	// U_GravaSX1 (cPerg, '11', 'Z')    // Gerar com qual parcela
	// U_GravaSX1 (cPerg, '12', 3)      // Variedade de uva [Comum/Fina/Todas]
	// U_GravaSX1 (cPerg, '13', 3)      // Cor da uva [Tinta/Bca+rose/Todas]
	// U_GravaSX1 (cPerg, '14', '') // Apenas estas variedades (bordo, bordo de bordadura/em conversao/organico)
	// U_GravaSX1 (cPerg, '15', '')     // Exceto estas variedades.
	// U_GravaSX1 (cPerg, '16', '')     // Coop. origem.
	// U_GravaSX1 (cPerg, '17', 3)      // Tintoreas [So tintoreas/Exceto tintoreas/Todas]
	// U_GravaSX1 (cPerg, '18', 'OCEB') // [O]rganicas / [C]onvencionais / [E]m coversao / [B]ordadura.
	// U_GravaSX1 (cPerg, '19', 'Z')    // Grupo para pagamento
	// U_GravaSX1 (cPerg, '20', '3')    // 1=Latadas; 2=Espaldeira; 3=Todas
	// U_GravaSX1 (cPerg, '21', '107')  // TES compra de associados
	// U_GravaSX1 (cPerg, '22', '077')  // TES compra de nao associados
	// U_VA_GNF1 (.T.)

	_sArqLog := 'U_VA_GNF3_' + alltrim (cusername) + '_' + dtos (date ()) + ".log"
	if cFilAnt == '07'
		cPerg = "VAGNF3"
		U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
		U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
		U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
		U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
		U_GravaSX1 (cPerg, '05', '2021') // Safra referencia
		U_GravaSX1 (cPerg, '06', 'B')    // gerar qual Parcela
		U_GravaSX1 (cPerg, '07', '')     // DCO inicial
		U_GravaSX1 (cPerg, '08', 'z')    // DCO final
		U_GravaSX1 (cPerg, '09', '')     // Prod ini
		U_GravaSX1 (cPerg, '10', 'z')    // Prod final
		U_GravaSX1 (cPerg, '11', 0)    // Preco 2016
		U_GravaSX1 (cPerg, '12', '9845/9854/9911/9932/9920/9928/9912') // Apenas estas variedades (moscatos, riesling e procecco), trebiano
		U_GravaSX1 (cPerg, '13', '')  // Exceto estas variedades
		U_GravaSX1 (cPerg, '14', '07')   // Filial inicial
		U_GravaSX1 (cPerg, '15', '07')   // Filial final
		U_VA_GNF3 (.T.)
	endif
	if cFilAnt == '03'
		cPerg = "VAGNF3"
		U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
		U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
		U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
		U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
		U_GravaSX1 (cPerg, '05', '2021') // Safra referencia
		U_GravaSX1 (cPerg, '06', 'B')    // gerar qual Parcela
		U_GravaSX1 (cPerg, '07', '')     // DCO inicial
		U_GravaSX1 (cPerg, '08', 'z')    // DCO final
		U_GravaSX1 (cPerg, '09', '')     // Prod ini
		U_GravaSX1 (cPerg, '10', 'z')    // Prod final
		U_GravaSX1 (cPerg, '11', 0)      // Preco (especifico safra 2016)
		U_GravaSX1 (cPerg, '12', '')     // Apenas estas variedades
		U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades
		U_GravaSX1 (cPerg, '14', '03')   // Filial inicial
		U_GravaSX1 (cPerg, '15', '03')   // Filial final
		U_VA_GNF3 (.T.)
	endif
return

// --------------------------------------------------------------------------
// Gera pre-notas complemento 2023 (em maio)
static function _CplSaf23A ()
	local _sSafraCpl := '2023'
	U_MudaLog ('CplSaf23.log')
/*
	cPerg = "VAGNF3"
	// assoc 000156 a 000196 --> ha cargas compartilhadas em 2023
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', _sSafraCpl) // Safra referencia
	U_GravaSX1 (cPerg, '06', 'L')    // gerar qual Parcela
	U_GravaSX1 (cPerg, '07', '')     // DCO inicial
	U_GravaSX1 (cPerg, '08', 'z')    // DCO final
	U_GravaSX1 (cPerg, '09', '')     // Prod ini
	U_GravaSX1 (cPerg, '10', 'z')    // Prod final
	U_GravaSX1 (cPerg, '11', 0)      // Preco total (especifico safra 2016)
	U_GravaSX1 (cPerg, '12', '')     // Apenas estas variedades (separadas por /)
	U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades (separadas por /)
	U_GravaSX1 (cPerg, '14', '')   // Filial inicial
	U_GravaSX1 (cPerg, '15', 'z')   // Filial final
	U_VA_GNF3 (.T.)
*/
/*
	dbselectarea ("ZZ9")
	set filter to zz9_safra = '2023' .and. zz9_parcel = 'K'
	zz9 -> (dbgotop ())
	do while ! zz9 -> (eof ())
		if zz9 -> zz9_safra == _sSafraCpl .and. zz9 -> zz9_parcel == 'K'
			U_Log2 ('debug', '[' + procname () + ']F' + zz9 -> zz9_filial + ' ' + zz9 -> zz9_safra + ' ' + zz9 -> zz9_parcel + ' ' + zz9 -> zz9_pre_nf)
			_sClasFina = ''
			if zz9 -> zz9_conduc == 'L'
				_sClasFina = zz9 -> zz9_clabd
			else
				_sClasFina = zz9 -> zz9_classe
			endif
			reclock ("ZZ9", .F.)
			zz9 -> zz9_vunit3 = U_PrcUva23 (zz9 -> zz9_filial, zz9 -> zz9_produt, val (zz9 -> zz9_grau), _sClasFina, zz9 -> zz9_conduc, .F., .F.) [5]
			msunlock ()
		endif
		zz9 -> (dbskip ())
	enddo
	*/
//	_aParPgSaf := aclone (U_VA_RusPP (_sSafraCpl, 'C', 300, 0, dDataBase))
//	U_Log2 ('debug', _aParPgSaf)

	Private cPerg   := "VAGNF2"
	U_GravaSX1 (cPerg, '01', '005567')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', '005567')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', _sSafraCpl) // Safra referencia
	U_GravaSX1 (cPerg, '06', 'M')    // Parcelas sep.barras (bco=todas)
	U_GravaSX1 (cPerg, '07', 'A')    // Grupo pagto
	U_GravaSX1 (cPerg, '08', 3)      // Geracao por DCO: {"Com DCO", "Sem DCO", "Todos"}
	U_GravaSX1 (cPerg, '09', 3)      // fina/comum: {"Comum", "Fina", "Todas"}
	U_GravaSX1 (cPerg, '10', 2)      // tipo NF: {"Normais", "Compl.preco"}
	U_GravaSX1 (cPerg, '11', '801')     // Cond pagto
	U_GravaSX1 (cPerg, '12', '')     // Apenas estas variedades
	U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades
	U_GravaSX1 (cPerg, '14', 1)      // 1=Assoc+ex assoc;2=Terceiros;3=Todos
	u_va_gnf2 (.t.)
return


// --------------------------------------------------------------------------
// Gera pre-notas complemento 2023 (em junho)
static function _CplSaf23B ()
	local _sSafraCpl := '2023'
	U_MudaLog ('CplSaf23.log')

	Private cPerg   := "VAGNF2"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', _sSafraCpl) // Safra referencia
	U_GravaSX1 (cPerg, '06', 'N')    // Parcelas sep.barras (bco=todas)
	U_GravaSX1 (cPerg, '07', 'C')    // Grupo pagto
	U_GravaSX1 (cPerg, '08', 3)      // Geracao por DCO: {"Com DCO", "Sem DCO", "Todos"}
	U_GravaSX1 (cPerg, '09', 3)      // fina/comum: {"Comum", "Fina", "Todas"}
	U_GravaSX1 (cPerg, '10', 2)      // tipo NF: {"Normais", "Compl.preco"}
	U_GravaSX1 (cPerg, '11', '801')     // Cond pagto
	U_GravaSX1 (cPerg, '12', '9911')     // Apenas estas variedades (neste momento, apenas o moscato branco)
	U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades
	U_GravaSX1 (cPerg, '14', 1)      // 1=Assoc+ex assoc;2=Terceiros;3=Todos
	u_va_gnf2 (.t.)
return


// --------------------------------------------------------------------------
// Gera pre-notas complemento 2023 (em junho - uva alicante)
static function _CplSaf23C ()
	local _sSafraCpl := '2023'
	U_MudaLog ('CplSaf23.log')
/*
	cPerg = "VAGNF3"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', _sSafraCpl) // Safra referencia
	U_GravaSX1 (cPerg, '06', 'O')    // gerar qual Parcela
	U_GravaSX1 (cPerg, '07', '')     // DCO inicial
	U_GravaSX1 (cPerg, '08', 'z')    // DCO final
	U_GravaSX1 (cPerg, '09', '')     // Prod ini
	U_GravaSX1 (cPerg, '10', 'z')    // Prod final
	U_GravaSX1 (cPerg, '11', 0)      // Preco total (especifico safra 2016)
	U_GravaSX1 (cPerg, '12', '9969')     // Apenas estas variedades (separadas por /)
	U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades (separadas por /)
	U_GravaSX1 (cPerg, '14', '')   // Filial inicial
	U_GravaSX1 (cPerg, '15', 'z')   // Filial final
	U_VA_GNF3 (.T.)
*/
	Private cPerg   := "VAGNF2"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', _sSafraCpl) // Safra referencia
	U_GravaSX1 (cPerg, '06', 'O')    // Parcelas sep.barras (bco=todas)
	U_GravaSX1 (cPerg, '07', 'B')    // Grupo pagto
	U_GravaSX1 (cPerg, '08', 3)      // Geracao por DCO: {"Com DCO", "Sem DCO", "Todos"}
	U_GravaSX1 (cPerg, '09', 3)      // fina/comum: {"Comum", "Fina", "Todas"}
	U_GravaSX1 (cPerg, '10', 2)      // tipo NF: {"Normais", "Compl.preco"}
	U_GravaSX1 (cPerg, '11', '801')     // Cond pagto
	U_GravaSX1 (cPerg, '12', '9969')     // Apenas estas variedades
	U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades
	U_GravaSX1 (cPerg, '14', 1)      // 1=Assoc+ex assoc;2=Terceiros;3=Todos
	u_va_gnf2 (.t.)

return

// --------------------------------------------------------------------------
// Testes correcao monetaria associados
static function _CorrMonSZI ()
	U_GravaSX1 ("SZI_CM2", '01', 2)  // Calcular / Descalcular {"Calcular", "Descalcular"}
	U_GravaSX1 ("SZI_CM2", '02', '07/2023')  // Mes/ano de referencia (MMAAAA)
	U_GravaSX1 ("SZI_CM2", '03', 0.0667)  // Taxa % correcao
	U_GravaSX1 ("SZI_CM2", '04', '000634')  // Associado inicial
	U_GravaSX1 ("SZI_CM2", '05', '')  // Loja associado inicial
	U_GravaSX1 ("SZI_CM2", '06', '000634')  // Associado final
	U_GravaSX1 ("SZI_CM2", '07', '01')  // Loja associado final
//	u_szi_cm2 (.t.)
//	U_GravaSX1 ("SZI_CM2", '01', 1)  // Calcular / Descalcular {"Calcular", "Descalcular"}
//	u_szi_cm2 (.t.)
return


// --------------------------------------------------------------------------
static function _ctbanc ()
	U_GravaSX1 ("CTBANC", '01', stod ('20220331'))
	U_CtbANC (.t.)
return

// --------------------------------------------------------------------------
// Testes custo em partes
static function _cusPartes ()
	local _lContinua := .T.
	local _dDataSB9  := stod ('20240331')  // '20191231'

//	if _lContinua .and. ! U_AmbTeste ()
//		u_help ("Por enquanto, apenas em base de teste!",, .t.)
//		_lContinua = .F.
//	endif

	// Inicializa custo em partes. Cfe o link https://centraldeatendimento.totvs.com/hc/pt-br/articles/4416690411159-Cross-Segmento-Backoffice-Linha-Protheus-SIGAEST-Configuração-do-Custo-em-Partes-sem-procedures
	// os saldos das partes devem ser inicializados, como se fosse uma distribuicao inicial do saldo existente antes de comecar a trabalhar em partes.
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT count (*) "
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB9") + " SB9"
		_oSQL:_sQuery += " WHERE SB9.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SB9.B9_FILIAL  = '" + xfilial ("SB9") + "'"
		_oSQL:_sQuery +=   " AND SB9.B9_DATA    > '" + dtos (_dDataSB9) + "'"
		_oSQL:Log ()
		if _oSQL:RetQry (1, .f.) > 0
			u_help ("Encontrei SB9 com data posterior. Processo abortado.",, .t.)
			_lContinua = .F.
		endif
	endif
	if _lContinua
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT SB9.R_E_C_N_O_ AS REGSB9, B9_COD, B1_TIPO, B1_CODLIN, B1_DESC, B1_AGREGCU, B1_VAMARCM, B9_VINI1, B9_QINI"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB9") + " SB9,"
		_oSQL:_sQuery +=            RetSQLName ("SB1") + " SB1 "
		_oSQL:_sQuery += " WHERE SB9.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SB9.B9_FILIAL  = '" + xfilial ("SB9")  + "'"
		_oSQL:_sQuery +=   " and SB9.B9_DATA    = '" + dtos (_dDataSB9) + "'"
		_oSQL:_sQuery +=   " AND SB9.B9_VINI1   > 0"
		//_oSQL:_sQuery +=   " AND SB9.B9_QINI    > 0"
		_oSQL:_sQuery +=   " AND SB1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
		_oSQL:_sQuery +=   " AND SB1.B1_COD     = SB9.B9_COD"
		_oSQL:_sQuery += " ORDER BY SB9.B9_COD"
		_oSQL:Log ()
		_sAliasQ := _oSQL:Qry2Trb ()
		do while ! (_sAliasQ) -> (eof ())
			sb9 -> (dbgoto ((_sAliasQ) -> regsb9))
		
			// Criterios de distrbuicao definidos pela Liane em 2020 quando
			// fizemos um primeiro ensaio de custo em partes (GLPI 8807)
			// Fiz algumas definicoes por minha conta tambem.
			// REVISAR!
			_nParte1 := _nParte2 := _nParte3 := _nParte4 := _nParte5 := _nParte6 := 0
			do case
				case (_sAliasQ) -> b1_tipo $ 'MO/AP'
					_nParte1 = 100
				case (_sAliasQ) -> b1_tipo == 'GF'
					_nParte2 = 100
				case (_sAliasQ) -> b1_tipo == 'ME'
					_nParte3 = 100
				case (_sAliasQ) -> b1_tipo == 'MP'
					_nParte4 = 100
				case (_sAliasQ) -> b1_tipo == 'BN'
					_nParte5 = 100
				case alltrim ((_sAliasQ) -> b9_cod) $ '2343/2343/2347/4057/405/4059/4416'  // garrafas pet sopradas
					_nParte3 = 71.8
					_nParte5 = 28.2
				case (_sAliasQ) -> b1_codlin $ '18'  // NECTARES E BEBIDAS
					_nParte1 = 10.97
					_nParte2 = 13.25
					_nParte3 = 32.9
					_nParte4 = 42.88
				case (_sAliasQ) -> b1_tipo == 'VD' .and. right (alltrim ((_sAliasQ) -> b9_cod), 1) == 'R'  // Retrabalho (VD)
					_nParte1 = 4.84
					_nParte2 = 9.65
					_nParte4 = 83.7
				case ! (_sAliasQ) -> b1_tipo $ 'MR/MM/BN' .and. ((_sAliasQ) -> b1_desc $ 'CONCENT' .or. (_sAliasQ) -> b1_desc $ 'POLPA' .or. (_sAliasQ) -> b1_tipo = 'PP')  // concentrado/polpa
					_nParte1 = 4.25
					_nParte2 = 8.5
					_nParte4 = 73.4
					_nParte5 = 12.76
				case ! (_sAliasQ) -> b1_tipo $ 'II/ME/UC/MP' .and. ((_sAliasQ) -> b1_agregcu = '1' .or. (_sAliasQ) -> b1_vaMarcm = '10') // para terceiros + marcas de terceiros
					_nParte1 = 11.42
					_nParte2 = 10.41
					_nParte3 = 31.52
				case (_sAliasQ) -> b1_tipo == 'VD'  // granel
					_nParte1 = 4.87
					_nParte2 = 9.7
					_nParte4 = 84.15
				case (_sAliasQ) -> b1_codlin $ '01/13'  // especificos: 01	PREPARADOS;13	SAGU E QUENTAO
					_nParte1 = 6.49
					_nParte2 = 7.61
					_nParte3 = 39.3
					_nParte4 = 45.9
				case (_sAliasQ) -> b1_codlin $ '04'  // ESPUMANTES
					_nParte1 = 9.2
					_nParte2 = 6.3
					_nParte3 = 41
					_nParte4 = 42
					_nParte5 = 1
				case (_sAliasQ) -> b1_codlin $ '09'  // FILTRADOS
					_nParte1 = 3.83
					_nParte2 = 4.8
					_nParte3 = 44.23
					_nParte4 = 33.2
					_nParte5 = 13.44
				case (_sAliasQ) -> b1_codlin $ '06/08/11'  // 06	SUCOS INTEGRAIS; 08	SUCOS 100%; 11	ORGANICOS
					_nParte1 = 5.25
					_nParte2 = 3.24
					_nParte3 = 34.43
					_nParte4 = 56.11
					_nParte5 = 0.26
				case (_sAliasQ) -> b1_codlin $ '03'  // 03	VINHOS FINOS
					_nParte1 = 14.1
					_nParte2 = 11.5
					_nParte3 = 18.71
					_nParte4 = 54.8
					_nParte5 = 0.1
				case (_sAliasQ) -> b1_codlin $ '07/24'  // 07	VINHOS MESA e frisante
					_nParte1 = 13.6
					_nParte2 = 11.1
					_nParte3 = 29.53
					_nParte4 = 44.81
					_nParte5 = 0.06
				case (_sAliasQ) -> b1_tipo == 'PA' .and. (_sAliasQ) -> b1_codlin == '21' // industrializacao
					if 'SUCO' $ (_sAliasQ) -> b1_desc .and. 'UVA' $ (_sAliasQ) -> b1_desc
						_nParte1 = 5.25
						_nParte2 = 3.24
						_nParte3 = 34.43
						_nParte4 = 56.11
						_nParte5 = 0.26
					elseif 'VINHO' $ (_sAliasQ) -> b1_desc
						_nParte1 = 13.6
						_nParte2 = 11.1
						_nParte3 = 29.53
						_nParte4 = 44.81
						_nParte5 = 0.06
					elseif 'SUCO' $ (_sAliasQ) -> b1_desc .and. 'MACA' $ (_sAliasQ) -> b1_desc
						_nParte1 = 10.97
						_nParte2 = 13.25
						_nParte3 = 32.9
						_nParte4 = 42.88
					else
						// Nao inicializando nada, fica 100% para a parte outros.
					endif
				case (_sAliasQ) -> b1_tipo $ 'MM/RE/MR/PS/II/CL/GG/EP/II/MA/MT/UC/VA/MB/MC/SG'  // parte OUTROS
					// Nao inicializando nada, fica 100% para a parte outros.
				otherwise
					u_log2 ('aviso', 'Sem classificacao: ' + (_sAliasQ) -> b9_cod + ' (' + (_sAliasQ) -> b1_tipo + ') ' + (_sAliasQ) -> b1_desc)
					// Nao inicializando nada, fica 100% para a parte outros. Mas acho interessante gerar pelo menos um aviso.
			endcase
			_nParte6 = 100 - _nParte1 - _nParte2 - _nParte3 - _nParte4 - _nParte5
			if _nParte6 < 0
				u_log2 ('erro', 'Parte 6 nao pode ficar negativa')
			else
				reclock ("SB9", .F.)
				sb9 -> b9_cp0101  = _nParte1 / 100 * (_sAliasQ) -> b9_vini1
				sb9 -> b9_cp0201  = _nParte2 / 100 * (_sAliasQ) -> b9_vini1
				sb9 -> b9_cp0301  = _nParte3 / 100 * (_sAliasQ) -> b9_vini1
				sb9 -> b9_cp0401  = _nParte4 / 100 * (_sAliasQ) -> b9_vini1
				sb9 -> b9_cp0501  = _nParte5 / 100 * (_sAliasQ) -> b9_vini1
				sb9 -> b9_cp0601  = _nParte6 / 100 * (_sAliasQ) -> b9_vini1
				if (_sAliasQ) -> b9_qini > 0
					sb9 -> b9_cpm0101 = _nParte1 / 100 * (_sAliasQ) -> b9_vini1 / (_sAliasQ) -> b9_qini
					sb9 -> b9_cpm0201 = _nParte2 / 100 * (_sAliasQ) -> b9_vini1 / (_sAliasQ) -> b9_qini
					sb9 -> b9_cpm0301 = _nParte3 / 100 * (_sAliasQ) -> b9_vini1 / (_sAliasQ) -> b9_qini
					sb9 -> b9_cpm0401 = _nParte4 / 100 * (_sAliasQ) -> b9_vini1 / (_sAliasQ) -> b9_qini
					sb9 -> b9_cpm0501 = _nParte5 / 100 * (_sAliasQ) -> b9_vini1 / (_sAliasQ) -> b9_qini
					sb9 -> b9_cpm0601 = _nParte6 / 100 * (_sAliasQ) -> b9_vini1 / (_sAliasQ) -> b9_qini
				endif
				msunlock ()
			endif
			(_sAliasQ) -> (dbskip ())
		enddo
	endif
return

// --------------------------------------------------------------------------
// Desabilitar rastreabilidade (lote e/ou enderecamento) de algum item.
// AINDA EM CONSTRUCAO!!! (na verdade, espero nunca precisar usar)
static function _DesabRast ()
	local _aItens := {}
	local _nItem  := 0
	local _oSQL   := NIL
	local _aDados := {}
	local _nDado  := 0
	local _aErros := {}
	local _sUlMes := ''

	// Menor mes corrente entre todas as filiais
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += "SELECT MIN (B9_DATA)"
	_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB9") + " SB9"
	_oSQL:_sQuery += " WHERE SB9.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=   " AND SB9.B9_FILIAL  NOT IN ('02','04','05','06','12','14')"  // INATIVAS
	_oSQL:_sQuery +=   " AND SB9.B9_DATA != ''"
	_sUlMes = _oSQL:RetQry (1, .f.)
	U_Log2 ('debug', '[' + procname () + ']_sUlMes = ' + _sUlMes)

	// Lista de itens a analisar
	aadd (_aItens, U_TamFixo ('609939', TamSX3 ("B1_COD")[1], ' '))

	for _nItem = 1 to len (_aItens)
		_aErros = {}
//		_lDesabOK = .T.

		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
	//	_oSQL:_sQuery += "SELECT 'Item tem lote(s) com saldo em: ' + string_agg ('Filial ' + B8_FILIAL + '/ ax ' + B8_LOCAL, '; ')"
		_oSQL:_sQuery += "SELECT B8_FILIAL, B8_LOCAL"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB8") + " SB8"
		_oSQL:_sQuery += " WHERE SB8.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SB8.B8_PRODUTO = '" + _aItens [_nItem] + "'"
		_oSQL:_sQuery +=   " AND SB8.B8_SALDO  != 0"
		_oSQL:Log ('[' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		for _nDado = 1 to len (_aDados)
			aadd (_aErros, {_aItens [_nItem], _aDados [_nDado, 1], _aDados [_nDado, 2], 'Lote(s) com saldo'})
		next

		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT BF_FILIAL, BF_LOCAL"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SBF") + " SBF"
		_oSQL:_sQuery += " WHERE SBF.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SBF.BF_PRODUTO = '" + _aItens [_nItem] + "'"
		_oSQL:_sQuery +=   " AND SBF.BF_QUANT  != 0"
		_oSQL:Log ('[' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		for _nDado = 1 to len (_aDados)
			aadd (_aErros, {_aItens [_nItem], _aDados [_nDado, 1], _aDados [_nDado, 2], 'Endereco(s) com saldo'})
		next

		// Se tiver movimentacao no mes corrente, nao adianta limpar SBJ e SBK, pois ele vai gerar novamente
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT D1_FILIAL, D1_LOCAL"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD1")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND D1_COD     = '" + _aItens [_nItem] + "'"
		_oSQL:_sQuery +=   " AND D1_DTDIGIT > '" + _sUlMes + "'"
		_oSQL:_sQuery +=   " AND D1_LOTECTL != ''"
		_oSQL:Log ('[' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		for _nDado = 1 to len (_aDados)
			aadd (_aErros, {_aItens [_nItem], _aDados [_nDado, 1], _aDados [_nDado, 2], 'NF (tabela SD1) referenciando lote no mes corrente'})
		next

		_oSQL:_sQuery := ""
//		_oSQL:_sQuery += "SELECT 'Item tem movimentos referenciando lote e/ou endereco na tabela SD2 no mes corrente: ' + string_agg ('Filial ' + D2_FILIAL + '/ ax ' + D2_LOCAL, '; ')"
		_oSQL:_sQuery += "SELECT D2_FILIAL, D2_LOCAL"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD2")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND D2_COD     = '" + _aItens [_nItem] + "'"
		_oSQL:_sQuery +=   " AND D2_EMISSAO > '" + _sUlMes + "'"
		_oSQL:_sQuery +=   " AND (D2_LOTECTL != '' OR D2_LOCALIZ != '')"
		_oSQL:Log ('[' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		for _nDado = 1 to len (_aDados)
			aadd (_aErros, {_aItens [_nItem], _aDados [_nDado, 1], _aDados [_nDado, 2], 'NF (tabela SD2) referenciando lote ou endereco no mes corrente'})
		next

		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT D3_FILIAL, D3_LOCAL"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD3")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND D3_COD     = '" + _aItens [_nItem] + "'"
		_oSQL:_sQuery +=   " AND D3_EMISSAO > '" + _sUlMes + "'"
		_oSQL:_sQuery +=   " AND (D3_LOTECTL != '' OR D3_LOCALIZ != '')"
		_oSQL:Log ('[' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		for _nDado = 1 to len (_aDados)
			aadd (_aErros, {_aItens [_nItem], _aDados [_nDado, 1], _aDados [_nDado, 2], 'Movimento (tabela SD3) referenciando lote ou endereco no mes corrente'})
		next

		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT D5_FILIAL, D5_LOCAL"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SD5")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND D5_PRODUTO = '" + _aItens [_nItem] + "'"
		_oSQL:_sQuery +=   " AND D5_DATA    > '" + _sUlMes + "'"
		_oSQL:Log ('[' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		for _nDado = 1 to len (_aDados)
			aadd (_aErros, {_aItens [_nItem], _aDados [_nDado, 1], _aDados [_nDado, 2], 'Movimento (tabela SD5) no mes corrente'})
		next

		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT DA_FILIAL, DA_LOCAL"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SDA")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND DA_PRODUTO = '" + _aItens [_nItem] + "'"
		_oSQL:_sQuery +=   " AND DA_DATA    > '" + _sUlMes + "'"
		_oSQL:Log ('[' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		for _nDado = 1 to len (_aDados)
			aadd (_aErros, {_aItens [_nItem], _aDados [_nDado, 1], _aDados [_nDado, 2], 'Movimento (tabela SDA) no mes corrente'})
		next

		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT DB_FILIAL, DB_LOCAL"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SDB")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND DB_PRODUTO = '" + _aItens [_nItem] + "'"
		_oSQL:_sQuery +=   " AND DB_DATA    > '" + _sUlMes + "'"
		_oSQL:Log ('[' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		for _nDado = 1 to len (_aDados)
			aadd (_aErros, {_aItens [_nItem], _aDados [_nDado, 1], _aDados [_nDado, 2], 'Movimento (tabela SDB) no mes corrente'})
		next

		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT DD_FILIAL, DD_LOCAL"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SDD")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND DD_PRODUTO = '" + _aItens [_nItem] + "'"
		_oSQL:_sQuery +=   " AND DD_SALDO  != 0"
		_oSQL:Log ('[' + procname () + ']')
		_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
		for _nDado = 1 to len (_aDados)
			aadd (_aErros, {_aItens [_nItem], _aDados [_nDado, 1], _aDados [_nDado, 2], 'Bloqueio (com saldo) de lotes (tabela SDD)'})
		next

	next

	if len (_aErros) > 0
		//u_showarray (_aErros)
		help ("Impossivel desabilitar rastro / enderecamento do item '" + _aItens [_nItem] + "' pelo(s) seguinte(s) motivo(s):" + chr (13) + chr (10) + _sMsg,, .t.)
		U_Log2 ('debug', _aErros)
	endif
return

// --------------------------------------------------------------------------
static function _gerasze()
	local _oAssoc    := NIL
	local _sSafra    := '2024'
	local _sBalanca  := 'LB'
	local _sSerieNF  := ''
	local _sNumNF    := ''
	local _sChvNfPe  := ''
	local _sPlacaVei := 'DODGE'
	local _sObs      := 'TESTE ROBERT'
	local _sCadVit   := '13410'  //'13386'
	local _sVaried   := '9901'
	local _sVaried2  := '9959'
	local _sEmbalag  := 'G'
	local _sTombador := '1'
	local _aItensCar := {}
	local _sLote     := ''
	local _sSenhaOrd := ''
//	local _sCPFCarg  := '43176070004   '
//	local _sInscCarg := '0291074634        '
	local _sImpTkCar := '99'
//	local _oSQL      := NIL
//	local _aRegSA2   := {}
	local _sSivibe   := 'RS-000.013.392'
	local _sEspumant := ''
	local _sCompart  := ''
	local _lAmostra  := .F.
	_oAssoc := ClsAssoc ():New ('000167', '01')
	PRIVATE _sErroWS   := ''  // normalmente instanciada pelo programa WS_ALIANCA
	private _sMsgRetWS := ''  // normalmente instanciada pelo programa WS_ALIANCA
	aadd (_aItensCar, {_sCadVit, _sVaried, _sEmbalag, _sLote, _sSivibe, _sEspumant})
	if ! empty (_sVaried2)
		aadd (_aItensCar, {_sCadVit, _sVaried2, _sEmbalag, _sLote, _sSivibe, _sEspumant})
	endif
	u_log2 ('info', 'Itens da carga:')
	u_log2 ('info', _aItensCar)
	U_GeraSZE (_oAssoc,_sSafra,_sBalanca,_sSerieNF,_sNumNF,_sChvNfPe,_sPlacaVei,_sTombador,_sObs,_aItensCar, _lAmostra, _sSenhaOrd, _sImpTkCar, _sCompart) //_sCargaC1, _sCargaC2)
return

// --------------------------------------------------------------------------
// Recalcula frete safra e compara com conteudo jah gravado.
static function _GLPI13221 ()
	local _aCargas := {}
	local _nCarga  := 0
	private _aHistFrt := {}  // Para poder gerar, no final, uma planilha com todos os valores.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT FILIAL, SAFRA, CARGA "
	_oSQL:_sQuery +=  " FROM VA_VCARGAS_SAFRA"
	_oSQL:_sQuery += " WHERE SAFRA = '2023'"
	_oSQL:_sQuery +=   " and STATUS != 'C'"
	_oSQL:_sQuery +=   " and CONTRANOTA != ''"
	// _oSQL:_sQuery +=   " and ASSOCIADO in ('000248','001301','002083')
	_oSQL:_sQuery += " ORDER BY ASSOCIADO, FILIAL, CARGA"
	_oSQL:Log ()
	_aCargas = _oSQL:Qry2Array ()
	sze -> (dbsetorder (1))
	for _nCarga = 1 to len (_aCargas)
		u_log2 ('info', replicate ('-', 80))
		if sze -> (dbseek (_aCargas [_nCarga, 1] + _aCargas [_nCarga, 2] + _aCargas [_nCarga, 3], .T.))
			U_VA_RUSCF (.f., @_aHistFrt)
		else
			u_log2 ('erro', 'Carga nao encontrada com a seguinte chave: ' + _aCargas [_nCarga, 1] + _aCargas [_nCarga, 2] + _aCargas [_nCarga, 3])
		endif
	next
	U_Log2 ('debug', _aHistFrt)
	u_acolsXLS (_aHistFrt)
return

// --------------------------------------------------------------------------
// Como as NF complemento safra maio/2023 foram acumuladas por produto+grau
// (devido à grande quantidade de talões que precisaríamos preencher), perdi
// a referencia à NF origem de pelo menos um dos itens, e isso inviabiliza
// o uso da view VA_VPRECO_EFETIVO_SAFRA. Vou tentar usar o SZH para isso.
static function _GLPI13674 ()
	local _aNFCpl   := {}
	local _sAliasQ  := ''
	local _nVlUsado := 0

	// Primeira passagem: somente as pre-notas que nao foram acumuladas em contranotas.
	dbselectarea ("ZZ9")
	set filter to zz9_safra = '2023' .and. zz9_parcel = 'M'
	zz9 -> (dbgotop ())
	do while ! zz9 -> (eof ())
		if zz9 -> zz9_safra == '2023' .and. zz9 -> zz9_parcel == 'M' .AND. zz9_nfComp != 'VLR_MENOR'  .AND. zz9_nfComp != '' .and. empty (zz9_dco)
			U_Log2 ('debug', '[' + procname () + ']1p F' + zz9 -> zz9_filial + ' ' + zz9 -> zz9_safra + ' ' + zz9 -> zz9_parcel + ' prenf:' + zz9 -> zz9_pre_nf + ' forn:' + zz9 -> zz9_fornec + ' ori:' + zz9 -> zz9_nfori + ' comp:' + zz9 -> zz9_nfComp)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery += " SELECT COUNT (*)"
			_oSQL:_sQuery += " FROM " + RetSQLName ("ZZ9") + " ZZ9"
			_oSQL:_sQuery += " WHERE ZZ9.D_E_L_E_T_ = ''"
			_oSQL:_sQuery += " AND ZZ9.ZZ9_FILIAL = '" + zz9 -> zz9_FILIAL + "'"
			_oSQL:_sQuery += " AND ZZ9.ZZ9_SAFRA  = '" + zz9 -> zz9_SAFRA  + "'"
			_oSQL:_sQuery += " AND ZZ9.ZZ9_FORNEC = '" + zz9 -> zz9_FORNEC + "'"
			_oSQL:_sQuery += " AND ZZ9.ZZ9_LOJA   = '" + zz9 -> zz9_LOJA   + "'"
			_oSQL:_sQuery += " AND ZZ9.ZZ9_PARCEL = '" + zz9 -> zz9_PARCEL + "'"
			_oSQL:_sQuery += " AND ZZ9.ZZ9_PRODUT = '" + zz9 -> zz9_PRODUT + "'"
			_oSQL:_sQuery += " AND ZZ9.ZZ9_GRAU   = '" + zz9 -> zz9_GRAU   + "'"
			_oSQL:_sQuery += " AND ZZ9.ZZ9_NFORI + ZZ9.ZZ9_ITEMOR != '" + zz9 -> zz9_NFORI + zz9 -> zz9_ITEMOR + "'"
			
			// Por enquanto, apenas notas 'de 1 para 1'
			if _oSQL:RetQry (1, .f.) == 0

				// Posiciona a tabela SD1 na nota ORIGINAL para garantir um pouco mais.
				sd1 -> (dbsetorder (1))  // D1_FILIAL, D1_DOC, D1_SERIE, D1_FORNECE, D1_LOJA, D1_COD, D1_ITEM, R_E_C_N_O_, D_E_L_E_T_
				if sd1 -> (dbseek (zz9 -> zz9_filial + zz9 -> zz9_nfori + zz9 -> zz9_serior + zz9 -> zz9_fornec + zz9 -> zz9_loja + zz9 -> zz9_produt + zz9 -> zz9_itemor, .F.))

					// Quero encontrar, tambem, a nota de complemento.
					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := ""
					_oSQL:_sQuery += "SELECT DATA, ITEM_NOTA, VALOR_TOTAL"
					_oSQL:_sQuery +=  " FROM VA_VNOTAS_SAFRA V"
					_oSQL:_sQuery += " WHERE V.SAFRA         = '" + zz9 -> zz9_safra  + "'"
					_oSQL:_sQuery +=   " AND V.TIPO_NF       = 'V'"
					_oSQL:_sQuery +=   " AND V.FILIAL        = '" + zz9 -> zz9_filial + "'"
					_oSQL:_sQuery +=   " AND V.ASSOCIADO     = '" + zz9 -> zz9_fornec + "'"
					_oSQL:_sQuery +=   " AND V.LOJA_ASSOC    = '" + zz9 -> zz9_loja   + "'"
					_oSQL:_sQuery +=   " AND V.DOC           = '" + zz9 -> zz9_nfcomp + "'"
					_oSQL:_sQuery +=   " AND V.SERIE         = '" + zz9 -> zz9_sercom + "'"
					_oSQL:_sQuery +=   " AND V.PRODUTO       = '" + zz9 -> zz9_produt + "'"
					_oSQL:_sQuery +=   " AND V.GRAU          = '" + zz9 -> zz9_grau   + "'"
					_oSQL:_sQuery +=   " AND V.CLAS_FINAL    = '" + zz9 -> zz9_classe + "'"
					_oSQL:_sQuery +=   " AND V.CLAS_ABD      = '" + zz9 -> zz9_clabd  + "'"
					_oSQL:_sQuery +=   " AND V.SIST_CONDUCAO = '" + zz9 -> zz9_conduc + "'"
					_aNFCpl := aclone (_oSQL:RetFixo (1, 'ao procurar NF complemento', .f.))
					if len (_aNFCpl) == 1
						reclock ("SZH", .T.)
						szh -> zh_filial  = zz9 -> zz9_filial
						szh -> zh_NFSAIDA = 'SAFRA2023'
						szh -> zh_fornece = zz9 -> zz9_fornec
						szh -> zh_loja    = zz9 -> zz9_loja
						szh -> zh_Data    = stod (_aNFCpl [1, 1])
						szh -> zh_NFFrete = zz9 -> zz9_nfcomp
						szh -> zh_SerFret = zz9 -> zz9_sercom
						szh -> zh_ItNFs   = substr (_aNFCpl [1, 2], 3, 2)  // Siiiim, eh um aproveitamento de campos muito descarado!
						szh -> zh_TpFre   = 'E'
						szh -> zh_NFentr  = sd1 -> d1_doc
						szh -> zh_Srnfent = sd1 -> d1_serie
						szh -> zh_ItNFE   = sd1 -> d1_item
						szh -> zh_TpNFEnt = 'N'
						szh -> zh_CliFor  = sd1 -> d1_fornece
						szh -> zh_LjCliFo = sd1 -> d1_loja
						szh -> zh_SeqEntr = "1"  // DIFERENCIAR PARTE 1 E PARTE 2 DESTE PROCESSO
						szh -> zh_Rateio  = _aNFCpl [1, 3]
						szh -> zh_TpDesp  = 'S'
						MsUnLock()
						reclock ("ZZ9", .f.)
						zz9 -> zz9_dco = 'GLPI13674 ok1'
						msunlock ()
					else
						U_Log2 ('erro', '[' + procname () + ']Era pra ter achado apenas 1 NF complemento: ' + _oSQL:_sQuery)
					endif
				else
					U_Log2 ('erro', '[' + procname () + ']Nao encontrei SD1: ' + zz9 -> zz9_filial + zz9 -> zz9_nfori + zz9 -> zz9_serior + zz9 -> zz9_fornec + zz9 -> zz9_loja + zz9 -> zz9_produt + zz9 -> zz9_itemor)
				endif
			else
				U_Log2 ('aviso', '[' + procname () + ']Teve outra nota de origem com mesma combinacao de produto/grau/classe/...')
			endif
		endif
		zz9 -> (dbskip ())
	enddo

	// Segunda passagem: procura notas originais que foram acumuladas num mesmo complemento
	// Calcula coluna com o acumulado do complemento que deveria ter sido gerado para
	// aquela combinacao de filial/forn;produto/grau (com base no ZZ9)
	// E busca a nota de complemento para ver se tem o mesmo valor.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery += " SELECT SUM (ROUND ((ZZ9_QTORI * ZZ9_VUNIT) - (ZZ9_QTORI * ZZ9_VUNOLD), 2)) OVER (PARTITION BY ZZ9_FILIAL, ZZ9_FORNEC, ZZ9_LOJA, ZZ9_PRODUT, ZZ9_GRAU, ZZ9_CLASSE, ZZ9_CLABD, ZZ9.ZZ9_NFCOMP) as TOTCOMP"
	_oSQL:_sQuery +=       ", count (*) OVER (PARTITION BY ZZ9_FILIAL, ZZ9_FORNEC, ZZ9_LOJA, ZZ9_PRODUT, ZZ9_GRAU, ZZ9_CLASSE, ZZ9_CLABD, ZZ9.ZZ9_NFCOMP) AS QTCOMP"
	_oSQL:_sQuery +=       ", ROUND ((ZZ9_QTORI * ZZ9_VUNIT) - (ZZ9_QTORI * ZZ9_VUNOLD), 2) as COMPL_PREV"
	_oSQL:_sQuery +=       ", ZZ9.*"
	_oSQL:_sQuery +=       ", (SELECT VALOR_TOTAL
	_oSQL:_sQuery +=           " FROM VA_VNOTAS_SAFRA V
	_oSQL:_sQuery +=          " WHERE V.SAFRA = ZZ9_SAFRA
	_oSQL:_sQuery +=            " AND V.FILIAL = ZZ9_FILIAL
	_oSQL:_sQuery +=            " AND V.ASSOCIADO = ZZ9_FORNEC
	_oSQL:_sQuery +=            " AND V.LOJA_ASSOC = ZZ9_LOJA
	_oSQL:_sQuery +=            " AND V.DOC = ZZ9.ZZ9_NFCOMP
	_oSQL:_sQuery +=            " AND V.SERIE = ZZ9.ZZ9_SERCOM
	_oSQL:_sQuery +=            " AND V.TIPO_NF = 'V'
	_oSQL:_sQuery +=            " AND V.PRODUTO = ZZ9.ZZ9_PRODUT
	_oSQL:_sQuery +=            " AND V.GRAU = ZZ9.ZZ9_GRAU
	_oSQL:_sQuery +=         " ) AS VL_NF"
	_oSQL:_sQuery +=   " FROM " + RetSQLName ("ZZ9") + " ZZ9"
	_oSQL:_sQuery +=  " WHERE ZZ9.D_E_L_E_T_  = ''"
	_oSQL:_sQuery +=    " AND ZZ9.ZZ9_SAFRA   = '2023'"
	_oSQL:_sQuery +=    " AND ZZ9.ZZ9_PARCEL  = 'M'"
	_oSQL:_sQuery +=    " AND ZZ9.ZZ9_NFCOMP != ''"
	_oSQL:_sQuery +=    " AND ZZ9.ZZ9_NFCOMP != 'VLR_MENOR'"
	_oSQL:_sQuery +=    " AND ZZ9.ZZ9_DCO     = ''"
	_oSQL:_sQuery +=  " ORDER BY ZZ9_FILIAL, ZZ9_FORNEC, ZZ9_LOJA, ZZ9_PRODUT, ZZ9_GRAU, ZZ9_CLASSE, ZZ9_CLABD, COMPL_PREV"
	_oSQL:Log ('[' + procname () + ']')
	_sAliasQ = _oSQL:Qry2Trb (.F.)
	(_sAliasQ) -> (dbgotop ())
	do while ! (_sAliasQ) -> (eof ())
		
		// Vou aceitar diferenca nos centavos. Ajustarei na ultima (maior valor).
		if abs ((_sAliasQ) -> totcomp - (_sAliasQ) -> vl_nf) <= 1
			U_Log2 ('debug', '[' + procname () + ']2p  F' + (_sAliasQ) -> zz9_filial + ' ' + (_sAliasQ) -> zz9_safra + ' ' + (_sAliasQ) -> zz9_parcel + ' prenf:' + (_sAliasQ) -> zz9_pre_nf + ' forn:' + (_sAliasQ) -> zz9_fornec + ' ori:' + (_sAliasQ) -> zz9_nfori + ' comp:' + (_sAliasQ) -> zz9_nfComp)
			_nVlUsado = 0
			_nQual    = 1
			_sChave := (_sAliasQ) -> ZZ9_FILIAL + (_sAliasQ) -> ZZ9_FORNEC + (_sAliasQ) -> ZZ9_LOJA + (_sAliasQ) -> ZZ9_PRODUT + (_sAliasQ) -> ZZ9_GRAU + (_sAliasQ) -> ZZ9_CLASSE + (_sAliasQ) -> ZZ9_CLABD
			do while ! (_sAliasQ) -> (eof ()) .and. (_sAliasQ) -> ZZ9_FILIAL + (_sAliasQ) -> ZZ9_FORNEC + (_sAliasQ) -> ZZ9_LOJA + (_sAliasQ) -> ZZ9_PRODUT + (_sAliasQ) -> ZZ9_GRAU + (_sAliasQ) -> ZZ9_CLASSE + (_sAliasQ) -> ZZ9_CLABD == _sChave

				// Quero encontrar a nota de complemento.
				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery := ""
				_oSQL:_sQuery += "SELECT DATA, ITEM_NOTA, VALOR_TOTAL" //, sum (VALOR_TOTAL) over () as TOTGER"
				_oSQL:_sQuery +=  " FROM VA_VNOTAS_SAFRA V"
				_oSQL:_sQuery += " WHERE V.SAFRA         = '" + (_sAliasQ) -> zz9_safra  + "'"
				_oSQL:_sQuery +=   " AND V.TIPO_NF       = 'V'"
				_oSQL:_sQuery +=   " AND V.FILIAL        = '" + (_sAliasQ) -> zz9_filial + "'"
				_oSQL:_sQuery +=   " AND V.ASSOCIADO     = '" + (_sAliasQ) -> zz9_fornec + "'"
				_oSQL:_sQuery +=   " AND V.LOJA_ASSOC    = '" + (_sAliasQ) -> zz9_loja   + "'"
				_oSQL:_sQuery +=   " AND V.DOC           = '" + (_sAliasQ) -> zz9_nfcomp + "'"
				_oSQL:_sQuery +=   " AND V.SERIE         = '" + (_sAliasQ) -> zz9_sercom + "'"
				_oSQL:_sQuery +=   " AND V.PRODUTO       = '" + (_sAliasQ) -> zz9_produt + "'"
				_oSQL:_sQuery +=   " AND V.GRAU          = '" + (_sAliasQ) -> zz9_grau   + "'"
				_oSQL:_sQuery +=   " AND V.CLAS_FINAL    = '" + (_sAliasQ) -> zz9_classe + "'"
				_oSQL:_sQuery +=   " AND V.CLAS_ABD      = '" + (_sAliasQ) -> zz9_clabd  + "'"
				_oSQL:_sQuery +=   " AND V.SIST_CONDUCAO = '" + (_sAliasQ) -> zz9_conduc + "'"
			//	_oSQL:Log ('[' + procname () + ']')
				_aNFCpl := aclone (_oSQL:Qry2Array (.f., .f.)) // :RetFixo (1, 'na leitura de NF complemento', .f.))
				if len (_aNFCpl) != 1
					U_Log2 ('erro', '[' + procname () + ']Era pra ter achado 1 NF complemento, mas achei ' + cvaltochar (len (_aNFCpl)) + '  ' + _oSQL:_sQuery)
				else
					if abs ((_sAliasQ) -> totcomp - _aNFCpl [1, 3]) > 1  // Vou aceitar 1 real de fiferenca nos arredondementos e somas.
						U_Log2 ('erro', '[' + procname () + ']Eu esperava total de complemento ' + cvaltochar ((_sAliasQ) -> totcomp) + ' e achei ' + cvaltochar (_aNFCpl [1, 3]))
					else
						// No ultimo item farei o ajuste de algum centavo de diferenca.
						if _nQual == (_sAliasQ) -> qtcomp
							U_Log2 ('debug', '[' + procname () + ']Hora de ajustar diferenca. TotCompl = ' + cvaltochar ((_sAliasQ) -> totcomp) + ' Jah usado = ' + cvaltochar (_nVlUsado) + ' vl deste item = ' + cvaltochar ((_sAliasQ) -> compl_prev))
							_nZHRat = (_sAliasQ) -> totcomp - _nVlUsado
						else
							_nZHRat = (_sAliasQ) -> compl_prev
						endif
						reclock ("SZH", .T.)
						szh -> zh_filial  = (_sAliasQ) -> zz9_filial
						szh -> zh_NFSAIDA = 'SAFRA2023'
						szh -> zh_fornece = (_sAliasQ) -> zz9_fornec
						szh -> zh_loja    = (_sAliasQ) -> zz9_loja
						szh -> zh_Data    = stod (_aNFCpl [1, 1])
						szh -> zh_NFFrete = (_sAliasQ) -> zz9_nfcomp
						szh -> zh_SerFret = (_sAliasQ) -> zz9_sercom
						szh -> zh_ItNFs   = substr (_aNFCpl [1, 2], 3, 2)  // Siiiim, eh um aproveitamento de campos muito descarado!
						szh -> zh_TpFre   = 'E'
						szh -> zh_NFentr  = (_sAliasQ) -> zz9_nfori
						szh -> zh_Srnfent = (_sAliasQ) -> zz9_serior
						szh -> zh_ItNFE   = (_sAliasQ) -> zz9_itemor
						szh -> zh_TpNFEnt = 'N'
						szh -> zh_CliFor  = (_sAliasQ) -> zz9_fornec
						szh -> zh_LjCliFo = (_sAliasQ) -> zz9_loja
						szh -> zh_SeqEntr = "2"  // DIFERENCIAR PARTE 1 E PARTE 2 DESTE PROCESSO
						szh -> zh_Rateio  = _nZHRat
						szh -> zh_TpDesp  = 'S'
						MsUnLock ()
						ZZ9 -> (DBGOTO ((_sAliasQ) -> R_E_C_N_O_))
						if ! empty (zz9 -> zz9_dco)
							U_Log2 ('erro', '[' + procname () + ']ZZ9_DCO deveria estar vazio!')
							exit
						endif
						reclock ("ZZ9", .f.)
						zz9 -> zz9_dco = 'GLPI13674 ok2'
						msunlock ()
						_nVlUsado += _nZHRat
						_nQual ++
						U_Log2 ('debug', '[' + procname () + ']agr F' + (_sAliasQ) -> zz9_filial + ' ' + (_sAliasQ) -> zz9_safra + ' ' + (_sAliasQ) -> zz9_parcel + ' prenf:' + (_sAliasQ) -> zz9_pre_nf + ' forn:' + (_sAliasQ) -> zz9_fornec + ' ori:' + (_sAliasQ) -> zz9_nfori + ' comp:' + (_sAliasQ) -> zz9_nfComp + ' ' + cvaltochar (_nVlUsado))
					endif
				endif
				(_sAliasQ) -> (dbskip ())
			enddo
		else
			U_Log2 ('erro', '[' + procname () + ']2p F' + (_sAliasQ) -> zz9_filial + ' ' + (_sAliasQ) -> zz9_safra + ' ' + (_sAliasQ) -> zz9_parcel + ' prenf:' + (_sAliasQ) -> zz9_pre_nf + ' forn:' + (_sAliasQ) -> zz9_fornec + ' ori:' + (_sAliasQ) -> zz9_nfori + ' comp:' + (_sAliasQ) -> zz9_nfComp + 'totais nao batem:' + cvaltochar ((_sAliasQ) -> totcomp) + ' e ' + cvaltochar ((_sAliasQ) -> vl_nf))
			(_sAliasQ) -> (dbskip ())
		endif
	enddo
	(_sAliasQ) -> (dbclosearea ())
	dbselectarea ("ZZ9")
return

// --------------------------------------------------------------------------
// Ajusta parcelamento de notas de complremento de safra 2023 (moscato)
// Geracao original GLPI 13699. Foram geradas com vcto a partir do mês 06/2023,
// mas o direito do associado é desde maio, então a parcela de junho deve 
// contemplar junho + [o que ele devia ter recebido em maio]
static function _GLPI13773 ()
	local _aNF := {}
	local _nNF := 0
	local _aParc := {}
	local _nParc := 0

	_oSQL := ClsSQL():New ()
	_oSQL:_sQuery := "SELECT FILIAL, ASSOCIADO, LOJA_ASSOC, SERIE, DOC, SUM (VALOR_TOTAL)"
	_oSQL:_sQuery +=  " FROM VA_VNOTAS_SAFRA V"
	_oSQL:_sQuery += " WHERE SAFRA = '2023'"
	_oSQL:_sQuery +=   " AND FILIAL = '" + cFilAnt + "'"
	_oSQL:_sQuery +=   " AND DATA = '20230616'"
	_oSQL:_sQuery += " GROUP BY FILIAL, ASSOCIADO, LOJA_ASSOC, DOC, SERIE"
	_oSQL:_sQuery += " ORDER BY FILIAL, ASSOCIADO, LOJA_ASSOC, DOC, SERIE"
	_aNF = _oSQL:Qry2Array (.f., .f.)
	U_Log2 ('debug', _aNF)
	for _nNF = 1 to len (_aNF)
		_sPrefLog = 'NF ' + _aNF [_nNF, 5]
		_aParc = {}
		se2 -> (dbsetorder (6))  // E2_FILIAL, E2_FORNECE, E2_LOJA, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, R_E_C_N_O_, D_E_L_E_T_
		se2 -> (dbseek (_aNF [_nNf, 1] + _aNF [_nNf, 2] + _aNF [_nNf, 3] + _aNF [_nNf, 4] + _aNF [_nNf, 5], .t.))
		do while ! se2 -> (eof ()) ;
			.and. se2 -> e2_filial  == _aNF [_nNf, 1] ;
			.and. se2 -> e2_fornece == _aNF [_nNf, 2] ;
			.and. se2 -> e2_loja    == _aNF [_nNf, 3] ;
			.and. se2 -> e2_prefixo == _aNF [_nNf, 4] ;
			.and. se2 -> e2_num     == _aNF [_nNf, 5]
			aadd (_aParc, {se2 -> (recno ()), se2 -> e2_valor, se2 -> e2_vencto, 0})
			se2 -> (dbskip ())
		enddo

		// Verifica o valor total, divide-o em 11 (deveriam ter sido 11 parcelas)
		// depois grava a 1a. e 2a.parcelas (das 11) somadas na posicao 1 da array
		// e distribui o restante do valor.
		_o10p := ClsAUtil ():New (_aParc)
		_o11p := ClsAUtil ():New (afill (array (11), {0}))
		
		// Redistribui as parcelas
		U_Log2 ('debug', '[' + procname () + ']distribuindo ' + cvaltochar (_o10p:TotCol (2)))
		_o11p:Dist (1, _o10p:TotCol (2), 2, 'U')
	//	U_Log2 ('debug', _o11p:_aArray)

		for _nParc = 1 to 10
			_aParc [_nParc, 2] = _o11p:_aArray [_nParc + 1, 1]
		next
		_aParc [1, 2] += _o11p:_aArray [1, 1]
		U_Log2 ('debug', _aParc)

		// soh pra conferir
		_oConf := ClsAUtil ():New (_aParc)
		if _oConf:TotCol (2) != _o10p:TotCol (2)
			U_Log2 ('erro', '[' + procname () + ']distribuiu diferente!')
		endif

		// Regrava os valores
		for _nParc = 1 to len (_aParc)
			se2 -> (dbgoto (_aParc [_nParc, 1]))
			reclock ("SE2", .f.)
			se2 -> e2_valor  = _aParc [_nParc, 2]
			se2 -> e2_saldo  = _aParc [_nParc, 2]
			se2 -> e2_vlcruz = _aParc [_nParc, 2]
			msunlock ()
		next

	next
return

// --------------------------------------------------------------------------
// Atualiza B1_CUSTD cfe planilha
static function _GLPI14020 ()
	local _aDados    := {}
	local _nDado     := 0
	local _nCustD    := 0

	_aDados = U_LeCSV ('c:\temp\GLPI_14020_2.csv', ';')
	u_log (_aDados)

	sb1 -> (dbsetorder (1))
	sb5 -> (dbsetorder (1))
	for _nDado = 1 to len (_aDados)
		if len (_aDados [_nDado]) < 3
			U_Log2 ('erro', '[' + procname () + ']Sem custo para ' + _aDados [_nDado, 1] + ' ' + _aDados [_nDado, 2])
		else
			if ! sb1 -> (dbseek (xfilial ("SB1") + U_TamFixo (_aDados [_nDado, 1], 15, ' '), .F.))
				U_Log2 ('erro', '[' + procname () + ']Nao encontrado no SB1: ' + _aDados [_nDado, 1])
			else
				if ! sb5 -> (dbseek (xfilial ("SB5") + sb1 -> b1_cod, .F.))
					u_log2 ('ERRO', 'Nao encontrei SB5 para o produto ' + sb1 -> b1_cod)
				else
					u_log2 ('info', 'Verificando item ' + sb1 -> b1_cod + SB1 -> B1_DESC)

					_nCustD = val (strtran (_aDados [_nDado, 3], ',', '.'))
				//	U_Log2 ('debug', '[' + procname () + '] >>' + _aDados [_nDado, 3] + '<< para >>' + cvaltochar (_nCustD) + '<<')

					if _nCustD == 0
						U_Log2 ('aviso', '[' + procname () + ']'+ sb1 -> b1_cod + SB1 -> B1_DESC + ' custo zerado na planilha. Nao vou alterar.')
					else
						if sb1 -> b1_custd != _nCustD .or. sb1 -> B1_DATREF != STOD ('20230801')

							u_log2 ('info', 'Alterando custo ' + sb1 -> b1_cod + SB1 -> B1_DESC + ' de ' + transform (sb1 -> b1_custd, '@E 999,999.9999') + ' para ' + transform (_nCustD, '@E 999,999.9999'))

							// Cria variaveis para uso na gravacao do evento de alteracao
							regtomemory ("SB1", .F., .F.)
							//regtomemory ("SB5", .F., .F.)
							//m->b5_vasisde = 'S'
							m->b1_custd  = _nCustD
							m->B1_DATREF = STOD ('20230801')

							// Grava evento de alteracao
							_oEvento := ClsEvent():new ()
							_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), 'GLPI 14020 - ajustar B1_CUSTD', .F.)
							reclock ("SB1", .f.)
							sb1 -> B1_custd  = m->b1_custd
							SB1 -> B1_DATREF = m->B1_DATREF
							msunlock ()
							U_AtuMerc ("SB1", sb1 -> (recno ()))

							// Cai fora no primeiro, para testes.
							// exit

						else
							U_Log2 ('debug', '[' + procname () + ']Dados jah estavam corretos')
						endif
					endif
				endif
			endif
		endif
	next
return

// --------------------------------------------------------------------------
// Atualiza taxa depreciacao imobilizado cfe planilha
static function _GLPI14034 ()
	local _aDados    := {}
	local _nDado     := 0
	local _nQtNotF   := 0
	local _nQtAlter  := 0
	local _nQtNAlter := 0
	local _nQtMulti  := 0
	local _nQtJaOk   := 0

	_aDados = U_LeCSV ('c:\temp\GLPI_14034_F05.csv', ';')
	for _nDado = 1 to len (_aDados)
		_aDados [_nDado, 1] = strzero (val (_aDados [_nDado, 1]), 2)
		_aDados [_nDado, 2] = strzero (val (_aDados [_nDado, 2]), 10)
		_aDados [_nDado, 4] = strzero (val (_aDados [_nDado, 4]), 2)
		_aDados [_nDado, 5] = val (_aDados [_nDado, 5])
	next
	//u_log (_aDados)
	pergunte ('AFA230', .F.)
	MV_PAR03 = ''  // Do Grupo ?                   
	MV_PAR04 = 'z'  // Ate o Grupo ?                
	MV_PAR06 = 1  // Alterar Tx na Moeda ?        
	MV_PAR07 = ''  // Do Centro de Custo ?         
	MV_PAR08 = 'z'  // Ate o Centro Custo ?         
	MV_PAR09 = ''  // Da Conta ?                   
	MV_PAR10 = 'z'  // Ate a Conta ?                
	MV_PAR11 = 1  // Moedas: Todas/Especifica
	MV_PAR12 = ''  // Do Item Contabil ?           
	MV_PAR13 = 'z'  // Ate Item Contabil ?          
	MV_PAR14 = ''  // Da Classe de Valor ?         
	MV_PAR15 = 'z'  // Ate Classe de Valor ?        
	MV_PAR18 = 2  // Seleciona Filiais ?          
	MV_PAR19 = ''  // Filial De ?                  
	MV_PAR20 = ''  // Filial Até ?                 
	_oSQL := ClsSQL ():New ()
	for _nDado = 1 to len (_aDados)
		if _aDados [_nDado, 1] != cFilAnt
			U_Log2 ('aviso', '[' + procname () + ']Filial errada (' + _aDados [_nDado, 1] + ')')
		else
			U_Log2 ('debug', '[' + procname () + '](' + cvaltochar (_nDado) + ' de ' + cvaltochar (len (_aDados)) + ')' + _aDados [_nDado, 2] + '-' + _aDados [_nDado, 3] + '-' + _aDados [_nDado, 4])

			// Como temos casos de N3_ITEM com zeros e com espacos na frente,
			// achei melhor testar se existe mais de um, por que na planilha que
			// recebi, consta apenas "1" e nao sei se eh '0001' ou '   1'.
			_sItOpcao1 = U_TamFixo (alltrim (_aDados [_nDado, 3]), 4, ' ')
			_sItOpcao2 = replicate (' ', 4-len (alltrim (_aDados [_nDado, 3]))) + alltrim (_aDados [_nDado, 3])
			_sItOpcao3 = replicate ('0', 4-len (alltrim (_aDados [_nDado, 3]))) + alltrim (_aDados [_nDado, 3])
			_sItOpcao4 = iif (len (alltrim (_aDados [_nDado, 3])) == 1, '  '  + alltrim (_aDados [_nDado, 3]) + ' ', '####')  // Soh achei essa situacao em um item.
			_lTemOp1 = .F.
			_lTemOp2 = .F.
			_lTemOp3 = .F.
			_lTemOp4 = .F.
			_sQry1   = ''
			_sQry2   = ''
			_sQry3   = ''
			_sQry4   = ''
			_sN3Item = ''
			_sWhere := "select count (*)"
			_sWhere +=  " FROM " + RetSQLName ("SN3") + " SN3"
			_sWhere += " WHERE SN3.D_E_L_E_T_ = ''"
			_sWhere +=   " AND SN3.N3_FILIAL  = '" + _aDados [_nDado, 1] + "'"
			_sWhere +=   " AND SN3.N3_CBASE   = '" + _aDados [_nDado, 2] + "'"
			_sWhere +=   " AND SN3.N3_TIPO    = '" + _aDados [_nDado, 4] + "'"
			_sWhere +=   " AND SN3.N3_BAIXA   = '0'"

			_oSQL:_sQuery = _sWhere + " AND SN3.N3_ITEM = '" + _sItOpcao1 + "'"
			if _oSQL:RetQry (1, .t.) == 1
				_lTemOp1 = .T.
				_sN3Item = _sItOpcao1
				_sQry1   = _oSQL:_sQuery
			endif

			_oSQL:_sQuery = _sWhere + " AND SN3.N3_ITEM = '" + _sItOpcao2 + "'"
			if _oSQL:RetQry (1, .t.) == 1
				_lTemOp2 = .T.
				_sN3Item = _sItOpcao2
				_sQry2   = _oSQL:_sQuery
			endif

			_oSQL:_sQuery = _sWhere + " AND SN3.N3_ITEM = '" + _sItOpcao3 + "'"
			if _oSQL:RetQry (1, .t.) == 1
				_lTemOp3 = .T.
				_sN3Item = _sItOpcao3
				_sQry3   = _oSQL:_sQuery
			endif

			_oSQL:_sQuery = _sWhere + " AND SN3.N3_ITEM = '" + _sItOpcao4 + "'"
			if _oSQL:RetQry (1, .t.) == 1
				_lTemOp4 = .T.
				_sN3Item = _sItOpcao4
				_sQry4   = _oSQL:_sQuery
			endif

			if   (_lTemOp1 .and. _lTemOp2) ;
			.or. (_lTemOp1 .and. _lTemOp3) ;
			.or. (_lTemOp1 .and. _lTemOp4) ;
			.or. (_lTemOp2 .and. _lTemOp3) ;
			.or. (_lTemOp2 .and. _lTemOp4) ;
			.or. (_lTemOp3 .and. _lTemOp4)
				U_Log2 ('aviso', '[' + procname () + ']CBASE/ITEM tem mais de 1 possibilidade: ' + _aDados [_nDado, 1] + _aDados [_nDado, 2] + _aDados [_nDado, 3])
				U_Log2 ('debug', '[' + procname () + ']' + _sQry1)
				U_Log2 ('debug', '[' + procname () + ']' + _sQry2)
				U_Log2 ('debug', '[' + procname () + ']' + _sQry3)
				U_Log2 ('debug', '[' + procname () + ']' + _sQry4)
				_nQtMulti ++
			else
				sn3 -> (dbsetorder (1))  // N3_FILIAL, N3_CBASE, N3_ITEM, N3_TIPO, N3_BAIXA, N3_SEQ, R_E_C_N_O_, D_E_L_E_T_
				_sChaveSD3 = _aDados [_nDado, 1] + _aDados [_nDado, 2] + _sN3Item + _aDados [_nDado, 4]
				if ! sn3 -> (dbseek (_sChaveSD3, .F.))
					U_Log2 ('erro', '[' + procname () + ']Nao localizado no SN3. bem: ' + _aDados [_nDado, 2] + ' item: ' + _aDados [_nDado, 3] + ' tipo: ' + _aDados [_nDado, 4])
					_nQtNotF ++
				else
					if   sn3 -> N3_TXDEPR1 != _aDados [_nDado, 5] ;
					.or. sn3 -> N3_TXDEPR2 != _aDados [_nDado, 5] ;
					.or. sn3 -> N3_TXDEPR3 != _aDados [_nDado, 5] ;
					.or. sn3 -> N3_TXDEPR4 != _aDados [_nDado, 5] ;
					.or. sn3 -> N3_TXDEPR5 != _aDados [_nDado, 5]
						MV_PAR01 = sn3 -> n3_cbase  // Do Codigo ?                  
						MV_PAR02 = sn3 -> n3_cbase  // Ate o Codigo ?               
						MV_PAR05 = _aDados [_nDado, 5]  // Nova taxa de depreciacao
						MV_PAR16 = sn3 -> n3_item  // Do Código do Item do bem ?   
						MV_PAR17 = sn3 -> n3_item  // Até o Código do Item do bem ?
						MV_PAR21 = sn3 -> n3_tipo  // Do Tipo do Ativo ?           
						MV_PAR22 = sn3 -> n3_tipo  // Ate o Tipo do Ativo ?        
						AFA230Proc ()
						if sn3 -> n3_txdepr1 != _aDados [_nDado, 5]
							U_Log2 ('erro', '[' + procname () + ']Nao alterou')
							_nQtNAlter ++
						else
							_nQtAlter ++
						endif
					else
						_nQtJaOk ++
					endif
				endif
			endif
		endif
	next
	U_Log2 ('info', '[' + procname () + ']Qt.reg. nao encontrados...: ' + cvaltochar (_nQtNotF))
	U_Log2 ('info', '[' + procname () + ']Qt.reg. alterados.........: ' + cvaltochar (_nQtAlter))
	U_Log2 ('info', '[' + procname () + ']Qt.reg. nao alterados.....: ' + cvaltochar (_nQtNAlter))
	U_Log2 ('info', '[' + procname () + ']Qt.reg. ja estavam ok.....: ' + cvaltochar (_nQtJaOk))
	U_Log2 ('info', '[' + procname () + ']Qt.reg. multiplicidade....: ' + cvaltochar (_nQtMulti))
return

// --------------------------------------------------------------------------
// Importa para cta corrente as compras de mudas de associados
static function _GLPI14182 ()
	local _aDados    := {}
	local _nDado     := 0
	local _lContinua := .T.
	local _oAux      := NIL
	local _aAcum     := {}
	local _nAcum     := 0
	local _sAssoc    := ''
	local _sLoja     := ''
	local _sViveiro  := ''
	local _sNFViv    := ''
	local _aParc     := {}
	local _nParc     := 0
	local _nTotParc  := 0
	local _oCtaCorr  := NIL

	U_Log2 ('debug', '[' + procname () + ']nModulo = ' + cvaltochar (nModulo))

	sa2 -> (dbsetorder (1))
	_aDados = U_LeCSV ('c:\temp\mudas23.csv', ';')
	u_log (_aDados)
	
	// Remove a primeira linha (nomes dos campos)
	_oAux := ClsAUtil ():New (_aDados)
	_oAux:Del (1, 1)
	_aDados := aclone (_oAux:_aArray)

	// Ajustes e verificacoes na array lida
	for _nDado = 1 to len (_aDados)
		_aDados [_nDado,  4] = strzero (val (_aDados [_nDado, 4]), 6)
		do case
		case 'MIGUEL MASCHIO PIAZZA' $ alltrim (_aDados [_nDado, 12])
			_aDados [_nDado, 12] = '005780 01 '
		case 'SINIGAGLIA' $ _aDados [_nDado, 12]
			_aDados [_nDado, 12] = '001577 01 '
		case 'VITACEA' $ _aDados [_nDado, 12]
			_aDados [_nDado, 12] = '010324 01 '
		endcase
		_aDados [_nDado, 15] = val (strtran (strtran (strtran (_aDados [_nDado, 15], '"', ''), ' ', ''), ',', '.'))
		_aDados [_nDado, 16] = val (strtran (strtran (strtran (_aDados [_nDado, 16], '"', ''), ' ', ''), ',', '.'))
		if ! sa2 -> (dbseek (xfilial ("SA2") + _aDados [_nDado, 4] + _aDados [_nDado, 5], .f.))
			U_Log2 ('erro', '[' + procname () + ']Assoc.nao encontrado no SA2: ' + _aDados [_nDado, 4] + _aDados [_nDado, 5])
			_lContinua = .F.
		else
			_aDados [_nDado, 7] = sa2 -> a2_nome
			if _aDados [_nDado, 7] != _aDados [_nDado, 7]
				U_Log2 ('erro', '[' + procname () + ']Linha ' + cvaltochar (_nDado) + _aDados [_nDado, 6] + ' --> ' + _aDados [_nDado, 7])
				_lContinua = .F.
			endif
		endif
	next
	
	// Remove registros a desconsiderar:
	// - uma NF de viveirista que jah foi cobrada dos associados pelo metodo antigo
	// - notas para a propria cooperativa (nos compramos mudas tb)
	// - registros zerados (reposicao; ficou na planilha apenas para registro)
	for _nDado = len (_aDados) to 1 step -1
		U_Log2 ('debug', '[' + procname () + ']>>' + _aDados [_nDado, 4] + _aDados [_nDado, 5] + '<<')
		if alltrim (_aDados [_nDado, 17]) == '729616' .or. _aDados [_nDado, 4] + _aDados [_nDado, 5] == '00136902' .or. _aDados [_nDado, 16] == 0
			U_Log2 ('debug', '[' + procname () + ']Removendo linha ' + cvaltochar (_nDado))
			_oAux := ClsAUtil ():New (_aDados)
			_oAux:Del (_nDado, _nDado)
			_aDados := aclone (_oAux:_aArray)
		endif
	next

	// Ordena por codigo/loja/NF viveirista
	_aDados = asort (_aDados,,, {|_x, _y| _x[4] + _x[5] + _x [17] < _y[4] + _y[5] + _y [17]})
	U_Log (_aDados)

	// Gera array de valores acumulados por associado (a planilha original tem
	// as mudas separadas, mas na conta corrente o que preciso fazer eh somar
	// todas as mudas por associado e parcelar em 4 vezes).
	if _lContinua
		_aAcum = {}
		_nDado = 1
		do while _nDado <= len (_aDados)
//			U_Log2 ('debug', '[' + procname () + ']iniciando loop externo com _nDado = ' + cvaltochar (_nDado))
			_sAssoc   = _aDados [_nDado, 4]
			_sLoja    = _aDados [_nDado, 5]
			_sViveiro = _aDados [_nDado, 12]
			_sNFViv   = _aDados [_nDado, 17]
			do while _nDado <= len (_aDados) ;
			.and. _aDados [_nDado,  4] == _sAssoc ;
			.and. _aDados [_nDado,  5] == _sLoja ;
			.and. _aDados [_nDado, 17] == _sNFViv
//				U_Log2 ('debug', '[' + procname () + ']   iniciando loop interno com _nDado = ' + cvaltochar (_nDado))
				_nAcum = ascan (_aAcum, {|_aVal| _aVal [1] == _sAssoc ;
											.and. _aVal [2] == _sLoja ;
											.and. _aVal [3] == _sViveiro ;
											.and. _aVal [4] == _sNFViv})
				if _nAcum == 0
					aadd (_aAcum, {_sAssoc, _sLoja, _sViveiro, _sNFViv, 0, ''})
					_nAcum = len (_aAcum)
				endif
				
				// Acumula valor total
				_aAcum [_nAcum, 5] += _aDados [_nDado, 16]
				
				// Concatena string com qtd/descritivo
				if ! empty (_aAcum [_nAcum, 6])
					_aAcum [_nAcum, 6] += '; '
				endif
				_aAcum [_nAcum, 6] += cvaltochar (_aDados [_nDado, 13]) + ' ' + _aDados [_nDado, 14] + ' ' + alltrim (_aDados [_nDado, 10])

				_nDado ++
			enddo
		//	U_Log2 ('debug', '[' + procname () + ']Terminei o loop interno com:')
		//	u_log (_aAcum)
		enddo
	endif
	u_log (_aAcum)
//	u_acolsxls (_aAcum)
	
	// Agora tenho o total acumulado por associado, mas preciso fazer
	// o parcelamento de forma que possa ser descontado do associado
	// cfe definido pela cooperativa (4x neste caso)
	if _lContinua
		for _nAcum = 1 to len (_aAcum)
			_aParc = {}
			_nTotParc = 0
			for _nParc = 1 to 4
				aadd (_aParc, round (_aAcum [_nAcum, 5] / 4, 2))
				_nTotParc += _aParc [len (_aParc)]
			next
			
			// Faz ajuste de algum possivel arredondamento na ultima parcela.
		//	U_Log2 ('debug', '[' + procname () + ']somando aa ult parc. o vlr ' + cvaltochar (_aAcum [_nAcum, 5] - _nTotParc) + ' para ajuste')
			_aParc [len (_aParc)] += (_aAcum [_nAcum, 5] - _nTotParc)
		//	U_Log2 ('debug', '[' + procname () + ']Parcelas a gravar:')
		//	u_log (_aParc)

			for _nParc = 1 to len (_aParc)
				_oCtaCorr := ClsCtaCorr ():New ()
				_oCtaCorr:Assoc    = _aAcum [_nAcum, 1]
				_oCtaCorr:Loja     = _aAcum [_nAcum, 2]
				_oCtaCorr:Fornece  = substr (_aAcum [_nAcum, 3], 1, 6)  // cod.forn.viveirista
				_oCtaCorr:LojaFor  = substr (_aAcum [_nAcum, 3], 8, 2)  // loja.forn.viveirista
				_oCtaCorr:TM       = '24'
				_oCtaCorr:DtMovto  = stod ('20230831')  // Cfe solicitado no chamado
				_oCtaCorr:Valor    = _aParc [_nParc]
				_oCtaCorr:SaldoAtu = _aParc [_nParc]
				_oCtaCorr:VctoSE2  = stod ({'20230929','20231031','20231130','20231229'}[_nParc])
				_oCtaCorr:Usuario  = cUserName
				_oCtaCorr:Histor   = 'MUDAS 2023 ' + alltrim (cvaltochar (_nParc)) + 'de' + alltrim (cvaltochar (len (_aParc)))
				if _nParc == 1
					_oCtaCorr:Obs  = 'Compra de ' + alltrim (fBuscaCpo ("SA2", 1, xfilial ("SA2") + _oCtaCorr:Fornece + _oCtaCorr:LojaFor, 'A2_NOME')) + ' '
				else
					_oCtaCorr:Obs  = ''
				endif
				_oCtaCorr:Obs      += alltrim (_aAcum [_nAcum, 6])
				_oCtaCorr:MesRef   = strzero(month(_oCtaCorr:DtMovto),2)+strzero(year(_oCtaCorr:DtMovto),4)
				_oCtaCorr:Doc      = strzero (val (_aAcum [_nAcum, 4]), 9)  // NF viveirista
				_oCtaCorr:Serie    = 'MUD'
				_oCtaCorr:Origem   = "GLPI14182"
				_oCtaCorr:Parcela  = chr (64 + _nParc)  // Gera letras a partir do 'A'.
				_oCtaCorr:Safra    = '2023'
				if _oCtaCorr:PodeIncl ()
					if ! _oCtaCorr:Grava (.F., .F.)
						U_help ("Erro na atualizacao da conta corrente" + _oCtaCorr:UltMsg,, .t.)
					endif
				else
					U_help ("Gravacao do SZI nao permitida " + _oCtaCorr:UltMsg,, .t.)
				endif
			next
		next
	endif
return

// --------------------------------------------------------------------------
// Gera simulacoes de pagamentos safra 2023 e comparativo com Coop.Sao Joao.
static function _GLPI14200 ()
//	local _aMenorVl  := {}
//	local _oCarSaf   := NIL
//	local _aRetPrc   := {}
//	local _aRetPrcSJ := {}
//	local _aRetPrcS1 := {}
/*
	// Passo 1: gero pre-notas com os detalhes de misturas, etc e o preco efetivo ateh entao.
	cPerg = "VAGNF3"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2023') // Safra referencia
	U_GravaSX1 (cPerg, '06', 'P')    // gerar qual Parcela
	U_GravaSX1 (cPerg, '07', '')     // DCO inicial
	U_GravaSX1 (cPerg, '08', 'z')    // DCO final
	U_GravaSX1 (cPerg, '09', '')     // Prod ini
	U_GravaSX1 (cPerg, '10', 'z')    // Prod final
	U_GravaSX1 (cPerg, '11', 0)      // Preco total (especifico safra 2016)
	U_GravaSX1 (cPerg, '12', '')     // Apenas estas variedades (separadas por /)
	U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades (separadas por /)
	U_GravaSX1 (cPerg, '14', '')     // Filial inicial
	U_GravaSX1 (cPerg, '15', 'z')    // Filial final
	U_VA_GNF3 (.T.)
*/
/*
	// Passo 2: altero a tabela de precos da uva (bordo=$2,00 ; isabel=$1,50 ; tintoreas=$1,75)
	// e rodo novamente alimentando outro campo com os novos precos.
	// Jah tenho, tambem, a tabela SJ23 que eh da Coop.Sao Joao.
	dbselectarea ("ZZ9")
	set filter to zz9_safra = '2023' .and. zz9_parcel = 'P'
	count to _nRecCount
	zz9 -> (dbgotop ())
	_nRecAtu = 0
	do while ! zz9 -> (eof ())
		incproc ()
		if zz9 -> zz9_safra == '2023' .and. zz9 -> zz9_parcel == 'P'
			_sClasFina = iif (zz9 -> zz9_conduc == 'L', zz9 -> zz9_clabd, zz9 -> zz9_classe)
			if ++_nRecAtu % 100 == 0
				u_log2 ('info', '[' + cvaltochar (_nRecAtu) + ' de ' + cvaltochar (_nRecCount) + ']Produto ' + alltrim (zz9 -> zz9_produt) + ' gr.' + zz9 -> zz9_grau + ' ' + _sClasFina)
			endif

			// Se ha suspeita de mistura, instancia a carga para verificar mais a fundo.
			_aMenorVl = {}
			if ! empty (zz9 -> zz9_mistu1) .or. ! empty (zz9 -> zz9_mistu2) .or. ! empty (zz9 -> zz9_mistu3) .or. ! empty (zz9 -> zz9_ccomp)
				sze -> (dbsetorder (3))  // ZE_FILIAL, ZE_NFGER, ZE_SERIE, R_E_C_N_O_, D_E_L_E_T_
				if ! sze -> (dbseek (zz9 -> zz9_filial + zz9 -> zz9_nfori + zz9 -> zz9_serior, .F.))
					u_help ("Nao encotrei nenhuma carga referenciando a contranota '" + zz9 -> zz9_nfori + '/' + zz9 -> zz9_serior + "' da filial '" + zz9 -> zz9_filial + "'",, .t.)
					exit
				endif
				_oCarSaf := ClsCarSaf ():New (sze -> (recno ()))
				if empty (_oCarSaf:Carga)
					u_help ("Impossivel instanciar carga (ou carga invalida).",, .t.)
					exit
				endif
				_aMenorVl = aclone (_oCarSaf:VarMenorVl (2))  // pos.2=preco de compra
			endif
			if len (_aMenorVl) > 1
				u_log2 ('info', 'Pre-NF ' + zz9 -> zz9_pre_nf)
				U_Log2 ('debug', _aMenorVl)
		//		_aRetPrc   = aclone (U_PrcUva23 (zz9 -> zz9_filial, _aMenorVl [1, 1], val (zz9 -> zz9_grau), _sClasFina, zz9 -> zz9_conduc, .F., .F.))
		//		_aRetPrcSJ = aclone (U_PrcUvaSJ (zz9 -> zz9_filial, _aMenorVl [1, 1], val (zz9 -> zz9_grau), _sClasFina, zz9 -> zz9_conduc, .F., .F.))
				_aRetPrcS1 = aclone (U_PrcUvaS1 (zz9 -> zz9_filial, _aMenorVl [1, 1], val (zz9 -> zz9_grau), _sClasFina, zz9 -> zz9_conduc, .F., .F.))
			else
		//		_aRetPrc   = aclone (U_PrcUva23 (zz9 -> zz9_filial, zz9 -> zz9_produt, val (zz9 -> zz9_grau), _sClasFina, zz9 -> zz9_conduc, .F., .F.))
		//		_aRetPrcSJ = aclone (U_PrcUvaSJ (zz9 -> zz9_filial, zz9 -> zz9_produt, val (zz9 -> zz9_grau), _sClasFina, zz9 -> zz9_conduc, .F., .F.))
				_aRetPrcS1 = aclone (U_PrcUvaS1 (zz9 -> zz9_filial, zz9 -> zz9_produt, val (zz9 -> zz9_grau), _sClasFina, zz9 -> zz9_conduc, .F., .F.))
			endif
			reclock ("ZZ9", .F.)
		//	zz9 -> zz9_vunit  = _aRetPrc   [2]
		//	zz9 -> zz9_vunit4 = _aRetPrcSJ [2]
			zz9 -> zz9_vunit5 = _aRetPrcS1 [2]
			msunlock ()
		endif
		zz9 -> (dbskip ())
	enddo
*/
	// Outra simulacao: gerar precos medios por variedade e respectivos precos.
	local _oSQL   := NIL
	local _aDados := {}
	local _nDado  := 0

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += "SELECT PRODUTO, DESCRICAO, FINA_COMUM, SIST_CONDUCAO"
	_oSQL:_sQuery +=       ",sum (PESO_LIQ) as PESO_LIQ"
	_oSQL:_sQuery +=       ",ROUND (SUM (PESO_LIQ * GRAU) / SUM (PESO_LIQ), 1) AS GRAU_MEDIO"
	_oSQL:_sQuery +=       ",0,0,0,0,0,0,0,0"
	_oSQL:_sQuery +=  " FROM VA_VNOTAS_SAFRA"
	_oSQL:_sQuery += " WHERE SAFRA = '2023'"
	_oSQL:_sQuery += " GROUP BY PRODUTO, DESCRICAO, COR, FINA_COMUM, SIST_CONDUCAO"
	_oSQL:_sQuery += " ORDER BY FINA_COMUM, DESCRICAO, SIST_CONDUCAO"
	_oSQL:Log ('[' + procname () + ']')
	_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
	U_LOG (_aDados)
	for _nDado = 1 to len (_aDados)
		if _aDados [_nDado, 3] == 'L'
			_sFilSimul = '07'
		else
			_sFilSimul = '03'
		endif
		_aDados [_nDado, 7]  = U_PrcUva22 (_sFilSimul, _aDados [_nDado, 1], _aDados [_nDado, 6], 'B', _aDados [_nDado, 4], .F., .F.)[2]
		_aDados [_nDado, 8]  = U_PrcUva22 (_sFilSimul, _aDados [_nDado, 1], 15.0               , 'B', _aDados [_nDado, 4], .F., .F.)[2]
		_aDados [_nDado, 9]  = U_PrcUva23 (_sFilSimul, _aDados [_nDado, 1], _aDados [_nDado, 6], 'B', _aDados [_nDado, 4], .F., .F.)[2]
		_aDados [_nDado, 10] = U_PrcUva23 (_sFilSimul, _aDados [_nDado, 1], 15.0               , 'B', _aDados [_nDado, 4], .F., .F.)[2]
		_aDados [_nDado, 11] = U_PrcUvaSJ (_sFilSimul, _aDados [_nDado, 1], _aDados [_nDado, 6], 'B', _aDados [_nDado, 4], .F., .F.)[2]
		_aDados [_nDado, 12] = U_PrcUvaSJ (_sFilSimul, _aDados [_nDado, 1], 15.0               , 'B', _aDados [_nDado, 4], .F., .F.)[2]
		_aDados [_nDado, 13] = U_PrcUva23 (_sFilSimul, _aDados [_nDado, 1], _aDados [_nDado, 6], 'B', _aDados [_nDado, 4], .F., .F.)[5]  // 5=MOC
		_aDados [_nDado, 14] = U_PrcUva23 (_sFilSimul, _aDados [_nDado, 1], 15.0               , 'B', _aDados [_nDado, 4], .F., .F.)[5]  // 5=MOC
	next
	aHeader := {}
	aadd (aHeader, {'cod'})
	aadd (aHeader, {'descr'})
	aadd (aHeader, {'fina_comum'})
	aadd (aHeader, {'conducao'})
	aadd (aHeader, {'peso'})
	aadd (aHeader, {'GM2023'})
	aadd (aHeader, {'Prc_GM22'})
	aadd (aHeader, {'Prc_G15_22'})
	aadd (aHeader, {'Prc_GM23'})
	aadd (aHeader, {'Prc_G15_23'})
	aadd (aHeader, {'Prc_GM_SJ'})
	aadd (aHeader, {'Prc_G15_SJ'})
	aadd (aHeader, {'Prc_GM_MOC'})
	aadd (aHeader, {'Prc_G15_MOC'})
	u_acolsXLS (_aDados, .t.)
return

// --------------------------------------------------------------------------
// rEPROCESSA NOTAS DE VENDA DE TABORES PARA ASSOCIADOS
static function _GLPI14397 ()
	local _oSQL   := NIL
	local _aDados := {}
	local _nLinha := 0
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT R_E_C_N_O_ "
	_oSQL:_sQuery += " FROM " + RetSQLName ("SF2")
	_oSQL:_sQuery += " WHERE F2_FILIAL = '" + xfilial ("SF2") + "'"  // Deixar esta opcao para poder ler os campos memo.
	_oSQL:_sQuery += " AND D_E_L_E_T_  = ''"
	_oSQL:_sQuery += " AND F2_SERIE    = '30 '"
	_oSQL:_sQuery += " AND F2_DOC      BETWEEN '000035664' AND '000035667'"
	_oSQL:Log ()
	_aDados = aclone (_oSQL:Qry2Array ())
	For _nLinha := 1 To Len(_aDados)
		sf2 -> (dbgoto (_aDados [_nLinha, 1]))
		U_Log2 ('debug', '[' + procname () + ']' + sf2 -> f2_doc + ' ' + cvaltochar (sf2 -> f2_valmerc))
		_AtuSZIMudas ()  // Copiei a funcao do SF2460I para ca. Depois vou remover ela daqui.
	next
return


// --------------------------------------------------------------------------
// Gera simulacoes de pagamentos safra 2023 (versao consad nov/23)
static function _GLPI14483 ()
//	local _aMenorVl  := {}
//	local _oCarSaf   := NIL
//	local _aRetPrc   := {}
//	local _aRetPrcS1 := {}
	/*
	// Passo 1: gero pre-notas com os detalhes de misturas, etc e o preco efetivo ateh entao.
	cPerg = "VAGNF3"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2023') // Safra referencia
	U_GravaSX1 (cPerg, '06', 'Q')    // gerar qual Parcela
	U_GravaSX1 (cPerg, '07', '')     // DCO inicial
	U_GravaSX1 (cPerg, '08', 'z')    // DCO final
	U_GravaSX1 (cPerg, '09', '')     // Prod ini
	U_GravaSX1 (cPerg, '10', 'z')    // Prod final
	U_GravaSX1 (cPerg, '11', 0)      // Preco total (especifico safra 2016)
	U_GravaSX1 (cPerg, '12', '')     // Apenas estas variedades (separadas por /)
	U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades (separadas por /)
	U_GravaSX1 (cPerg, '14', '')     // Filial inicial
	U_GravaSX1 (cPerg, '15', 'z')    // Filial final
	U_VA_GNF3 (.T.)
	*/
	/*
	// Passo 2: altero a tabela de precos da uva
	// e rodo novamente alimentando outro campo com os novos precos.
	dbselectarea ("ZZ9")
	set filter to zz9_safra = '2023' .and. zz9_parcel = 'Q'
	count to _nRecCount
	zz9 -> (dbgotop ())
	_nRecAtu = 0
	do while ! zz9 -> (eof ())
		incproc ()
		if zz9 -> zz9_safra == '2023' .and. zz9 -> zz9_parcel == 'Q'
			_sClasFina = iif (zz9 -> zz9_conduc == 'L', zz9 -> zz9_clabd, zz9 -> zz9_classe)
			if ++_nRecAtu % 100 == 0
				u_log2 ('info', '[' + cvaltochar (_nRecAtu) + ' de ' + cvaltochar (_nRecCount) + ']Produto ' + alltrim (zz9 -> zz9_produt) + ' gr.' + zz9 -> zz9_grau + ' ' + _sClasFina)
			endif

			// Se ha suspeita de mistura, instancia a carga para verificar mais a fundo.
			_aMenorVl = {}
			if ! empty (zz9 -> zz9_mistu1) .or. ! empty (zz9 -> zz9_mistu2) .or. ! empty (zz9 -> zz9_mistu3) .or. ! empty (zz9 -> zz9_ccomp)
				sze -> (dbsetorder (3))  // ZE_FILIAL, ZE_NFGER, ZE_SERIE, R_E_C_N_O_, D_E_L_E_T_
				if ! sze -> (dbseek (zz9 -> zz9_filial + zz9 -> zz9_nfori + zz9 -> zz9_serior, .F.))
					u_help ("Nao encontrei nenhuma carga referenciando a contranota '" + zz9 -> zz9_nfori + '/' + zz9 -> zz9_serior + "' da filial '" + zz9 -> zz9_filial + "'",, .t.)
					exit
				endif
				_oCarSaf := ClsCarSaf ():New (sze -> (recno ()))
				if empty (_oCarSaf:Carga)
					u_help ("Impossivel instanciar carga (ou carga invalida).",, .t.)
					exit
				endif
				_aMenorVl = aclone (_oCarSaf:VarMenorVl (2))  // pos.2=preco de compra
			endif
			if len (_aMenorVl) > 1
				u_log2 ('info', 'Pre-NF ' + zz9 -> zz9_pre_nf)
				U_Log2 ('debug', _aMenorVl)
				_aRetPrcS1 = aclone (U_PrcUvaS1 (zz9 -> zz9_filial, _aMenorVl [1, 1], val (zz9 -> zz9_grau), _sClasFina, zz9 -> zz9_conduc, .F., .F.))
			else
				_aRetPrcS1 = aclone (U_PrcUvaS1 (zz9 -> zz9_filial, zz9 -> zz9_produt, val (zz9 -> zz9_grau), _sClasFina, zz9 -> zz9_conduc, .F., .F.))
			endif
			reclock ("ZZ9", .F.)
			// primeira rodada com agios de organica 15/55/70%    rodada zz9 -> zz9_vunit  = _aRetPrcS1 [2]
			// primeira rodada com agios de organica 15/55/70%    rodada zz9 -> zz9_vunit3 = _aRetPrcS1 [5]
			zz9 -> zz9_vunit4 = _aRetPrcS1 [2]  // rodada com ajustes CONSAD 29/11/23
			msunlock ()
		endif
		zz9 -> (dbskip ())
	enddo
	*/
	// Passo 3: com a tabela ZZ9 ajustada e conferida, gero as contranotas.
	Private cPerg   := "VAGNF2"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2023') // Safra referencia
	U_GravaSX1 (cPerg, '06', 'Q')    // Parcelas sep.barras (bco=todas)
	U_GravaSX1 (cPerg, '07', '')     // Grupo pagto (vazio=todos)
	U_GravaSX1 (cPerg, '08', 3)      // Geracao por DCO: {"Com DCO", "Sem DCO", "Todos"}
	U_GravaSX1 (cPerg, '09', 3)      // fina/comum: {"Comum", "Fina", "Todas"}
	U_GravaSX1 (cPerg, '10', 2)      // tipo NF: {"Normais", "Compl.preco"}
	U_GravaSX1 (cPerg, '11', '801')  // Cond pagto
	U_GravaSX1 (cPerg, '12', '')     // Apenas estas variedades
	U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades
	U_GravaSX1 (cPerg, '14', 1)      // 1=Assoc+ex assoc;2=Terceiros;3=Todos
	u_va_gnf2 (.t.)

return

// --------------------------------------------------------------------------
// Testes importacao XML
static function _GLPI14809 ()
	local _sXMLOri   := ''
	local _oXMLSEF   := NIL
	local _nItXML    := 0
	
//	local _nItRastro := 0
	local _aLotes := {}
	local _nLote  := 0

	_sXMLOri = ''
	if FT_FUSE (alltrim ('c:\temp\1_lote_alt.xml')) < 0
		u_help ("Impossivel abrir arquivo XML.",, .t.)
	else
		FT_FGOTOP()
		While !FT_FEOF()
			_sXMLOri += FT_FREADLN ()
			FT_FSKIP()
		EndDo
		FT_FUSE()  // Fecha o arquivo
		U_Log2 ('debug', '[' + procname () + ']_sXMLOri = ' + _sXMLOri)
		_oXMLSEF := ClsXMLSEF ():New ()
		_oXMLSEF:LeXML (_sXMLOri)

		// Loop em todos os itens (produtos) do XML
		for _nItXML = 1 to len (_oXMLSEF:NFe:ItRastro)
			U_Log2 ('debug', '[' + procname () + ']Verificando se o item ' + cvaltochar (_nItXML) + ' da nota tem lotes.')
			U_Log2 ('debug', '[' + procname () + ']Para este item, constam ' + cvaltochar (len (_oXMLSEF:NFe:ItRastro [_nItXML])) + ' lotes no XML')

			// Posso ter mais de um lote no mesmo item (produto) da nota
			_aLotes = _oXMLSEF:NFe:ItRastro [_nItXML]
			U_Log2 ('debug', '[' + procname () + ']_aLotes do item:')
			U_Log2 ('debug', _aLotes)
			for _nLote = 1 to len (_aLotes)
				U_Log2 ('debug', '[' + procname () + '] _nLote ' + cvaltochar (_nLote) + ' Lote :' + cvaltochar (_aLotes [_nLote][1]))
				U_Log2 ('debug', '[' + procname () + '] _nLote ' + cvaltochar (_nLote) + ' Quant:' + cvaltochar (_aLotes [_nLote][2]))
				U_Log2 ('debug', '[' + procname () + '] _nLote ' + cvaltochar (_nLote) + ' DtFab:' + cvaltochar (_aLotes [_nLote][3]))
				U_Log2 ('debug', '[' + procname () + '] _nLote ' + cvaltochar (_nLote) + ' DtVal:' + cvaltochar (_aLotes [_nLote][4]))
			next
		next

	endif
return

// --------------------------------------------------------------------------
// Gera contranota especifica (jah cadastrei ZZ9 manualmente)
static function _GLPI15020 ()
	Private cPerg   := "VAGNF2"
	U_GravaSX1 (cPerg, '01', '006501')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '02')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', '006501')    // Produtor final
	U_GravaSX1 (cPerg, '04', '02')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2023') // Safra referencia
	U_GravaSX1 (cPerg, '06', 'R')    // Parcelas sep.barras (bco=todas)
	U_GravaSX1 (cPerg, '07', '')     // Grupo pagto (vazio=todos)
	U_GravaSX1 (cPerg, '08', 3)      // Geracao por DCO: {"Com DCO", "Sem DCO", "Todos"}
	U_GravaSX1 (cPerg, '09', 3)      // fina/comum: {"Comum", "Fina", "Todas"}
	U_GravaSX1 (cPerg, '10', 2)      // tipo NF: {"Normais", "Compl.preco"}
	U_GravaSX1 (cPerg, '11', '801')  // Cond pagto
	U_GravaSX1 (cPerg, '12', '')     // Apenas estas variedades
	U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades
	U_GravaSX1 (cPerg, '14', 1)      // 1=Assoc+ex assoc;2=Terceiros;3=Todos
	u_va_gnf2 (.t.)
return

// --------------------------------------------------------------------------
// Gera complemento safra 2023 Isabel Precoce (aumentamos uva Isabel e esquecemos da Isabel Precoce)
static function _GLPI15070 ()
/*
	// Gera pre-notas
	U_MudaLog ('GLPI15070.log')
	U_GravaSX1 ('VAGNF3', '01', '')     // Produtor inicial
	U_GravaSX1 ('VAGNF3', '02', '')     // Loja produtor inicial
	U_GravaSX1 ('VAGNF3', '03', 'z')    // Produtor final
	U_GravaSX1 ('VAGNF3', '04', 'z')    // Loja produtor final
	U_GravaSX1 ('VAGNF3', '05', '2023') // Safra referencia
	U_GravaSX1 ('VAGNF3', '06', 'S')    // gerar qual Parcela
	U_GravaSX1 ('VAGNF3', '07', '')     // DCO inicial
	U_GravaSX1 ('VAGNF3', '08', 'z')    // DCO final
	U_GravaSX1 ('VAGNF3', '09', '')     // Prod ini
	U_GravaSX1 ('VAGNF3', '10', 'z')    // Prod final
	U_GravaSX1 ('VAGNF3', '11', 0)      // Preco total (especifico safra 2016)
	U_GravaSX1 ('VAGNF3', '12', '9940/9807/9808')     // Apenas estas variedades (separadas por /)
	U_GravaSX1 ('VAGNF3', '13', '')     // Exceto estas variedades (separadas por /)
	U_GravaSX1 ('VAGNF3', '14', '')     // Filial inicial
	U_GravaSX1 ('VAGNF3', '15', 'z')    // Filial final
	U_VA_GNF3 (.T.)
*/
	// Gera notas
	U_GravaSX1 ('VAGNF2', '01', '')     // Produtor inicial
	U_GravaSX1 ('VAGNF2', '02', '')     // Loja produtor inicial
	U_GravaSX1 ('VAGNF2', '03', 'z')    // Produtor final
	U_GravaSX1 ('VAGNF2', '04', 'z')    // Loja produtor final
	U_GravaSX1 ('VAGNF2', '05', '2023') // Safra referencia
	U_GravaSX1 ('VAGNF2', '06', 'S')    // Parcelas sep.barras (bco=todas)
	U_GravaSX1 ('VAGNF2', '07', ' ')    // Grupo pagto (bco=todos)
	U_GravaSX1 ('VAGNF2', '08', 3)      // Geracao por DCO: {"Com DCO", "Sem DCO", "Todos"}
	U_GravaSX1 ('VAGNF2', '09', 3)      // fina/comum: {"Comum", "Fina", "Todas"}
	U_GravaSX1 ('VAGNF2', '10', 2)      // tipo NF: {"Normais", "Compl.preco"}
	U_GravaSX1 ('VAGNF2', '11', '801')  // Cond pagto
	U_GravaSX1 ('VAGNF2', '12', '')     // Apenas estas variedades
	U_GravaSX1 ('VAGNF2', '13', '')     // Exceto estas variedades
	U_GravaSX1 ('VAGNF2', '14', 1)      // 1=Assoc+ex assoc;2=Terceiros;3=Todos
	u_va_gnf2 (.t.)
return

// --------------------------------------------------------------------------
// Atualiza custo standard cfe planilha (inclusive itens filhos (unitarios)
static function _GLPI15191 ()
	local _aDados    := {}
	local _nDado     := 0
	local _nCustD    := 0
	local _aCSV      := {}
	local _nCSV      := 0
	local _aFilhos   := {}
	local _nFilho    := 0
	local _oSQL      := NIL
	local _nDecCustD := tamsx3 ("B1_CUSTD")[2]

	_aCSV = U_LeCSV ('c:\temp\GLPI_15191.csv', ';')
	for _nCSV = 1 to len (_aCSV)
		_aCSV [_nCSV, 3] = round (val (strtran (strtran (_aCSV [_nCSV, 3], '"', ''), ',', '.')), _nDecCustD)
	next
	U_Log2 ('debug', _aCSV)

	// Usuario deseja atualizar tambem o cadastro das unidades. Para isso
	// vou procurar os filhos de cada item do arquivo CSV (que tem somente
	// as caixas) e acrescentar esses filhos na array de dados que vai ser
	// usada para alterar os cadastros.
	sb1 -> (dbsetorder (1))
	for _nCSV = 1 to len (_aCSV)

		if ! sb1 -> (dbseek (xfilial ("SB1") + U_TamFixo (_aCSV [_nCSV, 1], 15, ' '), .F.))
			U_Log2 ('erro', '[' + procname () + ']Nao encontrado no SB1: ' + _aCSV [_nCSV, 1])
		else

			// Adiciona o pai (que estava no CSV original)
			aadd (_aDados, {_aCSV [_nCSV, 1], _aCSV [_nCSV, 2], _aCSV [_nCSV, 3]})

			// Adiciona os (se existirem) filhos dele.
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += "SELECT B1_COD, B1_DESC"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB1") + " SB1"
			_oSQL:_sQuery += " WHERE SB1.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
			_oSQL:_sQuery +=   " AND SB1.B1_CODPAI  = '" + _aCSV [_nCSV, 1] + "'"
			_aFilhos := _oSQL:Qry2Array (.f., .f.)
			for _nFilho = 1 to len (_aFilhos)
				aadd (_aDados, {_aFilhos [_nFilho, 1], _aFilhos [_nFilho, 2], _aCSV [_nCSV, 3] / sb1 -> b1_qtdemb})
			next
		endif
	next
	U_Log2 ('debug', _aDados)

	sb1 -> (dbsetorder (1))
	sb5 -> (dbsetorder (1))
	for _nDado = 1 to len (_aDados)
		if len (_aDados [_nDado]) < 3
			U_Log2 ('erro', '[' + procname () + ']Sem custo para ' + _aDados [_nDado, 1] + ' ' + _aDados [_nDado, 2])
		else
			if ! sb1 -> (dbseek (xfilial ("SB1") + U_TamFixo (_aDados [_nDado, 1], 15, ' '), .F.))
				U_Log2 ('erro', '[' + procname () + ']Nao encontrado no SB1: ' + _aDados [_nDado, 1])
			else
				if ! sb5 -> (dbseek (xfilial ("SB5") + sb1 -> b1_cod, .F.))
					u_log2 ('ERRO', 'Nao encontrei SB5 para o produto ' + sb1 -> b1_cod)
				else
				//	u_log2 ('info', 'Verificando item ' + sb1 -> b1_cod + SB1 -> B1_DESC)

					_nCustD = _aDados [_nDado, 3]
					if _nCustD == 0
						U_Log2 ('aviso', '[' + procname () + ']'+ sb1 -> b1_cod + SB1 -> B1_DESC + ' custo zerado na planilha. Nao vou alterar.')
					else
						if sb1 -> b1_custd != _nCustD .or. sb1 -> B1_DATREF != date ()

							u_log2 ('info', 'Alterando custo ' + sb1 -> b1_cod + SB1 -> B1_DESC + ' de ' + transform (sb1 -> b1_custd, '@E 999,999.9999') + ' para ' + transform (_nCustD, '@E 999,999.9999'))

							// Cria variaveis para uso na gravacao do evento de alteracao
							regtomemory ("SB1", .F., .F.)
							//regtomemory ("SB5", .F., .F.)
							//m->b5_vasisde = 'S'
							m->b1_custd  = _nCustD
							m->B1_DATREF = date ()

							// Grava evento de alteracao
							_oEvento := ClsEvent():new ()
							_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), 'GLPI 15191 - ajustar B1_CUSTD', .F.)
							reclock ("SB1", .f.)
							sb1 -> B1_custd  = m->b1_custd
							SB1 -> B1_DATREF = m->B1_DATREF
							msunlock ()
							U_AtuMerc ("SB1", sb1 -> (recno ()))

							// Cai fora no primeiro, para testes.
						//	exit

						else
							U_Log2 ('debug', '[' + procname () + ']Dados jah estavam corretos')
						endif
					endif
				endif
			endif
		endif
	next
return

// --------------------------------------------------------------------------
// Gera contranotas complemento 2024 (em abr/24)
static function _GLPI15287 ()

	// Parte 1 - gerar as pre-notas na tabela ZZ9 para conferencia
	/*cPerg = "VAGNF3"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2024') // Safra referencia
	U_GravaSX1 (cPerg, '06', 'A')    // gerar qual sequencia  // SELECT MAX (ZZ9_PARCEL) FROM ZZ9010 WHERE D_E_L_E_T_ = '' AND ZZ9_SAFRA = '2024'
	U_GravaSX1 (cPerg, '07', '')     // DCO inicial
	U_GravaSX1 (cPerg, '08', 'z')    // DCO final
	U_GravaSX1 (cPerg, '09', '')     // Prod ini
	U_GravaSX1 (cPerg, '10', 'z')    // Prod final
	U_GravaSX1 (cPerg, '11', 0)      // Preco total (especifico safra 2016)
	U_GravaSX1 (cPerg, '12', '')     // Apenas estas variedades (separadas por /)
	U_GravaSX1 (cPerg, '13', '')     // Exceto estas variedades (separadas por /)
	U_GravaSX1 (cPerg, '14', '')     // Filial inicial
	U_GravaSX1 (cPerg, '15', 'z')    // Filial final
	U_GravaSX1 (cPerg, '16', '24C')  // Tabela a qual será usada para buscar o preço unitário
	U_VA_GNF3 (.T.)
	*/

	// Parte 2 - gerar as contranotas, com base nas pre-notas.
	//Private cPerg   := "VAGNF2"
	Private cPerg   := "VAGNF6"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2024') // Safra referencia
	U_GravaSX1 (cPerg, '06', 'A')    // Gerar sequencia 
	U_GravaSX1 (cPerg, '07', 'A')     // Grupo pagto -- definido no ClsAssoc, chumbado no programa grupo A
	U_GravaSX1 (cPerg, '08', 3)      // fina/comum: {"Comum", "Fina", "Todas"}
	U_GravaSX1 (cPerg, '09', '801')  // Cond pagto
	U_GravaSX1 (cPerg, '10', '') 	 // Apenas estas variedades
	U_GravaSX1 (cPerg, '11', '')     // Exceto estas variedades
	//U_GravaSX1 (cPerg, '14', 1)      // 1=Assoc+ex assoc;2=Terceiros;3=Todos
	//u_va_gnf2 (.t.)
	u_va_gnf6 (.t.)

return

// --------------------------------------------------------------------------
// Simulacoes com cargas de safra
static function _CargSaf ()
	local _nContador := 0
	local _oCarSaf := NIL
	local _nItCarga := 0
	local _nTmp1 := _nTmp2 := 0

	sze -> (dbsetorder (1))
	dbselectarea ("SZE")
	// Safra 2024(F01) Cargas compartilhadas com variedades de precos diferentes: '1332/1334' e '1709/1710/1711'
	set filter to ze_filial = cFilAnt .and. ze_safra = '2024' .AND. ze_carga >= '1800' //'1822' //0834/1141/1208'
	sze -> (dbgotop ())
	do while ! sze -> (eof ()) .and. _nContador++ <= 100
		if ! sze -> ze_status $ 'C/D'
			U_Log2 ('debug', '[' + procname () + ']' + sze -> ze_filial + ' ' + sze -> ze_safra + ' ' + sze -> ze_carga)
			_oCarSaf := ClsCarSaf ():New (sze -> (recno ()))
			if empty (_oCarSaf:Carga)
				u_help ("Impossivel instanciar carga (ou carga invalida).", _oCarSaf:UltMsg, .t.)
			else
				_nSegIni = seconds ()
				if ! _oCarSaf:Precifica_ant ('Base')
					U_Log2 ('erro', '[' + procname () + ']erro metodo original: ' + _oCarSaf:UltMsg)
				else
					_aPrcBas1 := aclone (_oCarSaf:ItPrcBase)
					if ! _oCarSaf:Precifica_ant ('ParaNF')
						U_Log2 ('erro', '[' + procname () + ']erro metodo original: ' + _oCarSaf:UltMsg)
					else
						_nTmp1 += seconds () - _nSegIni
						_aPrcNF1 := aclone (_oCarSaf:ItPrcParaNF)
						_nSegIni = seconds ()
						if ! _oCarSaf:Precifica ('Base')
							U_Log2 ('erro', '[' + procname () + ']erro metodo novo: ' + _oCarSaf:UltMsg)
						else
							_aPrcBas2 := aclone (_oCarSaf:ItPrcBase)
							if ! _oCarSaf:Precifica ('ParaNF')
								U_Log2 ('erro', '[' + procname () + ']erro metodo novo: ' + _oCarSaf:UltMsg)
							else
								_nTmp2 += seconds () - _nSegIni
								_aPrcNF2 := aclone (_oCarSaf:ItPrcParaNF)
			//					U_Log2 ('debug', _aPrcBas1)
			//					U_Log2 ('debug', _aPrcNF1)
			//					U_Log2 ('debug', _aPrcBas2)
			//					U_Log2 ('debug', _aPrcNF2)
								for _nItCarga = 1 to len (_oCarSaf:ItItem)
									if _aPrcBas2 [_nItCarga] != _aPrcBas1 [_nItCarga]
										U_Log2 ('erro', '[' + procname () + ']Diferenca no preco base')
									endif
									if _aPrcNF2 [_nItCarga] != _aPrcNF1 [_nItCarga]
										U_Log2 ('erro', '[' + procname () + ']Diferenca no preco nota')
										_oCarSaf:Log ()
									endif
								next
							endif
						endif
					endif
				endif
			endif
		endif
		sze -> (dbskip ())
	enddo
	U_Log2 ('debug', '[' + procname () + ']Tmp1 = ' + cvaltochar (_nTmp1))
	U_Log2 ('debug', '[' + procname () + ']Tmp2 = ' + cvaltochar (_nTmp2))
return

// --------------------------------------------------------------------------
static function _SF1 ()
	sa2 -> (dbsetorder (1))
	sa2 -> (dbseek (xfilial ("SA2") + '00016101', .t.))
	sb1 -> (dbsetorder (1))
	sb1 -> (dbseek (xfilial ("SB1") + '9925', .t.))
	_aLinha = {}
	AADD(_aLinha , {"D1_COD"     , sb1 -> b1_cod    , Nil } )
	AADD(_aLinha , {"D1_UM"      , sb1 -> B1_UM         , Nil } )
//	AADD(_aLinha , {"D1_TP"      , sb1 -> B1_TIPO       , Nil } )
	AADD(_aLinha , {"D1_LOCAL"   , sb1 -> B1_LOCPAD,      Nil } )
	AADD(_aLinha , {"D1_GRAU"    , '13.0'       , Nil } )
	//AADD(_aLinha , {"D1_PRM02"   , szf -> zf_prm02      , Nil } )
	//AADD(_aLinha , {"D1_PRM03"   , szf -> zf_prm03      , Nil } )
	//AADD(_aLinha , {"D1_PRM04"   , szf -> zf_prm04      , Nil } )
	//AADD(_aLinha , {"D1_PRM05"   , szf -> zf_prm05      , Nil } )
	//AADD(_aLinha , {"D1_PRM99"   , szf -> zf_prm99      , Nil } )
	AADD(_aLinha , {"D1_VACLABD" , 'B'   , Nil } )
	AADD(_aLinha , {"D1_QUANT"   , 1000       , Nil } )
	AADD(_aLinha , {"D1_VUNIT"   , 0.5              , Nil } )
	AADD(_aLinha , {"D1_TOTAL"   , 500              , Nil } )
	AADD(_aLinha , {"D1_TES"     , '310'                , Nil } )
	AADD(_aLinha , {"D1_DESCRI"  , 'teste robert'          , Nil } )
	AADD(_aLinha , {"D1_VAVOLES" , 'granel'    , Nil } )
	AADD(_aLinha , {"D1_VAVOLQT" , 1    , Nil } )
	AADD(_aLinha , {"D1_PESBRT"  , 510, Nil } )
	AADD(_aLinha , {"D1_TARA"    , 10          , Nil } )
	AADD(_aLinha , {"D1_VAVITIC" , '12345'    , Nil } )
	AADD(_aLinha , {"D1_LOTECTL", '001', Nil } )
	AADD(_aLinha , {"D1_LOTEFOR", '001', Nil } )
	AADD(_aLinha , {"D1_VACONDU" , 'L'  , Nil } )
	AADD(_aLinha , {"D1_DESPESA" , 10 , Nil } )
	u_log2 ('info', _aLinha)
	_sErroAuto = ''  // A funcao OrdAuto tambem faz algumas validacoes
	_aAutoSD1 := {}
	AADD(_aAutoSD1, aClone (U_OrdAuto (_aLinha)))
	_sSerie = '30 '
	U_Log2 ('debug', '[' + procname () + '] antes do NxtSX5Nota')
	_sNF = NxtSX5Nota (_sSerie)
	U_Log2 ('debug', '[' + procname () + '] passou do NxtSX5Nota')
	_aAutoSF1 := {}
	AADD( _aAutoSF1, { "F1_DOC"      , _sNF,            Nil})
	AADD( _aAutoSF1, { "F1_SERIE"    , _sSerie,         Nil})
	AADD( _aAutoSF1, { "F1_TIPO"     , "N",             Nil})
	AADD( _aAutoSF1, { "F1_FORMUL"   , "S",             Nil})
	AADD( _aAutoSF1, { "F1_EMISSAO"  , dDataBase,       Nil})
	AADD( _aAutoSF1, { "F1_FORNECE"  , sa2 -> a2_cod,   Nil})
	AADD( _aAutoSF1, { "F1_LOJA"     , sa2 -> a2_loja,  Nil})
	AADD( _aAutoSF1, { "F1_EST"      , sa2 -> a2_est,   Nil})
	AADD( _aAutoSF1, { "F1_ESPECIE"  , "SPED",          Nil})
	AADD( _aAutoSF1, { "F1_VANFPRO"  , strtran (time(), ':'),  Nil})  // Campo customizado, serah tratado pelo P.E. SF1100I
	AADD( _aAutoSF1, { "F1_VASEPRO"  , '001', Nil})  // Campo customizado, serah tratado pelo P.E. SF1100I
	AADD( _aAutoSF1, { "F1_VAPLVEI"  , 'fusca',   Nil})  // Campo customizado, serah tratado pelo P.E. SF1100I
	AADD( _aAutoSF1, { "F1_VASAFRA"  , '2023',   Nil})  // Campo customizado, serah tratado pelo P.E. SF1100I
	AADD( _aAutoSF1, { "F1_VAFLAG"   , 'G',             Nil})  // Campo customizado, serah tratado pelo P.E. SF1100I. Indica 'nota ja gerada' para a rotina de manut. XML
	AADD( _aAutoSF1, { "F1_VAGPSAF"  , 'z',      Nil})  // Campo customizado, serah tratado pelo P.E. SF1100I
	AADD( _aAutoSF1, { "F1_COND"     , '020',        Nil})
	_aAutoSF1 = aClone (U_OrdAuto (_aAutoSF1))
//		PutMv ('MV_LIMPAG', max (_nVlFrete, 0.09)) // Valor original do parametro
	_sErroAuto = ''
	lMsHelpAuto := .F.  // se .t. direciona as mensagens de help
	lMsErroAuto := .F.  // necessario a criacao
	DbSelectArea ("SF1")
	begin transaction
	MsExecAuto({|x,y,z|MATA103(x,y,z)},_aAutoSF1,_aAutoSD1,3)
	If lMsErroAuto
		_lContinua = .F.
		DisarmTransaction()
		u_log2 ('erro', 'lMsErroAuto')
		if ! empty (NomeAutoLog ())
			u_log2 ('erro', memoread (NomeAutoLog ()))
			MostraErro()
		else
			u_help ("Nao foi possivel ler o arquivo de log de erros.",, .t.)
		endif
	else
		u_log2 ('info', '[' + procname () + ']gerou NF ' + sf1 -> f1_doc)
	endif
	end transaction
return

// --------------------------------------------------------------------------
// Tentativa de encher a memoria do servico
static function _EstFul ()
	dak -> (dbsetorder (1))
	IF dak -> (dbseek (xfilial ("DAK") + "018112", .f.))
		_ValEstFul ()
	ELSE
		U_HELP ('DAK nao localizado',, .t.)
	endif
return

// --------------------------------------------------------------------------
static function _FtSafra ()
	cPerg := 'FTSAFRA'
	U_GravaSX1 (cPerg, '01', '')           // fornec ini
	U_GravaSX1 (cPerg, '02', '')               // loja forn ini
	U_GravaSX1 (cPerg, '03', '000160')           // forn ate
	U_GravaSX1 (cPerg, '04', '01')               // loja fint ate
	U_GravaSX1 (cPerg, '05', stod ('20230401'))  // vcto ini
	U_GravaSX1 (cPerg, '06', stod ('20230430'))  // vcto ate
	U_GravaSX1 (cPerg, '07', '2023')             // safra
	U_GravaSX1 (cPerg, '08', '801')              // cond pagto
	U_GravaSX1 (cPerg, '09', stod ('20230101'))  // emissao ini
	U_GravaSX1 (cPerg, '10', stod ('20230430'))  // emissao ate
	U_GravaSX1 (cPerg, '11', 'NF/DP/FAT')        // tipos titulo
	U_GravaSX1 (cPerg, '12', 2)                  // Buscar fretes [S/N]
	u_FtSafra (.t.)
return

// --------------------------------------------------------------------------
// Tentativa de encher a memoria do servico
static function _memoria ()
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT TOP 1000 * FROM SD1010"
	_a1 := aclone (_oSQL:Qry2Array ())
	_a2 := {}
	do while .t.
		// pior que sobe a memoria mesmo!!!  -->  aadd (_a2, aclone (_a1))
		sleep (10500)
		u_log2 ('debug', cvaltochar (len (_a2)))
	enddo
return

// --------------------------------------------------------------------------
static function _impGPC ()
	local _aDados := {}
	local _nDado  := 0

	_aDados = U_LeCSV ('c:\temp\gpc1.csv', ';')
	u_log (_aDados)
	for _nDado = 1 to 10 //len (_aDados)
		u_log (U_NoAcento (_aDados [_nDado, 4]))
	next
return


// --------------------------------------------------------------------------
// Testes/validacoes de expressoes regulares
static function _regExp ()
	local _sPattern := ''
	local _oRegex   := tlpp.regex.Regex():new ('')

	_oRegex:setCaseSensitive (.F.)

	// Monta pattern (padrao) de pesquisa usando a sintaxe das expressoes regulares.
	_sPattern := '2[0-9]{3}'  // Ano: iniciar por 2 seguido de 3 algarismos
	_sPattern += '(0[1-9]|1[012])'  // Mes: (0 seguido de [1-9] ou 1 seguido de [012])
	_sPattern += '(0[1-9]|[12][0-9]|3[01])'  // Dia: (0 seguido de [1-9] ou [12] seguido de [0-9] ou 3 seguido de [0 ou 1])
	_sPattern += ' '                   // Um espaco entre a data e a hora
	_sPattern += '([01][0-9]|2[0-3])'  // Horas: de (00 a 19) ou (20 a 23)
	_sPattern += ':'                   // : separando horas e minutos
	_sPattern += '[0-5][0-9]'          // Minutos: de 00 a 59

	_oRegex:SetPattern (_sPattern)

	m->zz6_suspen := '20240219 12:30'
	if ! _oRegex:PartialMatch (m->zz6_suspen)
		u_help ("Data / hora deve estar no formato AAAAMMDD HH:MM",, .t.)
	endif
return

// --------------------------------------------------------------------------
static function _reginv ()
	local _aDados := {}
	local _nDado  := 0

	_aDados = U_LeCSV ('c:\temp\matr460.txt', '|')
	u_log (_aDados)
	for _nDado = 1 to len (_aDados)
	//	u_log (_nDado)
	next
return

// --------------------------------------------------------------------------
static function _va_xls ()
//	// Producao em litros
//	Private cPerg   := "VAXLS4"
//	U_GravaSX1 (cPerg, '01', '')
//	U_GravaSX1 (cPerg, '02', 'z')
//	U_GravaSX1 (cPerg, '03', '')
//	U_GravaSX1 (cPerg, '04', 'z')
//	U_GravaSX1 (cPerg, '05', '')
//	U_GravaSX1 (cPerg, '06', 'z')
//	U_GravaSX1 (cPerg, '07', date () - 10)
//	U_GravaSX1 (cPerg, '08', date ())
//	U_GravaSX1 (cPerg, '09', '')
//	U_GravaSX1 (cPerg, '10', 'z')
//	U_GravaSX1 (cPerg, '11', '')
//	U_GravaSX1 (cPerg, '12', 'z')
//	u_va_xls4 (.T.)

//	// Estoque com codigo de Sisdevin
//	Private cPerg   := "VAXLS15"
//	U_GravaSX1 (cPerg, '01', '2445')
//	U_GravaSX1 (cPerg, '02', '2445')
//	U_GravaSX1 (cPerg, '03', '')
//	U_GravaSX1 (cPerg, '04', 'z')
//	U_GravaSX1 (cPerg, '05', date ())
//	U_GravaSX1 (cPerg, '06', 1)
//	u_va_xls15 (.T.)

//	Private cPerg   := "VAXLS19"
//	U_GravaSX1 (cPerg, '01', '')  // assoc ini
//	U_GravaSX1 (cPerg, '02', '')  // loja ini
//	U_GravaSX1 (cPerg, '03', '000200')  // assoc fim
//	U_GravaSX1 (cPerg, '04', 'z')  // loja fim
//	U_GravaSX1 (cPerg, '05', 1)  // ativos/inat/todos
//	U_GravaSX1 (cPerg, '06', 2)  // listar capital social
//	U_GravaSX1 (cPerg, '07', 1)  // listar endereco
//	U_GravaSX1 (cPerg, '08', 2)  // listar DAP
//	U_GravaSX1 (cPerg, '09', 1)  // lista grupo familiar
//	U_GravaSX1 (cPerg, '10', 2)  // lista ultima safra
//	U_GravaSX1 (cPerg, '11', stod ('20190311'))
//	U_VA_XLS19 (.t.)

//	Private cPerg   := "VAXLS26"
//	U_GravaSX1 (cPerg, '01', cfilant)      // Filial inicial
//	U_GravaSX1 (cPerg, '02', cfilant)      // Filial final
//	U_GravaSX1 (cPerg, '03', date() - 10)  // Data inicial
//	U_GravaSX1 (cPerg, '04', date ())      // Data final
//	U_GravaSX1 (cPerg, '05', '')           // Produto (produzido) inicial
//	U_GravaSX1 (cPerg, '06', 'z')          // Produto (produzido) final
//	U_GravaSX1 (cPerg, '07', '')           // Componente (consumido) inicial
//	U_GravaSX1 (cPerg, '08', 'z')          // Componente (consumido) final
//	U_GravaSX1 (cPerg, '09', '')           // Numero OP inicial
//	U_GravaSX1 (cPerg, '10', 'z')          // Numero OP final
//	U_GravaSX1 (cPerg, '11', 3)            // Tipos de movimentos a exportar {"Producao", "Consumo/devol", "Todos"}
//	U_VA_XLS26 (.t.)

//	Private cPerg   := "VAXLS30"
//	U_GravaSX1 (cPerg, '01', '000161')  // assoc 
//	U_GravaSX1 (cPerg, '02', '')  // loja
//	U_GravaSX1 (cPerg, '03', '000161')  // assoc 
//	U_GravaSX1 (cPerg, '04', 'z')  // loja
//	U_GravaSX1 (cPerg, '05', '2021')  // safra
//	U_GravaSX1 (cPerg, '06', '')  // filial
//	U_GravaSX1 (cPerg, '07', 'zz')  // filial
//	U_GravaSX1 (cPerg, '08', '')  // carga
//	U_GravaSX1 (cPerg, '09', 'z')  // carga
//	U_GravaSX1 (cPerg, '10', 3)  // comum/fina/ambas
//	U_GravaSX1 (cPerg, '11', '')  // nf produtor ini
//	U_GravaSX1 (cPerg, '12', 'z')  // nf produtor fim
//	U_GravaSX1 (cPerg, '13', stod ('20210101'))  // data contranota inicial
//	U_GravaSX1 (cPerg, '14', stod ('20210223'))  // data contranota final
//	U_GravaSX1 (cPerg, '15', 1)  // notas de entrada [S/N]
//	U_GravaSX1 (cPerg, '16', 1)  // notas de prod.propria [S/N]
//	U_GravaSX1 (cPerg, '17', 1)  // notas de compra [S/N]
//	U_GravaSX1 (cPerg, '18', 1)  // notas de complemento valor [S/N]
//	u_va_xls30 (.T.)

//	// Sequencia descarga safra
//	Private cPerg   := "VAXLS34"
//	U_GravaSX1 (cPerg, '01', '2023')
//	U_GravaSX1 (cPerg, '02', '01')
//	U_GravaSX1 (cPerg, '03', '01')
//	U_GravaSX1 (cPerg, '04', stod ('20230215'))
//	U_GravaSX1 (cPerg, '05', stod ('20230216'))
//	U_GravaSX1 (cPerg, '06', 2)
//	u_va_xls34 (.T.)

//	Private cPerg   := "VAXLS35"
//	U_GravaSX1 (cPerg, '01', '')  // assoc 
//	U_GravaSX1 (cPerg, '02', '')  // loja
//	U_GravaSX1 (cPerg, '03', 'z')  // assoc 
//	U_GravaSX1 (cPerg, '04', 'z')  // loja
//	U_GravaSX1 (cPerg, '05', '2020')  // safra
//	U_GravaSX1 (cPerg, '06', '09')  // filial
//	U_GravaSX1 (cPerg, '07', '09')  // filial
//	U_GravaSX1 (cPerg, '08', '')  // carga
//	U_GravaSX1 (cPerg, '09', 'z')  // carga
//	U_GravaSX1 (cPerg, '10', 3)  // comum/fina/ambas
//	U_GravaSX1 (cPerg, '11', '')  // nf produtor ini
//	U_GravaSX1 (cPerg, '12', 'z')  // nf produtor fim
//	U_GravaSX1 (cPerg, '13', 1)  // ignorar cargas canceladas / redirecionadas
//	u_va_xls35 (.T.)

//	Private cPerg   := "VAXLS37"
//	U_GravaSX1 (cPerg, '01', stod ('20201231'))  // data inicial
//	U_GravaSX1 (cPerg, '02', 2)  // qt meses
//	U_GravaSX1 (cPerg, '03', '0150')  // prod inicial
//	U_GravaSX1 (cPerg, '04', '0150')  // prod final
//	U_GravaSX1 (cPerg, '05', 'MO/AP/')  // tipos ignorar
//	U_GravaSX1 (cPerg, '06', 1)  // [qt;custo]
//	u_va_xls37 (.T.)

//	Private cPerg   := "VAXLS38"
//	U_GravaSX1 (cPerg, '01', stod ('20210401'))  // data inicial
//	U_GravaSX1 (cPerg, '02', stod ('20210430'))  // data final
//	U_GravaSX1 (cPerg, '03', 'RS-866/2020')  // codigo CR
//	u_va_xls38 (.T.)

// Private cPerg   := "VAXLS40"
// U_GravaSX1 (cPerg, '01', 'S23A')  // safra
// U_GravaSX1 (cPerg, '02', 2)  // 'Comuns', 'Finas espaldeira', 'Finas latadas', 'Finas SC'
// U_GravaSX1 (cPerg, '03', 2)  // Entrada/Compra/MOC
// U_GravaSX1 (cPerg, '04', 2)  // Todos(decimais) / Apenas inteiros
// U_GravaSX1 (cPerg, '05', 2)  // Descricao completa/resumida
// u_va_xls40 (.T.)

//	Private cPerg   := "VAXLS41"
//	U_GravaSX1 (cPerg, '01', '')  // assoc 
//	U_GravaSX1 (cPerg, '02', '')  // loja
//	U_GravaSX1 (cPerg, '03', 'z')  // assoc 
//	U_GravaSX1 (cPerg, '04', 'z')  // loja
//	U_GravaSX1 (cPerg, '05', '2020')  // safra
//	U_GravaSX1 (cPerg, '06', '')  // grp fam
//	U_GravaSX1 (cPerg, '07', 'z')  // grp fam
//	U_GravaSX1 (cPerg, '08', '01')  // filial
//	U_GravaSX1 (cPerg, '09', '01')  // filial
//	U_GravaSX1 (cPerg, '10', '1520')  // carga
//	U_GravaSX1 (cPerg, '11', '1520')  // carga
//	U_GravaSX1 (cPerg, '12', stod (''))  // data
//	U_GravaSX1 (cPerg, '13', stod ('20201231'))  // data
//	u_va_xls41 (.T.)

//	Private cPerg   := "VAXLS42"
//	U_GravaSX1 (cPerg, '01', '2019')  // safra
//	U_GravaSX1 (cPerg, '02', stod ('20190101'))  // data ini
//	U_GravaSX1 (cPerg, '03', stod ('20191231'))  // data fim
//	u_va_xls42 (.T.)

//	cPerg := "VAXLS46"
//	U_GravaSX1 (cPerg, '01', stod ('20190901'))
//	U_GravaSX1 (cPerg, '02', date ())
//	U_GravaSX1 (cPerg, '03', '')
//	U_GravaSX1 (cPerg, '04', 'z')
//	U_VA_XLS46 (.T.)

//	Private cPerg   := "VAXLS50"
//	U_GravaSX1 (cPerg, '01', stod ('20200101'))
//	U_GravaSX1 (cPerg, '02', stod ('20201231'))
//	u_va_xls50 (.T.)

//	Private cPerg   := "VAXLS53"
//	U_GravaSX1 (cPerg, '01', '2020')
//	U_GravaSX1 (cPerg, '02', '2020')
//	u_va_xls53 (.T.)
//	Private cPerg   := "VAXLS57"
//	U_GravaSX1 (cPerg, '01', stod ('20210101'))
//	U_GravaSX1 (cPerg, '02', stod ('20210930'))
//	u_va_xls57 (.T.)

//	Private cPerg   := "VAXLS59"
//	U_GravaSX1 (cPerg, '01', '01')
//	U_GravaSX1 (cPerg, '02', '01')
//	U_GravaSX1 (cPerg, '03', stod ('20220501'))
//	U_GravaSX1 (cPerg, '04', stod ('20220531'))
//	U_GravaSX1 (cPerg, '05', '')
//	U_GravaSX1 (cPerg, '06', 'z')
//	u_va_xls59 (.T.)

//	// Produtos para planilha GTIN (cadastro nacional de produtos - GS1)
//	Private cPerg   := "VAXLS61"
//	U_GravaSX1 (cPerg, '01', '30744')
//	U_GravaSX1 (cPerg, '02', '30744')
//	u_va_xls61 (.T.)

	// // exporta dados de OS
	// Private cPerg   := "VAXLS62"
	// U_GravaSX1 (cPerg, '01', '')  // filial
	// U_GravaSX1 (cPerg, '02', 'z')
	// U_GravaSX1 (cPerg, '03', '')  // OS
	// U_GravaSX1 (cPerg, '04', 'z')
	// U_GravaSX1 (cPerg, '05', 'RDR-004-02-0002')  // Bem
	// U_GravaSX1 (cPerg, '06', 'RDR-004-02-0002')
	// U_GravaSX1 (cPerg, '07', date () - 60)  // dt prev ini
	// U_GravaSX1 (cPerg, '08', date () - 30)
	// u_va_xls62 (.T.)

	// Private cPerg   := "VAXLS63"
	// U_GravaSX1 (cPerg, '01', '')
	// U_GravaSX1 (cPerg, '02', 'z')
	// U_GravaSX1 (cPerg, '03', stod ('20221101'))
	// U_GravaSX1 (cPerg, '04', stod ('20221120'))
	// u_va_xls63 (.T.)

	Private cPerg   := "VAXLS65"
	U_GravaSX1 (cPerg, '01', '13408101')
	u_va_xls65 (.T.)
return

// --------------------------------------------------------------------------
static function _batBlUsr ()
	U_MudaLog ('U_BatBlUsr.log')
	u_batBlUsr ()
return

// --------------------------------------------------------------------------
static function _batfull ()
	U_MudaLog ('U_BatFullW.log')
//	U_BatFullW ('S') //, nil, 'ZAG  0000005551')  // E=entradas;S=Saidas, ENTRADA_ID, SAIDA_ID
	U_BatFullW ('E') //, 'ZA1012000698507', NIL)  // E=entradas;S=Saidas, ENTRADA_ID, SAIDA_ID

//	U_MudaLog ('U_BatFullM.log')
//	U_BatFullM ()
return

// --------------------------------------------------------------------------
static function _batLimp ()
	U_MudaLog ('U_BatLimp.log')
	U_BatLimp ()
return

// --------------------------------------------------------------------------
static function _batMerc ()
//	U_MudaLog ('U_BatMercP.log')
//	u_batmercp ()
//	U_MudaLog ('U_BatMercN.log')
//	u_batMercN (5)
	U_MudaLog ('U_BatEMerc.log')
	u_batEMerc ()
return

// --------------------------------------------------------------------------
static function _BatSafr ()
//	u_batsafr ('ConfCadastros')  // Conferencia cadastros basicos
//	u_batsafr ('CargasSemContranota')  // cargas sem contranota
//	u_batsafr ('ContranotasSemCarga')  // contranotas sem carga
//	u_batsafr ('ConferirFrete')  // conferencia fretes
//	u_batsafr ('ConferirParcelamento')  // conferencia geracao das parcelas financeiro
//	u_batsafr ('MailAcompanhamento')  // e-mail diario de acompanhamento de safra
//	u_batsafr ('GerarSZI')  // gera SZI a partir das parcelas
//	u_batsafr ('TransfTitNaoAssocParaMatriz')  // Transfere (das filiais para a matriz) os titulos de nao associados.
	u_batsafr ('TransfSZIParaMatriz', '2023', 0)  // Transfere SZI para a matriz
//	u_batsafr ('ConferirSZI')  // conferencia conta corrente (SZI) x titulos referentes as notas de compra
//	u_batsafr ('ConfInspecoes')  // conferencia cargas X NaWeb
return

// --------------------------------------------------------------------------
static function _BatTrSZI ()
//	U_MudaLog ("U_BatTrSZI.log")
	U_BatTrSZI('016300','01','000287','01','07','01','13','20240105',757.51)
return

// --------------------------------------------------------------------------
static function _BatXML ()
	U_MudaLog ("U_BatXML.log")
	U_BatXML("\\192.168.1.3\Siga\Protheus12\protheus_data\xml_NFe\", 1, .F.)
//	U_BatXML("\\192.168.1.2\Siga\Protheus11\protheus_data\xml_NFe\", 200, .F.)
//	U_BatXML("\\192.168.1.2\Siga\Protheus11\protheus_data\xml_NFe\CT-e\", 100, .F.)
return

// --------------------------------------------------------------------------
static function _BatZBE ()
	U_MudaLog ("U_BatZBE.log")
	U_BatZBE ()
return

// --------------------------------------------------------------------------
// Bloqueia / desbloqueia estoque FullWMS
static function _BlEstF ()
	local _aListaSolBloq := {}
	local _oListaSolBloq := JsonObject():New()
	local _oSolBloq      := NIL
	
	_oSolBloq = JsonObject():New()
	_oSolBloq ['IdOper']     = ''
	_oSolBloq ['Almox']      = '01'
	_oSolBloq ['Produto']    = '0345           '
	_oSolBloq ['Lote']       = '13042601'
	_oSolBloq ['Endereco']   = 'E-1-1-1'
	_oSolBloq ['Quantidade'] = 55
	_oSolBloq ['Operacao']   = 'L'
	_oSolBloq ['Resultado']  = .f.
	_oSolBloq ['Obs']        = ''
	_oSolBloq ['StatusFull'] = ''
	aadd (_aListaSolBloq, _oSolBloq)
	_oSolBloq = JsonObject():New()
	_oSolBloq ['IdOper']     = ''
	_oSolBloq ['Almox']      = '01'
	_oSolBloq ['Produto']    = '0345           '
	_oSolBloq ['Lote']       = '23102201'
	_oSolBloq ['Endereco']   = 'E-1-6'
	_oSolBloq ['Quantidade'] = 80
	_oSolBloq ['Operacao']   = 'B'
	_oSolBloq ['Resultado']  = .f.
	_oSolBloq ['Obs']        = ''
	_oSolBloq ['StatusFull'] = ''
	aadd (_aListaSolBloq, _oSolBloq)

	_oListaSolBloq:Set (_aListaSolBloq)

	//aadd (_aBloq, {'', '01', '0345           ', '13042601', 'E-1-1-1', 55, 'B', .t., '', ''})
	//U_BlEstF (@_aBloq)
	U_BlEstF (@_oListaSolBloq)
	//U_Log2 ('debug', '[' + procname () + ']Retorno da funcao:')
	//U_Log2 ('debug', _aBloq)
return

// --------------------------------------------------------------------------
static function _ESXEst ()
	U_GravaSX1 ("ESXEST01", '01', stod ('20240331'))  // Ultimo dia mes processamento
	U_ESXEst01 (.t.)
return

// --------------------------------------------------------------------------
static function _evtxml ()
	// Envia ciencia da operacao
	U_FBTRS101({'43220701784637000189550010000401951013095045'}, 4, '')
return

// --------------------------------------------------------------------------
static function _BatOcor ()
	U_MudaLog ('U_BatOcor.log')
	u_batocor ()
return

// --------------------------------------------------------------------------
//static function _AndaLogo ()
//	local _sQuery    := ""
//	local _sAliasQ   := ""
//	local _oEvento   := NIL
//	local _aArqTrb   := {}
//	local _aRetSQL   := {}
//	local _nRetSQL   := 0
//	local _sCRLF     := chr (13) + chr (10)
//	local _oSQL      := NIL
//	local _lContinua := .T.
//	local _aDados    := {}
//	local _nDado     := 0
//	local _aCargas   := {}
//	local _nCarga    := 0
//	local _nNovaClas := 0
//	local _aResult   := {}
//	local _i         := 0
//	local _sError    := ''
//	local _sWarning  := ''
//	local _oCtaCorr  := NIL
//	local _nParc     := 0
//	local _oAssoc    := NIL
//	local _nParc := 0
//	local _sCampo := ""
//	local _nCampo := 0


// --------------------------------------------------------------------------
// Testes gravacao ElasticSearch - https://tdn.totvs.com/display/framework/FWRest
static function _elastic ()
	// Assim jah funcionou:
	// oRestClient := NIL
	// oRestClient := FWRest():New("http://192.168.1.2:9200")
	// oRestClient:setPath ('/_search')  // retorna os indices existentes
	// _aHeadStr := {}
	// // inclui o campo Authorization no formato : na base64
	// aadd (_aHeadStr, "Authorization: Basic " + Encode64('elastic:IeIRdnpYht9gI2fxoSYM'))
	// if oRestClient:Post(_aHeadStr)
	// 	U_Log2 ('debug', '[' + procname () + ']GetResult: ' + oRestClient:GetResult())
	// else
	// 	U_Log2 ('debug', '[' + procname () + ']GetLastError: ' + oRestClient:GetLastError())
	// endif

	oRestClient := NIL
	oRestClient := FWRest():New("http://192.168.1.2:9200")
	oRestClient:setPath ('/_search')  // retorna os indices existentes
//	oRestClient:setPath ('{"name":"Elasticsearch Essentials","author":"nome_do_autor", "etiqueta":"200014132", "produto":"0328", "usr":"robert.koch"}')

	_aHeadStr := {}
	// inclui o campo Authorization no formato : na base64
	aadd (_aHeadStr, "Authorization: Basic " + Encode64('elastic:IeIRdnpYht9gI2fxoSYM'))

	//_sParPost := '{"name":"Elasticsearch Essentials","author":"nome_do_autor", "etiqueta":"200014132", "produto":"0328", "usr":"robert.koch"}'
	//oRestClient:SetPostParams(_sParPost)
	if oRestClient:Post(_aHeadStr)
		U_Log2 ('debug', '[' + procname () + ']GetResult: ' + oRestClient:GetResult())
	else
		U_Log2 ('debug', '[' + procname () + ']GetLastError: ' + oRestClient:GetLastError())
	endif

return

// --------------------------------------------------------------------------
static function _exml ()
	local _sFilOrig  := ''
	local _sFilDest  := ''
	local _sOP       := ''
	local _sImprEtq  := ''
	local _nItem     := 0
	local _lTodosOK  := .F.
	local _sRetGrid  := ''
	private _sError := _sWarning := _sXmlRcv := _sErroWS := _sWS_Empr := _sWS_Filia := _sAcao := _sMsgRetWS := ''
	private _oXML := NIL
	_sXmlRcv +=    '<WSAlianca><User>robert.koch</User><IDAplicacao>gg2gj256y5f2c5b89</IDAplicacao><Empresa>01</Empresa><Filial>01</Filial>'
	_sXmlRcv +=    '<Acao>TransfEstqInsereGrid</Acao>'
	_sXmlRcv +=    '<FilialOrigem>01</FilialOrigem>'
	_sXmlRcv +=    '<FilialDestino>01</FilialDestino>'
	_sXmlRcv +=    '<OP></OP>'
	_sXmlRcv +=    '<Impressora>98</Impressora>'
	_sXmlRcv +=    '<TransfEstqItens>'
	_sXmlRcv +=       '<Item>'
	_sXmlRcv +=          '<ProdutoOrigem>0348</ProdutoOrigem>'
	_sXmlRcv +=          '<ProdutoDestino>0348</ProdutoDestino>'
	_sXmlRcv +=          '<AlmoxOrigem>25</AlmoxOrigem>'
	_sXmlRcv +=          '<AlmoxDestino>01</AlmoxDestino>'
	_sXmlRcv +=          '<LoteOrigem></LoteOrigem>'
	_sXmlRcv +=          '<LoteDestino>001</LoteDestino>'
	_sXmlRcv +=          '<EnderecoOrigem></EnderecoOrigem>'
	_sXmlRcv +=          '<EnderecoDestino></EnderecoDestino>'
	_sXmlRcv +=          '<QtdSolic>1</QtdSolic>'
	_sXmlRcv +=          '<Motivo>teste robert grid item 1</Motivo>'
	_sXmlRcv +=       '</Item>'
	_sXmlRcv +=       '<Item>'
	_sXmlRcv +=          '<ProdutoOrigem>0327</ProdutoOrigem>'
	_sXmlRcv +=          '<ProdutoDestino>0327</ProdutoDestino>'
	_sXmlRcv +=          '<AlmoxOrigem>25</AlmoxOrigem>'
	_sXmlRcv +=          '<AlmoxDestino>01</AlmoxDestino>'
	_sXmlRcv +=          '<LoteOrigem></LoteOrigem>'
	_sXmlRcv +=          '<LoteDestino>001</LoteDestino>'
	_sXmlRcv +=          '<EnderecoOrigem></EnderecoOrigem>'
	_sXmlRcv +=          '<EnderecoDestino></EnderecoDestino>'
	_sXmlRcv +=          '<QtdSolic>1</QtdSolic>'
	_sXmlRcv +=          '<Motivo>teste robert grid item 2</Motivo>'
	_sXmlRcv +=       '</Item>'
	_sXmlRcv +=       '<Item>'
	_sXmlRcv +=          '<ProdutoOrigem>0345</ProdutoOrigem>'
	_sXmlRcv +=          '<ProdutoDestino>0345</ProdutoDestino>'
	_sXmlRcv +=          '<AlmoxOrigem>25</AlmoxOrigem>'
	_sXmlRcv +=          '<AlmoxDestino>01</AlmoxDestino>'
	_sXmlRcv +=          '<LoteOrigem></LoteOrigem>'
	_sXmlRcv +=          '<LoteDestino>001</LoteDestino>'
	_sXmlRcv +=          '<EnderecoOrigem></EnderecoOrigem>'
	_sXmlRcv +=          '<EnderecoDestino></EnderecoDestino>'
	_sXmlRcv +=          '<QtdSolic>1</QtdSolic>'
	_sXmlRcv +=          '<Motivo>teste robert grid item 3</Motivo>'
	_sXmlRcv +=       '</Item>'
	_sXmlRcv +=       '<Item>'
	_sXmlRcv +=          '<ProdutoOrigem>0345</ProdutoOrigem>'
	_sXmlRcv +=          '<ProdutoDestino>0345</ProdutoDestino>'
	_sXmlRcv +=          '<AlmoxOrigem>25</AlmoxOrigem>'
	_sXmlRcv +=          '<AlmoxDestino>01</AlmoxDestino>'
	_sXmlRcv +=          '<LoteOrigem>001</LoteOrigem>'
	_sXmlRcv +=          '<LoteDestino>001</LoteDestino>'
	_sXmlRcv +=          '<EnderecoOrigem></EnderecoOrigem>'
	_sXmlRcv +=          '<EnderecoDestino></EnderecoDestino>'
	_sXmlRcv +=          '<QtdSolic>1</QtdSolic>'
	_sXmlRcv +=          '<Motivo>teste robert grid item 4</Motivo>'
	_sXmlRcv +=       '</Item>'
	_sXmlRcv +=    '</TransfEstqItens>'
	_sXmlRcv +=    '</WSAlianca>'
	U_Log2 ('debug', '[' + procname () + ']' + _sXmlRcv)
	U_ValReqWS ('WS_ALIANCA', _sXmlRcv, @_sErroWS, @_sWS_Empr, @_sWS_Filia, @_sAcao)
	
	// Algumas tags serao unicas, como se fosse um cabecalho de tela.
	if empty (_sErroWS) ; _sFilOrig = padr (_ExtraiTag ("_oXML:_WSAlianca:_FilialOrigem",    .t., .F.), 2)  ; endif
	if empty (_sErroWS) ; _sFilDest = padr (_ExtraiTag ("_oXML:_WSAlianca:_FilialDestino",   .t., .F.), 2)  ; endif
	if empty (_sErroWS) ; _sOP      = padr (_ExtraiTag ("_oXML:_WSAlianca:_OP",              .f., .F.), 14) ; endif
	if empty (_sErroWS) ; _sImprEtq =       _ExtraiTag ("_oXML:_WSAlianca:_Impressora",      .f., .F.)      ; endif
	if empty (_sErroWS) .and. type ("_oXML:_WSAlianca:_TransfEstqItens") != 'O'
		_SomaErro ("Tag '_oXML:_WSAlianca:_TransfEstqItens' deve estar presente no XML.")
	endif

	// Se eu tiver recebido mais de um item (a tag <item> pode se repetir), o
	// o tipo do objeto vai ser 'array'. Para trabalhar mais adiante com um
	// soh trecho de programa, usarei nomes de objetos _oTrEstq1, _oTrEstq2, ...
	// Tentei trabalhar com uma array e guardar objetos nela, mas comecei a ter
	// problemas de misturar dados entre os objetos. Entao achei melhor criar
	// um objeto para cada item do XML recebido. O acesso a cada objeto fica
	// chato de fazer por que preciso do '&', mas posso criar quantos objetos
	// forem necessarios.
	if type ("_oXML:_WSAlianca:_TransfEstqItens:_Item") == 'A'  // Mais de um item no XML
		if len (_oXML:_WSAlianca:_TransfEstqItens:_Item) > 99
			_SomaErro ("Limite maximo de 99 itens.")  // Na verdade, espero ficar abaixo de 10
		endif
		_nItem = 1
		do while empty (_sErroWS) .and. _nItem <= len (_oXML:_WSAlianca:_TransfEstqItens:_Item)
			U_Log2 ('debug', '[' + procname () + ']Lendo item ' + cvaltochar (_nItem) + ' do XML')
			&('_oTrEstq' + cvaltochar (_nItem)) := ClsTrEstq ():New ()
			&('_oTrEstq' + cvaltochar (_nItem)):FilOrig  = _sFilOrig
			&('_oTrEstq' + cvaltochar (_nItem)):FilDest  = _sFilDest
			&('_oTrEstq' + cvaltochar (_nItem)):OP       = _sOP
			&('_oTrEstq' + cvaltochar (_nItem)):ImprEtq  = _sImprEtq
			&('_oTrEstq' + cvaltochar (_nItem)):UsrIncl  = cUserName
			&('_oTrEstq' + cvaltochar (_nItem)):DtEmis   = date ()
			if empty (_sErroWS) ; &('_oTrEstq' + cvaltochar (_nItem)):ProdOrig = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item[" + cvaltochar (_nItem) + "]:_ProdutoOrigem",   .T., .F.), 15) ; endif
			if empty (_sErroWS) ; &('_oTrEstq' + cvaltochar (_nItem)):ProdDest = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item[" + cvaltochar (_nItem) + "]:_ProdutoDestino",  .T., .F.), 15) ; endif
			if empty (_sErroWS) ; &('_oTrEstq' + cvaltochar (_nItem)):AlmOrig  = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item[" + cvaltochar (_nItem) + "]:_AlmoxOrigem",     .T., .F.), 2) ;  endif
			if empty (_sErroWS) ; &('_oTrEstq' + cvaltochar (_nItem)):AlmDest  = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item[" + cvaltochar (_nItem) + "]:_AlmoxDestino",    .T., .F.), 2) ;  endif
			if empty (_sErroWS) ; &('_oTrEstq' + cvaltochar (_nItem)):LoteOrig = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item[" + cvaltochar (_nItem) + "]:_LoteOrigem",      .F., .F.), 10) ; endif
			if empty (_sErroWS) ; &('_oTrEstq' + cvaltochar (_nItem)):LoteDest = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item[" + cvaltochar (_nItem) + "]:_LoteDestino",     .F., .F.), 10) ; endif
			if empty (_sErroWS) ; &('_oTrEstq' + cvaltochar (_nItem)):EndOrig  = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item[" + cvaltochar (_nItem) + "]:_EnderecoOrigem",  .F., .F.), 15) ; endif
			if empty (_sErroWS) ; &('_oTrEstq' + cvaltochar (_nItem)):EndDest  = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item[" + cvaltochar (_nItem) + "]:_EnderecoDestino", .F., .F.), 15) ; endif
			if empty (_sErroWS) ; &('_oTrEstq' + cvaltochar (_nItem)):QtdSolic = val  (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item[" + cvaltochar (_nItem) + "]:_QtdSolic",        .T., .F.)) ;     endif
			if empty (_sErroWS) ; &('_oTrEstq' + cvaltochar (_nItem)):Motivo   =       _ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item[" + cvaltochar (_nItem) + "]:_Motivo",          .T., .F.) ;      endif
			_nItem ++
		enddo
	elseif type ("_oXML:_WSAlianca:_TransfEstqItens:_Item") == 'O'  // Um item apenas no XML
		_oTrEstq1 := ClsTrEstq ():New ()
		_oTrEstq1:FilOrig  = _sFilOrig
		_oTrEstq1:FilDest  = _sFilDest
		_oTrEstq1:OP       = _sOP
		_oTrEstq1:ImprEtq  = _sImprEtq
		_oTrEstq1:UsrIncl  = cUserName
		_oTrEstq1:DtEmis   = date ()
		if empty (_sErroWS) ; _oTrEstq1:ProdOrig = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item:_ProdutoOrigem",   .T., .F.), 15) ; endif
		if empty (_sErroWS) ; _oTrEstq1:ProdDest = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item:_ProdutoDestino",  .T., .F.), 15) ; endif
		if empty (_sErroWS) ; _oTrEstq1:AlmOrig  = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item:_AlmoxOrigem",     .T., .F.), 2) ;  endif
		if empty (_sErroWS) ; _oTrEstq1:AlmDest  = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item:_AlmoxDestino",    .T., .F.), 2) ;  endif
		if empty (_sErroWS) ; _oTrEstq1:LoteOrig = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item:_LoteOrigem",      .F., .F.), 10) ; endif
		if empty (_sErroWS) ; _oTrEstq1:LoteDest = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item:_LoteDestino",     .F., .F.), 10) ; endif
		if empty (_sErroWS) ; _oTrEstq1:EndOrig  = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item:_EnderecoOrigem",  .F., .F.), 15) ; endif
		if empty (_sErroWS) ; _oTrEstq1:EndDest  = padr (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item:_EnderecoDestino", .F., .F.), 15) ; endif
		if empty (_sErroWS) ; _oTrEstq1:QtdSolic = val  (_ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item:_QtdSolic",        .T., .F.)) ;     endif
		if empty (_sErroWS) ; _oTrEstq1:Motivo   =       _ExtraiTag ("_oXML:_WSAlianca:_TransfEstqItens:_Item:_Motivo",          .T., .F.) ;      endif
	endif

	// Antes de gravar qualquer coisa, preciso ver se todos os itens podem ser aceitos.
	_lTodosOK = .T.
	_nItem = 1
	do while empty (_sErroWS) .and. type ('_oTrEstq' + cvaltochar (_nItem)) == 'O' //valtype (&('_oTrEstq' + cvaltochar (_nItem))) == 'O'
		U_Log2 ('debug', '[' + procname () + ']vOU VER SE PODE INCLUIR O SEGUINTE OBJETO:')
		u_logObj (&('_oTrEstq' + cvaltochar (_nItem)), .t., .f.)
		if ! &('_oTrEstq' + cvaltochar (_nItem)):PodeIncl ()
			_lTodosOK = .F.
		endif
		_nItem ++
	enddo

	// Prepara variavel para dar retorno de cada item.
	_sRetGrid = '<RetornoSolicitacao>'
	_nItem = 1
	do while type ('_oTrEstq' + cvaltochar (_nItem)) == 'O' //valtype (&('_oTrEstq' + cvaltochar (_nItem))) == 'O'
		_sRetGrid += '<Item' + strzero (_nItem, 3) + '>'
		
		// Se todos estao ok (deverao ser aceitos), jah posso grava-los.
		if _lTodosOK
			if ! &('_oTrEstq' + cvaltochar (_nItem)):Grava ()
				_sRetGrid += "ERRO:" + &('_oTrEstq' + cvaltochar (_nItem)):UltMsg
				U_Log2 ('debug', '[' + procname () + ']Nao gravou: ' + &('_oTrEstq' + cvaltochar (_nItem)):UltMsg)
			else
				_sRetGrid += "OK:Gerada solicitacao " + &('_oTrEstq' + cvaltochar (_nItem)):Docto + '/' + &('_oTrEstq' + cvaltochar (_nItem)):Seq
				U_Log2 ('debug', '[' + procname () + ']Gravei solicitacao ' + cvaltochar (_nItem) + ', que ficou assim:')
				u_logObj (&('_oTrEstq' + cvaltochar (_nItem)), .t., .f.)
			endif
		else  // Vou apenas retornar se os itens seriam ou nao aceitos
			if ! empty (&('_oTrEstq' + cvaltochar (_nItem)):UltMsg)
				_sRetGrid += "ERRO:" + &('_oTrEstq' + cvaltochar (_nItem)):UltMsg
			else
				_sRetGrid += "OK"
			endif
		endif
		_sRetGrid += '</Item' + strzero (_nItem, 3) + '>'
		_nItem ++
	enddo

	_sRetGrid += '</RetornoSolicitacao>'
	_sMsgRetWS = _sRetGrid
	U_Log2 ('debug', '[' + procname () + ']' + _sMsgRetWS)
return
// --------------------------------------------------------------------------
// Extrair tag do XML original
static function _ExtraiTag (_sTag, _lObrig, _lValData)
	local _sRet    := ""
	local _lDataOK := .T.
	local _nPos    := 0

//	U_Log2 ('debug', '[' + procname () + ']Tentando ler a tag ' + _sTag)
//	U_Log2 ('debug', '[' + procname () + ']Type:' + type (_sTag))
	if type (_sTag) != "O"
		if _lObrig
			_SomaErro ("XML invalido: Tag '" + _sTag + "' nao encontrada.")
		endif
	else
		_sRet = &(_sTag + ":TEXT")
//		U_Log2 ('debug', '[' + procname () + ']Li a tag ' + _sTag + ' e obtive: ' + _sRet)
		if empty (_sRet) .and. _lObrig
			_SomaErro ("XML invalido: valor da tag '" + _sTag + "' deve ser informado.")
		endif
		if _lValData  // Preciso validar formato da data
			if ! empty (_sRet)
				if len (_sRet) != 8
					_lDataOK = .F.
				else
					for _nPos = 1 to len (_sRet)
						if ! IsDigit (substr (_sRet, _nPos, 1))
							_lDataOK = .F.
							exit
						endif
					next
				endif
				if ! _lDataOK
					_SomaErro ("Data deve ser informada no formato AAAAMMDD")
				endif
			endif
		endif
	endif
return _sRet

// --------------------------------------------------------------------------
static function _metaf ()
	// Pela complexidade, prefixo manter o log. Jah aprontei mais de uma vez e o log me ajudou...
	U_MudaLog ('U_BatMetaF.log')
	u_batmetaf ()
return

// --------------------------------------------------------------------------
static function _Etiq ()
	local _oEtiq := NIL
//	local _nConta := 0

	local _nEtiq := 0
	local _aEtiq := {}
	aadd (_aEtiq, '2000694752')
	aadd (_aEtiq, '2000694755')
	aadd (_aEtiq, '2000694756')
	aadd (_aEtiq, '2000694757')
	for _nEtiq = 1 to len (_aEtiq)
		_oEtiq := ClsEtiq ():New (_aEtiq [_nEtiq])
	//	_oEtiq:Imprime ('97')
	//	_oEtiq:EnviaFull (.f.)
	//	if ! _oEtiq:ApontaOP (date(), '1')
	//	if ! _oEtiq:Recebe3 ()
	//	if ! _oEtiq:Inutiliza ()
		_sEndGuard = _oEtiq:EndGuardaFull ()
		U_Log2 ('debug', '[' + procname () + ']guardada em ' + _sEndGuard)
		if empty (_sEndGuard)
			U_Log2 ('debug', '[' + procname () + ']' + _oEtiq:UltMsg)
		else
			U_Log2 ('debug', '[' + procname () + '] executou ok')
		endif
	next
RETURN

/*
	za1 -> (dbsetorder (2))  // ZA1_FILIAL, ZA1_OP, R_E_C_N_O_, D_E_L_E_T_
	za1 -> (dbseek (xfilial ("ZA1") + '0', .t.))
	dbselectarea ("ZA1")
	set filter to za1_data >= stod ('20220101') .and. za1_op != ''
	_conta = 0
	dbgotop ()
	do while ! za1 -> (eof ())
		//if za1 -> ZA1_DATA < stod ('20220101')
		//	u_log ('skip ' + dtoc (za1 -> za1_data))
		//	za1 -> (dbskip ())
		//	loop
		//endif
		_sOP = za1 -> za1_op
		U_Log2 ('debug', '[' + procname () + ']' + _sOP)
		_oEtiq := ClsEtiq ():New (za1 -> za1_codigo)
		if _oEtiq:QtApontada > 0 .and. _oEtiq:AlmApontOP != '11'
			U_Log2 ('debug', '[' + procname () + ']' + _oEtiq:Codigo + '  OP: ' + _oEtiq:OP + ' alm.apont: ' + _oEtiq:AlmApontOP)
			if _conta ++ > 100
				exit
			endif
		endif
		do while ! za1 -> (eof ()) .and. za1 -> za1_op == _sOP
			za1 -> (dbskip ())
		enddo
	enddo
*/	//_oEtiq:ImprCBProd = 'S'
//	_oEtiq:Imprime ('98')
//	_oEtiq:ApontaOP (date(), '1')

//	sd5 -> (dbgoto (509183))
//	_oEtiq := CLsEtiq ():New ()
//	_oEtiq:NovaPorSD5 (sd5 -> d5_produto, sd5 -> d5_LoteCtl, sd5 -> d5_local, sd5 -> d5_NumSeq)
//	U_Log2 ('debug', _oEtiq:UltMsg)

/*	_nLock := U_Semaforo ('GeraNumeroZA1', .T.)  // Usar a mesma chave em todas as chamadas!
	u_log (_nLock)
	if _nLock == 0
		u_help ("Bloqueio de semaforo")
	else
		_nConta = 30
		do while _nConta-- > 0
			U_Log2 ('debug', '[' + procname () + ']segurando semaforo... ' + cvaltochar (_nConta))
			sleep (1000)
		enddo
	endif
	if _nLock > 0
		U_Semaforo (_nLock)
	endif
*/
/*
	RegToMemory ("ZA1", .t., .t.)
	m->za1_op   = '13216701002'
	m->za1_data = date ()
	m->za1_prod = '0345           '
	M->ZA1_QUANT = 41
	M->ZA1_USRINC = CUSERNAME
	_oEtiq := ClsEtiq ():New ()
	_oEtiq:GeraAtrib ('M')  // Gerar a partir das variaveis M-> da tela.
	if _oEtiq:PodeIncl ()
		if _oEtiq:Grava ()
			_oEtiq:GeraAtrib ("ZA1")  // Atualiza demais atributos, que soh existirao depois da gravacao.
			//_oEtiq:Imprime ('98')
		endif
	endif
*/
return

// --------------------------------------------------------------------------
static function _recmail ()
	U_MudaLog ('U_RecMail.log')
	U_RecMail ()
return

// --------------------------------------------------------------------------
static function _RevCH()
	U_BatRevCh ("AC", "CTE", 2)  // 90)
	U_BatRevCh ("AC", "NFE", 2)  // 90)
	U_BatRevCh ("AL", "CTE", 2)  // 90)
	U_BatRevCh ("AL", "NFE", 2)  // 90)
	U_BatRevCh ("AM", "CTE", 2)  // 90)
	U_BatRevCh ("AM", "NFE", 2)  // 90)
	U_BatRevCh ("AP", "CTE", 2)  // 90)
	U_BatRevCh ("AP", "NFE", 2)  // 90)
	U_BatRevCh ("BA", "CTE", 2)  // 90)
	U_BatRevCh ("BA", "NFE", 2)  // 90)
	U_BatRevCh ("CE", "CTE", 2)  // 90)
	U_BatRevCh ("CE", "NFE", 2)  // 90)
	U_BatRevCh ("DF", "CTE", 2)  // 90)
	U_BatRevCh ("DF", "NFE", 2)  // 90)
	U_BatRevCh ("ES", "CTE", 2, 90, '32230893561108000304570000000132841174876808', .t.)
	U_BatRevCh ("ES", "NFE", 2)  // 90)
	U_BatRevCh ("GO", "CTE", 2)  // 90)
	U_BatRevCh ("GO", "NFE", 2)  // 90)
	U_BatRevCh ("MA", "CTE", 2)  // 90)
	U_BatRevCh ("MA", "NFE", 2)  // 90)
	U_BatRevCh ("MG", "CTE", 2)  // 90) //, '31230902442313000710570000000015161100015166', .t.)
	U_BatRevCh ("MG", "NFE", 2)  // 90) //, '31231000506346000166550010014048221036580096', .t.)
	U_BatRevCh ("MS", "CTE", 2)  // 90)
	U_BatRevCh ("MS", "NFE", 2)  // 90)
	U_BatRevCh ("MT", "CTE", 2)  // 90)
	U_BatRevCh ("MT", "NFE", 2)  // 90)
	U_BatRevCh ("PA", "CTE", 2)  // 90)
	U_BatRevCh ("PA", "NFE", 2)  // 90)
	U_BatRevCh ("PB", "CTE", 2)  // 90)
	U_BatRevCh ("PB", "NFE", 2)  // 90)
	U_BatRevCh ("PE", "CTE", 2)  // 90)
	U_BatRevCh ("PE", "NFE", 2)  // 90)
	U_BatRevCh ("PI", "CTE", 2)  // 90)
	U_BatRevCh ("PI", "NFE", 2)  // 90)
	U_BatRevCh ("PR", "CTE", 2)  // 90)
	U_BatRevCh ("PR", "NFE", 2)  // 90)
	U_BatRevCh ("RJ", "CTE", 2)  // 90)
	U_BatRevCh ("RJ", "NFE", 2)  // 90)
	U_BatRevCh ("RN", "CTE", 2)  // 90)
	U_BatRevCh ("RN", "NFE", 2)  // 90)
	U_BatRevCh ("RO", "CTE", 2)  // 90)
	U_BatRevCh ("RO", "NFE", 2)  // 90)
	U_BatRevCh ("RR", "CTE", 2)  // 90)
	U_BatRevCh ("RR", "NFE", 2)  // 90)
	U_BatRevCh ("RS", "CTE", 2)  // 90) //0, '43230802442313000125570000001696871101696875', .t.)
 	U_BatRevCh ("RS", "NFE", 2)  // 90, '43230888612486000160550100002285321423987847', .t.)
	U_BatRevCh ("SC", "CTE", 2)  // 90)
	U_BatRevCh ("SC", "NFE", 2)  // 90)
	U_BatRevCh ("SE", "CTE", 2)  // 90)
	U_BatRevCh ("SE", "NFE", 2)  // 90)
	U_BatRevCh ("SP", "CTE", 2)  // 90)  //, '35230802442313000559570000000715391100715397', .t.)
	U_BatRevCh ("SP", "NFE", 2)  // 90)
	U_BatRevCh ("TO", "CTE", 2)  // 90)
	U_BatRevCh ("TO", "NFE", 2)  // 90)
RETURN


// --------------------------------------------------------------------------
// Simulacoes safra 2023 durante reuniao.
static function _SimSafr23 ()
	local _sParcel   := 'N'
	local _nRecCount := 0
	local _nRecAtu   := 0
	local _aRetPrc   := {}

	dbselectarea ("ZZ9")
	set filter to zz9_safra = '2023' .and. zz9_parcel = _sParcel
	count to _nRecCount
	zz9 -> (dbgotop ())
	_nRecAtu = 0
	do while ! zz9 -> (eof ())
		incproc ()
		if zz9 -> zz9_safra == '2023' .and. zz9 -> zz9_parcel == _sParcel
			_sClasFina = ''
			if zz9 -> zz9_conduc == 'L'
				_sClasFina = zz9 -> zz9_clabd
			else
				_sClasFina = zz9 -> zz9_classe
			endif
			//u_log2 ('info', '[' + cvaltochar (++_nRecAtu) + ' de ' + cvaltochar (_nRecCount) + ']Produto ' + alltrim (zz9 -> zz9_produt) + ' gr.' + zz9 -> zz9_grau + ' ' + _sClasFina)
			if ++_nRecAtu % 100 == 0
				u_log2 ('info', '[' + cvaltochar (_nRecAtu) + ' de ' + cvaltochar (_nRecCount) + ']Produto ' + alltrim (zz9 -> zz9_produt) + ' gr.' + zz9 -> zz9_grau + ' ' + _sClasFina)
			endif
//			IF alltrim (zz9 -> zz9_produt) == '9911' //.and. zz9 -> zz9_grau <= '09.9'  // TESTES
//				u_log2 ('info', 'Produto ' + alltrim (zz9 -> zz9_produt) + ' gr.' + zz9 -> zz9_grau + ' ' + _sClasFina)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT VUNIT_EFETIVO"
			_oSQL:_sQuery +=  " FROM VA_VPRECO_EFETIVO_SAFRA2 P"
			_oSQL:_sQuery += " WHERE P.SAFRA      = '" + zz9 -> zz9_safra + "'"
			_oSQL:_sQuery +=   " AND P.FILIAL     = '" + zz9 -> zz9_filial + "'"
			_oSQL:_sQuery +=   " AND P.ASSOCIADO  = '" + zz9 -> zz9_fornec + "'"
			_oSQL:_sQuery +=   " AND P.LOJA_ASSOC = '" + zz9 -> zz9_loja + "'"
			_oSQL:_sQuery +=   " AND P.DOC        = '" + zz9 -> zz9_nfori + "'"
			_oSQL:_sQuery +=   " AND P.SERIE      = '" + zz9 -> zz9_serior + "'"
			_oSQL:_sQuery +=   " AND P.ITEM_NOTA  = '" + zz9 -> zz9_itemor + "'"
		//	_oSQL:Log ('[' + procname () + ']')
			_nVUnOld = _oSQL:RetQry (1, .f.)

			_aRetPrc = aclone (U_PrcUva23 (zz9 -> zz9_filial, zz9 -> zz9_produt, val (zz9 -> zz9_grau), _sClasFina, zz9 -> zz9_conduc, .F., .F.))

			reclock ("ZZ9", .F.)
			zz9 -> zz9_vunold = _nVUnOld
			zz9 -> zz9_vunit  = _aRetPrc [2]
			zz9 -> zz9_obs    = _aRetPrc [3]  // Observacoes geradas pelo prog. de calculo do preco
			zz9 -> zz9_nfcomp = iif (zz9 -> zz9_vunit <= zz9 -> zz9_vunold, 'VLR_MENOR', '')  // Para evitar que posteriormente o programa VA_GNF2 tente gerar nota para este registro.
			zz9 -> zz9_sercom = ''
			msunlock ()
//			ENDIF
		endif
		zz9 -> (dbskip ())
	enddo
return

// --------------------------------------------------------------------------
// Simulacao de pagamento safras antigas com graus inteiros, apenas para comparativos
static function _SimSafrGI ()
	local _oSQL      := NIL
	local _sAliasQ   := ""
	local _nVCompl   := 0
	local _sClasFina := ''
	local _aRetPrc   := 0
	local _sMsgNF    := ''
	local _nRecAtu   := 0
	local _nRecCount := 0
	local _lVerMist  := .F.
	local _aMenorVl  := {}
	local _nAux      := 0
	local _oCarSaf   := NIL
	local _nCpoZZ9   := 0
	local _sGrau     := ''

	// Como fiz uma copia do VA_GNF3, vou usar mesmas variaveis de parametros.
	mv_par01 = ''     // Produtor inicial
	mv_par02 = ''     // Loja produtor inicial
	mv_par03 = 'z'    // Produtor final
	mv_par04 = 'z'    // Loja produtor final
	mv_par05 = '2022' // Safra referencia
	mv_par06 = 'F'    // gerar qual Parcela
	mv_par07 = ''     // DCO inicial
	mv_par08 = 'z'    // DCO final
	mv_par09 = ''     // Prod ini
	mv_par10 = 'z'    // Prod final
	mv_par11 = 0      // Preco total (especifico safra 2016)
	mv_par12 = ''     // Apenas estas variedades (separadas por /)
	mv_par13 = ''     // Exceto estas variedades (separadas por /)
	mv_par14 = ''     // Filial inicial
	mv_par15 = 'z'    // Filial final

	// Busca valores efetivos recebidos pelo produtor, para depois verificar
	// necessidade de complementar.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT FILIAL, ASSOCIADO, LOJA_ASSOC, DOC, SERIE, ITEM_NOTA"
	_oSQL:_sQuery +=      ", PRODUTO, DESCRICAO, PESO_LIQ"
	_oSQL:_sQuery +=      ", GRAU"
//	_oSQL:_sQuery +=      ", rtrim (cast (ROUND (GRAU, 0) as varchar (4))) + '.0' AS GRAU"  // Simulando graus sem decimal
	_oSQL:_sQuery +=      ", SIST_CONDUCAO, CLAS_ABD, CLAS_FINAL, VUNIT_EFETIVO, GRUPO_PAGTO"
	_oSQL:_sQuery +=      ", COUNT (*) OVER (PARTITION BY FILIAL, ASSOCIADO, LOJA_ASSOC, DOC, SERIE) AS QTITENS"
	_oSQL:_sQuery +=  " FROM VA_VPRECO_EFETIVO_SAFRA P"
	_oSQL:_sQuery += " WHERE P.SAFRA  = '" + mv_par05 + "'"
	_oSQL:_sQuery +=   " AND P.ASSOCIADO + P.LOJA_ASSOC BETWEEN '" + mv_par01 + mv_par02 + "' AND '" + mv_par03 + mv_par04 + "'"
	_oSQL:_sQuery +=   " AND P.FILIAL  BETWEEN '" + mv_par14 + "' AND '" + mv_par15 + "'"
	_oSQL:_sQuery +=   " AND P.PRODUTO BETWEEN '" + mv_par09 + "' AND '" + mv_par10 + "'"
	if ! empty (mv_par12)
		_oSQL:_sQuery +=    " AND P.PRODUTO IN " + FormatIn (alltrim (mv_par12), "/")
	endif
	if ! empty (mv_par13)
		_oSQL:_sQuery +=    " AND P.PRODUTO NOT IN " + FormatIn (alltrim (mv_par13), "/")
	endif
	_oSQL:_sQuery += " ORDER BY FILIAL, ASSOCIADO, LOJA_ASSOC, DOC, SERIE, PRODUTO, GRAU, CLAS_FINAL, CLAS_ABD"
	_oSQL:Log ('[' + procname () + ']')
	_sAliasQ = _oSQL:Qry2Trb ()
	dbselectarea (_sAliasQ)
	count to _nRecCount
	dbselectarea ("ZZ9")
	(_sAliasQ) -> (dbgotop ())
	procregua (_nRecCount)
	_nRecAtu = 0
	do while ! (_sAliasQ) -> (eof ())
		incproc ()
		u_log2 ('info', '[' + cvaltochar (++_nRecAtu) + ' de ' + cvaltochar (_nRecCount) + ']NF orig: ' + (_sAliasQ) -> doc + ' Produto ' + alltrim ((_sAliasQ) -> produto) + '-' + alltrim ((_sAliasQ) -> descricao) + ' gr.' + (_sAliasQ) -> grau + ' ' + _sClasFina)
		_sMsgNF = ''
		
		// Simulando graus sem decimal
		_sGrau = strzero (round (val ((_sAliasQ) -> grau), 0), 2) + '.0'

		// Encontra a carga de origem, pois pode ter sido compartilhada com
		// outro produtor.
		sze -> (dbsetorder (3))  // ZE_FILIAL, ZE_NFGER, ZE_SERIE, R_E_C_N_O_, D_E_L_E_T_
		if ! sze -> (dbseek ((_sAliasQ) -> filial + (_sAliasQ) -> doc + (_sAliasQ) -> serie, .F.))
			u_help ("Nnao encotrei nenhuma carga referenciando a contranota '" + (_sAliasQ) -> doc + "' da filial '" + (_sAliasQ) -> filial + "'",, .t.)
			exit
		endif

		// Se a contranota original tem mais de um item, eh suspeita de ter
		// mistura de variedades. Se a carga for compartilhada, eh mais suspeita ainda
		_aMenorVl = {}
		_lVerMist = .f.
		_oCarSaf  = NIL
		if (_sAliasQ) -> qtItens > 1
			U_Log2 ('info', '[' + procname () + ']Vou verificar mistura por que a contranota tem mais de um item')
			_lVerMist = .t.
		endif
		if ! empty (sze -> ze_ccompar)
			U_Log2 ('info', '[' + procname () + ']Vou verificar mistura por que a carga ' + sze -> ze_carga + ' foi compartilhada com a(s) carga(s) ' + sze -> ze_ccompar)
			_lVerMist = .t.
		endif
		if _lVerMist
			// Instancia a carga para poder verificar mais a fundo.
			_oCarSaf := ClsCarSaf ():New (sze -> (recno ())) //(_sAliasQ) -> filial + mv_par05 + _aMenorVl [_nAux, 3])
			if empty (_oCarSaf:Carga)
				u_help ("Impossivel instanciar carga (ou carga invalida).",, .t.)
				exit
			endif
			//U_Log2 ('debug', '[' + procname () + ']' + _oCarSaf:ConsCompar ())
			_aMenorVl = aclone (_oCarSaf:VarMenorVl (2))  // pos.2=preco de compra
		endif
		if len (_aMenorVl) > 3
			u_help ("Este programa nao tem tratamento para cargas com mistura de mais de 3 variedades. Faltariam campos na tabela ZZ9 !!!")
			exit
		else
			if len (_aMenorVl) > 1
				_sMsgNF += "Mistura:"
			endif
			for _nAux = 1 to len (_aMenorVl)
				if ! alltrim (_aMenorVl [_nAux, 1]) $ _sMsgNF
					_sMsgNF += alltrim (_aMenorVl [_nAux, 1]) + '-' + alltrim (fBuscaCpo ("SB5", 1, xfilial ("SB5") + _aMenorVl [_nAux, 1], "B5_CEME")) + ';'
				endif
			next
		endif

		// Se teve mistura, preciso assumir a variedade de menor valor.
		// Mas geralmente a 'variedade de menor valor' eh a propria variedade
		// da contranota original, entao nem preciso ficar gravando mensagem
		// sobre misturas.
		if len (_aMenorVl) >= 1 .and. _aMenorVl [1, 1] != (_sAliasQ) -> produto
			_sMsgNF += 'Usar preco de ' + alltrim (_aMenorVl [1, 1]) + ';'
//			_aRetPrc = aclone (U_PrcUva21 ((_sAliasQ) -> filial, _aMenorVl [1, 1], val (_sGrau), _sClasFina, _aMenorVl [1, 3], .F., .F.))
			_aRetPrc = aclone (U_PrcUva22 ((_sAliasQ) -> filial, _aMenorVl [1, 1], val (_sGrau), _sClasFina, _aMenorVl [1, 3], .F., .F.))
		else
			// Assume a classificacao da uva vinifera conforme o sistema de conducao.
			_sClasFina = ''
			if (_sAliasQ) -> sist_conducao == 'L'
				_sClasFina = (_sAliasQ) -> clas_abd
			elseif (_sAliasQ) -> sist_conducao == 'E'
				_sClasFina = (_sAliasQ) -> clas_final
			else
				u_help ("Sistema de conducao '" + (_sAliasQ) -> sist_conducao + "' sem tratamento (NF compra " + (_sAliasQ) -> doc + ")",, .t.)
			endif
//			_aRetPrc = aclone (U_PrcUva21 ((_sAliasQ) -> filial, (_sAliasQ) -> produto, val (_sGrau), _sClasFina, (_sAliasQ) -> sist_conducao, .F., .F.))
			_aRetPrc = aclone (U_PrcUva22 ((_sAliasQ) -> filial, (_sAliasQ) -> produto, val (_sGrau), _sClasFina, (_sAliasQ) -> sist_conducao, .F., .F.))
		endif

		// A funcao retorna diferentes valores, mas aqui quero apenas o valor de compra e as observacoes.
		_aRetPrc = {_aRetPrc[2], _aRetPrc [3], _aRetPrc [5]}
	//	u_log2 ('info', 'Preco unit gerado           : ' + cvaltochar (_aRetPrc [1]) + '  ' + _aRetPrc [2])
	//	u_log2 ('info', 'Preco total gerado          : ' + cvaltochar ((_sAliasQ) -> peso_liq * _aRetPrc [1]))
	//	u_log2 ('info', 'Preco total efetivo ateh o momento: ' + cvaltochar ((_sAliasQ) -> peso_liq * (_sAliasQ) -> VUnit_efetivo))
		_nVCompl = ((_sAliasQ) -> peso_liq * _aRetPrc [1]) - ((_sAliasQ) -> peso_liq * (_sAliasQ) -> VUnit_efetivo)
	//	u_log2 ('info', 'Valor total complemento     : ' + cvaltochar (_nVCompl))

		// Gera proxima pre-nf livre
		_sQuery := " select max (ZZ9_PRE_NF)"
		_sQuery +=  " from " + RETSQLNAME ("ZZ9") + " ZZ9  "
		_sQuery += " where ZZ9.D_E_L_E_T_ != '*'"
		_sQuery +=   " and ZZ9.ZZ9_FILIAL = '" + (_sAliasQ) -> FILIAL + "'"
		_sQuery +=   " and ZZ9.ZZ9_SAFRA  = '" + mv_par05 + "'"
		_sPreNF = soma1 (U_RetSQL (_sQuery))

		reclock ("ZZ9", .T.)
		zz9 -> zz9_filial = (_sAliasQ) -> FILIAL
		zz9 -> zz9_safra  = mv_par05
		zz9 -> zz9_grupo  = (_sAliasQ) -> grupo_PAGTO
		zz9 -> zz9_parcel = mv_par06
		zz9 -> zz9_fornec = (_sAliasQ) -> associado
		zz9 -> zz9_loja   = (_sAliasQ) -> loja_assoc
		zz9 -> zz9_pre_nf = _sPreNF
		zz9 -> zz9_tiponf = "V"  // C=Compra;V=[complemento de]Valor
		zz9 -> zz9_produt = (_sAliasQ) -> produto
		zz9 -> zz9_grau   = _sGrau
		zz9 -> zz9_grau2  = (_sAliasQ) -> grau  // grau original
		zz9 -> zz9_classe = (_sAliasQ) -> clas_final
		zz9 -> zz9_clabd  = (_sAliasQ) -> clas_abd
		zz9 -> zz9_conduc = (_sAliasQ) -> sist_conducao
		zz9 -> zz9_vunOld = (_sAliasQ) -> VUnit_efetivo
		zz9 -> zz9_quant  = 0
		zz9 -> zz9_qtOri  = (_sAliasQ) -> peso_liq  // Campo util para relatorios posteriores
		zz9 -> zz9_vunit  = _nVCompl   // Valor total a complementar
		zz9 -> zz9_vunit2 = _aRetPrc [1]  // Preco unitario que foi usado para calcular o complemento
		zz9 -> zz9_obs    = _aRetPrc [2]  // Observacoes geradas pelo prog. de calculo do preco
		//zz9 -> zz9_vunit3 = _aRetPrc [3]  // Preco unitario da tabela CONAB
		zz9 -> zz9_nfori  = (_sAliasQ) -> doc
		zz9 -> zz9_serior = (_sAliasQ) -> serie
		zz9 -> zz9_itemor = (_sAliasQ) -> item_nota
		zz9 -> zz9_msgNF  = 'TESTE GRAU INTEIRO;' + _sMsgNF
		zz9 -> zz9_TES    = iif (_nVCompl <= 0, '', U_TESSafra (mv_par05, (_sAliasQ) -> associado, (_sAliasQ) -> loja_assoc, 'V'))
		zz9 -> zz9_dco    = ''
		if valtype (_oCarSaf) == 'O' .and. len (_oCarSaf:CCompart) > 0
			zz9 -> zz9_ccomp  = _oCarSaf:TodasComp ()
		endif

		// Grava as possibilidades de misturas de variedades.
		_nCpoZZ9 = 1
		for _nAux = 1 to len (_aMenorVl)
			// Geralmente a 'variedade de menor valor' eh a propria variedade
			// da contranota original, entao nem preciso gravar.
			if _aMenorVl [_nAux, 1] != (_sAliasQ) -> produto
				zz9 -> &('zz9_mistu' + cvaltochar (_nCpoZZ9)) = _aMenorVl [_nAux, 1]
				_nCpoZZ9 ++
			endif
		next
		
		msunlock ()
		(_sAliasQ) -> (dbskip ())
	enddo
return

// --------------------------------------------------------------------------
// Testes classe tabela preco uva safra
static function _TbUva ()
	local _sHTML  := ''
	local _nHdl    := 0
	local _sArq    := ''
	local _sCodTab := '24C'
	local _sVarUva := 'F'
	local _sConduc := 'E'
	local _oTbUva := ClsTbUva ():New ()
	_oTbUva:GeraAtrib (_sCodTab, _sVarUva, _sConduc, 'I')

	if empty (_oTbUva:CodTabela)
		U_Log2 ('erro', '[' + procname () + ']' + _oTbUva:UltMsg)
	else
		// Exporta para arquivo, durante a implementacao, para conferencia.
		_sHTML = _oTbUva:GeraHTM ()
		if empty (_sHTML)
			u_help (_oTbUva:UltMsg,, .t.)
		else
			_sArq := 'c:\temp\TabUva.htm'
			if file (_sArq)
				delete file (_sArq)
			endif
			_nHdl = fcreate (_sArq, 0)
			fwrite (_nHdl, _sHtml)
			fclose (_nHdl)
			ShellExecute ("Open", _sArq, "", "", 1)
		endif
	endif
return

// --------------------------------------------------------------------------
static function _VA_ACR ()

	U_GravaSX1 ("VA_ACR", "01", "0345")
	U_GravaSX1 ("VA_ACR", "02", "0345")  //2627
	U_GravaSX1 ("VA_ACR", "03", 'PA')  // Tipos a listar
	U_GravaSX1 ("VA_ACR", "04", 1)  // Considerar ateh qual nivel do VD: {"Todos", "Mais alto", "Mais baixo"}
	U_GravaSX1 ("VA_ACR", "05", '')  // Linha coml.de
	U_GravaSX1 ("VA_ACR", "06", 'z')  // Linha coml.ate
	U_GravaSX1 ("VA_ACR", "07", 1)  // Apenas MRP / todos
	U_GravaSX1 ("VA_ACR", "08", 1)  // Std / medio
	U_GravaSX1 ("VA_ACR", "09", '')  // Quem usa este componente
	U_VA_ACR (.t.)
return

// --------------------------------------------------------------------------
// Retorna lista de produtos que usam o componente.
static function _QuemUsa (_sCompon as character, _aLista as array)
	local _aAreaAnt := U_ML_SRArea ()
	U_Log2 ('debug', '[' + procname () + ']Verificando componente ' + _sCompon)
	sb1 -> (dbsetorder (1))
	sg1 -> (dbsetorder (2))  // G1_FILIAL, G1_COMP, G1_COD, R_E_C_N_O_, D_E_L_E_T_
	sg1 -> (dbseek (xfilial ("SG1") + _sCompon, .T.))
	do while ! sg1 -> (eof ()) .and. sg1 -> g1_filial == xfilial ("SG1") .and. sg1 -> g1_comp == _sCompon
		U_Log2 ('debug', '[' + procname () + ']loop 1 com g1_cod = ' + sg1 -> g1_cod)
		if sg1 -> g1_ini <= dDataBase .and. sg1 -> g1_fim >= dDataBase .and. sg1 -> g1_fantasm != '1'
			U_Log2 ('debug', '[' + procname () + ']loop 2 com g1_cod = ' + sg1 -> g1_cod)
			if sb1 -> (dbseek (xfilial ("SB1") + sg1 -> g1_cod, .f.))
				U_Log2 ('debug', '[' + procname () + ']loop 3 com g1_cod = ' + sg1 -> g1_cod)
				if sg1 -> g1_revini <= sb1 -> b1_revatu .and. sg1 -> g1_revfim >= sb1 -> b1_revatu
					U_Log2 ('debug', '[' + procname () + ']loop 4 com g1_cod = ' + sg1 -> g1_cod)
					_nTamAnt = len (_aLista)
					_QuemUsa (sg1 -> g1_cod, @_aLista)
					if len (_aLista) == _nTamAnt  // Nao achou mais nada
						aadd (_aLista, sg1 -> g1_cod)
					endif
				endif
			endif
		endif
		sg1 -> (dbskip ())
	enddo
	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Retorna lista de produtos que usam o componente em formato string.
static function _QuemUsa2 (_sCompon as character)
	local _sRet := ''
	local _nIdxQuemUsa := 0
	local _aQuemUsa := {}

	_QuemUsa (_sCompon, @_aQuemUsa)

	for _nIdxQuemUsa = 1 to len (_aQuemUsa)
		if ! alltrim (_aQuemUsa [_nIdxQuemUsa]) $ _sRet
			_sRet += "'" + alltrim (_aQuemUsa [_nIdxQuemUsa]) + "',"
		endif
	next

	// Remove a provavel virgula do final
	if right (_sRet, 1) == ','
		_sRet = left (_sRet, len (_sRet) - 1)
	endif
return _sRet


// --------------------------------------------------------------------------
static function _VACCR2 ()
	cPerg := 'VA_CCR2'
	U_GravaSX1 (cPerg, '01', '0345           ')  // prod pai ini
	U_GravaSX1 (cPerg, '02', '0348           ')  // prod pai fim
	U_GravaSX1 (cPerg, '03', 'PA')  // tipo pai ini
	U_GravaSX1 (cPerg, '04', 'PA')  // tipo pai fim
	U_GravaSX1 (cPerg, '05', 1)  // 1=apenas pais ativos; 2=todos
	U_GravaSX1 (cPerg, '06', '')  // LINHA COML pai ini
	U_GravaSX1 (cPerg, '07', 'Z')  // LINHA COML pai fim
	u_va_ccr2 (.t., .t.)
return

// --------------------------------------------------------------------------
static function _VA_VEF ()
	// https://centraldeatendimento.totvs.com/hc/pt-br/articles/360049503954-MP-ADVPL-Salvar-relat%C3%B3rio-Treport-PDF-em-diret%C3%B3rio
	cPerg := 'VA_VEF'
	U_GravaSX1 (cPerg, '01', STOD ('20221231'))  //stod ('20110613'))  // data ref (uma data qquer em que tenho alguns saldos)
	U_GravaSX1 (cPerg, '02', 3)   // [aberto/encerrados/todos]
	U_GravaSX1 (cPerg, '03', '07')  // filial ini
	U_GravaSX1 (cPerg, '04', '07')  // filial fim
	U_GravaSX1 (cPerg, '05', '')  // cliente ini
	U_GravaSX1 (cPerg, '06', '')  // loja cliente ini
	U_GravaSX1 (cPerg, '07', 'z')  // cliente fim
	U_GravaSX1 (cPerg, '08', 'z')  // loja cliente fim
	U_GravaSX1 (cPerg, '09', '4682')  // produto ini
	U_GravaSX1 (cPerg, '10', '4682')  // produto fim
	u_va_vef (.t.)
return


// --------------------------------------------------------------------------
// Testes verificacoes genericas.
static function _verif ()
	// _oVerif := ClsVerif():New (4)
	// _oVerif:SetParam ('01', stod ('20230401'))
	// _oVerif:SetParam ('02', stod ('20230630'))
	// _oVerif:SetParam ('03', '')
	// _oVerif:SetParam ('04', 'z')
	// _oVerif := ClsVerif():New (24)
	// _oVerif:SetParam ('01', '13633101001   ')
	// _oVerif:SetParam ('02', '13633101001   ')
	// _oVerif:SetParam ('03', '4342           ')
	// _oVerif:SetParam ('04', '4342           ')
	// _oVerif := ClsVerif():New (25)
	// _oVerif:SetParam ('01', '2017')
	// _oVerif:SetParam ('02', '')
	// _oVerif:SetParam ('03', 'zz')
	// _oVerif:SetParam ('04', '30 ')
	// _oVerif:SetParam ('05', '028')
	// _oVerif:SetParam ('06', '077')
	// _oVerif:SetParam ('07', '000017')
	// _oVerif := ClsVerif():New (26)

	_oVerif := ClsVerif():New (28)
	_oVerif:SetParam ('01', stod ('20220701'))
	_oVerif:SetParam ('02', stod ('20220830'))

	//_oVerif := ClsVerif():New (95)
	//_oVerif:SetParam ('01', date () - 30)
	//_oVerif:SetParam ('02', date ())
	//_oVerif:SetParam ('03', '')
	//_oVerif:SetParam ('04', 'z')
	// _oVerif := ClsVerif():New (98)
	// _oVerif:SetParam ('01', '0150')
	// _oVerif:SetParam ('02', '0348')
	// _oVerif:SetParam ('03', '')
	// _oVerif:SetParam ('04', 'zzzzzzzzzz')
	// _oVerif:SetParam ('05', 2)
	//_oVerif := ClsVerif():New (99)
	if _oVerif:Executa ()
		u_log2 ('debug', 'Pendencias do tipo ' + _oVerif:Descricao)
		u_log2 ('debug', _oVerif:Result)
	//// 	//u_acolsxls (_oVerif:Result)
	else
		u_log2 ('erro', 'Erro na verificacao: ' + _oVerif:UltMsg)
	endif

	// _oVerif := ClsVerif():New ()
	// _sHtmHlp = _oVerif:GeraHelp ()
	// Exporta para arquivo, durante a implementacao, para conferencia.
	// _sArq := 'c:\temp\verif.htm'
	// if file (_sArq)
	// 	delete file (_sArq)
	// endif
	// _nHdl = fcreate (_sArq, 0)
	// fwrite (_nHdl, _sHtmHlp)
	// fclose (_nHdl)
	// ShellExecute ("Open", _sArq, "", "", 1)

//	U_MudaLog ('U_BatVerif.log')
//	u_batverif ()

return

/*
	// Roda comparativo entre precos de diferentes safras x tabela MOC - GLPI 12080
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " WITH C AS ("
	_oSQL:_sQuery += " SELECT B1_VARUVA AS FINA_COMUM, SAFRA, PRODUTO, DESCRICAO, SIST_CONDUCAO AS CONDUCAO"
	_oSQL:_sQuery += " 	, SUM (PESO_LIQ) AS PESO_LIQ"
	_oSQL:_sQuery += " 	, ROUND (SUM (GRAU * PESO_LIQ) / SUM (PESO_LIQ), 2) AS GRAU_MEDIO"
	_oSQL:_sQuery += " 	, ROUND (SUM (PESO_LIQ * VUNIT_EFETIVO) / SUM (PESO_LIQ), 4) AS PRECO_MEDIO"
	_oSQL:_sQuery +=  " FROM VA_VPRECO_EFETIVO_SAFRA"
	_oSQL:_sQuery +=      "," + RetSQLName ("SB1") + " SB1 "
	_oSQL:_sQuery += " WHERE SAFRA IN ('2021','2022')"
	_oSQL:_sQuery +=   " AND SB1.D_E_L_E_T_ = ''
	_oSQL:_sQuery +=   " AND SB1.B1_FILIAL = '  '
	_oSQL:_sQuery +=   " AND SB1.B1_COD = PRODUTO
	_oSQL:_sQuery += " GROUP BY SAFRA, PRODUTO, DESCRICAO, SIST_CONDUCAO, B1_VARUVA"
	_oSQL:_sQuery += " )"
	_oSQL:_sQuery += " SELECT top 1 FINA_COMUM, CONDUCAO, PRODUTO, DESCRICAO"
	_oSQL:_sQuery += " 	, SUM (CASE WHEN SAFRA = '2021' THEN PESO_LIQ    ELSE 0 END) AS KG_2021"
	_oSQL:_sQuery += " 	, SUM (CASE WHEN SAFRA = '2022' THEN PESO_LIQ    ELSE 0 END) AS KG_2022"
	_oSQL:_sQuery += " 	, SUM (CASE WHEN SAFRA = '2021' THEN GRAU_MEDIO  ELSE 0 END) AS GR_MED_21"
	_oSQL:_sQuery += " 	, SUM (CASE WHEN SAFRA = '2022' THEN GRAU_MEDIO  ELSE 0 END) AS GR_MED_22"
	_oSQL:_sQuery += " 	, SUM (CASE WHEN SAFRA = '2021' THEN PRECO_MEDIO ELSE 0 END) AS PR_MED_21"
	_oSQL:_sQuery += " 	, SUM (CASE WHEN SAFRA = '2022' THEN PRECO_MEDIO ELSE 0 END) AS PR_MED_22"
	_oSQL:_sQuery += " 	, 0 AS PR_MOC_21"
	_oSQL:_sQuery += " 	, 0 AS PR_MOC_22"
	_oSQL:_sQuery += " FROM C"
	_oSQL:_sQuery += " GROUP BY FINA_COMUM, CONDUCAO, PRODUTO, DESCRICAO"
	_oSQL:_sQuery += " ORDER BY FINA_COMUM, CONDUCAO, DESCRICAO"
	_oSQL:Log ('[' + procname () + ']')
	_oSQL:Copy2Trb (.f., 4, '_trb', {})
	do while ! _trb -> (eof ())
		U_Log ()
		reclock ('_trb', .F.)
		_trb -> Pr_MOC_21 = U_PrcUva21 (iif (_trb -> fina_comum == 'F', '03', '01'), _trb -> produto, round (_trb -> Gr_Med_21, 0), 'B ', _trb -> conducao, .F., .T.)[5]  // pos.5 = preco MOC
		_trb -> Pr_MOC_22 = U_PrcUva22 (iif (_trb -> fina_comum == 'F', '03', '01'), _trb -> produto, round (_trb -> Gr_Med_22, 0), 'B ', _trb -> conducao, .F., .T.)[5]  // pos.5 = preco MOC
		msunlock ()
		_trb -> (dbskip ())
	enddo
	U_LogTrb ('_trb', .t.)
	U_TRB2XLS ('_trb', .T., .t., .t., 'GLPI12080')
return
*/

// --------------------------------------------------------------------------
// Testes especificos para problemas de performance
Static Function _PerfMon ()
	_oEvento := NIL
	u_perfmon ('I', 'Gravar_evento_' + cValToChar (GetServerPort ()))
	_oEvento := ClsEvent():new ()
	_oEvento:CodEven    = '000001'
	_oEvento:Texto      = 'TESTE PERFORMANCE - APAGAR DEPOIS!'
	_oEvento:CodAlias   = PROCNAME ()
	_oEvento:DiasValid  = 1
	_oEvento:Grava ()
	u_perfmon ('F', 'Gravar_evento_' + cValToChar (GetServerPort ()))
Return

// --------------------------------------------------------------------------
// Retorno do type - type em looling nao é permitido da R25 
Static Function _RetType(_var)
	_type := type(_var)
return _type

// --------------------------------------------------------------------------
// Testes arvore de rastreabilidade
static function _Rast()
	local _aLotes := {}
	local _nLote  := 0
//	private _aLtXLS58 := {}  // Deixar PRIVATE para ser alimentada pelo U_RastLT().
	_aLotes := {}
	//aadd (_aLotes, {'01','1193', '09033601'  
	//aadd (_aLotes, {'01','2203', '09071401'})  // pequeno (3 OP + 2 tr.lote)  
	//aadd (_aLotes, {'01','2203', '09071501  '})  // grande, com transf. para filial 09 + laudo  
	//aadd (_aLotes, {'01','1193', '09163601'  // gigante, com recursividade
	//aadd (_aLotes, {'01','1193', '09166101'  // muito grande
	//aadd (_aLotes, {'01','2444', 'N000012947'  // Pequeno, um nivel abaixo + transf. da filial 09
	//aadd (_aLotes, {'01','2445', '09120801  '  // Pequeno, teve venda e transf para filial 13  
	//aadd (_aLotes, {'01','1180', '000001A   '  
	//aadd (_aLotes, {'01','2445', '000001    '
	//aadd (_aLotes, {'01','0345', '09166101'  // Gigante
	//aadd (_aLotes, {'01', '2763', '09245501'})  // NECTAR MACA           
	//aadd (_aLotes, {'01', '1370', '09272501'})  // VINHO TTO BORDO
	//aadd (_aLotes, {'01', '2385', '09248401'})  // NECTAR LARANJA
	//aadd (_aLotes, {'01', '0247', '09264801'})  // Vinho pinot
	//aadd (_aLotes, {'01', '0431', '09269601'})  // gigante - suco bag tto
	//aadd (_aLotes, {'01', '0328', '09260601'})  // filtrado bco
	//aadd (_aLotes, {'01', '2448', '09249201'})  // mosto bco
	//aadd (_aLotes, {'01', '4225', '09214501'})  // monstro - suco tto tetra 200
	//aadd (_aLotes, {'01', '9901', '01166401'})  // CARGA DE UVA 2018
	//aadd (_aLotes, {'01', '9925', '01001201'})  // CARGA DE UVA 2018
	//aadd (_aLotes, {'01', '9909', '01012901'})  // CARGA DE UVA 2018
	//aadd (_aLotes, {'01', U_TamFixo ('3630', 15, ' '), '12101401'  , 0, 14660})  // item 2580 lote 12101401 transformado em 3630 (mesmo lote) em 28/01/2022 na filial 01
	//aadd (_aLotes, {'01', U_TamFixo ('1274', 15, ' '), 'AUTO009215', 0, 1})      // enzima (arvore grande)
	//aadd (_aLotes, {'01', U_TamFixo ('2444', 15, ' '), 'AUTO009238', 0, 24200})  // lado 1 do par
	//aadd (_aLotes, {'09', U_TamFixo ('2444', 15, ' '), '4123'      , 0, 24200})  // lado 2 do par
	//aadd (_aLotes, {'01', U_TamFixo ('9959', 15, ' '), '2201028401', 0, 1})      // enzima (arvore grande)
	//aadd (_aLotes, {'01', U_TamFixo ('2776', 15, ' '), '11310701'  , 0, 1})      // gera mais de 15 niveis de rastro.
	//aadd (_aLotes, {'01', U_TamFixo ('3630', 15, ' '), '12107401A ', 0, 30000})  // NF 000202304 que foi para CENECOOP
	//aadd (_aLotes, {'09', U_TamFixo ('2445', 15, ' '), 'AUTO009869', 0, 1})      // Recebeu transf. da filial 01
	//aadd (_aLotes, {'09', U_TamFixo ('1181', 15, ' '), '009159', 0, 1})      // Transferido da F09 para para F01 (origem bem grande, diversas transf. entre filiais)
	//aadd (_aLotes, {'07', U_TamFixo ('1180', 15, ' '), '001970001x', 0, 1})      // Transferido da F07 para para F01 (origem muito grande, 16 niveis, nem esperei terminar)
	//aadd (_aLotes, {'03', U_TamFixo ('3779', 15, ' '), '00229201  ', 0, 1})      // 
	  aadd (_aLotes, {'01', U_TamFixo ('2642', 15, ' '), '13039201  ', 0, 1})      // 

	for _nLote = 1 to len (_aLotes)
		u_perfmon ('I', 'RastLt')
		_sMapa := U_RastLT (_aLotes [_nLote, 1], _aLotes [_nLote, 2], _aLotes [_nLote, 3], _aLotes [_nLote, 4], NIL, _aLotes [_nLote, 5], 'A')
		_nTmpExec = u_perfmon ('L', 'RastLt')
		_sArq := 'c:\temp\rast_F' + _aLotes [_nLote, 1] + '_' + alltrim (_aLotes [_nLote, 2]) + '_' + alltrim (_aLotes [_nLote, 3]) + '.mm'  //'_tempo' + cvaltochar (round (_nTmpExec, 0)) + 's.mm'
		delete file (_sArq)
		if file (_sArq)
			_nHdl = fopen(_sArq, 1)
		else
			_nHdl = fcreate(_sArq, 0)
		endif
		fwrite (_nHdl, _sMapa)
		fclose (_nHdl)
		ShellExecute ("Open", _sArq, "", "", 1)
//		u_log (_aLtXLS58)
//		_oLtXLS58 := CLsAUtil ():New ()
//		_oLtXLS58:_aArray := aclone (_aLtXLS58)
//		U_Log2 ('debug', '[' + procname () + ']' + cvaltochar (_oLtXLS58:TotCol (7)))
	next
return

// --------------------------------------------------------------------------
// Testes conta corrente associados
static function _SZI ()
	//local _nMovCC := 0
	//local _nDado  := 0

	// _aMovCC := {} // TM   SERIE   DOCTO                       ASSOC    LOJA  bco    ag       cta
	// aadd (_aMovCC, {'32', 'ART', strtran (time (), ':', ''), '000161', '01', '',    '',      ''})
	// aadd (_aMovCC, {'07', 'ADT', strtran (time (), ':', ''), '000161', '01', '001', '3412 ', '32972     '})
	// aadd (_aMovCC, {'01', 'UNI', strtran (time (), ':', ''), '000161', '01', '',    '',      ''})
	// aadd (_aMovCC, {'21', 'OUT', strtran (time (), ':', ''), '000161', '01', '001', '3412 ', '32972     '})
	// aadd (_aMovCC, {'25', 'MUD', strtran (time (), ':', ''), '000161', '01', '',    '',      ''})
	// aadd (_aMovCC, {'26', 'MUL', strtran (time (), ':', ''), '000161', '01', '',    '',      ''})
	// aadd (_aMovCC, {'15', 'CM ', strtran (time (), ':', ''), '000161', '01', '',    '',      ''})
	// aadd (_aMovCC, {'12', 'INT', strtran (time (), ':', ''), '000161', '01', '',    '',      ''})
	// aadd (_aMovCC, {'20', 'INT', strtran (time (), ':', ''), '000161', '01', '',    '',      ''})
	// aadd (_aMovCC, {'11', 'RCC', strtran (time (), ':', ''), '000161', '01', '',    '',      ''})
	// for _nMovCC = 1 to len (_aMovCC)
		//U_Log2 ('info', 'Tentando incluir TM/serie/doc ' + _aMovCC [_nMovCC, 1] + '/' + _aMovCC [_nMovCC, 2] + '/' + _aMovCC [_nMovCC, 3])
		_oCtaCorr := ClsCtaCorr():New ()
		//_oCtaCorr:TM       = '39'  // ENTRAR COMO FORNECEDOR DE UVA
		_oCtaCorr:TM       = '40'  // SAIR COMO FORNECEDOR DE UVA
		//_oCtaCorr:Serie    = _aMovCC [_nMovCC, 2]
		_oCtaCorr:Doc      = strtran (time (), ':', '') //_aMovCC [_nMovCC, 3]
		_oCtaCorr:Assoc    = '000132' //_aMovCC [_nMovCC, 4]
		_oCtaCorr:Loja     = '01' //_aMovCC [_nMovCC, 5]
		//_oCtaCorr:Banco    = _aMovCC [_nMovCC, 6]
		//_oCtaCorr:Agencia  = _aMovCC [_nMovCC, 7]
		//_oCtaCorr:NumCon   = _aMovCC [_nMovCC, 8]
		_oCtaCorr:DtMovto  = dDataBase - 1
		//_oCtaCorr:Valor    = 1
		_oCtaCorr:Usuario  = cUserName
		_oCtaCorr:Histor   = 'teste inclusao szi'
		_oCtaCorr:MesRef   = strzero(month(_oCtaCorr:DtMovto),2)+strzero(year(_oCtaCorr:DtMovto),4)
		_oCtaCorr:Parcela  = '0'
		_oCtaCorr:Origem   = 'robert'
		//_oCtaCorr:FormPag  = '3'  // 1=Cheque;2=Dinheiro;3=Depos.conta do associado;4=Deposito conta terceiros
		//_oCtaCorr:Fornece  = '000131'
		//_oCtaCorr:LojaFor  = '01'
		//_oCtaCorr:VctoSE2For = date () + 1
		if _oCtaCorr:PodeIncl ()
			if ! _oCtaCorr:Grava (.F., .F.)
				U_help (_oCtaCorr:UltMsg,, .t.)
			else
				u_log2 ('debug', 'gravou a conta corrente com sucesso.')
			endif
		else
			U_help ("Gravacao do SZI nao permitida:" + _oCtaCorr:UltMsg,, .T.)
		endif
//	next

/*
	// Testes exclusao conta corrente associados.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT top 10 R_E_C_N_O_"
	_oSQL:_sQuery +=   " FROM " + RetSqlName ("SZI") + " SZI "
	_oSQL:_sQuery +=  " WHERE SZI.D_E_L_E_T_ != '*'"
	_oSQL:_sQuery +=    " AND SZI.ZI_FILIAL = '" + xfilial ("SZI") + "'"
	_oSQL:_sQuery +=    " AND SZI.ZI_TM IN ('19','21', '32','25')"
	//_oSQL:_sQuery +=    " AND SZI.ZI_ASSOC = '002960'"
	_oSQL:_sQuery +=    " AND SZI.ZI_SALDO = ZI_VALOR"
	_oSQL:_sQuery +=    " AND SZI.ZI_DATA  = '" + dtos (date ()) + "'"
//	_oSQL:_sQuery +=    " AND EXISTS (SELECT *"
//	_oSQL:_sQuery +=                  " FROM " + RetSQLName ("SA2") + " SA2 "
//	_oSQL:_sQuery +=                 " WHERE SA2.D_E_L_E_T_ = ''"
//	_oSQL:_sQuery +=                   " AND SA2.A2_FILIAL  = '" + xfilial ("SA2") + "'"
//	_oSQL:_sQuery +=                   " AND SA2.A2_COD     = SZI.ZI_ASSOC"
//	_oSQL:_sQuery +=                   " AND SA2.A2_LOJA    = SZI.ZI_LOJASSO"
//	_oSQL:_sQuery +=                   " AND SA2.A2_VACBASE = SA2.A2_COD"
//	_oSQL:_sQuery +=                   " AND SA2.A2_VALBASE = SA2.A2_LOJA)"  // Somente codigo/loja base
//	_oSQL:_sQuery +=    " AND NOT EXISTS (SELECT * FROM ZZM010 WHERE D_E_L_E_T_ = '' AND ZZM_ASSOC = ZI_ASSOC AND ZZM_LOJA = ZI_LOJASSO AND ZZM_DATA = '20171231')"
	//_oSQL:_sQuery +=    " AND EXISTS (SELECT * FROM SE5010 SE5 WHERE SE5.D_E_L_E_T_ = '' AND E5_FORNECE = ZI_ASSOC AND E5_DATA > '20180706')"
	_oSQL:_sQuery +=  " ORDER BY ZI_ASSOC, ZI_LOJASSO, ZI_FILIAL, ZI_SEQ"
	_oSQL:Log ()
	_aDados = _oSQL:Qry2Array ()
	for _nDado = 1 to len (_aDados)
		szi -> (dbgoto (_aDados [_nDado, 1]))
		U_Log2 ('debug', '#####################################')
		U_Log2 ('debug', 'Tentando excluir SZI forn/loja ' + szi -> zi_assoc + '/' + szi -> zi_lojasso + ' doc/serie/parc ' + szi -> zi_doc + '/' + szi -> zi_serie + '/' + szi -> zi_parcela + ' TM ' + szi -> zi_tm)
		//_nSaldoAnt = szi -> zi_saldo
		//u_log2 ('info', szi -> zi_assoc + '/' + szi -> zi_lojasso + ' seq.' + szi -> zi_seq + ' ' + szi -> zi_histor)
		_oCtaCorr := ClsCtaCorr ():New (szi -> (recno ()))
		if _oCtaCorr:PodeExcl ()
			_oCtaCorr:Exclui ()
		endif
		U_Log2 ('debug', _oCtaCorr:UltMsg)
		//_oCtaCorr:AtuSaldo ()
		//if szi -> zi_saldo != _nSaldoAnt
		//	u_log2 ('aviso', szi -> zi_assoc + '/' + szi -> zi_lojasso + ' seq.' + szi -> zi_seq + ' sld ant:' + transform (_nSaldoAnt, "@E 999,999,999.99") + ' novo:' +  transform (szi -> zi_saldo, "@E 999,999,999.99") + ' ' + _oCtaCorr:UltMsg)
		//endif
	next
*/
return

// --------------------------------------------------------------------------
// Testes com telnet
static function _Telnet ()
	local _lContinua   := .T.
	local _nTamCBEmb   := TamSX3 ("C2_VABARCX")[1]
	private _sBarEtiq  := ''
	private _sCBEmbCol := ''
	private _sProdEtq  := ''
	private _dDatProd  := ctod ('')
	private _oEtiq     := NIL
	private _sTnoProd  := ' '
	private _nAltTela  := 10
	private _nLargTela := 39

	U_Log2 ('debug', '[' + procname () + ']Entrou no programa.')

	do while _lContinua
		
		// Limpa variaveis para ler nova etiqueta.
		_sBarEtiq = space (10)
		_sCBEmbCol = space (_nTamCBEmb)  // Maior que o necessario por que tem casos de licitacoes de SP que exigem uns caracteres de controle no inicio das barras.
		_sProdEtq = space (15)
		// Nao limpar entre as etiquetas --> _dDatProd = ctod ('')
		_oEtiq    = NIL
		// Nao limpar entre as etiquetas --> _sTnoProd   = space (1)

		vtSetSize (_nAltTela, _nLargTela)
		terCls()
		U_Log2 ('debug', '[' + procname () + ']Limpei a tela e vou abrir GET para ler codigo de etiqueta')

		if _lContinua
			terSay(0, 0, "Apontar etiqueta:")
			VTSetGet (@_sBarEtiq, "_sBarEtiq", 0, 19, {||allwaystrue ()})
			vtRead ()
			_lContinua = (vtLastkey() != 27)
			terCBuffer ()
		endif
		if _lContinua
			terSay (1, 0, "Cod.barras produto:")
			VTSetGet (@_sCBEmbCol, "_sCBEmbCol", 1, 19, {||allwaystrue ()})
			vtRead ()
			_lContinua = (vtLastkey() != 27)
			terCBuffer ()
		endif
		if _lContinua
			terSay (4, 0, "Dt.producao:")
			VTSetGet (@_dDatProd, "_dDatProd", 4, 13, {||allwaystrue ()})
			vtRead ()
			_lContinua = (vtLastkey() != 27)
			terCBuffer ()
		endif
		if _lContinua
			terSay (4, 25, "Turno:")
			VTSetGet (@_sTnoProd, "_sTnoProd", 4, 31, {||allwaystrue ()})
			vtRead ()
			_lContinua = (vtLastkey() != 27)
			terCBuffer ()
		endif
		if _lContinua
			U_Log2 ('debug', '[' + procname () + ']Campos lidos. Vou gerar apontamento')
			terSay (6, 0, "Aguarde, gerando apontamento")
		//	if _oEtiq:ApontaOP (_dDatProd, _sTnoProd)
				sleep (60000)
				U_Log2 ('debug', '[' + procname () + ']Retornou de _oEtiq:ApontaOP(). Vou dar msg para o usuario.')
				u_help ("Etiq." + '1234567890' + " apontada com sucesso!")
				U_Log2 ('debug', '[' + procname () + ']Retornou da msg de #apontada com socesso#')
		//	else
		//		u_help ("ERRO no apontamento.",, .t.)
		//	endif
		endif
		U_Log2 ('debug', '[' + procname () + ']fim do loop de apontamento')
	enddo

return

// --------------------------------------------------------------------------
// Testes com associados
static function _TesteAssoc ()
	local _oSQL := NIL
	local _aAssoc := {}
	local _nAssoc := 0

	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT distinct ZI_ASSOC, ZI_LOJASSO"
	_oSQL:_sQuery +=   " FROM " + RetSqlName ("SZI") + " SZI "
	_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = '*'"
	_oSQL:_sQuery +=  " ORDER BY ZI_ASSOC, ZI_LOJASSO"
	_aAssoc = _oSQL:Qry2Array ()
	for _nAssoc = 1 to len (_aAssoc)
		u_log (cvaltochar (_nAssoc) + ' de ' + cvaltochar (len (_aAssoc)))
		_oAssoc := ClsAssoc():New (_aAssoc [_nAssoc, 1], _aAssoc [_nAssoc, 2])
		if ! empty (_oAssoc:Codigo)
			U_Log (_oAssoc:SldQuotCap (date ()) [.QtCapRetTXT])
		endif
	next
return

// --------------------------------------------------------------------------
// Testes classe transf.estq.
static function _TrEstq ()
	private _sErroAuto := ''
/*
//	_sDocZAG := U_RetSQL ("SELECT MIN (ZAG_DOC+ZAG_SEQ) FROM ZAG010 WHERE D_E_L_E_T_ = '' AND ZAG_EMIS BETWEEN '20221104' AND '20221104' AND ZAG_USRINC = 'robert.koch'")
	_sDocZAG = '0000016074' + '01'
	zag -> (dbsetorder (1))  // ZAG_FILIAL+ ZAG_DOC + zag_seq
	if ! zag -> (dbseek (xfilial ("ZAG") + _sDocZAG, .F.))
		u_help ("Documento '" + _sDocZAG + "' nao localizado na tabela ZAG",, .t.)
	else
		U_Log2 ('debug', '[' + procname () + ']Instanciando...')
		_oTrEstq := ClsTrEstq ():New (zag -> (recno ()))
		U_Log2 ('debug', '[' + procname () + ']Instanciou')
		if empty (_oTrEstq:Docto)
			u_help ("Nao foi possivel instanciar objeto _oTrEstq",, .t.)
		else
//			_oTrEstq:Exclui ()
			// Se nao tem etiqueta, eh possivel que tenha dado problema na
			// geracao da mesma. Vou tentar gerar novamente.
			if empty (_oTrEstq:Etiqueta)
				U_Log2 ('debug', '[' + procname () + ']nao tem etiq.ainda. Vou gerar.')
				_oTrEstq:ImprEtq = '97'
				if ! _oTrEstq:GeraEtiq (.T.)
					U_Log2 ('erro', '[' + procname () + ']' + _oTrEstq:UltMsg)
				endif
			else
				U_Log2 ('debug', '[' + procname () + ']jah tem a etiq ' + _oTrEstq:Etiqueta + ' Vou imprimir.')
				_oEtiq := ClsEtiq ():New (_oTrEstq:Etiqueta)
				if _oEtiq:Codigo != _oTrEstq:Etiqueta
					U_Log2 ('erro', '[' + procname () + "]Numero de etiqueta invalido.")
				else
					if ! _oEtiq:Imprime ('97')
						U_Log2 ('erro', '[' + procname () + ']Erro na impressao.' + _oEtiq:UltMsg)
					endif
				endif
			endif

			U_Log2 ('debug', '[' + procname () + ']retorno:' + cvaltochar (_oTrEstq:UltMsg))
		endif
	endif
*/

	_oTrEstq := ClsTrEstq ():New ()
	_oTrEstq:FilOrig  = cFilAnt
	_oTrEstq:FilDest  = cFilAnt
	_oTrEstq:DtEmis   = date ()
	//_oTrEstq:OP       = ''
	//_oTrEstq:Motivo   = 'GLPI15121'
	_oTrEstq:ProdOrig = '30590          '
	_oTrEstq:ProdDest = '30590          '
	_oTrEstq:AlmOrig  = '92'
	_oTrEstq:AlmDest  = '11'
	_oTrEstq:EndOrig  = '               '
	_oTrEstq:EndDest  = '               '
	_oTrEstq:LoteOrig = '          '
	_oTrEstq:LoteDest = '          '
	_oTrEstq:QtdSolic = 20
	//_oTrEstq:CodMotivo = '04'
	//_oTrEstq:OP        = '13926901001'
	_oTrEstq:UsrIncl  = 'robert.koch'
	_oTrEstq:ImprEtq  = '98' // 14=AX EMBALAGENS;15=logistica;16=Elgin TI;98=sato em disco
	if _oTrEstq:Grava ()
		U_Log2 ('debug', '[' + procname () + ']Gravou! msg: ' + _oTrEstq:UltMsg)
//		if _oTrEstq:Libera ()
//			u_log ('Liberou!', _oTrEstq:UltMsg)
//		else
//			u_help (_oTrEstq:UltMsg)
//		endif
//		if _oTrEstq:Exclui ()
//			u_log ('Excluiu!', _oTrEstq:UltMsg)
//		else
//			u_help (_oTrEstq:UltMsg)
//		endif
	else
		U_Log2 ('erro', '[' + procname () + ']Nao gravou. msg: ' + _oTrEstq:UltMsg)
	endif

return

// --------------------------------------------------------------------------
static function _AtuCR ()
	U_GravaSX1 ('VA_ATUCR', '01', 'VD')  // Tipo produto
	U_GravaSX1 ('VA_ATUCR', '02', '1200')  // Produto inicial
	U_GravaSX1 ('VA_ATUCR', '03', '2000')  // Produto final
	U_VA_AtuCR (.t.)
return


// --------------------------------------------------------------------------
// Ajusta cadastro produtos em lote
static function _AtuSB1 ()
/*
	//local _lContinua := .T.
	local _oSQL      := NIL
//	local _aPrev     := {}
	local _aDados    := {}
	local _nDado     := 0

	_oSQL := ClsSQL():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT R_E_C_N_O_, B1_CUSTD * 1.015 * 1.0129"
	_oSQL:_sQuery +=   " FROM " + RetSQLName ("SB1") + " SB1"
	_oSQL:_sQuery +=  " WHERE SB1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=    " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
	_oSQL:_sQuery +=    " AND SB1.B1_GRUPO   = '0400'"
	_oSQL:_sQuery += " ORDER BY B1_COD"
	_oSQL:Log ('[' + procname () + ']')
	_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
	sb1 -> (dbsetorder (1))
	for _nDado = 1 to len (_aDados)
		sb1 -> (dbgoto (_aDados [_nDado, 1]))
		U_Log2 ('debug', '[' + procname () + ']' + sb1 -> b1_cod + ' de ' + cvaltochar (sb1 -> b1_custd) + ' para ' + cvaltochar (_aDados [_nDado, 2]))

		// Cria variaveis para uso na gravacao do evento de alteracao
		regtomemory ("SB1", .F., .F.)
		m->b1_CUSTD = ROUND (_aDados [_nDado, 2], 4)
		m->b1_datref = date ()

		// Grava evento de alteracao
		_oEvento := ClsEvent():new ()
		_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), 'Atualizar custo repos. uva somando FUNRURAL e frete', .F.)
	// nao posso rodar novamente, senao vai duplicar	reclock ("SB1", .f.)
		sb1 -> B1_custd = m->b1_custd
		sb1 -> B1_datref = m->b1_datref
		MsUnLock ()
		U_AtuMerc ("SB1", sb1 -> (recno ()))

		// Cai fora no primeiro, para testes.
		// exit
	next
*/
return

/*
	// GLPI 14994 (filho: 14998)
	local _aUvas    := {}
	local _nUva     := 0
	local _sSafra   := ''
	local _aHistSaf := {}
	local _sHistEven := ''
	local _nDecCustD := tamsx3 ("B1_CUSTD")[2]
	private mv_par01 := ''
	private mv_par02 := 'z'
	private mv_par03 := '24D '

	// Cria uma lista de variedades e graus a considerar.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += "SELECT B1_COD"     // 1 - codigo
	_oSQL:_sQuery +=      ", B1_DESC"    // 2 - descricao
	_oSQL:_sQuery +=      ", '00.0'"     // 3 - Reservado para o grau medio
	_oSQL:_sQuery +=      ", ''"         // 4 - Reservado para a safra referencia, B1_VARUVA"
	_oSQL:_sQuery +=      ", B1_VARUVA"  // 5 - Identificar se eh uva fina ou comum
	_oSQL:_sQuery +=      ", ''"         // 6 - Reservado para sistema de conducao
	_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB1") + " SB1"
	_oSQL:_sQuery += " WHERE SB1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=   " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
	_oSQL:_sQuery +=   " AND SB1.B1_GRUPO   = '0400'"
	_oSQL:_sQuery +=   " AND SB1.B1_COD BETWEEN '" + mv_par01 + "' AND '" + mv_par02 + "'"
	_oSQL:_sQuery +=   " ORDER BY B1_DESC"
	_aUvas := aclone (_oSQL:Qry2Array (.f., .f.))

	U_Log2 ('debug', _aUvas)

	// Verifica o grau medio de cada variedade retroativamente, partindo da
	// safra mais recente e retroagindo ateh encontrar alguma safra em que
	// essa uva tenha sido recebida.
	for _nUva = 1 to len (_aUvas)
		_sSafra = U_IniSafra (date ())

		// Tenta ateh o limite das ultimas 3 safras
		do while _sSafra >= tira1 (tira1 (tira1 (U_IniSafra (date ()))))
			U_Log2 ('debug', '[' + procname () + ']Iniciando busca de grau medio do ' + _aUvas [_nUva, 1] + ' (' + cvaltochar (_nUva) + ' de ' + cvaltochar (len (_aUvas)) + ') na safra ' + _sSafra)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := "SELECT ROUND(SUM(PESO_LIQ * GRAU) / SUM(PESO_LIQ), 1) AS GRAU_MEDIO"
			_oSQL:_sQuery +=      ", SUM (CASE SIST_CONDUCAO WHEN 'L' THEN PESO_LIQ ELSE 0 END) AS KG_LATADA"
			_oSQL:_sQuery +=      ", SUM (CASE SIST_CONDUCAO WHEN 'E' THEN PESO_LIQ ELSE 0 END) AS KG_ESPALD"
			_oSQL:_sQuery +=  " FROM VA_VNOTAS_SAFRA"
			_oSQL:_sQuery += " WHERE SAFRA = '" + _sSafra + "'"
			_oSQL:_sQuery +=   " AND TIPO_NF IN ('C', 'P')"
			_oSQL:_sQuery +=   " AND PRODUTO = '" + _aUvas [_nUva, 1] + "'"
			_oSQL:Log ('[' + procname () + ']')
			_aHistSaf := aclone (_oSQL:Qry2Array (.f., .f.))
			if _aHistSaf [1, 1] > 0
				_aUvas [_nUva, 3] = ClsCarSaf():FormataGrau (_aHistSaf [1, 1])  // Converte para caracter com decimais, etc
				_aUvas [_nUva, 4] = _sSafra
				_aUvas [_nUva, 6] = iif (_aHistSaf [1, 2] > _aHistSaf [1, 3], 'L', 'E')  // Usarei pelo de maior volume
				exit
			endif
			_sSafra = tira1 (_sSafra)
		enddo

		// Se nao consegui chegar a um grau medio desta variedade pelo historico, vou arbitrar.
		if val (_aUvas [_nUva, 3]) == 0
			U_Log2 ('aviso', '[' + procname () + "]Variedade " + alltrim (_aUvas [_nUva, 1]) + ' - ' + alltrim (_aUvas [_nUva, 2]) + " nao consegui identificar grau medio. Arbitrando!")
			_aUvas [_nUva, 3] = ClsCarSaf():FormataGrau (15.0)  // Converte para caracter com decimais, etc
			_aUvas [_nUva, 6] = 'L'  // Estou arbitrando que vai ser latada, e tenho dito! Jah arbitrei grau, mesmo...
		endif

		// Busca preco de tabela para esta variedade/grau
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT top 1 ZBI_VUNIT1"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZBI")
		_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZBI_FILIAL = '" + xfilial ("ZBI") + "'"
		_oSQL:_sQuery +=   " AND ZBI_CODTAB = '" + mv_par03 + "'"
		_oSQL:_sQuery +=   " AND ZBI_PRODUT = '" + _aUvas [_nUva, 1] + "'"
		_oSQL:_sQuery +=   " AND ZBI_GRAU   = '" + _aUvas [_nUva, 3] + "'"
		_oSQL:_sQuery +=   " AND ZBI_CLASSE = '" + iif (_aUvas [_nUva, 5] == 'C', ' ', 'B') + "'"  // Classif. 'base'
		_oSQL:_sQuery +=   " AND ZBI_CONDUC = '" + _aUvas [_nUva, 6] + "'"
		_oSQL:Log ('[' + procname () + ']')
		_nNovoCust = _oSQL:RetQry (1, .f.)

		U_Log2 ('debug', '[' + procname () + ']Preco para esta variedade = ' + cvaltochar (_nNovoCust))
		if _nNovoCust > 0
			sb1 -> (dbsetorder (1))
			if ! sb1 -> (dbseek (xfilial ("SB1") + _aUvas [_nUva, 1],, .F.))
				u_help ("Nao encontrei cadastro da uva '" + _aUvas [_nUva, 1] + "'",, .t.)
			else
				if round (_nNovoCust, _nDecCustD) == round (sb1 -> b1_custd, _nDecCustD)
					U_Log2 ('debug', '[' + procname () + ']B1_CUSTD jah estah certo.')
				else
					
					// Cria variaveis para uso na gravacao do evento de alteracao
					regtomemory ("SB1", .F., .F.)
					m->b1_custd  = _nNovoCust
					m->b1_datref = date ()

					// Grava evento de alteracao
					
					_sHistEven := ''
					_sHistEven += 'Atualizar custo reposicao uvas'
					_sHistEven += " com base na tabela de precos '" + mv_par03 + "'."
					_sHistEven += ' Grau medio usado para esta variedade: ' + _aUvas [_nUva, 3]
					if empty (_aUvas [_nUva, 4])
						_sHistEven += ' (grau este arbitrado, pois nao encontrei historico de safra para este produto)'
					else
						_sHistEven += ' (grau este baseado na safra mais recente: ' + _aUvas [_nUva, 4] + ')'
					endif
					_oEvento := ClsEvent():new ()
					_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), _sHistEven, .F.)
					reclock ("SB1", .f.)
					sb1 -> B1_custd = m->b1_custd
					msunlock ()
					U_AtuMerc ("SB1", sb1 -> (recno ()))

					// Cai fora no primeiro, para testes.
//					exit

				endif
			endif
		endif
	next
*/

/*
	//local _lContinua := .T.
	local _oSQL      := NIL
	local _aPrev     := {}
	local _aDados    := {}
	local _nDado     := 0

	U_MudaLog ('GLPI14539_B1_PESO.log')

	_oSQL := ClsSQL():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " WITH PRODUTOS AS"
	_oSQL:_sQuery += " ("
	_oSQL:_sQuery +=    " SELECT B1_COD, R_E_C_N_O_"
	_oSQL:_sQuery +=      " FROM " + RetSQLName ("SB1") + " SB1"
	_oSQL:_sQuery +=     " WHERE SB1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=       " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
	_oSQL:_sQuery +=       " AND SB1.B1_TIPO    = 'VD'"
	_oSQL:_sQuery += " )"
	_oSQL:_sQuery += " , ULTIMOS_SB9 AS"
	_oSQL:_sQuery += " ("
	_oSQL:_sQuery +=    " SELECT B9_COD, MAX (B9_DATA) B9_DATA"
	_oSQL:_sQuery +=      " FROM " + RetSQLName ("SB9") + " ULT"
	_oSQL:_sQuery +=     " WHERE ULT.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=       " AND ULT.B9_FILIAL  = '01'"  // Atualmente focamos na matriz por que eh onde temos o envase.
	_oSQL:_sQuery +=       " AND ULT.B9_QINI    > 0"
	_oSQL:_sQuery +=       " AND ULT.B9_VINI1   > 0"
	_oSQL:_sQuery +=       " AND EXISTS (SELECT *"
	_oSQL:_sQuery +=                     " FROM PRODUTOS"
	_oSQL:_sQuery +=                    " WHERE B1_COD = ULT.B9_COD"
	_oSQL:_sQuery +=                   ")"
	_oSQL:_sQuery +=     " GROUP BY ULT.B9_COD"
	_oSQL:_sQuery += " )"
	_oSQL:_sQuery += " SELECT PRODUTOS.*"
	_oSQL:_sQuery +=      " , ISNULL ((SELECT SUM (B9_VINI1) / SUM (B9_QINI)"
	_oSQL:_sQuery +=      " FROM " + RetSQLName ("SB9") + " SB9"
	_oSQL:_sQuery +=     " WHERE SB9.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=       " AND SB9.B9_FILIAL  = '01'"  // Atualmente focamos na matriz por que eh onde temos o envase.
	_oSQL:_sQuery +=       " AND SB9.B9_COD     = PRODUTOS.B1_COD"
	_oSQL:_sQuery +=       " AND SB9.B9_QINI    > 0"
	_oSQL:_sQuery +=       " AND SB9.B9_VINI1   > 0"
	_oSQL:_sQuery +=       " AND SB9.B9_DATA    = ULTIMOS_SB9.B9_DATA"
	_oSQL:_sQuery +=      "), 0) AS CUSMED"
	_oSQL:_sQuery +=  " FROM PRODUTOS, ULTIMOS_SB9"
	_oSQL:_sQuery += " WHERE B9_COD = B1_COD"
	_oSQL:_sQuery += " ORDER BY B1_COD"
	_oSQL:Log ('[' + procname () + ']')
	_aDados := aclone (_oSQL:Qry2Array (.f., .f.))
	sb1 -> (dbsetorder (1))
	for _nDado = 1 to len (_aDados)
		sb1 -> (dbgoto (_aDados [_nDado, 2]))
		U_Log2 ('debug', '[' + procname () + ']' + _aDados [_nDado, 1] + ' ' + sb1 -> b1_cod)
		//sb5 -> (dbsetorder (1))
		//syd -> (dbsetorder (1))  // YD_FILIAL, YD_TEC, YD_EX_NCM, YD_EX_NBM, YD_DESTAQU, R_E_C_N_O_, D_E_L_E_T_
		//if _lContinua .and. ! sb5 -> (dbseek (xfilial ("SB5") + sb1 -> b1_cod, .F.))
		//	u_log2 ('ERRO', 'Nao encontrei SB5 para o produto ' + sb1 -> b1_cod)
		//	_lContinua = .F.
		//endif
		//if _lContinua .and. ! syd -> (dbseek (xfilial ("SYD") + sb1 -> b1_posipi, .F.))
		//	u_log2 ('ERRO', "Nao encontrei SYD '" + sb1 -> b1_posipi + "' para o produto " + sb1 -> b1_cod)
		//	_lContinua = .F.
		//endif
//		u_log2 ('info', 'Verificando item ' + sb1 -> b1_tipo + ' ' + sb1 -> b1_cod + ' ' + SB1 -> B1_DESC)
		if round (sb1 -> b1_custd, 4) != round (_aDados [_nDado, 3], 4)
			aadd (_aPrev, {sb1 -> b1_tipo, "'" + sb1 -> b1_cod, SB1 -> B1_DESC, sb1 -> b1_custd, _aDados [_nDado, 3]})

			// Cria variaveis para uso na gravacao do evento de alteracao
			regtomemory ("SB1", .F., .F.)
			//regtomemory ("SB5", .F., .F.)
			//m->b5_vasisde = 'S'
			m->b1_CUSTD = ROUND (_aDados [_nDado, 3], 4)
			m->b1_datref = date ()

			// Grava evento de alteracao
			_oEvento := ClsEvent():new ()
			_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), 'GLPI 14539 - Atualizar custo repos. dos VD pelo custo medio', .F.)
			reclock ("SB1", .f.)
			sb1 -> B1_custd = m->b1_custd
			sb1 -> B1_datref = m->b1_datref
		// pra dar pau, mesmo	msunlock ()
			//reclock ("SB5", .f.)
			//sb5->b5_vasisde = m->b5_vasisde
			//msunlock ()
			U_AtuMerc ("SB1", sb1 -> (recno ()))

			// Cai fora no primeiro, para testes.
			// exit
			
			// sb1 -> (dbskip ())
		endif
	next
	u_acolsXLS (_aPrev)
*/

	//sb1 -> (dbsetorder (1))
	//sb5 -> (dbsetorder (1))
	//sb1 -> (dbgotop ())
	//do while ! sb1 -> (eof ())
	//	if sb1 -> b1_tipo = 'PS' .and. sb1 -> b1_um == 'KG' .and. sb1 -> b1_pesbru < sb1 -> b1_peso
	//		u_log2 ('info', 'Verificando item ' + sb1 -> b1_tipo + ' ' + sb1 -> b1_cod + ' ' + SB1 -> B1_DESC)
	//		sb5 -> (dbsetorder (1))
	//		if ! sb5 -> (dbseek (xfilial ("SB5") + sb1 -> b1_cod, .F.))
	//			u_log2 ('ERRO', 'Nao encontrei SB5 para o produto ' + sb1 -> b1_cod)
	//		else
//
	//			// Cria variaveis para uso na gravacao do evento de alteracao
	//			regtomemory ("SB1", .F., .F.)
	//			//regtomemory ("SB5", .F., .F.)
	//			//m->b5_vasisde = 'S'
	//			m->b1_pesbru = sb1 -> b1_peso
//
	//			// Grava evento de alteracao
	//			_oEvento := ClsEvent():new ()
	//			_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), 'Atualizar pesos insumos', .F.)
	//			// pra me obrigar a revisar ---> reclock ("SB1", .f.)
	//			sb1 -> B1_pesbru = m->b1_pesbru
	//			msunlock ()
	//			//reclock ("SB5", .f.)
	//			//sb5->b5_vasisde = m->b5_vasisde
	//			//msunlock ()
	//			U_AtuMerc ("SB1", sb1 -> (recno ()))
	//		endif
//
	//		// Cai fora no primeiro, para testes.
	//		exit
	//		
	//	endif
	//	sb1 -> (dbskip ())
	//enddo

	// Ajusta cadastro produtos em lote (itens das lojas)
	// sb1 -> (dbsetorder (1))
	// sb5 -> (dbsetorder (1))
	// sb1 -> (dbgotop ())
	// do while ! sb1 -> (eof ())
	// 	if sb1 -> b1_tipo = 'PA' .and. ! empty (sb1 -> b1_codpai)
	// 		if ! sb5 -> (dbseek (xfilial ("SB5") + sb1 -> b1_cod, .F.))
	// 			u_log ('ERRO: Nao encontrei SB5 para o produto ' + sb1 -> b1_cod)
	// 		else
	// 			u_log ('Verificando item', sb1 -> b1_cod, SB1 -> B1_DESC)
	// 			if sb1 -> B1_CODBAR != sb1 -> B1_VAEANUN ;
	// 				.and. substr (sb1 -> b1_codbar, 1, 8) != '78961005' ;
	// 				.and. substr (sb1 -> b1_vaeanun, 1, 8) = '78961005' ;
	// 				.and. ! "EXP" $ sb1 -> b1_desc  // Itens de exportacao jah estao corretos
	// 			
	// 				// Cria variaveis para uso na gravacao do evento de alteracao
	// 				regtomemory ("SB1", .F., .F.)
	// 				regtomemory ("SB5", .F., .F.)
	// 				m->b1_codgtin = ''
	// 				m->b1_codbar  = sb1 -> b1_vaeanun
	// 				m->b5_2codbar = ''
	// 				m->b5_convdip = 0
	// 				m->b5_umdipi  = ''
	// 				
	// 				// Grava evento de alteracao
	// 				_oEvento := ClsEvent():new ()
	// 				_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), '', .F.)
	// 				
	// 				reclock ("SB1", .f.)
	// 				sb1 -> b1_codgtin = m->b1_codgtin
	// 				sb1 -> b1_codbar = m->b1_codbar
	// 				msunlock ()
	// 				U_AtuMerc ("SB1", sb1 -> (recno ()))
	// 				reclock ("SB5", .f.)
	// 				sb5 -> b5_2codbar = m->b5_2codbar
	// 				sb5 -> b5_convdip = m->b5_convdip
	// 				sb5 -> b5_umdipi  = m->b5_umdipi
	// 				msunlock ()
	// 			else
	// 				u_log ('nada a alterar')
	// 			endif
	// 		endif
	// 	endif
	// 	sb1 -> (dbskip ())
	// enddo

	// Ajusta cadastro produtos em lote (PAs vendidos em caixas)
	// sb1 -> (dbsetorder (1))
	// sb5 -> (dbsetorder (1))
	// sb1 -> (dbgotop ())
	// do while ! sb1 -> (eof ())
	// 	if sb1 -> b1_tipo = 'PA' .and. empty (sb1 -> b1_codpai)
	// 		if ! sb5 -> (dbseek (xfilial ("SB5") + sb1 -> b1_cod, .F.))
	// 			u_log ('ERRO: Nao encontrei SB5 para o produto ' + sb1 -> b1_cod)
	// 		else
	// 			u_log ('Verificando item', sb1 -> b1_cod, SB1 -> B1_DESC)
	// 			if ! '789' $ sb1 -> b1_codbar .and. ! "EXP" $ sb1 -> b1_desc  // exportacao jah estao corretos
	// 				if sb1->b1_codbar != sb1 -> b1_vaDunCx .or. sb5->b5_2codbar != sb1 -> b1_vaEanUn .or. sb5->b5_convdip != sb1 -> b1_conv .or. sb5->b5_umdipi != sb1 -> b1_segum
	// 			
	// 					// Cria variaveis para uso na gravacao do evento de alteracao
	// 					regtomemory ("SB1", .F., .F.)
	// 					regtomemory ("SB5", .F., .F.)
	// 					m->b1_codgtin = ''
	// 					if left (sb1 -> b1_vaduncx, 3) != '000' 
	// 						m->b1_codbar  = sb1 -> b1_vaDunCx
	// 					endif
	// 					if substr (sb1 -> b1_vaeanun, 1, 3) = '789'
	// 						m->b5_2codbar = sb1 -> b1_vaEanUn
	// 					endif
	// 					m->b5_convdip = sb1 -> b1_convml
	// 					m->b5_umdipi  = sb1 -> b1_segum
	// 					
	// 					// Grava evento de alteracao
	// 					_oEvento := ClsEvent():new ()
	// 					_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), '', .F.)
	// 					
	// 					reclock ("SB1", .f.)
	// 					sb1 -> b1_codgtin = m->b1_codgtin
	// 					sb1 -> b1_codbar = m->b1_codbar
	// 					msunlock ()
	// 					U_AtuMerc ("SB1", sb1 -> (recno ()))
	// 					reclock ("SB5", .f.)
	// 					sb5 -> b5_2codbar = m->b5_2codbar
	// 					sb5 -> b5_convdip = m->b5_convdip
	// 					sb5 -> b5_umdipi  = m->b5_umdipi
	// 					msunlock ()
	// 					//exit
	// 				else
	// 					u_log ('nada a alterar')
	// 				endif
	// 			endif
	// 		endif
	// 	endif
	// 	sb1 -> (dbskip ())
	// enddo


	// Ajusta cadastro de produtos em lote (altera unidades conforme cadastro da caixa)
	// sb1 -> (dbgotop ())
	// do while ! sb1 -> (eof ())
	// 	if sb1 -> b1_tipo == 'PA' .and. ! empty (sb1 -> b1_codpai)
	// 		_aArea := sb1 -> (getarea ())
	// 		_sLinPai = posicione ("SB1", 1, xfilial ("SB1") + sb1 -> b1_codpai, "B1_VALINEN")
	// 		_sDescPai = sb1 -> b1_desc
	// 		sb1 -> (restarea (_aArea))
	// 		if ! empty (_sLinPai) .and. alltrim (_sLinPai) != '999' .and. _sLinPai != sb1 -> b1_vaLinEn
	// 			u_log (sb1 -> b1_cod, sb1 -> b1_desc, sb1 -> b1_valinen, '->', _sLinPai, '(', sb1 -> b1_codpai, _sDescPai)
	// 			_sCodAnt = sb1 -> b1_valinen
	// 			reclock ("SB1", .f.)
	// 			sb1 -> b1_valinen = _sLinPai
	// 			msunlock ()
	// 			_oEvento := ClsEvent ():New ()
	// 			_oEvento:Produto  = sb1 -> b1_cod
	// 			_oEvento:Texto   += "Produto " + alltrim (sb1 -> b1_cod) + "-" + alltrim (sb1 -> b1_desc) 
	// 			_oEvento:Texto   += chr (13) + chr (10)
	// 			_oEvento:Texto   += "Campo B1_VALINEN (" + alltrim (RetTitle ("B1_VALINEN")) + "):"
	// 			_oEvento:Texto   += " alterado de '" + alltrim (_sCodAnt) + "' para '" + alltrim (sb1 -> b1_valinen) + "' cfe. cadastro do codigo pai."
	// 			_oEvento:Alias    = 'SB1'
	// 			_oEvento:CodEven  = "ALT001"
	// 			_oEvento:CodAlias = sb1 -> b1_cod
	// 			_oEvento:Recno    = sb1 -> (recno ())
	// 			//u_log (_oEvento:Texto)
	// 			_oEvento:Grava ()
	// 			//exit
	// 		endif
	// 	endif
	// 	sb1 -> (dbskip ())
	// enddo
	// u_log ('finalizado')
return

/*
	_sArqLog := 'GLPI11986_SYD.log'
	syd -> (dbsetorder (1))
	_aDados = U_LeCSV ('\robert\syd_35.csv', ';')
	//u_log2 ('debug', _adados)
	for _nDado = 1 to len (_aDados)
		_aDados [_nDado, 1] = strtran (_aDados [_nDado, 1], '.', '')
		if ! syd -> (dbseek (xfilial ("SYD") + padl (_aDados [_nDado, 1], 8, '0'), .F.))
		//	U_Log2 ('erro', _aDados [_nDado, 1] + ' nao encontrado')
		else
			_nPerc = val (strtran (strtran (_aDados [_nDado, 4], '"', ''), ',', '.'))
			if syd -> yd_per_ipi != _nPerc
				U_Log2 ('debug', syd -> yd_tec + ' ' + U_TamFixo (syd -> yd_desc_p, 40) + ' ' + transform (syd -> yd_per_ipi, "@E 999.99") + ' -> ' + transform (_nPerc, "@E 999.99"))
				regtomemory ("SYD", .F., .F.)
				m->yd_per_ipi = _nPerc

				// Grava evento de alteracao
				_oEvento := ClsEvent():new ()
				_oEvento:AltCadast ("SYD", m->yd_tec, syd -> (recno ()), 'GLPI 11986 - Revisao geral TIPI', .F.)

				reclock ("SYD", .f.)
				syd -> yd_per_ipi = m->yd_per_ipi
				msunlock ()
				// Cai fora no primeiro, para testes.
				// exit
			endif
		endif
	next
return
*/
/*
	// testes tratamento de erros
	try
		U_Log2 ('debug', '[' + procname () + ']logo apos TRY')
		//_oErro := ErrorClass():New()
		//u_logObj (_oErro)
		robert ()
		U_Log2 ('debug', '[' + procname () + ']executei ROBERT()')
		b :=A+1
		U_Log2 ('debug', '[' + procname () + ']executei b:=a+1')
	catch _oErro
		U_Log2 ('debug', '[' + procname () + ']aqui seria tratado o erro')
		u_logObj (_oErro)
	endtry
return
*/

// --------------------------------------------------------------------------
// Testes relatorios associados que devem trazer totais consistentes entre si
static function _RelAssoc ()
	local _aAssoc  := {}
	local _nAssoc  := 0
//	aadd (_aAssoc, {'003024', '01', '2020'})  // Vilson Da Campo - NF de compra devolvida em 2020.
//	aadd (_aAssoc, {'002660', '01', '2020'})  // Cledinei Da Campo - NF trocada com Vilson em 2020.
//	aadd (_aAssoc, {'005567', '01', '2022'})  // Fazenda Passo da Cria
//	aadd (_aAssoc, {'002517', '01', '2022'})  // Santo Jose Busetti (diversas variedades de uva)
//	aadd (_aAssoc, {'003621', '01', '2022'})  // Dejair Betlinski
//	aadd (_aAssoc, {'010637', '01', '2022'})  // Cristiano Adilio de Souza - premio 2022 duplicado
//	aadd (_aAssoc, {'002911', '01', '2017'})  // Honorino - premio 2022 duplicado - saiu em 2022
//	aadd (_aAssoc, {'010602', '01', '2019'})  // Jorge Salton - conferencia IR 2022
//	aadd (_aAssoc, {'003003', '01', '2020'})  // Tania zanata Boz - conferencia IR 2022
//	aadd (_aAssoc, {'018409', '01', '2021'})  // Marcelo Avelino Parisotto  - conferencia IR 2022
//	aadd (_aAssoc, {'002924', '01', '2022'})  // Ivo Boldrin - fech.safra 2022 parece trazer R$ 79,79 a mais (deve ser funrural)
//	aadd (_aAssoc, {'002832', '01', '2022'})  // Alex Boldrin - fech.safra 2022 resumo pagto nao bate com notas de safra
//	aadd (_aAssoc, {'003587', '01', '2018'})  // Marisa Guisso Possa - safra 2018 aparecem movtos de 2023 !!!
//	aadd (_aAssoc, {'023824', '01', '2023'})  // EMA SOSTER BOFF
//	aadd (_aAssoc, {'023827', '01', '2023'})  // MERCELO BOFF
//	aadd (_aAssoc, {'002480', '01', '2023'})  // DANIEL SGANZERLA
	aadd (_aAssoc, {'012722', '01', '2022'})  // Casiano Arcari - muitos descontos de Unimed
//	aadd (_aAssoc, {'002380', '01', '2023'})  // Elmar Busetti
//	aadd (_aAssoc, {'002859', '01', '2023'})  // Celso Chiarani
//	aadd (_aAssoc, {'003026', '01', '2023'})  // Marcos Parisotto
//	aadd (_aAssoc, {'005212', '01', '2022'})  // Heleno Facchin - estaria faltando matade dos valores no demonatrativo de IR ano base 2022
//	aadd (_aAssoc, {'005212', '01', '2023'})  // Heleno Facchin
//	aadd (_aAssoc, {'003865', '01', '2023'})  // Sidimar Fleck
//	_oSQL := ClsSQL ():New ()
//	_oSQL:_sQuery += " SELECT DISTINCT ZI_ASSOC, ZI_LOJASSO, ZI_SAFRA"
//	_oSQL:_sQuery +=   " FROM " + RetSqlName ("SZI") + " SZI "
//	_oSQL:_sQuery +=  " WHERE SZI.D_E_L_E_T_ != '*'"
//	_oSQL:_sQuery +=    " AND SZI.ZI_FILIAL = '" + xfilial ("SZI") + "'"
//	_oSQL:_sQuery +=    " AND SZI.ZI_TM = '13'"
//	_oSQL:_sQuery +=    " AND SZI.ZI_SAFRA = '2023'"
//	_oSQL:_sQuery +=    " AND SZI.ZI_ASSOC <= '005491'"
//	_oSQL:_sQuery += " ORDER BY ZI_ASSOC, ZI_LOJASSO"
//	_aAssoc := aclone (_oSQL:Qry2Array (.f., .f.))
	for _nAssoc = 1 to len (_aAssoc)
		U_Log2 ('info', 'Iniciando associado ' + _aAssoc [_nAssoc, 1])
		U_GravaSX1 ("ML_FECHASA", '01', _aAssoc [_nAssoc, 3])  // safra
		U_GravaSX1 ("ML_FECHASA", '02', _aAssoc [_nAssoc, 1])  // cod assoc
		U_GravaSX1 ("ML_FECHASA", '03', _aAssoc [_nAssoc, 2])  // loja
		U_GravaSX1 ("ML_FECHASA", '04', 2)  // lista saldo CC 1=sim;2=nao
		U_GravaSX1 ("ML_FECHASA", '05', 2)  // lista pagtos/compens
		U_ml_fechasafra (.T.)

		//
		// U_GravaSX1 ("IRASSOC", '01', '')  // CPF ini
		// U_GravaSX1 ("IRASSOC", '02', 'z')  // CPF fim
		// U_GravaSX1 ("IRASSOC", '03', '2022')  // ano base
		// U_GravaSX1 ("IRASSOC", '04', _aAssoc [_nAssoc])  // assoc ini
		// U_GravaSX1 ("IRASSOC", '05', '  ')  // loja ini
		// U_GravaSX1 ("IRASSOC", '06', _aAssoc [_nAssoc]) //002932')  // assoc fim
		// U_GravaSX1 ("IRASSOC", '07', 'zz')  // loja fim
		// U_GravaSX1 ("IRASSOC", '08', '  ')  // nucleo
		// u_IRAssoc (.T.)
		// U_GravaSX1 ("IRASSOC", '03', '2023')  // ano base
		// u_IRAssoc (.T.)
		//
		//U_GravaSX1 ("SZI_REL2", "01", _aAssoc [_nAssoc])
		//U_GravaSX1 ('SZI_REL2', "02", '')
		//U_GravaSX1 ("SZI_REL2", "03", _aAssoc [_nAssoc])
		//U_GravaSX1 ('SZI_REL2', "04", 'zz')
		//U_GravaSX1 ('SZI_REL2', "05", stod ("19000000"))
		//U_GravaSX1 ('SZI_REL2', "06", stod ("20491231"))
		//U_GravaSX1 ('SZI_REL2', "07", 1)  // tipo normal/capital
		//U_GravaSX1 ('SZI_REL2', "08", 2)  //listar OBS S/N
		//U_szi_rel2 (.t.)
		//U_GravaSX1 ('SZI_REL', "01", _aAssoc [_nAssoc])
		//U_GravaSX1 ('SZI_REL', "02", '')
		//U_GravaSX1 ('SZI_REL', "03", _aAssoc [_nAssoc])
		//U_GravaSX1 ('SZI_REL', "04", 'zz')
		//U_GravaSX1 ('SZI_REL', "05", '')
		//U_GravaSX1 ('SZI_REL', "06", 'zz')
		//U_GravaSX1 ('SZI_REL', "07", stod ("19000000"))
		//U_GravaSX1 ('SZI_REL', "08", stod ("20491231"))
		//U_GravaSX1 ('SZI_REL', "09", 1)
		//U_GravaSX1 ('SZI_REL', "10", '')
		//U_GravaSX1 ('SZI_REL', "11", 2)
		//U_GravaSX1 ('SZI_REL', "12", 1)
		//U_GravaSX1 ('SZI_REL', "13", '')
		//U_GravaSX1 ('SZI_REL', "14", 'zz')
		//U_GravaSX1 ('SZI_REL', "15", 2)
		//U_szi_rel (.t., 1)
		//
		//u_gravasx1 ('SZI_LCS', '01', '') // _aAssoc [_nAssoc])  // Associado inicial
		//u_gravasx1 ('SZI_LCS', '02', '')  // Loja associado inicial
		//u_gravasx1 ('SZI_LCS', '03', 'z') // _aAssoc [_nAssoc])  // Associado final
		//u_gravasx1 ('SZI_LCS', '04', 'z')  // Loja associado final
		//u_gravasx1 ('SZI_LCS', '05', '13')  // Tipo de movimento inicial
		//u_gravasx1 ('SZI_LCS', '06', '13')  // Tipo de movimento final
		//u_gravasx1 ('SZI_LCS', '07', date ())  // Posicao em
		//u_gravasx1 ('SZI_LCS', '08', '')  // Coop.orig(AL/SV/...) bco=todas
		//u_gravasx1 ('SZI_LCS', '09', '')  // Filial inicial
		//u_gravasx1 ('SZI_LCS', '10', 'z')  // Filial final
		//u_gravasx1 ('SZI_LCS', '11', '')  // Forma pagamento (bco=todas)
		//u_gravasx1 ('SZI_LCS', '12', 3)   // Movtos a: debito /credito /Todos
		//u_gravasx1 ('SZI_LCS', '13', '')  // T.M. desconsiderar (separ. /)
		//u_gravasx1 ('SZI_LCS', '14', '')  // Parcelas (separ. /) bco=todas
		//u_gravasx1 ('SZI_LCS', '15', 1)  // com saldo / sem saldo / todos
		//u_gravasx1 ('SZI_LCS', '16', stod ('20220101'))  // emissao a partir de
		//u_gravasx1 ('SZI_LCS', '17', stod ('20220301'))  // vencto ini
		//u_gravasx1 ('SZI_LCS', '18', stod ('20220331'))  // vencto fim
		//u_szi_lcs (.t., 4)
	next
return

/*
// Testes batches em geral
//	_sArqLog := 'U_BatCompAssoc_' + alltrim (cusername) + '_' + dtos (date ()) + ".log"
//	u_batCompAssoc ()
//	_sArqLog := 'U_BatSZI_' + alltrim (cusername) + ".log"
//	if cFilAnt == '01'
//		u_batSZI (stod ('20200101'), stod ('20210228'))
//	endif
//	_sArqLog := 'U_BatFunAtlz_' + alltrim (cusername) + '_' + dtos (date ()) + ".log"
//	u_batfunatlz ()
//	_sArqLog := 'U_BatEDIM_' + alltrim (cusername) + '_' + dtos (date ()) + ".log"
//	u_batedim ("I")
//	u_log2 ('info', _oBatch:Mensagens)
return
*/
/*
	// Releitura inspecoes safra (GLPI 11746)
	szf -> (dbsetorder (1))  // filial + safra + carga + item
	private _aNovaClas := {}  // Para poder gerar, no final, uma planilha com todos os valores.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT FILIAL, SAFRA, CARGA "
	_oSQL:_sQuery +=  " FROM VA_VCARGAS_SAFRA"
	_oSQL:_sQuery += " WHERE SAFRA = '2022'"
	_oSQL:_sQuery +=   " and STATUS != 'C'"
//	_oSQL:_sQuery +=   " and DATA <= '20220310'"
	//_oSQL:_sQuery +=   " and ASSOCIADO = '000167'"
	_oSQL:_sQuery +=   " and FILIAL = '" + cFilAnt + "'"
	_oSQL:_sQuery += " ORDER BY CARGA"
	_oSQL:Log ()
	_aCargas = _oSQL:Qry2Array ()
	for _nCarga = 1 to len (_aCargas)
		u_log2 ('info', replicate ('-', 80))
		u_log2 ('info', replicate ('-', 80))
		sze -> (dbsetorder (1))
		if sze -> (dbseek (_aCargas [_nCarga, 1] + _aCargas [_nCarga, 2] + _aCargas [_nCarga, 3], .T.))
			_aNovaClas = {}
			U_VA_RUSLI (2, .t.)
		//	U_Log2 ('debug', _aNovaClas)
			for _nNovaClas = 1 to len (_aNovaClas)
				if ! szf -> (dbseek (xfilial ("SZF") + sze -> ze_safra + sze -> ze_carga + _aNovaClas [_nNovaClas, 1], .F.))
					u_help ("SZF nao encontrado para filial/safra/carga/item " + xfilial ("SZF") + sze -> ze_safra + sze -> ze_carga + _aNovaClas [_nNovaClas, 1],, .t.)
				else
					aadd (_aResult, {_aCargas [_nCarga, 1], _aCargas [_nCarga, 2], _aCargas [_nCarga, 3], _aNovaClas [_nNovaClas, 1], iif (szf -> zf_conduc == 'L', szf -> zf_clasabd, szf -> zf_prm99), _aNovaClas [_nNovaClas, 2]})
				endif
			next
		else
			u_log2 ('erro', 'Carga nao encontrada com a seguinte chave: ' + _aCargas [_nCarga, 1] + _aCargas [_nCarga, 2] + _aCargas [_nCarga, 3])
		endif
	next
	U_Log2 ('debug', _aResult)
	U_acolsXLS (_aResult)
return
*/

/*
	// Ajustar parcelamento notas safra do dia 07/03/2022 (gerou uma apenas) - GLPI 11750
	_oSQL := ClsSQL():New ()
	_oSQL:_sQuery := "SELECT "
	for _nCampo = 1 to SE2 -> (fcount ())
		_sCampo = alltrim (SE2 -> (fieldname (_nCampo)))
		_oSQL:_sQuery += _sCampo + iif (_nCampo < SE2 -> (fcount ()), ', ', '')
	next
	_oSQL:_sQuery += ", (SELECT MAX (GRUPO_PAGTO) FROM VA_VNOTAS_SAFRA V"  // Usei MAX por que pode ter mais de uma variedade na nota
	_oSQL:_sQuery +=    " WHERE E2_FILIAL = V.FILIAL
	_oSQL:_sQuery +=      " AND E2_NUM = V.DOC
	_oSQL:_sQuery +=      " AND E2_PREFIXO = V.SERIE
	_oSQL:_sQuery +=      " AND E2_FORNECE = V.ASSOCIADO
	_oSQL:_sQuery +=      " AND E2_LOJA = V.LOJA_ASSOC) as GRPGT"
	_oSQL:_sQuery += ", (SELECT SUM (VALOR_TOTAL) FROM VA_VNOTAS_SAFRA V"  // Usei SUM por que pode ter mais de uma variedade na nota
	_oSQL:_sQuery +=    " WHERE E2_FILIAL = V.FILIAL
	_oSQL:_sQuery +=      " AND E2_NUM = V.DOC
	_oSQL:_sQuery +=      " AND E2_PREFIXO = V.SERIE
	_oSQL:_sQuery +=      " AND E2_FORNECE = V.ASSOCIADO
	_oSQL:_sQuery +=      " AND E2_LOJA = V.LOJA_ASSOC) as VLUVA"
	_oSQL:_sQuery += " FROM SE2010 SE2 WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery += " AND E2_FILIAL  = '" + cFilAnt + "'"
	_oSQL:_sQuery += " AND E2_SALDO   = E2_VALOR"
	_oSQL:_sQuery += " AND E2_EMISSAO = '20220307'"
//	_oSQL:_sQuery += " AND E2_NUM     IN ('000030884')"
	_oSQL:_sQuery += " AND E2_PREFIXO = '30'"
	_oSQL:_sQuery += " AND E2_PARCELA = ' '"
	_oSQL:_sQuery += " AND NOT EXISTS (SELECT *"
	_oSQL:_sQuery +=                   " FROM SE2010 JAH_TEM WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=                    " AND JAH_TEM.E2_FILIAL  = SE2.E2_FILIAL "
	_oSQL:_sQuery +=                    " AND JAH_TEM.E2_NUM     = SE2.E2_NUM"
	_oSQL:_sQuery +=                    " AND JAH_TEM.E2_PREFIXO = SE2.E2_PREFIXO"
	_oSQL:_sQuery +=                    " AND JAH_TEM.E2_FORNECE = SE2.E2_FORNECE"
	_oSQL:_sQuery +=                    " AND JAH_TEM.E2_LOJA    = SE2.E2_LOJA"
	_oSQL:_sQuery +=                    " AND JAH_TEM.E2_PARCELA = 'A')"
	_oSQL:_sQuery += " ORDER BY E2_NUM, E2_PARCELA"
	_oSQL:Log ()
	//_sAliasQ := _oSQL:Qry2Trb (.F.)
	_oSQL:Copy2Trb (.t., .f., '_trb', {})
	_trb -> (dbgotop ())
	do while ! _trb -> (eof ())
		U_Log2 ('debug', '[' + procname () + ']' + _trb -> e2_num + '-' + _trb -> e2_parcela + ' gr.pgt: ' + _trb -> GRPGT)
		sf1 -> (dbsetorder (1))  // F1_FILIAL, F1_DOC, F1_SERIE, F1_FORNECE, F1_LOJA, F1_TIPO, R_E_C_N_O_, D_E_L_E_T_
		if ! sf1 -> (dbseek (_trb -> e2_filial + _trb -> e2_num + _trb -> e2_prefixo + _trb -> e2_fornece + _trb -> e2_loja, .F.))
			U_Log2 ('erro', 'Nao encontrei SF1')
		else
			_aParcPP := aclone (U_VA_RusPP ('2022', _trb -> GrPgt, _trb -> VlUva, sf1 -> f1_despesa, sf1 -> f1_emissao))
			U_Log2 ('debug', _aParcPP)
			for _nParc = 1 to len (_aParcPP)
				_trb -> e2_parcela = _aParcPP [_nParc, 6]
				_trb -> e2_hist    = _aParcPP [_nParc, 5]
				_trb -> e2_vencto  = _aParcPP [_nParc, 2]
				_trb -> e2_vencrea = _aParcPP [_nParc, 2]
				_trb -> e2_vencori = _aParcPP [_nParc, 2]
				_trb -> e2_valor   = _aParcPP [_nParc, 4]
				_trb -> e2_saldo   = _aParcPP [_nParc, 4]
				_trb -> e2_vlcruz  = _aParcPP [_nParc, 4]
				_trb -> e2_vachvex = ''
				U_Log2 ('debug', '[' + procname () + ']Criando parcela ' + _trb -> e2_parcela)
				_CopiaReg ('_trb', 'SE2')
			next
		endif
		_trb -> (dbskip ())

	//	exit  // ainda em testes. vou rodar um apenas.
	enddo
return
*/
/*
// --------------------------------------------------------------------------
// Cria novo registro no alias destino e copia dados do registro atual do alias origem.
static function _CopiaReg (_sOrig, _sDest)
	local _sCampo := ""
	local _nCampo := 0
	local _xDado  := NIL
	local _aAreaAnt := U_ML_SRArea ()

 	reclock (_sDest, .T.)
	for _nCampo = 1 to (_sDest) -> (fcount ())
		_sCampo = alltrim ((_sDest) -> (fieldname (_nCampo)))
		if (_sOrig) -> (fieldpos (_sCampo)) > 0 .and. valtype ((_sOrig) -> &(_sCampo)) == valtype ((_sDest) -> &(_sCampo))
			_xDado = (_sOrig) -> &(_sCampo)
			(_sDest) -> &(_sCampo) = _xDado
		endif
	next
	msunlock ()
	U_ML_SRArea (_aAreaAnt)
return
*/
/*
	// Gera complemento de frete (ficamos dia 07/03/22 sem gravar o campo D1_DESPESA) safra 2022 (GLPI 
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""  // consulta baseada na verificacao numero 86
	_oSQL:_sQuery += "WITH C AS ( SELECT SAFRA, FILIAL, ASSOCIADO, LOJA_ASSOC, NOME_ASSOC, DOC, SERIE, dbo.VA_DTOC (DATA) AS DATA, SUM (VALOR_FRETE) AS ZF_VALFRET"
	_oSQL:_sQuery +=                  ", GRUPO_PAGTO, PRODUTO, GRAU, CLAS_FINAL, CLAS_ABD, SIST_CONDUCAO, ITEM_NOTA"
	_oSQL:_sQuery +=                  ", (SELECT D1_DESPESA"
	_oSQL:_sQuery +=                      " FROM SD1010 SD1"
	_oSQL:_sQuery +=                     " WHERE SD1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=                       " AND SD1.D1_FILIAL  = V.FILIAL"
	_oSQL:_sQuery +=                       " AND SD1.D1_DOC     = V.DOC"
	_oSQL:_sQuery +=                       " AND SD1.D1_SERIE   = V.SERIE"
	_oSQL:_sQuery +=                       " AND SD1.D1_FORNECE = V.ASSOCIADO"
	_oSQL:_sQuery +=                       " AND SD1.D1_LOJA    = V.LOJA_ASSOC"
	_oSQL:_sQuery +=                       " AND SD1.D1_ITEM    = V.ITEM_NOTA) AS D1_DESPESA"
	_oSQL:_sQuery +=              " FROM VA_VNOTAS_SAFRA V WHERE SAFRA   = '2022' AND TIPO_NF = 'C'"
	_oSQL:_sQuery +=             " GROUP BY SAFRA, FILIAL, ASSOCIADO, LOJA_ASSOC, NOME_ASSOC, DOC, SERIE, DATA, GRUPO_PAGTO, PRODUTO, GRAU, CLAS_FINAL, CLAS_ABD, SIST_CONDUCAO, ITEM_NOTA)"
	_oSQL:_sQuery +=  " SELECT C.* FROM C"
	_oSQL:_sQuery +=  " WHERE round (ZF_VALFRET, 2) != round (D1_DESPESA, 2)"
	_oSQL:_sQuery +=    " AND C.FILIAL = '" + cFilAnt + "'"
	_oSQL:_sQuery +=  " ORDER BY SAFRA, FILIAL, ASSOCIADO, LOJA_ASSOC, DOC, SERIE, ITEM_NOTA"
	_oSQL:Log ()
	_sAliasQ := _oSQL:Qry2Trb (.f.)
	_sPreNF := U_RetSQL ("SELECT MAX (ZZ9_PRE_NF) FROM ZZ9010 WHERE ZZ9_SAFRA = '2022' AND ZZ9_FILIAL = '" + cFilAnt + "'")
	do while ! (_sAliasQ) -> (eof ())
		reclock ("ZZ9", .T.)
		zz9 -> zz9_filial = (_sAliasQ) -> filial
		zz9 -> zz9_safra  = (_sAliasQ) -> safra
		zz9 -> zz9_grupo  = (_sAliasQ) -> grupo_pagto
		zz9 -> zz9_parcel = 'D'
		zz9 -> zz9_fornec = (_sAliasQ) -> associado
		zz9 -> zz9_loja   = (_sAliasQ) -> loja_assoc
		zz9 -> zz9_pre_nf = _sPreNF
		zz9 -> zz9_TipoNF = "C"
		zz9 -> zz9_produt = (_sAliasQ) -> produto
		zz9 -> zz9_grau   = (_sAliasQ) -> grau
		zz9 -> zz9_classe = (_sAliasQ) -> clas_final
		zz9 -> zz9_clabd  = (_sAliasQ) -> clas_abd
		zz9 -> zz9_conduc = (_sAliasQ) -> sist_conducao
		zz9 -> zz9_vunold = 0
		zz9 -> zz9_vunit2 = 0
		zz9 -> zz9_quant  = 0
		zz9 -> zz9_vunit  = (_sAliasQ) -> ZF_VALFRET
		zz9 -> zz9_obs    = 'NF orig.ficou sem frete (GLPI 11721)'
		zz9 -> zz9_DCO    = 'GLPI11721'
		zz9 -> zz9_nfori  = (_sAliasQ) -> doc
		zz9 -> zz9_serior = (_sAliasQ) -> serie
		zz9 -> zz9_itemor = (_sAliasQ) -> item_nota
		zz9 -> zz9_mistu1 = ''
		zz9 -> zz9_mistu2 = ''
		zz9 -> zz9_mistu3 = ''
		zz9 -> zz9_msgNF  = 'Compl.frt.safra 2022'
		zz9 -> zz9_TES    = '310'  //TES que altera estoque por que quero somar no custo da uva, que ainda consta em estoque.  U_TESSafra ('2022', (_sAliasQ) -> associado, (_sAliasQ) -> loja_assoc, 'V')
		msunlock ()
		_sPreNF = soma1 (soma1 (soma1 (soma1 (soma1 (_sPreNF)))))
		(_sAliasQ) -> (dbskip ())
	enddo
return
*/
/*
	// Testes verificacoes genericas.
	// _oVerif := ClsVerif():New (25)
	// _oVerif:SetParam ('01', '2017')
	// _oVerif:SetParam ('02', '')
	// _oVerif:SetParam ('03', 'zz')
	// _oVerif:SetParam ('04', '30 ')
	// _oVerif:SetParam ('05', '028')
	// _oVerif:SetParam ('06', '077')
	// _oVerif:SetParam ('07', '000017')
	// _oVerif := ClsVerif():New (24)
	// _oVerif:SetParam ('01', '09189201001  ')
	// _oVerif:SetParam ('02', '09189201001  ')
	// _oVerif:SetParam ('03', '')
	// _oVerif:SetParam ('04', 'z')
	_oVerif := ClsVerif():New (86)
	if _oVerif:Executa ()
		u_log2 ('debug', 'Pendencias do tipo ' + _oVerif:Descricao)
		u_log2 ('debug', _oVerif:Result)
		u_acolsxls (_oVerif:Result)
	else
		u_log2 ('erro', 'Erro na verificacao: ' + _oVerif:UltMsg)
	endif
return
/*
	// Ajusta cadastro de TIPI em lote
	syd -> (dbsetorder (1))
	syd -> (dbgotop ())
	do while ! syd -> (eof ())
		if syd -> yd_per_ipi > 0
			if alltrim (syd -> yd_tec) $ '22042100/22041090/22043000/22021000/22042100/22060090/22082000'
				u_log2 ('aviso', 'Ja foi feito manuelmente (GLPI 11681)' + syd -> yd_tec + Syd -> yd_DESC_p)
			else
				//u_log2 ('info', 'Verificando SYD ' + syd -> yd_tec + Syd -> yd_DESC_p)

				// Cria variaveis para uso na gravacao do evento de alteracao
				regtomemory ("SYD", .F., .F.)
				m->yd_per_ipi = syd -> yd_per_ipi * 0.75
				U_Log2 ('info', syd -> yd_tec + ' alterando YD_PER_IPI de ' + transform (syd->yd_per_ipi, "@E 999.99") + ' para ' + transform (m->yd_per_ipi, "@E 999.99") + ' ' + ' ' + syd -> yd_desc_p)

				// Grava evento de alteracao
				_oEvento := ClsEvent():new ()
				_oEvento:AltCadast ("SYD", m->yd_tec, syd -> (recno ()), 'GLPI 11682 - Reducao geral 25% toda TIPI', .F.)

				reclock ("SYD", .f.)
				syd -> yd_per_ipi = m->yd_per_ipi
				msunlock ()
				U_AtuMerc ("SYD", syd -> (recno ()))
				
				// Cai fora no primeiro, para testes.
				//exit
			endif
		endif
		syd -> (dbskip ())
	enddo
return
*/
/*
	// Gera conta 'PREMIACAO QUALIDADE' na corrente ref. safra 2021 (GLPI 11661)
	_sArqLog := 'GLPI11661_' + alltrim (cusername) + '_' + dtos (date ()) + ".log"
	_sSafra := '2021'
	_nVlrKg := 0.02
	_sTM := '16'
	_sOrigSZI := 'GLPI11661'
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += "SELECT N.ASSOCIADO, N.LOJA_ASSOC, FILIAL, N.DOC, N.NOME_ASSOC, N.PRODUTO, N.DESCRICAO, N.GRAU, N.CLAS_ABD, SUM (N.PESO_LIQ) AS PESO_LIQ"
	_oSQL:_sQuery +=      ", SUM (N.VALOR_TOTAL) / SUM (N.PESO_LIQ) AS VL_UNIT_JA_COM_COMPLEMENTOS"
	_oSQL:_sQuery +=      ", SUM (N.PESO_LIQ) * " + cvaltochar (_nVlrKg) + " AS PREVISTO"
	_oSQL:_sQuery +=  " FROM VA_VNOTAS_SAFRA N"
	_oSQL:_sQuery += " WHERE N.SAFRA = '" + _sSafra + "'"
	_oSQL:_sQuery +=   " AND N.FINA_COMUM = 'C'"
	_oSQL:_sQuery +=   " and N.TIPO_ORGANICO != 'O'"
	_oSQL:_sQuery +=   " AND N.CLAS_ABD = 'A'"
	_oSQL:_sQuery +=   " AND NOT EXISTS (SELECT *" // Para nao gerar em duplicidade
	_oSQL:_sQuery +=                     " FROM " + RetSQLName ("SZI") + " SZI "
	_oSQL:_sQuery +=                    " WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=                      " AND ZI_ASSOC   = N.ASSOCIADO"
	_oSQL:_sQuery +=                      " AND ZI_LOJASSO = N.LOJA_ASSOC"
	_oSQL:_sQuery +=                      " AND ZI_TM      = '" + _sTM + "'"
	_oSQL:_sQuery +=                      " AND ZI_ORIGEM  = '" + _sOrigSZI + "')"
	_oSQL:_sQuery += " GROUP BY N.ASSOCIADO, N.LOJA_ASSOC, FILIAL, N.NOME_ASSOC, DOC, N.PRODUTO, N.DESCRICAO, N.GRAU, N.CLAS_ABD"
	_oSQL:_sQuery += " ORDER BY N.ASSOCIADO, N.LOJA_ASSOC, FILIAL, N.NOME_ASSOC, DOC, N.PRODUTO, N.DESCRICAO, N.GRAU, N.CLAS_ABD"
	_oSQL:Log ()
	_sAliasQ := _oSQL:Qry2Trb (.F.)
	U_Log2 ('debug', _oSQL:QtLinRet)
	do while ! (_sAliasQ) -> (eof ())
		_sFornece = (_sAliasQ) -> associado
		_sLoja = (_sAliasQ) -> loja_assoc
		u_log2 ('debug', 'iniciando forn/loja ' + _sFornece + _sLoja)
		_nTotForn = 0
		_sHistCpl = "Premiacao qualidade R$" + cvaltochar (_nVlrKg) + " por Kg ref:" + chr (13) + chr (10)
		do while ! (_sAliasQ) -> (eof ()) .and. (_sAliasQ) -> associado == _sFornece .and. (_sAliasQ) -> loja_assoc == _sLoja
			_nTotForn += (_sAliasQ) -> previsto
			_sLinHist = 'Fil/doc ' + (_sAliasQ) -> filial + '/' + (_sAliasQ) -> doc + " " + alltrim ((_sAliasQ) -> descricao) + ' gr.' + (_sAliasQ) -> grau + ' (' + cvaltochar ((_sAliasQ) -> peso_liq) + ' Kg)' + chr (13) + chr (10)
			if ! _sLinHist $ _sHistCpl
				_sHistCpl += _sLinHist
			endif
			(_sAliasQ) -> (dbskip ())
		enddo
		U_Log2 ('debug', _sHistCpl)
		_oCtaCorr := ClsCtaCorr():New ()
		_oCtaCorr:Assoc    = _sFornece
		_oCtaCorr:Loja     = _sLoja
		_oCtaCorr:TM       = _sTM
		_oCtaCorr:Safra    = _sSafra
		_oCtaCorr:DtMovto  = dDataBase
		_oCtaCorr:Valor    = _nTotForn
		_oCtaCorr:SaldoAtu = _nTotForn
		_oCtaCorr:Usuario  = cUserName
		_oCtaCorr:Histor   = 'PREMIACAO QUALIDADE SAFRA ' + _sSafra
		_oCtaCorr:MesRef   = strzero(month(_oCtaCorr:DtMovto),2)+strzero(year(_oCtaCorr:DtMovto),4)
		_oCtaCorr:Doc      = _sSafra + '11661'  // safra + numero chamado. Eu sou mesmo criativo, neh?
		_oCtaCorr:Serie    = 'OUT'
		_oCtaCorr:Parcela  = '1'
		_oCtaCorr:Origem   = _sOrigSZI
		_oCtaCorr:Obs      = _sHistCpl
		_oCtaCorr:VctoSE2  = stod ('20220228')
		if _oCtaCorr:PodeIncl ()
			if ! _oCtaCorr:Grava (.F., .F.)
				U_help ("Erro na atualizacao da conta corrente para o associado '" + _sFornece + '/' + _sLoja + "'. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg,, .t.)
			endif
		else
			U_help ("Gravacao do SZI nao permitida na atualizacao da conta corrente para o associado '" + _sFornece + '/' + _sLoja + "'. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg,, .T.)
		endif
		FreeObj (_oCtaCorr)
		//EXIT  // por enquanto quero gerar apenas um
	enddo
	FreeObj (_oSQL)
return
*/
static function _Sisdevin ()
	// Gera arq. Sisdeclara.
	cPerg := "ML_DEC"
	U_GravaSX1 (cPerg, "01", stod ("20240109"))
	U_GravaSX1 (cPerg, "02", stod ("20240112"))
	U_GravaSX1 (cPerg, "03", 1)  // 1=mov.mensal;2=entradas uvas
	U_GravaSX1 (cPerg, "04", 'teste robert')  // Nome diretor empresa
	U_GravaSX1 (cPerg, "05", '????????')  // CRQ - '05404198' = Hugo    '05403148' = Flavio
	U_GravaSX1 (cPerg, "06", 'c:\temp\Sisdevin_teste.txt')
	U_GravaSX1 (cPerg, "07", 'robert.koch@novaalianca.coop.br')
	U_GravaSX1 (cPerg, "08", 1)  // Gera arq conferencia (s/n)
	U_GravaSX1 (cPerg, "09", 2)  // Exporta guias? (s/n)
	U_GravaSX1 (cPerg, "10", '11422401/11128701')  // Lotes de PA a ignorar
	U_ML_DEC (.t.)
return

/*
	// Ajusta cadastro de representantes em lote
	sa3 -> (dbsetorder (1))
	sa3 -> (dbgotop ())
	do while ! sa3 -> (eof ())
		if sa3 -> a3_ativo == 'S' .and. sa3 -> a3_indeniz == 'S'
			u_log2 ('info', 'Verificando codigo ' + sa3 -> a3_cod)
				
			// Cria variaveis para uso na gravacao do evento de alteracao
			regtomemory ("SA3", .F., .F.)
			m->A3_INDENIZ = 'N'

			// Grava evento de alteracao
			_oEvento := ClsEvent():new ()
			_oEvento:AltCadast ("SA3", m->a3_cod, sa3 -> (recno ()), 'GLPI 11583 - Desab. 1/12 comissao', .F.)

			reclock ("SA3", .f.)
			sa3->A3_indeniz = m->A3_INDENIZ
			msunlock ()
			U_AtuMerc ("SA3", sa3 -> (recno ()))
		endif
		sa3 -> (dbskip ())
	enddo
return
*/
/*
	// Varre safra anterior simulando precos da nova safra, para ver se ficaria algum caso sem tratamento.
	_sPreNF := U_RetSQL ("SELECT MAX (ZZ9_PRE_NF) FROM ZZ9010 WHERE ZZ9_SAFRA = '2022'")
	_aPrecos := {}
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT *"
	_oSQL:_sQuery +=   " FROM VA_VNOTAS_SAFRA V"
	_oSQL:_sQuery +=  " WHERE SAFRA = '2022'"
	_oSQL:_sQuery +=  " ORDER BY PRODUTO, GRAU"
	_oSQL:Log ()
	_sAliasQ = _oSQL:Qry2Trb ()
	do while ! (_sAliasQ) -> (eof ())
		if (_sAliasQ) -> sist_conducao == 'E'
			_sClasFina = (_sAliasQ) -> clas_final
		elseif (_sAliasQ) -> sist_conducao == 'L'
			_sClasFina = (_sAliasQ) -> clas_abd
		endif
		_nPrcNovo = U_PrcUva22 ((_sAliasQ) -> filial, (_sAliasQ) -> produto, val ((_sAliasQ) -> grau), _sClasFina, (_sAliasQ) -> SIST_CONDUCAO, .F.)[2]
		U_Log2 ('info', transform ((_sAliasQ) -> VALOR_UNIT, "@E 999.9999") + '  ' + transform (_nPrcNovo, "@E 999.9999"))
		if _nPrcNovo != (_sAliasQ) -> VALOR_UNIT
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += "SELECT SZE.R_E_C_N_O_"
			_oSQL:_sQuery +=  " FROM " + RetSQLName ("SZE") + " SZE"
			_oSQL:_sQuery += " WHERE SZE.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND SZE.ZE_FILIAL  = '" + (_sAliasQ) -> filial + "'"
			_oSQL:_sQuery +=   " AND SZE.ZE_SAFRA   = '" + (_sAliasQ) -> safra + "'"
			_oSQL:_sQuery +=   " AND SZE.ZE_ASSOC   = '" + (_sAliasQ) -> associado + "'"
			_oSQL:_sQuery +=   " AND SZE.ZE_LOJASSO = '" + (_sAliasQ) -> loja_assoc + "'"
			_oSQL:_sQuery +=   " AND SZE.ZE_NFGER   = '" + (_sAliasQ) -> doc + "'"
			_oSQL:_sQuery +=   " AND SZE.ZE_SERIE   = '" + (_sAliasQ) -> serie + "'"
			_oSQL:_sQuery +=   " AND (SELECT COUNT (DISTINCT ZF_PRODUTO)"
			_oSQL:_sQuery +=          " FROM " + RetSQLName ("SZF") + " SZF"
			_oSQL:_sQuery +=         " WHERE SZF.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=           " AND SZF.ZF_FILIAL  = SZE.ZE_FILIAL"
			_oSQL:_sQuery +=           " AND SZF.ZF_SAFRA   = SZE.ZE_SAFRA"
			_oSQL:_sQuery +=           " AND SZF.ZF_CARGA   = SZE.ZE_CARGA) > 1"
			_nRegSZE := _oSQL:RetQry (1, .f.)
			if _nRegSZE > 0
				sze -> (dbgoto (_nRegSZE))
				U_Log2 ('aviso', 'Carga com mistura: ' + sze -> ze_carga)
				if ! empty (sze -> ze_obs)
					U_Log2 ('aviso', sze -> ze_obs)
				endif
			endif
			aadd (_aPrecos, {(_sAliasQ) -> filial, (_sAliasQ) -> associado, (_sAliasQ) -> loja_assoc, (_sAliasQ) -> doc, (_sAliasQ) -> serie, (_sAliasQ) -> data, (_sAliasQ) -> produto, val ((_sAliasQ) -> grau), _sClasFina, (_sAliasQ) -> SIST_CONDUCAO, (_sAliasQ) -> VALOR_UNIT, _nPrcNovo})

			reclock ("ZZ9", .T.)
			zz9 -> zz9_filial = (_sAliasQ) -> filial
			zz9 -> zz9_safra  = (_sAliasQ) -> safra
			zz9 -> zz9_grupo  = (_sAliasQ) -> grupo_pagto
			zz9 -> zz9_parcel = 'A'
			zz9 -> zz9_fornec = (_sAliasQ) -> associado
			zz9 -> zz9_loja   = (_sAliasQ) -> loja_assoc
			zz9 -> zz9_pre_nf = _sPreNF
			zz9 -> zz9_TipoNF = "C"
			zz9 -> zz9_produt = (_sAliasQ) -> produto
			zz9 -> zz9_grau   = (_sAliasQ) -> grau
			zz9 -> zz9_classe = (_sAliasQ) -> clas_final
			zz9 -> zz9_clabd  = (_sAliasQ) -> clas_abd
			zz9 -> zz9_conduc = (_sAliasQ) -> sist_conducao
			zz9 -> zz9_vunold = (_sAliasQ) -> VALOR_UNIT
			zz9 -> zz9_vunit2 = _nPrcNovo
			zz9 -> zz9_quant  = 0
			zz9 -> zz9_vunit  = (_nPrcNovo - (_sAliasQ) -> VALOR_UNIT) * (_sAliasQ) -> PESO_LIQ
			zz9 -> zz9_obs    = ''
			zz9 -> zz9_nfori  = (_sAliasQ) -> doc
			zz9 -> zz9_serior = (_sAliasQ) -> serie
			zz9 -> zz9_itemor = (_sAliasQ) -> item_nota
			zz9 -> zz9_mistu1 = ''
			zz9 -> zz9_mistu2 = ''
			zz9 -> zz9_mistu3 = ''
			zz9 -> zz9_msgNF  = 'Compl.safra 2022'
			zz9 -> zz9_TES    = U_TESSafra ('2022', (_sAliasQ) -> associado, (_sAliasQ) -> loja_assoc, 'V')
			msunlock ()
			_sPreNF = soma1 (soma1 (soma1 (soma1 (soma1 (_sPreNF)))))
		endif
		(_sAliasQ) -> (dbskip ())
	enddo
	U_Log2 ('debug', _aPrecos)
	u_acolsxls (_aPrecos)
return
*/
/* conferencia 4 falecidos que ficaram de fora na vez anterior
	// Gera pre-notas de complemento de safra 2020 apos atualizacao de tabelas de precos (glpi 9415)
	aHeader := {}
	aadd (aHeader, {"Nome"   , 'Nome'     , "", 30, 0, "", "", "C"})
	aadd (aHeader, {"Varied" , 'Variedade', "", 15, 0, "", "", "C"})
	aadd (aHeader, {"Descr"  , 'Descricao', "", 50, 0, "", "", "C"})
	aadd (aHeader, {"Peso"   , 'Peso_liq' , "", 9, 2, "", "", "N"})
	aadd (aHeader, {"Grau"   , 'Grau'     , "", 5, 0, "", "", "C"})
	aadd (aHeader, {"ClasEsp", 'Cl_espald', "", 2, 0, "", "", "C"})
	aadd (aHeader, {"ClasLat", 'Cl_latada', "", 2, 0, "", "", "C"})
	aadd (aHeader, {"VUnEfet", 'Vun_pago' , "", 9, 4, "", "", "N"})
	aadd (aHeader, {"VlNovo" , 'Vun_novo' , "", 9, 4, "", "", "N"})
	aadd (aHeader, {"VlClas" , 'Acr_clas' , "", 9, 2, "", "", "N"})
	aadd (aHeader, {"Obs"    , 'Obs'      , "", 100, 0, "", "", "C"})
	_sPreNF := U_RetSQL ("SELECT MAX (ZZ9_PRE_NF) FROM ZZ9010 WHERE ZZ9_SAFRA = '2020'")
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT V.*, B1_VARUVA, A2_NOME" //, ZZ9_NFCOMP, ZZ9_MISTU1, ZZ9_MISTU2, ZZ9_MISTU3, ZZ9_MSGNF"
	_oSQL:_sQuery +=      ", ISNULL (
	_oSQL:_sQuery +=       " (select top 1 R_E_C_N_O_"  // Busca ZZ9 para ter dados de mistura de variedades, por isso ordena-o para trazer as misturas antes.
	_oSQL:_sQuery +=          " FROM ZZ9010 ZZ9"
	_oSQL:_sQuery +=         " WHERE ZZ9.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_FILIAL = V.FILIAL"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_SAFRA  = V.SAFRA"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_NFCOMP != ''"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_FORNEC = V.ASSOCIADO"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_LOJA   = V.LOJA_ASSOC"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_NFCOMP = V.DOC"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_SERCOM = V.SERIE"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_PRODUT = V.PRODUTO"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_GRAU   = V.GRAU"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_CLASSE = V.CLAS_FINAL"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_CLABD  = V.CLAS_ABD"
	_oSQL:_sQuery +=         " ORDER BY ZZ9_FILIAL, ZZ9_SAFRA,ZZ9_FORNEC,ZZ9_LOJA,ZZ9_NFCOMP,ZZ9_SERCOM,ZZ9_PRODUT,ZZ9_CLASSE,ZZ9_CLABD, ZZ9_MISTU1 desc, ZZ9_MISTU2 desc, ZZ9_MISTU3 desc, ZZ9_MSGNF desc"
	_oSQL:_sQuery +=        "), 0) AS REGZZ9"
	_oSQL:_sQuery +=   " FROM SB1010 SB1, SA2010 SA2, VA_VPRECO_EFETIVO_SAFRA V"
	_oSQL:_sQuery +=  " WHERE SAFRA = '2020'"
	_oSQL:_sQuery +=   " AND ASSOCIADO IN ('002779','002533','002714','002635')

	_oSQL:_sQuery +=    " AND SB1.D_E_L_E_T_ = '' AND B1_FILIAL = '  ' AND B1_COD = V.PRODUTO"
	_oSQL:_sQuery +=    " AND SA2.D_E_L_E_T_ = '' AND A2_FILIAL = '  ' AND A2_COD = V.ASSOCIADO AND A2_LOJA = V.LOJA_ASSOC"
	_oSQL:_sQuery +=  " ORDER BY SAFRA, FILIAL, ASSOCIADO, LOJA_ASSOC, PRODUTO, DESCRICAO, GRAU, CLAS_FINAL, CLAS_ABD, SIST_CONDUCAO, GRUPO_PAGTO"
	_oSQL:Log ()
	_sAliasQ = _oSQL:Qry2Trb ()
	_aPrev = {}
	do while ! (_sAliasQ) -> (eof ())
		_nVlClas = 0
		_sObs = ''
		if (_sAliasQ) -> regZZ9 = 0
			U_Log2 ('erro', 'Nao achei ZZ9 para filial/doc ' + (_sAliasQ) -> filial + '/' + (_sAliasQ) -> doc)
		else
			zz9 -> (dbgoto ((_sAliasQ) -> regZZ9))
			_sMistu1 = zz9 -> zz9_mistu1
			_sMistu2 = zz9 -> zz9_mistu2
			_sMistu3 = zz9 -> zz9_mistu3

			if (_sAliasQ) -> sist_conducao == 'E'
				_sClasFina = (_sAliasQ) -> clas_final
			elseif (_sAliasQ) -> sist_conducao == 'L'
				_sClasFina = (_sAliasQ) -> clas_abd
			endif

			// Verifica se teve mistura de variedades.
			_nPreco = U_PrcUva20 ((_sAliasQ) -> filial, (_sAliasQ) -> produto, val ((_sAliasQ) -> grau), _sClasFina, (_sAliasQ) -> SIST_CONDUCAO, .F.)[2]
			if ! empty (_sMistu1)
				_nPrecoM1 = U_PrcUva20 ((_sAliasQ) -> filial, _sMistu1, val ((_sAliasQ) -> grau), _sClasFina, (_sAliasQ) -> SIST_CONDUCAO, .F.)[2]
				if _nPrecoM1 < _nPreco
					_nPreco = _nPrecoM1
					_sObs = 'Mist.varied1-Precificando como ' + alltrim (fBuscaCpo ("SB1", 1, xFilial ("SB1") + _sMistu1, 'B1_DESC'))
				endif
			endif
			if ! empty (_sMistu2)
				_nPrecoM2 = U_PrcUva20 ((_sAliasQ) -> filial, _sMistu2, val ((_sAliasQ) -> grau), _sClasFina, (_sAliasQ) -> SIST_CONDUCAO, .F.)[2]
				if _nPrecoM2 < _nPreco
					_nPreco = _nPrecoM2
					_sObs = 'Mist.varied2-Precificando como ' + alltrim (fBuscaCpo ("SB1", 1, xFilial ("SB1") + _sMistu2, 'B1_DESC'))
				endif
			endif
			if ! empty (_sMistu3)
				_nPrecoM3 = U_PrcUva20 ((_sAliasQ) -> filial, _sMistu3, val ((_sAliasQ) -> grau), _sClasFina, (_sAliasQ) -> SIST_CONDUCAO, .F.)[2]
				if _nPrecoM3 < _nPreco
					_nPreco = _nPrecoM3
					_sObs = 'Mist.varied3-Precificando como ' + alltrim (fBuscaCpo ("SB1", 1, xFilial ("SB1") + _sMistu3, 'B1_DESC'))
				endif
			endif

			// Premiacao/incentivo por qualidade
			if (_sAliasQ) -> b1_varuva == 'C'

				// Solicitado por Rodrigo (e-mail) em 22/02/2021: Moscato Embrapa nao ganha classificacao.
				if ! alltrim ((_sAliasQ) -> produto) $ '9918/9838/9837/9836'

					if alltrim ((_sAliasQ) -> clas_abd) == 'A'
						_nVlClas = 0.05
					elseif alltrim ((_sAliasQ) -> clas_abd) == 'B'
						_nVlClas = 0.02  //0.03
					endif
				endif
			endif

			aadd (_aPrev, {(_sAliasQ) -> a2_nome,;
						(_sAliasQ) -> produto,;
						(_sAliasQ) -> descricao,;
						(_sAliasQ) -> peso_liq,;
						(_sAliasQ) -> grau,;
						(_sAliasQ) -> clas_final,;
						(_sAliasQ) -> clas_abd,;
						(_sAliasQ) -> vunit_efetivo,;
						_nPreco,;
						_nVlClas,;
						_sObs})

			// Gera somente se tiver valor a pagar
			_nAPagar = (_sAliasQ) -> peso_liq * (_nPreco + _nVlClas) - (_sAliasQ) -> peso_liq * (_sAliasQ) -> vunit_efetivo
			//	U_Log (left ((_sAliasQ) -> a2_nome, 30) + (_sAliasQ) -> produto + (_sAliasQ) -> descricao + (_sAliasQ) -> grau + (_sAliasQ) -> clas_final + (_sAliasQ) -> clas_abd + transform ((_sAliasQ) -> vunit_efetivo, '@E 999.9999') + transform (_nPreco, '@E 999.9999') + transform ((_sAliasQ) -> peso_liq * _nPreco, '@E 999,999.99'))

			if (_sAliasQ) -> grupo_pagto != U_VA_RusGP ((_sAliasQ) -> safra, (_sAliasQ) -> produto, (_sAliasQ) -> sist_conducao)
				U_Log2 ('erro', 'grupo ant: ' + (_sAliasQ) -> grupo_pagto + ' novo: ' + U_VA_RusGP ((_sAliasQ) -> safra, (_sAliasQ) -> produto, (_sAliasQ) -> sist_conducao))
			endif

			// reclock ("ZZ9", .T.)
			// zz9 -> zz9_filial = (_sAliasQ) -> filial
			// zz9 -> zz9_safra  = (_sAliasQ) -> safra
			// zz9 -> zz9_grupo  = (_sAliasQ) -> grupo_pagto
			// zz9 -> zz9_parcel = 'K'
			// zz9 -> zz9_fornec = (_sAliasQ) -> associado
			// zz9 -> zz9_loja   = (_sAliasQ) -> loja_assoc
			// zz9 -> zz9_pre_nf = _sPreNF
			// zz9 -> zz9_TipoNF = "C"
			// zz9 -> zz9_produt = (_sAliasQ) -> produto
			// zz9 -> zz9_grau   = (_sAliasQ) -> grau
			// zz9 -> zz9_classe = (_sAliasQ) -> clas_final
			// zz9 -> zz9_clabd  = (_sAliasQ) -> clas_abd
			// zz9 -> zz9_conduc = (_sAliasQ) -> sist_conducao
			// zz9 -> zz9_vunold = (_sAliasQ) -> vunit_efetivo
			// zz9 -> zz9_quant  = 0
			// zz9 -> zz9_vunit  = _nAPagar
			// zz9 -> zz9_vunit2 = _nPreco  // para facilitar na planilha de conferencia
			// zz9 -> zz9_vunit3 = _nVlClas  // para facilitar na planilha de conferencia
			// zz9 -> zz9_obs    = _sObs
			// zz9 -> zz9_nfori  = (_sAliasQ) -> doc
			// zz9 -> zz9_serior = (_sAliasQ) -> serie
			// zz9 -> zz9_itemor = (_sAliasQ) -> item_nota
			// zz9 -> zz9_mistu1 = _sMistu1
			// zz9 -> zz9_mistu2 = _sMistu2
			// zz9 -> zz9_mistu3 = _sMistu3
			// zz9 -> zz9_msgNF  = 'Compl.safra 2020'
			// zz9 -> zz9_TES    = '312'
			// msunlock ()
			// _sPreNF = soma1 (soma1 (soma1 (soma1 (soma1 (_sPreNF)))))
		endif
		(_sAliasQ) -> (dbskip ())
	enddo
	u_acolsxls (_aprev)
return
*/

// --------------------------------------------------------------------------
static function _SimCtb ()
	// Simula contabilizacoes
	cPerg := "SIMULCTB"
	U_GravaSX1 (cPerg, '01', stod ('20220701'))  // Data inicial
	U_GravaSX1 (cPerg, '02', stod ('20220831'))  // Data final
	U_GravaSX1 (cPerg, '03', '666')  // Quais LPAD (bco=todos)
//	U_GravaSX1 (cPerg, '03', '678')  // Quais LPAD (bco=todos)
	U_GravaSX1 (cPerg, '04', 'SD3')  // Quais tabelas ex: SD1/SD2/SD3
	U_GravaSX1 (cPerg, '05', '')  // Filtro adicional (em SQL) para tabela SD1
	U_GravaSX1 (cPerg, '06', '')  // Filtro adicional (em SQL) para tabela SD2
	U_GravaSX1 (cPerg, '07', "D3_CF IN (''RE0'',''RE1'') and D3_OP=''''")  // Filtro adicional (em SQL) para tabela SD3
	U_SimulCTB ()
return

/*
	// Testes recontabilizacao NF e titulos.
	cPerg = "ML_LCNF"
	_sArqLog := 'VA_LCNF_' + alltrim (cusername) + '_' + dtos (date ()) + ".log"
	U_GravaSX1 (cPerg, '01', 2)  // Recontabilizar o que           [NF Entrada, NF Saida, Movto.bancario]
	U_GravaSX1 (cPerg, '02', stod ('20211116'))  // Data inicial
	U_GravaSX1 (cPerg, '03', stod ('20211116'))  // Data final
	U_GravaSX1 (cPerg, '04', '508789')  // Nro (docto/NF/titulo) inicial
	U_GravaSX1 (cPerg, '05', '508789')  // Nro (docto/NF/titulo) final
	U_GravaSX1 (cPerg, '06', '')   // Banco (quando mov.banc)inicial
	U_GravaSX1 (cPerg, '07', 'z')  // Banco (quando mov.banc)final
	U_GravaSX1 (cPerg, '08', '')   // Agen. (quando mov.banc)inicial
	U_GravaSX1 (cPerg, '09', 'z')  // Agen. (quando mov.banc)final
	U_GravaSX1 (cPerg, '10', '')   // Conta (quando mov.banc)inicial
	U_GravaSX1 (cPerg, '11', 'z')  // Conta (quando mov.banc)final
	U_GravaSX1 (cPerg, '12', 1)    // Apenas CNAB (quando mov.banc) [So CNAB, Exceto CNAB, Todos]
	U_GravaSX1 (cPerg, '13', 2)    // Simular ou Executar           [Simular, Executar]
	u_va_lcnf (.t.)
return
*/
/* Nao vamos usar agora
User Function STMenu()
	Local _aRetMPDV := {}
	AAdd (_aRetMPDV, {"Alianca-Tabela precos", "U_STMenuTP ()"})
	//aRet[1][1] - Se Refere: ao Nome no Menu mostrado ao usuário
	//aRet[1][2] - Se Refere: à função que sera executada
Return _aRetMPDV
user function STMenuTP ()
	local _aTabPrc   := {}
	local _aCols     := {}
	public _nTabPrPDV  := 0
	aadd (_aTabPrc, {1, 'Gondola'})
	aadd (_aTabPrc, {2, 'Caixa fechada'})
	aadd (_aTabPrc, {3, 'Funcionarios / associados'})
	aadd (_aTabPrc, {5, 'Feirinha'})
	aadd (_aTabPrc, {7, 'Promocoes'})
	aadd (_aCols, {1, 'Tabela', 30, ''})
	aadd (_aCols, {2, 'Descricao', 100, ''})
	_nTabPrPDV = u_F3Array (_aTabPrc, 'Selecione tabela de precos', _aCols, 400, 300)
	if _nTabPrPDV > 0
		// Preciso pegar o numero da lista de precos que encontra-se na primeira coluna da array de opcoes mostradas ao usuario.
		_nTabPrPDV = _aTabPrc [_nTabPrPDV, 1]
	endif
	U_Log2 ('debug', 'Tabela de preco a ser usada: ' + cvaltochar (_nTabPrPDV))
return
*/


/*
	// Testes geracao XML
	paramixb := array (3, 7)
	_aNotas = {}
	//              Tipo  Serie    NF        CliFor    Loja
	// aadd (_aNotas, {'2', '10 ',   '000059408', '012732', '01', '', ''})  // F01 - Saida tipo I
	// aadd (_aNotas, {'2', '10 ',   '000059248', '014381', '01', '', ''})  // F01 - Exportacao
	//aadd (_aNotas, {'1', '10 ',   '000092506', '008478', '01', '', ''})  // F01 - Saida com ST para UF=MG
	//aadd (_aNotas, {'1', '10 ',   '000094484', '009830', '01', '', ''})  // F01 - Saida com ST para UF=PR
	//aadd (_aNotas, {'1', '10 ',   '000093720', '013301', '01', '', ''})  // F01 - Saida com ST para UF=PR
	//aadd (_aNotas, {'1', '10 ',   '000093920', '007492', '01', '', ''})  // F01 - Saida com ST para UF=RJ
	//aadd (_aNotas, {'1', '10 ',   '000087045', '005780', '01', '', ''})  // F01 - Saida com ST para UF=RS
	//aadd (_aNotas, {'1', '10 ',   '000094403', '015085', '01', '', ''})  // F01 - Saida com ST para UF=RS
	//aadd (_aNotas, {'1', '10 ',   '000094408', '002086', '01', '', ''})  // F01 - Saida com ST para UF=SC
	//aadd (_aNotas, {'1', '10 ',   '000093852', '010810', '01', '', ''})  // F01 - Saida com ST para UF=SC
	//aadd (_aNotas, {'1', '10 ',   '000087040', '014978', '01', '', ''})  // F01 - Saida com ST para UF=SP
	//aadd (_aNotas, {'1', '10 ',   '000094379', '016674', '01', '', ''})  // F01 - Saida com ST para UF=SP
	//aadd (_aNotas, {'2', '10 ',   '000004108', '015225', '01', '', ''})  // F03 - Entrada consignacao com ST
//	aadd (_aNotas, {'2', '10 ',   '000097924', '003882', '01', '', ''})  // F01 - Importacao
//	aadd (_aNotas, {'1', '10 ',   '000009508', '017469', '01', '', ''})  // F10 - Saida com impostos.
//	aadd (_aNotas, {'1', '10 ',   '000102422', '004478', '01', '', ''})  // F01 - Saida tipo B.
//	aadd (_aNotas, {'1', '10 ',   '000106732', '002942', '01', '', ''})  // F01 - Saida com fundo erradicacao pobreza.
//	aadd (_aNotas, {'1', '10 ',   '000105551', '014639', '01', '', ''})  // F01 - Saida com fundo erradicacao pobreza.
//	aadd (_aNotas, {'1', '10 ',   '000125643', '009189', '01', '', ''})  // F01 - Saida com transp. redespacho
//	aadd (_aNotas, {'1', '10 ',   '000125646', '009189', '01', '', ''})  // F01 - Saida com transp. redespacho
//	aadd (_aNotas, {'1', '10 ',   '000159196', '005410', '01', '', ''})  // F01 - Saida com dados adicionais do contribuinte e do fisco.
//	aadd (_aNotas, {'1', '10 ',   '000160432', '024238', '01', '', ''})  // F01 - Saida com dados adicionais do contribuinte e do fisco + redespacho.
//	aadd (_aNotas, {'1', '10 ',   '000160414', '023635', '01', '', ''})  // F01 - Entrada
//	aadd (_aNotas, {'1', '10 ',   '000160473', '005116', '01', '', ''})  // F01 - Saida com AMPARA
//	aadd (_aNotas, {'1', '10 ',   '000195265', '005026', '01', '', ''})  // F01 - Saida para SP com tag do intermediador - emissao 03/09/2021
//	aadd (_aNotas, {'1', '001',   '048515   ', '000000', '01', '', ''})  // F13 - Cupom com pagto.cartao de credito - emissao 03/09/2021
//	aadd (_aNotas, {'2', '10 ',   '000193785', '018465', '01', '', ''})  // F01 - Entrada da BA c/formul.proprio - emissao 02/08/2021
	aadd (_aNotas, {'1', '10 ',   '000194467', '035012', '01', '', ''})  // F01 - Saida com endereco e complemento no cliente - emissao 08/2021
	aadd (_aNotas, {'1', '10 ',   '000193892', '034057', '01', '', ''})  // F01 - Saida com endereco e complemento no cliente - emissao 08/2021
	
	for _nDado = 1 to len (_aNotas)
		u_logIni (_aNotas [_nDado, 3])
		PARAMIXB[1,1] = _anotas [_nDado, 1]
		PARAMIXB[1,3] = _anotas [_nDado, 2]
		PARAMIXB[1,4] = _anotas [_nDado, 3]
		PARAMIXB[1,5] = _anotas [_nDado, 4]
		PARAMIXB[1,6] = _anotas [_nDado, 5]
		PARAMIXB[1,7] = ''
		PARAMIXB[2] = "3.10"
		PARAMIXB[3] = '1'  // 1=producao, 2=homologacao
		U_XmlNfeSEF (_aNotas [_nDado, 1], _aNotas [_nDado, 2], _aNotas [_nDado, 3], _aNotas [_nDado, 4], _aNotas [_nDado, 5], _aNotas [_nDado, 6], _aNotas [_nDado, 7])
		u_logFim (_aNotas [_nDado, 3])
	next
return
*/
/*
	// GLPI 10637 - cria relacionamento produtos manutencao com o AX 02
	sb1 -> (dbgotop ())
	do while ! sb1 -> (eof ())
		if left (sb1 -> b1_cod, 1) == '6'
			if alltrim (sb1 -> b1_cod) $ '600200C/600294/606253C/600336/601041C/604425C/606261C/606196C/604363C/601173/600155C/604689C/606225C/600230C/604667C/6062693C/606302C/600142C/604563C/604564C/604565C/604667C/606291C/604705C/604642C' ;
			.or. alltrim (sb1 -> b1_cod) $ '600084C/606200C/600184C/606226C/606214C/600071C/600183C/606213C/600065C/606206C/600201C/600172C/600202C/606234C/600199C/606224C/601062C/606237C/600284C/600324C/606235C/606239C/606197C/606208C/606236C/603977C'
				U_Log2 ('debug',  sb1 -> b1_cod)
				CriaSB2 (sb1 -> b1_cod, '02')
			endif
		endif
		sb1 -> (dbskip ())
	enddo
return

/*
	// Tivemos um grupo de titulos que nao recontabiliza por que ficou gravado numero de CNAB (GLPI 10644)
	_sArqLog := 'GLPI_10644.log'
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "select SE5.R_E_C_N_O_"
	_oSQL:_sQuery += " FROM SE5010 SE5"
	_oSQL:_sQuery += " WHERE SE5.D_E_L_E_T_ = '' AND E5_FILIAL = '01' AND E5_DATA = '20210730' AND SE5.E5_PREFIXO = '30 ' AND SE5.E5_RECPAG = 'P'"
	_oSQL:_sQuery += " AND NOT EXISTS (SELECT * FROM CT2010 CT2 "
	_oSQL:_sQuery +=                  " WHERE CT2.D_E_L_E_T_ = '' AND CT2.CT2_FILIAL = SE5.E5_FILIAL AND CT2.CT2_DATA = SE5.E5_DATA AND CT2.CT2_KEY LIKE SE5.E5_FILIAL + SE5.E5_TIPODOC + SE5.E5_PREFIXO + SE5.E5_NUMERO + SE5.E5_PARCELA + SE5.E5_TIPO + SE5.E5_DATA)"
	_aDados = ACLONE (_oSQL:Qry2Array (.f., .f.))
	for _nDado = 1 to len (_aDados)
		se5 -> (dbgoto (_aDados [_nDado, 1]))
		U_Log2 ('debug', SE5 -> E5_NUMERO + ' ' + SE5 -> E5_BENEF)
		_oEvento := ClsEvent():new ()
		_oEvento:CodEven   = "SE5001"
		_oEvento:Texto     = "Limpando campo E5_LA e E5_DOCUMEN (GLPI 10644)"
		_oEvento:Recno     = se5 -> (recno ())
		_oEvento:Alias     = 'SE5'
		_oEvento:CodAlias  = se5 -> e5_prefixo + se5 -> e5_numero + se5 -> e5_parcela
		_oEvento:Grava ()
		reclock ("SE5", .F.)
		se5 -> e5_documen = ''
		se5 -> e5_la = ""
		msunlock ()
		if ! empty (se5 -> e5_idorig)
			fk2 -> (dbsetorder (1))  // FK2_FILIAL, FK2_IDFK2, R_E_C_N_O_, D_E_L_E_T_
			if fk2 -> (dbseek (xfilial ("FK2") + se5 -> e5_idorig, .F.))
				U_Log2 ('debug', 'Encontrei FK2')
				_oEvento := ClsEvent():new ()
				_oEvento:CodEven   = "FK2001"
				_oEvento:Texto     = "Limpando campo FK2_LA e FK2_DOC (GLPI 10644)"
				_oEvento:Recno     = fk2 -> (recno ())
				_oEvento:Alias     = 'FK2'
				_oEvento:CodAlias  = fk2 -> fk2_idfk2
				_oEvento:Grava ()
				reclock ("FK2", .f.)
				fk2 -> fk2_la = ''
				fk2 -> fk2_doc = ''
				msunlock ()
				fka -> (dbsetorder (3))  // FKA_FILIAL, FKA_TABORI, FKA_IDORIG, R_E_C_N_O_, D_E_L_E_T_
				if fka -> (dbseek (xfilial ("FKA") + 'FK2' + fk2 -> fk2_idfk2, .F.))
					U_Log2 ('debug', 'Encontrei FKA')
					_sIdFKA = fka -> fka_idproc
					fka -> (dbsetorder (2))  // FKA_FILIAL, FKA_IDPROC, FKA_IDORIG, FKA_TABORI, R_E_C_N_O_, D_E_L_E_T_
					fka -> (dbseek (xfilial ("FKA") + _sIdFKA, .T.))
					do while ! fka -> (eof ()) .and. fka -> fka_filial == xfilial ("FKA") .and. fka -> fka_idproc == _sIdFKA
						if fka -> fka_tabori == 'FK5'
							U_Log2 ('debug', 'Procurando FK5 com ID = ' + fka -> fka_idorig)
							fk5 -> (dbsetorder (1))  // FK5_FILIAL, FK5_IDMOV, R_E_C_N_O_, D_E_L_E_T_
							if fk5 -> (dbseek (xfilial ("FK5") + fka -> fka_idorig, .F.))
								U_Log2 ('debug', 'Encontrei FK5')
								_oEvento := ClsEvent():new ()
								_oEvento:CodEven   = "FK5001"
								_oEvento:Texto     = "Limpando campo FK5_LA e FK5_DOC (GLPI 10644)"
								_oEvento:Recno     = fk5 -> (recno ())
								_oEvento:Alias     = 'FK5'
								_oEvento:CodAlias  = fk5 -> fk5_idmov
								_oEvento:Grava ()
								reclock ("FK5", .f.)
								fk5 -> fk5_la = ''
								fk5 -> fk5_doc = ''
								msunlock ()
							endif
						endif
						fka -> (dbskip ())
					enddo
				endif
			endif
		endif
	next
return
*/
/*	// Teste inclusao de PA
	private _SZI_Bco   := '001'   // Inicializador padrao do campo A6_COD
	private _SZI_Age   := '3412'  // Inicializador padrao do campo A6_AGENCIA
	private _SZI_Cta   := '32972' // Inicializador padrao do campo A6_NUMCON

	_aAutoSE2 := {}
	aadd (_aAutoSE2, {"E2_PREFIXO", 'TST',           NIL})
	aadd (_aAutoSE2, {"E2_NUM"    , 'GLPI10494',             Nil})
	aadd (_aAutoSE2, {"E2_TIPO"   , 'PA',        Nil})
	aadd (_aAutoSE2, {"E2_FORNECE", '000161',           Nil})
	aadd (_aAutoSE2, {"E2_LOJA"   , '01',            Nil})
	aadd (_aAutoSE2, {"E2_EMISSAO", date (),         Nil})
	aadd (_aAutoSE2, {"E2_VENCTO" , date (),          Nil})
	aadd (_aAutoSE2, {"E2_VENCREA", date (),    Nil})
	aadd (_aAutoSE2, {"E2_VALOR"  , 1,           Nil})
	aadd (_aAutoSE2, {"E2_HIST"   , 'teste geracao automatica PA',          Nil})
	aadd (_aAutoSE2, {"E2_PARCELA", '1',         Nil})
	aadd (_aAutoSE2, {"E2_VACHVEX", 'GLPI10494',           Nil})
	aadd (_aAutoSE2, {"E2_ORIGEM" , "FINA050" ,        Nil})
	aadd (_aAutoSE2, {"AUTBANCO"  , "001" ,        Nil})
	aadd (_aAutoSE2, {"AUTAGENCIA", "3412" ,        Nil})
	aadd (_aAutoSE2, {"AUTCONTA"  , "32972" ,        Nil})
	lMsErroAuto	:=	.f.
	lMsHelpAuto	:=	.f.
	dbselectarea ("SE2")
	dbsetorder (1)
	MsExecAuto({ | x,y,z | Fina050(x,y,z) }, _aAutoSE2,, 3)
	if lMsErroAuto
		MostraErro ()
	endif
return
*/
/*
	// Ajusta cadastro fornecedores em lote
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT SA2.R_E_C_N_O_"
	_oSQL:_sQuery +=   " FROM " + RetSQLName ("SA2") + " SA2 "
	_oSQL:_sQuery +=  " WHERE SA2.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=    " AND SA2.A2_FILIAL = '" + xfilial ("SA2") + "'"
	_oSQL:_sQuery +=    " AND EXISTS (SELECT * FROM VA_VNOTAS_SAFRA WHERE ASSOCIADO = SA2.A2_COD AND LOJA_ASSOC = SA2.A2_LOJA)"
	_oSQL:_sQuery +=    " AND (A2_RECINSS != 'S' OR A2_TPESSOA != 'PF' OR A2_TIPORUR != 'F')"
	_oSQL:_sQuery +=  " ORDER BY A2_COD"
	_oSQL:Log ()
	_aDados = _oSQL:Qry2Array ()
	//u_log (_aDados)
	for _i = 1 to len (_aDados)
		sa2 -> (dbgoto (_aDados [_i, 1]))
		u_log2 ('info', 'Verificando forn ' + sa2 -> a2_cod + ' ' + Sa2 -> a2_nome)
		// Cria variaveis para uso na gravacao do evento de alteracao
		regtomemory ("SA2", .F., .F.)
		m->A2_RECINSS = 'S'
		m->A2_TPESSOA = 'PF'
		m->A2_TIPORUR = 'F'  // Senao, nao calcula FUNRURAL

		// Grava evento de alteracao
		_oEvento := ClsEvent():new ()
		_oEvento:AltCadast ("SA2", m->a2_cod + m->a2_loja, sa2 -> (recno ()), 'GLPI 10007 - Calcular FUNRURAL', .F.)

		reclock ("SA2", .f.)
		sa2 -> a2_recinss = m->a2_recinss
		sa2 -> A2_TPESSOA = m->A2_TPESSOA
		sa2 -> A2_TIPORUR = m->A2_TIPORUR
		msunlock ()
		U_AtuMerc ("SA2", sa2 -> (recno ()))
		//exit
	next

	// Ajusta cadastro de TES em lote (apenas aqueles que sao usados na compra de safra)
	sf4 -> (dbsetorder (1))
	sf4 -> (dbgotop ())
	do while ! sf4 -> (eof ())
		if sf4 -> f4_codigo $ '310/311/312/313/314' .and. (sf4->F4_CONTSOC != '1' .or. sf4->F4_ALSENAR != 0 .or. sf4->F4_BSRURAL != '2')
			u_log2 ('info', 'Verificando TES ' + sf4 -> f4_codigo)
				
			// Cria variaveis para uso na gravacao do evento de alteracao
			regtomemory ("SF4", .F., .F.)
			m->F4_CONTSOC = '1'
			m->F4_ALSENAR = 0
			m->F4_BSRURAL = '2'
				
			// Grava evento de alteracao
			_oEvento := ClsEvent():new ()
			_oEvento:AltCadast ("SF4", m->f4_codigo, sf4 -> (recno ()), 'GLPI 10007 - Calcular FUNRURAL', .F.)

			reclock ("SF4", .f.)
			SF4->F4_CONTSOC = m->F4_CONTSOC
			SF4->F4_ALSENAR = m->F4_ALSENAR
			SF4->F4_BSRURAL = m->F4_BSRURAL
			msunlock ()
			U_AtuMerc ("SF4", sF4 -> (recno ()))
		endif
		sf4 -> (dbskip ())
	enddo

	// Ajusta cadastro de naturezas em lote (apenas aquelas que sao usadas na compra de safra)
	sed -> (dbsetorder (1))
	sed -> (dbgotop ())
	do while ! sed -> (eof ())
		if alltrim (sed -> ed_codigo) $ '120201/120209/120236' .and. (sed->ED_CALCINS != 'N' .or. sed->ED_PERCINS != 0 .or. sed->ED_BASEINS != 0 .or. sed->ED_DEDINSS != '2')
			u_log2 ('info', 'Verificando natureza ' + sed -> ed_codigo)
				
			// Cria variaveis para uso na gravacao do evento de alteracao
			regtomemory ("SED", .F., .F.)
			m->ED_CALCINS = 'N'
			m->ED_PERCINS = 0
			m->ED_BASEINS = 0
			m->ED_DEDINSS = '2'  // Em todos os testes que fizemos, 1 ou 2 sempre deduzia.
				
			// Grava evento de alteracao
			_oEvento := ClsEvent():new ()
			_oEvento:AltCadast ("SED", m->ed_codigo, sed -> (recno ()), 'GLPI 10007 - Calcular FUNRURAL', .F.)

			reclock ("SED", .f.)
			sed->ED_CALCINS = m->ED_CALCINS
			sed->ED_PERCINS = m->ED_PERCINS
			sed->ED_BASEINS = m->ED_BASEINS
			sed->ED_DEDINSS = m->ED_DEDINSS
			msunlock ()
			U_AtuMerc ("SED", sed -> (recno ()))
		endif
		sed -> (dbskip ())
	enddo
return
*/
/*
	// Testes classe extrato CC
	_aAssoc = {}
	aadd (_aAssoc, '002378')  // tem compensacao com outro associado
	aadd (_aAssoc, '001071')  // Silvana Crocoli - tem compensacao com Luis Crocoli em 2012
	aadd (_aAssoc, '001104')  // Mateus Tansini - hist.compens.incompleto para titulo ADT/300316
	aadd (_aAssoc, '001287')  // Ricardo Frassini - tem compens.tit.de Ricardo Fabian em 2012 e de Maria Frassini em 2018
	for _nAssoc = 1 to len (_aAssoc)
		_oExtr := ClsExtrCC ():New ()
		_oExtr:Cod_assoc = _aAssoc [_nAssoc]
		_oExtr:Loja_assoc = '01'
		_oExtr:DataIni = stod ('20170101')
		_oExtr:DataFim = stod ('20491231')
		_oExtr:TMIni = ''
		_oExtr:TMFim = 'zz'
		_oExtr:LerObs = .F.
		_oExtr:LerComp3os = .t.
		_oExtr:TipoExtrato = 'N'
		_oExtr:TMPorVcto = '13'
		//_oExtr:FormaResult = 'N'
		//_oExtr:Gera ()
		//u_log ('Extrato retornado:', _oExtr:Resultado)
		u_log (_oExtr:UltMsg)
		_oExtr:FormaResult = 'A'
		_oExtr:Gera ()
		u_log (_oExtr:Resultado)
	next
return
*/
/*
	// Gera conta 'PREMIACAO QUALIDADE E FIDELIDADE' na corrente a partir de dados prontos na tabela ZZ9 (GLPI 9415)
	dDataBase = stod ('20210223')
	_sArqLog := 'GLPI9415_' + alltrim (cusername) + '_' + dtos (date ()) + ".log"
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "WITH C AS ("
	_oSQL:_sQuery += "SELECT ZZ9.R_E_C_N_O_ as regZZ9, ZZ9_SAFRA, ZZ9_FILIAL, ZZ9_FORNEC, ZZ9_LOJA, ZZ9_NFORI, B1_DESC"
	_oSQL:_sQuery +=      " ,(SELECT PESO_LIQ"  // BUSCO NA NOTA ORIGINAL POR QUE NESTE MOMENTO O ZZ9_QUANT ESTAH ZERADO (NF COMPLEMENTO PRECO)
	_oSQL:_sQuery +=          " FROM VA_VNOTAS_SAFRA V"
	_oSQL:_sQuery +=         " WHERE V.SAFRA = ZZ9.ZZ9_SAFRA"
	_oSQL:_sQuery +=           " AND V.FILIAL = ZZ9_FILIAL"
	_oSQL:_sQuery +=           " AND V.DOC = ZZ9_NFORI"
	_oSQL:_sQuery +=           " AND V.ITEM_NOTA = ZZ9_ITEMOR"
	_oSQL:_sQuery +=           " AND V.ASSOCIADO = ZZ9_FORNEC"
	_oSQL:_sQuery +=           " AND V.LOJA_ASSOC = ZZ9_LOJA) as PESO_LIQ"
	_oSQL:_sQuery +=      ",ZZ9_VUNOLD AS VUN_PAGO"
	_oSQL:_sQuery +=      ",ZZ9_VUNIT2 AS VUN_NOVO"
	_oSQL:_sQuery +=      ",ZZ9_VUNIT3 AS ACR_CLAS"
	_oSQL:_sQuery +=      ",ZZ9.ZZ9_OBS AS OBS"
	_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZZ9") + " ZZ9, "
	_oSQL:_sQuery +=             RetSQLName ("SB1") + " SB1, "
	_oSQL:_sQuery +=             RetSQLName ("SA2") + " SA2 "
	_oSQL:_sQuery += " WHERE ZZ9.D_E_L_E_T_ = ''"
	//_oSQL:_sQuery += " AND ZZ9.ZZ9_FILIAL = '" + xfilial ("ZZ9") + "'"
	_oSQL:_sQuery += " AND ZZ9_SAFRA = '2020'"
	_oSQL:_sQuery += " AND ZZ9_PARCEL = 'K'"
	_oSQL:_sQuery += " AND ZZ9_NFCOMP = ''"

//	_oSQL:_sQuery += " AND ZZ9_FORNEC = '001104'"

	_oSQL:_sQuery += " AND SB1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery += " AND SB1.B1_FILIAL = '" + xfilial ("SB1") + "'"
	_oSQL:_sQuery += " AND SB1.B1_COD = ZZ9.ZZ9_PRODUT"
	_oSQL:_sQuery += " AND SA2.D_E_L_E_T_ = ''"
	_oSQL:_sQuery += " AND SA2.A2_FILIAL = '" + xfilial ("SA2") + "'"
	_oSQL:_sQuery += " AND SA2.A2_COD = ZZ9.ZZ9_FORNEC"
	_oSQL:_sQuery += " AND SA2.A2_LOJA = ZZ9.ZZ9_LOJA"
	_oSQL:_sQuery += " )"
	_oSQL:_sQuery += " SELECT *"
	_oSQL:_sQuery += " ,(PESO_LIQ * VUN_NOVO) + (PESO_LIQ * ACR_CLAS) - (PESO_LIQ * VUN_PAGO) AS VLR_COMPL"
	_oSQL:_sQuery += " FROM C"
	_oSQL:_sQuery += " WHERE  (PESO_LIQ * VUN_NOVO) + (PESO_LIQ * ACR_CLAS) - (PESO_LIQ * VUN_PAGO) > 0"
	_oSQL:_sQuery += " ORDER BY ZZ9_SAFRA, ZZ9_FORNEC, ZZ9_LOJA, ZZ9_FILIAL, ZZ9_NFORI"
	_oSQL:Log ()
	_sAliasQ := _oSQL:Qry2Trb (.F.)
	U_Log2 ('debug', _oSQL:QtLinRet)
	do while ! (_sAliasQ) -> (eof ())
		_sFornece = (_sAliasQ) -> zz9_fornec
		_sLoja = (_sAliasQ) -> zz9_loja
		u_log2 ('debug', _sFornece + _sLoja)
		_nTotForn = 0
		_aRegZZ9 = {}
		_nRegZZ9 = 0
		_sHistCpl = ''
		do while ! (_sAliasQ) -> (eof ()) .and. (_sAliasQ) -> zz9_fornec == _sFornece .and. (_sAliasQ) -> zz9_loja == _sLoja
			_nTotForn += (_sAliasQ) -> vlr_compl
			_sLinHist = 'Fil/doc ' + (_sAliasQ) -> zz9_filial + '/' + (_sAliasQ) -> zz9_nfori + " " + alltrim ((_sAliasQ) -> b1_desc) + chr (13) + chr (10)
			if ! _sLinHist $ _sHistCpl
				_sHistCpl += _sLinHist
			endif
			aadd (_aRegZZ9, (_sAliasQ) -> regzz9)
			(_sAliasQ) -> (dbskip ())
		enddo

		U_Log2 ('debug', _aRegzz9)
		_oCtaCorr := ClsCtaCorr():New ()
		_oCtaCorr:Assoc    = _sFornece
		_oCtaCorr:Loja     = _sLoja
		_oCtaCorr:TM       = '16'
		_oCtaCorr:DtMovto  = dDataBase
		_oCtaCorr:Valor    = _nTotForn
		_oCtaCorr:SaldoAtu = _nTotForn
		_oCtaCorr:Usuario  = cUserName
		_oCtaCorr:Histor   = 'PREMIACAO QUALID/FIDELIDADE SAFRA 2020'
		_oCtaCorr:MesRef   = strzero(month(_oCtaCorr:DtMovto),2)+strzero(year(_oCtaCorr:DtMovto),4)
		_oCtaCorr:Doc      = '20209415'  // safra + numero chamado. Eu sou mesmo criativo, neh?
		_oCtaCorr:Serie    = 'OUT'
		_oCtaCorr:Parcela  = '1'
		_oCtaCorr:Origem   = 'GLPI9415'
		_oCtaCorr:Obs      = "Premiacao por qualidade e fidelidade ref:" + chr (13) + chr (10) + _sHistCpl
		if _oCtaCorr:PodeIncl ()
			if ! _oCtaCorr:Grava (.F., .F.)
				U_help ("Erro na atualizacao da conta corrente para o associado '" + _sFornece + '/' + _sLoja + "'. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg,, .t.)
			else
				for _nRegZZ9 = 1 to len (_aRegZZ9)
					zz9 -> (dbgoto (_aRegZZ9 [_nRegZZ9]))
					reclock ("ZZ9", .F.)
					zz9 -> zz9_nfComp = _oCtaCorr:Doc
					zz9 -> zz9_SerCom = _oCtaCorr:Serie
					msunlock ()
				next
			endif
		else
			U_help ("Gravacao do SZI nao permitida na atualizacao da conta corrente para o associado '" + _sFornece + '/' + _sLoja + "'. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg,, .T.)
		endif
		FreeObj (_oCtaCorr)
	//	EXIT  // por enquanto quero gerar apenas um
	enddo
	FreeObj (_oSQL)
return
*/
/*
	// Gera pre-notas de complemento de safra 2020 apos atualizacao de tabelas de precos (glpi 9415)
	aHeader := {}
	aadd (aHeader, {"Nome"   , 'Nome'     , "", 30, 0, "", "", "C"})
	aadd (aHeader, {"Varied" , 'Variedade', "", 15, 0, "", "", "C"})
	aadd (aHeader, {"Descr"  , 'Descricao', "", 50, 0, "", "", "C"})
	aadd (aHeader, {"Peso"   , 'Peso_liq' , "", 9, 2, "", "", "N"})
	aadd (aHeader, {"Grau"   , 'Grau'     , "", 5, 0, "", "", "C"})
	aadd (aHeader, {"ClasEsp", 'Cl_espald', "", 2, 0, "", "", "C"})
	aadd (aHeader, {"ClasLat", 'Cl_latada', "", 2, 0, "", "", "C"})
	aadd (aHeader, {"VUnEfet", 'Vun_pago' , "", 9, 4, "", "", "N"})
	aadd (aHeader, {"VlNovo" , 'Vun_novo' , "", 9, 4, "", "", "N"})
	aadd (aHeader, {"VlClas" , 'Acr_clas' , "", 9, 2, "", "", "N"})
	aadd (aHeader, {"Obs"    , 'Obs'      , "", 100, 0, "", "", "C"})
	_sPreNF := U_RetSQL ("SELECT MAX (ZZ9_PRE_NF) FROM ZZ9010 WHERE ZZ9_SAFRA = '2020'")
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT V.*, B1_VARUVA, A2_NOME" //, ZZ9_NFCOMP, ZZ9_MISTU1, ZZ9_MISTU2, ZZ9_MISTU3, ZZ9_MSGNF"
	_oSQL:_sQuery +=      ", ISNULL (
	_oSQL:_sQuery +=       " (select top 1 R_E_C_N_O_"  // Busca ZZ9 para ter dados de mistura de variedades, por isso ordena-o para trazer as misturas antes.
	_oSQL:_sQuery +=          " FROM ZZ9010 ZZ9"
	_oSQL:_sQuery +=         " WHERE ZZ9.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_FILIAL = V.FILIAL"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_SAFRA  = V.SAFRA"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_NFCOMP != ''"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_FORNEC = V.ASSOCIADO"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_LOJA   = V.LOJA_ASSOC"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_NFCOMP = V.DOC"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_SERCOM = V.SERIE"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_PRODUT = V.PRODUTO"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_GRAU   = V.GRAU"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_CLASSE = V.CLAS_FINAL"
	_oSQL:_sQuery +=           " AND ZZ9.ZZ9_CLABD  = V.CLAS_ABD"
	_oSQL:_sQuery +=         " ORDER BY ZZ9_FILIAL, ZZ9_SAFRA,ZZ9_FORNEC,ZZ9_LOJA,ZZ9_NFCOMP,ZZ9_SERCOM,ZZ9_PRODUT,ZZ9_CLASSE,ZZ9_CLABD, ZZ9_MISTU1 desc, ZZ9_MISTU2 desc, ZZ9_MISTU3 desc, ZZ9_MSGNF desc"
	_oSQL:_sQuery +=        "), 0) AS REGZZ9"
	_oSQL:_sQuery +=   " FROM SB1010 SB1, SA2010 SA2, VA_VPRECO_EFETIVO_SAFRA V"
	_oSQL:_sQuery +=  " WHERE SAFRA = '2020'"

	
	// Solicitado por Rodrigo (e-mail) em 22/02/2021:
	// Associados que nao vao receber por terem se desligado da cooperativa.
	_oSQL:_sQuery +=    " AND ASSOCIADO not IN ('001847','000640','000255','006455','004379','002870','003059','002933','002699','004266','000251','001071','004825','002768','002779','002717','003114','000568','002080','002081','003393','000564','003399','003383','002113','002533','002656','002748','010694','004364','002949','010569','002725','001130','003029','004611','012814','002937','002925','002988','002916','002283','001885','002500','012718','000236','010261','003853','006164','002567','002663','000977','000289','004625','002615','002714','002728','002734','002860','004556','003002','002732','003241','002635')"
	// Desconsiderar uvas viniferas em espaldeira
	_oSQL:_sQuery +=    " AND NOT (B1_VARUVA = 'F' AND SIST_CONDUCAO = 'E')"
	// Vinï¿½feras: apenas moscatos
	_oSQL:_sQuery +=    " AND NOT (B1_VARUVA = 'F' AND B1_DESC NOT LIKE '%MOSCATO%')"
	// Desconsiderar uvas organicas
	_oSQL:_sQuery +=    " AND B1_VAORGAN = 'C'"


	_oSQL:_sQuery +=    " AND SB1.D_E_L_E_T_ = '' AND B1_FILIAL = '  ' AND B1_COD = V.PRODUTO"
	_oSQL:_sQuery +=    " AND SA2.D_E_L_E_T_ = '' AND A2_FILIAL = '  ' AND A2_COD = V.ASSOCIADO AND A2_LOJA = V.LOJA_ASSOC"
	// pra bater com a planilha de out/2020 --->  _oSQL:_sQuery +=    " AND (PRODUTO IN ('9904','9922','9855','9832','9830','9827','9834','9827','9834')"
	// pra bater com a planilha de out/2020 --->  _oSQL:_sQuery +=         " OR PRODUTO IN ('9918','9837','9838','9836')"
	// pra bater com a planilha de out/2020 --->  _oSQL:_sQuery +=         " OR (PRODUTO IN ('9911','9854','9932','9845','9969','9829') AND SIST_CONDUCAO = 'L'))"
	_oSQL:_sQuery +=  " ORDER BY SAFRA, FILIAL, ASSOCIADO, LOJA_ASSOC, PRODUTO, DESCRICAO, GRAU, CLAS_FINAL, CLAS_ABD, SIST_CONDUCAO, GRUPO_PAGTO"
	_oSQL:Log ()
	_sAliasQ = _oSQL:Qry2Trb ()
	_aPrev = {}
	do while ! (_sAliasQ) -> (eof ())
		_nVlClas = 0
		_sObs = ''
		if (_sAliasQ) -> regZZ9 = 0
			U_Log2 ('erro', 'Nao achei ZZ9 para filial/doc ' + (_sAliasQ) -> filial + '/' + (_sAliasQ) -> doc)
		else
			zz9 -> (dbgoto ((_sAliasQ) -> regZZ9))
			_sMistu1 = zz9 -> zz9_mistu1
			_sMistu2 = zz9 -> zz9_mistu2
			_sMistu3 = zz9 -> zz9_mistu3

			if (_sAliasQ) -> sist_conducao == 'E'
				_sClasFina = (_sAliasQ) -> clas_final
			elseif (_sAliasQ) -> sist_conducao == 'L'
				_sClasFina = (_sAliasQ) -> clas_abd
			endif

			// Verifica se teve mistura de variedades.
			_nPreco = U_PrcUva20 ((_sAliasQ) -> filial, (_sAliasQ) -> produto, val ((_sAliasQ) -> grau), _sClasFina, (_sAliasQ) -> SIST_CONDUCAO, .F.)[2]
			if ! empty (_sMistu1)
				_nPrecoM1 = U_PrcUva20 ((_sAliasQ) -> filial, _sMistu1, val ((_sAliasQ) -> grau), _sClasFina, (_sAliasQ) -> SIST_CONDUCAO, .F.)[2]
				if _nPrecoM1 < _nPreco
					_nPreco = _nPrecoM1
					_sObs = 'Mist.varied1-Precificando como ' + alltrim (fBuscaCpo ("SB1", 1, xFilial ("SB1") + _sMistu1, 'B1_DESC'))
				endif
			endif
			if ! empty (_sMistu2)
				_nPrecoM2 = U_PrcUva20 ((_sAliasQ) -> filial, _sMistu2, val ((_sAliasQ) -> grau), _sClasFina, (_sAliasQ) -> SIST_CONDUCAO, .F.)[2]
				if _nPrecoM2 < _nPreco
					_nPreco = _nPrecoM2
					_sObs = 'Mist.varied2-Precificando como ' + alltrim (fBuscaCpo ("SB1", 1, xFilial ("SB1") + _sMistu2, 'B1_DESC'))
				endif
			endif
			if ! empty (_sMistu3)
				_nPrecoM3 = U_PrcUva20 ((_sAliasQ) -> filial, _sMistu3, val ((_sAliasQ) -> grau), _sClasFina, (_sAliasQ) -> SIST_CONDUCAO, .F.)[2]
				if _nPrecoM3 < _nPreco
					_nPreco = _nPrecoM3
					_sObs = 'Mist.varied3-Precificando como ' + alltrim (fBuscaCpo ("SB1", 1, xFilial ("SB1") + _sMistu3, 'B1_DESC'))
				endif
			endif

			// Premiacao/incentivo por qualidade
			if (_sAliasQ) -> b1_varuva == 'C'

				// Solicitado por Rodrigo (e-mail) em 22/02/2021: Moscato Embrapa nao ganha classificacao.
				if ! alltrim ((_sAliasQ) -> produto) $ '9918/9838/9837/9836'

					if alltrim ((_sAliasQ) -> clas_abd) == 'A'
						_nVlClas = 0.05
					elseif alltrim ((_sAliasQ) -> clas_abd) == 'B'
						_nVlClas = 0.02  //0.03
					endif
				endif
			endif

			aadd (_aPrev, {(_sAliasQ) -> a2_nome,;
						(_sAliasQ) -> produto,;
						(_sAliasQ) -> descricao,;
						(_sAliasQ) -> peso_liq,;
						(_sAliasQ) -> grau,;
						(_sAliasQ) -> clas_final,;
						(_sAliasQ) -> clas_abd,;
						(_sAliasQ) -> vunit_efetivo,;
						_nPreco,;
						_nVlClas,;
						_sObs})

			// Gera somente se tiver valor a pagar
			_nAPagar = (_sAliasQ) -> peso_liq * (_nPreco + _nVlClas) - (_sAliasQ) -> peso_liq * (_sAliasQ) -> vunit_efetivo
			//	U_Log (left ((_sAliasQ) -> a2_nome, 30) + (_sAliasQ) -> produto + (_sAliasQ) -> descricao + (_sAliasQ) -> grau + (_sAliasQ) -> clas_final + (_sAliasQ) -> clas_abd + transform ((_sAliasQ) -> vunit_efetivo, '@E 999.9999') + transform (_nPreco, '@E 999.9999') + transform ((_sAliasQ) -> peso_liq * _nPreco, '@E 999,999.99'))

			if (_sAliasQ) -> grupo_pagto != U_VA_RusGP ((_sAliasQ) -> safra, (_sAliasQ) -> produto, (_sAliasQ) -> sist_conducao)
				U_Log2 ('erro', 'grupo ant: ' + (_sAliasQ) -> grupo_pagto + ' novo: ' + U_VA_RusGP ((_sAliasQ) -> safra, (_sAliasQ) -> produto, (_sAliasQ) -> sist_conducao))
			endif

			reclock ("ZZ9", .T.)
			zz9 -> zz9_filial = (_sAliasQ) -> filial
			zz9 -> zz9_safra  = (_sAliasQ) -> safra
			zz9 -> zz9_grupo  = (_sAliasQ) -> grupo_pagto
			zz9 -> zz9_parcel = 'K'
			zz9 -> zz9_fornec = (_sAliasQ) -> associado
			zz9 -> zz9_loja   = (_sAliasQ) -> loja_assoc
			zz9 -> zz9_pre_nf = _sPreNF
			zz9 -> zz9_TipoNF = "C"
			zz9 -> zz9_produt = (_sAliasQ) -> produto
			zz9 -> zz9_grau   = (_sAliasQ) -> grau
			zz9 -> zz9_classe = (_sAliasQ) -> clas_final
			zz9 -> zz9_clabd  = (_sAliasQ) -> clas_abd
			zz9 -> zz9_conduc = (_sAliasQ) -> sist_conducao
			zz9 -> zz9_vunold = (_sAliasQ) -> vunit_efetivo
			zz9 -> zz9_quant  = 0
			zz9 -> zz9_vunit  = _nAPagar
			zz9 -> zz9_vunit2 = _nPreco  // para facilitar na planilha de conferencia
			zz9 -> zz9_vunit3 = _nVlClas  // para facilitar na planilha de conferencia
			zz9 -> zz9_obs    = _sObs
			zz9 -> zz9_nfori  = (_sAliasQ) -> doc
			zz9 -> zz9_serior = (_sAliasQ) -> serie
			zz9 -> zz9_itemor = (_sAliasQ) -> item_nota
			zz9 -> zz9_mistu1 = _sMistu1
			zz9 -> zz9_mistu2 = _sMistu2
			zz9 -> zz9_mistu3 = _sMistu3
			zz9 -> zz9_msgNF  = 'Compl.safra 2020'
			zz9 -> zz9_TES    = '312'
			msunlock ()
			_sPreNF = soma1 (soma1 (soma1 (soma1 (soma1 (_sPreNF)))))

		endif
		(_sAliasQ) -> (dbskip ())
	enddo
return
*/
/*
	// testes impressao danfe
	U_GravaSX1 ("NFSIGW", "01", '000022776')
	U_GravaSX1 ("NFSIGW", "02", '000022776')
	U_GravaSX1 ("NFSIGW", "03", '30 ')
	U_GravaSX1 ("NFSIGW", "04", 1)
	Private AFILBRW := {}
	Private cCondicao :=" "
	cCondicao := "F2_FILIAL=='"+xFilial("SF2")+"'"
	AFILBRW	 := {'SF2',cCondicao}
	do while u_msgyesno ('novo teste?')
		SpedDanfe ()  // Impressao do DANFe
	enddo
return
*/
/* exemplo de uso de profile para definicao de impressao. extraido de https://tdn.totvs.com/display/public/PROT/FWMsPrinter
Function u_localPrint()
    Local lAdjustToLegacy   := .F.
    Local lDisableSetup     := .T.
    Local oPrinter
    Local cLocal            := "c:\temp"
    Local nPrtType          := 6 // IMP_PDF > 6 || IMP_SPOOL > 2
    Local aDevice           := {}
    Local cSession          := GetPrinterSession()
 
    AADD(aDevice,"DISCO") // 1
    AADD(aDevice,"SPOOL") // 2
    AADD(aDevice,"EMAIL") // 3
    AADD(aDevice,"EXCEL") // 4
    AADD(aDevice,"HTML" ) // 5
    AADD(aDevice,"PDF"  ) // 6
     
    oProfile    := FWProfile():New()
    oProfile:SetTask('PRINTTYPE')   
    cDevice := oProfile:LoadStrProfile()
     
    nPrtType := aScan(aDevice,{|x| x == cDevice })
 
    oPrinter := FWMSPrinter():New("exemplo", nPrtType, lAdjustToLegacy, cLocal, lDisableSetup, , , , , , .F., )
    oPrinter:Say(10, 0, "teste")
    oPrinter:Setup()
 
    If oPrinter:nModalResult == PD_OK
        oProfile:SetTask('PRINTTYPE')   
        oProfile:SetStringProfile(If(oPrinter:nDevice==2, "SPOOL", "PDF"))
        oProfile:Save()
        oPrinter:Preview()
    EndIf
Return
*/
/*
	// Insere registro no SE2 para notas de safra que foram geradas com parcelamento incorreto
	_sFilial = '09'
	_sFornece = '004927'
	_sLoja = '01'
	_sPref = '30 '
	_sNum = '000003083'
	//_aParc := {'B','C','D','E','F','G','H','I','J','K'}
	_aParc := {'G'}
	for _nParc = 1 to len (_aParc)
		_sParc = _aParc [_nParc]
		se2 -> (dbsetorder (6))  // E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO
		if ! se2 -> (dbseek (_sFilial + _sFornece + _sLoja + _sPref + _sNum + _sParc, .F.))
			U_Log2 ('debug', 'nao tem ainda')
			if se2 -> (dbseek (_sFilial + _sFornece + _sLoja + _sPref + _sNum + 'A', .F.))
				U_Log2 ('info', 'criando parcela ' + _sParc + ' no SE2')
				_dEmis = se2 -> e2_emissao
				_sNomfor = se2 -> e2_nomfor
				_sHist = se2 -> e2_hist
				_dVencOri = se2 -> e2_vencori
				_sFilorig = se2 -> e2_filorig
				_sMSFil = se2 -> e2_msfil
				_scodrcof = se2 -> e2_codrcof
				_scodrcsl = se2 -> e2_codrcsl
				_scodrpis = se2 -> e2_codrpis
				_sForBco = se2 -> e2_forbco
				_sForAge = se2 -> e2_forage
				_sForCta = se2 -> e2_forcta
				_sFCtaDV = se2 -> e2_fctadv
				reclock ("SE2", .T.)
				se2 -> e2_filial = _sFilial
				se2 -> e2_fornece = _sFornece
				se2 -> e2_loja = _sLoja
				se2 -> e2_prefixo = _sPref
				se2 -> e2_num = _sNum
				se2 -> e2_parcela = _sParc
				se2 -> e2_emissao = _dEmis
				se2 -> e2_emis1 = _dEmis
				se2 -> e2_tipo = 'DP'
				se2 -> e2_naturez = '120201'
				se2 -> e2_nomfor = _sNomFor
				se2 -> e2_hist = _sHist
				se2 -> e2_la = 'S'
				se2 -> e2_vencori = _dVencOri
				se2 -> e2_moeda = 1
				se2 -> e2_fluxo = 'S'
				se2 -> e2_origem = 'MATA100'
				se2 -> e2_filorig = _sFilorig
				se2 -> e2_msfil = _sMSFil
				se2 -> e2_mdrtiss = '1'
				se2 -> e2_aplvlmn = '1'
				se2 -> e2_codrcof = _scodrcof
				se2 -> e2_codrcsl = _scodrcsl
				se2 -> e2_codrpis = _scodrpis
				se2 -> e2_forbco = _sForBco
				se2 -> e2_forage = _sForAge
				se2 -> e2_forcta = _sForcta
				se2 -> e2_fctadv = _sFCtaDV
				msunlock ()
			else
				U_Log2 ('erro', 'Nao encontrei SE2 original')
			endif
		endif
	next
return
*/
/*
	cPerg := "VA_RTSAF"
	U_GravaSX1 (cPerg, "01", stod ('20200131'))
	U_GravaSX1 (cPerg, "02", 1)
	U_GravaSX1 (cPerg, "03", 0)
	// if cFilAnt == '01' ; U_GravaSX1 (cPerg, "03", 1314513.17) ; endif // provisao compra safra
	// if cFilAnt == '03' ; U_GravaSX1 (cPerg, "03",  417707.26) ; endif // provisao compra safra
	// if cFilAnt == '07' ; U_GravaSX1 (cPerg, "03", 1260996.28) ; endif // provisao compra safra
	// if cFilAnt == '09' ; U_GravaSX1 (cPerg, "03",   45004.61) ; endif // provisao compra safra
	_sArqLog := 'VA_RTSAF_' + alltrim (cusername) + '_' + dtos (date ()) + ".log"
	U_VA_RTSAF (.t.)
RETURN
*/
/*
	// Importa TES inteligente (executar apenas 1 vez) - GLPI 8727
	_aDados = U_LeCSV ('\sfm_import.csv', ';')
	u_log (len(_aDados))
	for _nDado = 1 to len (_aDados)
		reclock ("SFM", .T.)
		sfm -> fm_filial  = xfilial ("SFM")
		sfm -> fm_tipo    = _aDados [_nDado, 1]
		sfm -> fm_grprod  = _aDados [_nDado, 2]
		sfm -> fm_est     = _aDados [_nDado, 3]
		sfm -> fm_tipocli = _aDados [_nDado, 4]
		sfm -> fm_ts      = _aDados [_nDado, 5]
		msunlock ()
		u_log (_nDado)
	next
return
*/
/* Este trecho funciona bem
	U_GravaSX1 ('SZI_REL2', '01', '000004')
	pergunte ('SZI_REL2', .T.)
	U_GravaSX1 ('SZI_REL', '01', '000004')
	pergunte ('SZI_REL', .T.)
	U_GravaSX1 ('SZI_RCB', '01', '000004')
	pergunte ('SZI_RCB', .T.)
*/
/*
	// Gera precos para as pre-notas de compra de safra.
	Private cPerg   := "VAZZ9P"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'Z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2020') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // produto ini
	U_GravaSX1 (cPerg, '07', 'z')    // fim
	U_GravaSX1 (cPerg, '08', 2)      // tipos uvas {"Comuns","Finas","Todas"}
	U_GravaSX1 (cPerg, '09', 2)      // regrava com NF ja gerada {"Sim", "Nao"}
	U_GravaSX1 (cPerg, '10', 1)      // regrava com obs {"Regrava","Nao altera"}
	U_GravaSX1 (cPerg, '11', '03')   // Filial inicial
	U_GravaSX1 (cPerg, '12', '03')   // Filial final
	U_GravaSX1 (cPerg, '13', 'Z')    // parcela ini
	U_GravaSX1 (cPerg, '14', 'Z')    // parcela final
	U_GravaSX1 (cPerg, '15', 1)      // regrava se ja tiver preco {"Sim", "Nao"}
	U_VA_ZZ9P (.t.)
return
*/

/*
	U_HELP ('VOU GRAVAR')
	_oEvento := ClsEvent ():New ()
	_oEvento:Texto   = "Teste inclusao evento" + CHR (13) + CHR(10)+"para ver como grava campo memo"
	_oEvento:CodEven = "000001"
	_oEvento:Grava ()
return
*/
/*
	// Ajusta profiles apos migracao dos SX para o banco de dados
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT ID_USR, NOME FROM VA_USR_USUARIOS"
	_oSQL:_sQuery += " WHERE BLOQUEADO = 'N'"
	_oSQL:_sQuery +=   " AND NOME LIKE '%.%'"
	_oSQL:_sQuery +=   " AND NOME NOT LIKE 'RET_%'"
	_oSQL:_sQuery +=   " AND NOT EXISTS (SELECT * FROM MP_SYSTEM_PROFILE WHERE P_NAME = ID_USR + '_OLD')"
	_oSQL:_sQuery += " ORDER BY ID_USR"
	_oSQL:Log ()
	_aDados := _oSQL:Qry2Array ()
	for _nDado = 1 to len (_aDados)
		_sUsr = _aDados [_nDado, 1]
		_sNomeUsr = '01' + upper (left (_aDados [_nDado, 2], 13))
		u_log2 ('info', _sUsr + ' ' + _sNomeUsr)
		begin transaction
		_oSQL:_sQuery := "UPDATE MP_SYSTEM_PROFILE SET P_NAME = '" + _sUsr + "_OLD'
		_oSQL:_sQuery += " WHERE upper (P_NAME)   = '" + _sUsr + "'"
		_oSQL:_sQuery +=   " AND P_EMPANT = ''"
		_oSQL:_sQuery +=   " AND MP_SYSTEM_PROFILE.P_TASK IN ('PERGUNTE')"
		_oSQL:Log ()
		_oSQL:Exec ()
		_oSQL:_sQuery := "UPDATE MP_SYSTEM_PROFILE SET P_NAME = '" + _sUsr + "', P_EMPANT = '01'"
		_oSQL:_sQuery += " WHERE upper (P_NAME) = '" + _sNomeUsr + "'"
		_oSQL:_sQuery +=   " AND MP_SYSTEM_PROFILE.P_TASK IN ('PERGUNTE')"
		_oSQL:_sQuery +=   " AND NOT EXISTS (SELECT * FROM MP_SYSTEM_PROFILE NOVO"
		_oSQL:_sQuery +=                    " WHERE NOVO.P_NAME = '" + _sUsr + "'"
		_oSQL:_sQuery +=                      " AND NOVO.P_PROG = MP_SYSTEM_PROFILE.P_PROG"
		_oSQL:_sQuery +=                      " AND NOVO.P_TASK = MP_SYSTEM_PROFILE.P_TASK"
		_oSQL:_sQuery +=                      " AND NOVO.P_TYPE = MP_SYSTEM_PROFILE.P_TYPE"
		_oSQL:_sQuery +=                      " AND NOVO.P_EMPANT = '01'"
		_oSQL:_sQuery +=                      " AND NOVO.P_FILANT = MP_SYSTEM_PROFILE.P_FILANT)"
		_oSQL:Log ()
		_oSQL:Exec ()
		end transaction
		//exit
	next
RETURN
*/
/*
// Envia atualizacoes diversas para o Mercanet
//	_oSQL := ClsSQL ():New ()
//	_oSQL:_sQuery := ""
//   	_oSQL:_sQuery += " SELECT R_E_C_N_O_ "
//	_oSQL:_sQuery += " FROM " + RetSQLName ("SB1")
//	_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
//	_oSQL:_sQuery += " AND B1_FILIAL = '" + xfilial ("SB1") + "'"  // Deixar esta opcao para poder ler os campos memo.
//	_oSQL:_sQuery += " AND B1_COD IN ('0345', '0215')"
//	_oSQL:Log ()
//	_aDados = aclone (_oSQL:Qry2Array ())
//	For _nLinha := 1 To Len(_aDados)
//		sb1 -> (dbgoto (_aDados [_nLinha, 1]))
//		U_AtuMerc ("SB1", sb1 -> (recno ()))
//	next
//
//	da0 -> (dbgotop ())
//	do while ! da0 -> (eof ())
//		if alltrim (da0 -> da0_codtab) $ '722'
//			U_AtuMerc ("DA0", da0 -> (recno ()))
//		endif
//		da0 -> (dbskip ())
//	enddo
//
//	_oSQL := ClsSQL ():New ()
//	_oSQL:_sQuery := ""
//	_oSQL:_sQuery += " SELECT R_E_C_N_O_ "
//	_oSQL:_sQuery += " FROM " + RetSQLName ("SA3")
//	_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
//	_oSQL:_sQuery += " AND A3_FILIAL = '" + xfilial ("SA3") + "'"  // Deixar esta opcao para poder ler os campos memo.
//	_oSQL:_sQuery += " AND A3_COD BETWEEN '291' and '298'"
//	_oSQL:Log ()
//	_aDados = aclone (_oSQL:Qry2Array ())
//	For _nLinha := 1 To Len(_aDados)
//		sa3 -> (dbgoto (_aDados [_nLinha, 1]))
//		U_LOG (SA3 -> A3_COD)
//		U_AtuMerc ("SA3", sa3 -> (recno ()))
//	next
//
//	_oSQL := ClsSQL ():New ()
//	_oSQL:_sQuery := ""
//	_oSQL:_sQuery += " SELECT R_E_C_N_O_ "
//	_oSQL:_sQuery += " FROM " + RetSQLName ("SF1")
//	_oSQL:_sQuery += " WHERE F1_FILIAL = '" + xfilial ("SF1") + "'"  // Deixar esta opcao para poder ler os campos memo.
//	_oSQL:_sQuery += " AND F1_EMISSAO >= '20150101'"  // DATA INICIA EXPORT P/ MERCANET
//	_oSQL:_sQuery += " AND (F1_DOC like '%28305%')"
//	_oSQL:_sQuery += " AND F1_SERIE = '1  '"
//	//_oSQL:_sQuery += " AND NOT EXISTS (SELECT * FROM LKSRV_MERCANETPRD.MercanetPRD.dbo.DB_NOTA_FISCAL WHERE DB_NOTA_NRO = CAST (F2_DOC AS INT))"
//	_oSQL:Log ()
//	_aDados = aclone (_oSQL:Qry2Array ())
//	For _nLinha := 1 To Len(_aDados)
//		sf1 -> (dbgoto (_aDados [_nLinha, 1]))
//		U_AtuMerc ("SF1", sf1 -> (recno ()))
//	next
//
//	_oSQL := ClsSQL ():New ()
//	_oSQL:_sQuery := ""
//	_oSQL:_sQuery += " SELECT R_E_C_N_O_ "
//	_oSQL:_sQuery += " FROM " + RetSQLName ("SF2")
//	_oSQL:_sQuery += " WHERE F2_FILIAL = '" + xfilial ("SF2") + "'"  // Deixar esta opcao para poder ler os campos memo.
//	_oSQL:_sQuery += " AND F2_EMISSAO >= '20150101'"  // DATA INICIA EXPORT P/ MERCANET
////	_oSQL:_sQuery += " AND (F2_DOC like '%28305%' or F2_DOC like '%139308%' or F2_DOC like '%139289%')"
//	_oSQL:_sQuery += " AND (F2_DOC like '%139289%')"
//	//_oSQL:_sQuery += " AND NOT EXISTS (SELECT * FROM LKSRV_MERCANETPRD.MercanetPRD.dbo.DB_NOTA_FISCAL WHERE DB_NOTA_NRO = CAST (F2_DOC AS INT))"
//	_oSQL:Log ()
//	_aDados = aclone (_oSQL:Qry2Array ())
//	For _nLinha := 1 To Len(_aDados)
//		sf2 -> (dbgoto (_aDados [_nLinha, 1]))
//		U_AtuMerc ("SF2", sf2 -> (recno ()))
//	next
//
//	_oSQL := ClsSQL ():New ()
//	_oSQL:_sQuery := ""
//	_oSQL:_sQuery += " SELECT R_E_C_N_O_ "
//	_oSQL:_sQuery += " FROM " + RetSQLName ("SA1")
//	_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
//	_oSQL:_sQuery += " AND A1_FILIAL = '" + xfilial ("SA1") + "'"  // Deixar esta opcao para poder ler os campos memo.
//	_oSQL:_sQuery += " AND EXISTS (SELECT *"
//	_oSQL:_sQuery += "			   FROM " + RetSQLName ("SZN")	
//	_oSQL:_sQuery += "			   WHERE SZN.ZN_CODEVEN = 'ALT001'"
//	_oSQL:_sQuery += "			   AND SZN.ZN_ALIAS = 'SA1'"
//	_oSQL:_sQuery += "			   AND SZN.ZN_DATA >= '20190801'"
//	_oSQL:_sQuery += "			   AND SZN.ZN_USUARIO IN ('ADMINISTRADOR', 'robert.koch')"
//	_oSQL:_sQuery += "			   AND SZN.ZN_PILHA LIKE '%BATLIMCR%'"
//	_oSQL:_sQuery += "			   AND SZN.ZN_CLIENTE = SA1.A1_COD"
//	_oSQL:_sQuery += "			   AND SZN.ZN_LOJACLI = SA1.A1_LOJA)
//	_oSQL:Log ()
//	_aDados = aclone (_oSQL:Qry2Array ())
//	For _nLinha := 1 To Len(_aDados)
//		sa1 -> (dbgoto (_aDados [_nLinha, 1]))
//		U_LOG (SA1 -> A1_COD)
//		U_AtuMerc ("SA1", sa1 -> (recno ()))
//	next
//
//	se4 -> (dbgotop ())
//	do while ! se4 -> (eof ())
//		U_AtuMerc ("SE4", se4 -> (recno ()))
//		se4 -> (dbskip ())
//	enddo
return
*/
/*
	cPerg := "ML_NFXCONH"
	U_GravaSX1 (cPerg, "01", stod ('20020128')) // Data Emissao/Recebimento
	U_GravaSX1 (cPerg, "02", stod ('20020225')) // Data Emissao/Recebimento
	U_GravaSX1 (cPerg, "03", '')  // Cliente de
	U_GravaSX1 (cPerg, "04", 'Z') // Cliente ate
	U_GravaSX1 (cPerg, "05", '')  //	Doc de Saida
	U_GravaSX1 (cPerg, "06", 'Z') // Doc de Saida
	U_GravaSX1 (cPerg, "07", '')  // Fornecedor de
	U_GravaSX1 (cPerg, "08", 'z') // Fornecedor atï¿½
	U_GravaSX1 (cPerg, "09", '')  // Doc de Entrada
	U_GravaSX1 (cPerg, "10", 'Z') // Doc de Entrada
	U_GravaSX1 (cPerg, "11", '')  // UF
	U_GravaSX1 (cPerg, "12", '000068736') // Conhecimento de
	U_GravaSX1 (cPerg, "13", '000070063') // Conhecimento ate
	U_GravaSX1 (cPerg, "14", 2) // Ordenar por
	U_GravaSX1 (cPerg, "15", 1) // Listar
	U_ML_NFXCONH (.t.)
RETURN
*/

//	_a := ALLGROUPS ()
//	for _n = 1 to len (_a)
//		u_log (_a [_n])
//		u_log (FWGrpParam (_a [_n, 1, 1]))
//	next

/*
	// Cria registros na conta corrente para nota trocada entre associados (GLPI 8175)
	if cFilAnt != '07'
		u_help ("Filial errada",, .t.)
		return
	endif
	_sQuery := ""
	_sQuery += " SELECT E2_FILIAL, E2_FORNECE, E2_LOJA, E2_NOMFOR, E2_EMISSAO, E2_VENCREA, E2_NUM, E2_PREFIXO, E2_TIPO, E2_VALOR, E2_SALDO, E2_HIST, R_E_C_N_O_, E2_LA, E2_PARCELA,"
	_sQuery +=        " ROW_NUMBER () OVER (ORDER BY E2_PARCELA) AS NUM_PARC"
	_sQuery +=   " FROM " + RetSQLName ("SE2")
	_sQuery +=  " WHERE D_E_L_E_T_ = ''"
	_sQuery +=    " AND E2_TIPO    = 'NF'"
	_sQuery +=    " AND E2_FORNECE = '002660'"
	_sQuery +=    " AND E2_LOJA    = '01'"
	_sQuery +=    " AND E2_PREFIXO = '30 '"
	_sQuery +=    " AND E2_NUM     = '000015371'"
	_sQuery +=    " AND E2_VACHVEX = ''"
	_sQuery +=    " AND E2_FILIAL  = '" + xfilial ("SE2") + "'"
	_sQuery +=  " ORDER BY E2_PARCELA"
	//u_log (_sQuery)
	_sAliasQ = GetNextAlias ()
	DbUseArea(.t., 'TOPCONN', TcGenQry (,, _sQuery), _sAliasQ, .f., .t.)
	U_TCSetFld (alias ())
	do while ! (_sAliasQ) -> (eof ())
		//u_log ('Filial:' + (_sAliasQ) -> e2_filial, 'Forn:' + (_sAliasQ) -> e2_fornece + '/' + (_sAliasQ) -> e2_loja + ' ' + (_sAliasQ) -> e2_nomfor, 'Emis:', (_sAliasQ) -> e2_emissao, 'Vcto:', (_sAliasQ) -> e2_vencrea, 'Doc:', (_sAliasQ) -> e2_num+'/'+(_sAliasQ) -> e2_prefixo, 'Tipo:', (_sAliasQ) -> e2_tipo, 'Valor: ' + transform ((_sAliasQ) -> e2_valor, "@E 999,999,999.99"), 'Saldo: ' + transform ((_sAliasQ) -> e2_saldo, "@E 999,999,999.99"), (_sAliasQ) -> e2_hist)

		_oCtaCorr := ClsCtaCorr():New ()
		_oCtaCorr:Assoc    = (_sAliasQ) -> e2_fornece
		_oCtaCorr:Loja     = (_sAliasQ) -> e2_loja
		_oCtaCorr:TM       = '13'
		_oCtaCorr:DtMovto  = (_sAliasQ) -> e2_EMISSAO
		_oCtaCorr:Valor    = (_sAliasQ) -> e2_valor
		_oCtaCorr:SaldoAtu = (_sAliasQ) -> e2_saldo
		_oCtaCorr:Usuario  = cUserName
		_oCtaCorr:Histor   = 'COMPRA SAFRA 2020 GRP.C'
		_oCtaCorr:MesRef   = strzero(month(_oCtaCorr:DtMovto),2)+strzero(year(_oCtaCorr:DtMovto),4)
		_oCtaCorr:Doc      = (_sAliasQ) -> e2_num
		_oCtaCorr:Serie    = (_sAliasQ) -> e2_prefixo
		_oCtaCorr:Parcela  = (_sAliasQ) -> e2_parcela
		_oCtaCorr:Origem   = 'GLPI8175'
		if _oCtaCorr:PodeIncl ()
			if ! _oCtaCorr:Grava (.F., .F.)
				U_help ("Erro na atualizacao da conta corrente para o associado '" + (_sAliasQ) -> e2_fornece + '/' + (_sAliasQ) -> e2_loja + "'. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg)
				_lContinua = .F.
			else
				se2 -> (dbgoto ((_sAliasQ) -> r_e_c_n_o_))
				if empty (se2 -> e2_vachvex)  // Soh pra garantir...
					reclock ("SE2", .F.)
					se2 -> e2_vachvex = _oCtaCorr:ChaveExt ()
					msunlock ()
				endif
			endif
		else
			U_help ("Gravacao do SZI nao permitida na atualizacao da conta corrente para o associado '" + (_sAliasQ) -> e2_fornece + '/' + (_sAliasQ) -> e2_loja + "'. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg)
			_lContinua = .F.
		endif

		(_sAliasQ) -> (dbskip ())
	enddo
	(_sAliasQ) -> (dbclosearea ())
return
*/
/*
User Function AFTERLOGIN
	Local cId     := ParamIXB[1]
	Local cNome := ParamIXB[2]
	IF OAPP:LMDI
		ALERT("VOCE Nï¿½O TEM AUTORIZAï¿½ï¿½O PARA FAZER ESTE ACESSO !!!")
		FINAL()
	ENDIF
RETURN
*/
/*
	// Gera lista de campos cuja numeracao automatica precisa ser ajustada manualmente.
	use sxe exclusive new alias sxe
	// parece que corrompe o arquivo --> index on xe_alias + xe_filial to (criatrab ({}, .F.))
	sx3 -> (dbsetorder (2))
	sxe -> (dbgotop ())
	do while ! sxe -> (eof ())
		if left (xe_filial, 2) $ '  /' + cFilAnt
			u_log2 ('debug', sxe -> xe_alias + ': ' + sxe -> xe_numero)
			if ! six -> (dbseek (sxe -> xe_alias + '1', .F.))
				u_help ("Nao encontrei SIX para " + sxe -> xe_alias)
			else
				(sxe -> xe_alias) -> (dbsetorder (1))
				if (sxe -> xe_alias) -> (dbseek (xfilial (sxe -> xe_alias) + left (sxe -> xe_numero, sxe -> xe_tamanho), .T.))
					u_log2 ('info', sxe -> xe_alias + ' = ' + alltrim (fBuscaCpo ("SX2", 1, sxe -> xe_alias, 'X2_NOME')))
					u_logTrb (sxe -> xe_alias)
					(sxe -> xe_alias) -> (dbskip ())
					if ! (sxe -> xe_alias) -> (eof ())
						u_log2 ('info', sxe -> xe_alias + ' tem lacuna')
					endif
				endif
			endif
	//		if ! sx3 -> (dbseek (sxe -> xe_campo, .F.))
	//			u_help ("Nao encontrei o campo no SX3",, .t.)
	//		endif
		endif
		_sxe_ant = sxe -> xe_alias + sxe -> xe_filial
		sxe -> (dbskip ())
		if sxe -> xe_alias + sxe -> xe_filial == _sxe_ant
			u_log2 ('aviso', 'Parece que temos duplicidade: ' + _sxe_ant)
		endif
	enddo
	sxe -> (dbclosearea ())
return
*/
/*
	// Geramos faturas de pagamento de safra indevidamente...
	dDataBase = stod ('20200720')
	if cFilAnt != '01'
		u_help ("Filial errada.",, .t.)
		return
	endif
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT R_E_C_N_O_"
	_oSQL:_sQuery +=   " FROM " + RetSqlName ("SZI") + " SZI "
	_oSQL:_sQuery +=  " WHERE SZI.D_E_L_E_T_ != '*'"
	_oSQL:_sQuery +=    " AND SZI.ZI_FILIAL = '01'"
	_oSQL:_sQuery +=    " AND SZI.ZI_DATA   = '20200720'"
	_oSQL:_sQuery +=    " AND SZI.ZI_SERIE  = '30'"
	_oSQL:_sQuery +=    " AND SZI.ZI_HISTOR = 'FAT.PAG.SAFRA 2020'"
	_oSQL:_sQuery +=    " AND SZI.ZI_SALDO  = ZI_VALOR"
	_oSQL:_sQuery +=  " ORDER BY ZI_ASSOC, ZI_LOJASSO, ZI_SEQ"
	_oSQL:Log ()
	_aDados = _oSQL:Qry2Array ()
	for _nDado = 1 to len (_aDados)
		szi -> (dbgoto (_aDados [_nDado, 1]))
		u_log2 ('info', '--------------------------------------------------------------------')
		u_log2 ('info', szi -> zi_assoc + '/' + szi -> zi_lojasso + ' doc.' + szi -> zi_doc + ' ' + szi -> zi_histor)
		if ! u_szicf (.T.)
			exit
		endif
		exit  // por enquanto, apenas um...
	next
return
*/

/*
	// Migra tabelas do SX5 para o ZX5
	//_aDePara = {'88', '39'} // Linhas comerciais 
	//_aDePara = {'Z7', '40'} // Marcas comerciais 
	_aDePara = {'79', '54'} // Eventos do sistema
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT X5_CHAVE, X5_DESCRI, X5_DESCSPA"
	_oSQL:_sQuery +=   " FROM " + RetSqlName ("SX5")
	_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ != '*'"
	_oSQL:_sQuery +=    " AND X5_FILIAL  = '" + xFilial ("SX5") + "'"
	_oSQL:_sQuery +=    " AND X5_TABELA  = '" + _aDePara [1] + "'"
	_oSQL:_sQuery +=  " ORDER BY X5_CHAVE"
	u_log (_oSQL:_sQuery)
	_aDados := _oSQL:Qry2Array ()
	u_log (_aDados)
	if U_RetSQL ("SELECT COUNT (*) FROM " + RetSqlName ("ZX5") + " WHERE D_E_L_E_T_ != '*' AND ZX5_FILIAL = '" + xFilial ("ZX5") + "' AND ZX5_TABELA  = '" + _aDePara [2] + "'") > 0
		u_help ("Jah existe a tabela '" + _aDePara [2] + "' no ZX5")
	else
		begin transaction
		for _nDado = 1 to len (_aDados)
			reclock ("ZX5", .t.)
			zx5 -> zx5_filial = xfilial ("ZX5")
			zx5 -> zx5_tabela = _aDePara [2]
			zx5 -> zx5_chave  = SOMA1 (U_RetSQL ("SELECT MAX (ZX5_CHAVE) FROM " + RetSqlName ("ZX5") + " WHERE D_E_L_E_T_ != '*' AND ZX5_FILIAL = '" + xFilial ("ZX5") + "' AND ZX5_TABELA  = '" + _aDePara [2] + "'"))
			zx5 -> &('zx5_' + _aDePara [2] + 'cod')  = _aDados [_nDado, 1]
			zx5 -> &('zx5_' + _aDePara [2] + 'desc') = _aDados [_nDado, 2]
			u_log ('incluindo ', _aDados [_nDado, 1])
			msunlock ()
		next
		end transaction
	endif
return
*/
	// teste de uso de memoria
//	_a := FWSFallGrps ()
//	for _i = 1 to 12  // mais que 17 trava o servico
//		u_log2 ('debug', _i)
//		aadd (_a, aclone (_a))
//		sleep (1000)
//	next
/*
	// Gera pre-notas complemento uva Rubea safra 2020
	cPerg = "VAGNF3"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2020') // Safra referencia
	U_GravaSX1 (cPerg, '06', 'H')    // Parcela
	U_GravaSX1 (cPerg, '07', '')     // DCO inicial
	U_GravaSX1 (cPerg, '08', 'z')    // DCO final
	U_GravaSX1 (cPerg, '09', '') //'9822')     // Prod ini
	U_GravaSX1 (cPerg, '10', 'z') //'9822')    // Prod final
	U_GravaSX1 (cPerg, '11', 0)    // Preco 2016
	U_GravaSX1 (cPerg, '12', '9936/9811/9812')  // Apenas estas variedades (Rubea, no caso)
	U_GravaSX1 (cPerg, '13', '')  // Exceto estas variedades
	U_VA_GNF3 (.T.)
return
*/
/*
	// Gera fatura para reagrupar vencimentos de titulos de compra de uva dos associados.
	// Busca notas cujas parcelas precisa recalcular.
	_sArqLog := 'Reparcelamento_notas_grupo_C_2020.log'
	if cFilAnt != '01'
		u_help ("Filial errada",, .t.)
		return
	endif
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT DISTINCT E2_FILIAL, E2_FORNECE, E2_LOJA, E2_PREFIXO, E2_NUM, E2_TIPO, E2_EMISSAO"
	_oSQL:_sQuery +=   " FROM SE2010 SE2, SZI010 SZI
	_oSQL:_sQuery +=  " WHERE SE2.D_E_L_E_T_ = ''"
	_oSQL:_sQuery += " AND SE2.E2_FILIAL = '01'"
	_oSQL:_sQuery += " AND SE2.E2_PREFIXO = '30 '"
	_oSQL:_sQuery += " AND SE2.E2_EMISSAO >= '20200501'"
	_oSQL:_sQuery += " AND SE2.E2_SALDO > 0"
	_oSQL:_sQuery += " AND SE2.E2_TIPO IN ('NF', 'DP')"
	_oSQL:_sQuery += " AND SE2.E2_HIST NOT LIKE 'AJ%'"
	_oSQL:_sQuery += " AND SZI.D_E_L_E_T_ = ''"
	_oSQL:_sQuery += " AND ZI_FILIAL = SE2.E2_FILIAL"
	_oSQL:_sQuery += " AND ZI_ASSOC = SE2.E2_FORNECE"
	_oSQL:_sQuery += " AND ZI_LOJASSO = SE2.E2_LOJA"
	_oSQL:_sQuery += " AND ZI_DOC = SE2.E2_NUM"
	_oSQL:_sQuery += " AND ZI_SERIE= SE2.E2_PREFIXO"
	_oSQL:_sQuery += " AND ZI_PARCELA = SE2.E2_PARCELA"
	_oSQL:_sQuery += " AND ZI_TM = '13'"
	_oSQL:_sQuery += " AND ZI_HISTOR LIKE '%GRP.C%'"
	
	// quero uns problematicos para testar
	// _oSQL:_sQuery += " AND exists (SELECT * FROM SE2010 PARCD WHERE PARCD.E2_FILIAL = SE2.E2_FILIAL AND PARCD.E2_FORNECE=SE2.E2_FORNECE AND PARCD.E2_NUM=SE2.E2_NUM AND PARCD.E2_PARCELA ='D' AND PARCD.E2_SALDO < PARCD.E2_VALOR)"
	
	_oSQL:_sQuery += " ORDER BY E2_FILIAL, E2_FORNECE, E2_LOJA, E2_PREFIXO, E2_NUM, E2_TIPO"
	_oSQL:Log ()
	_sAliasQ := _oSQL:Qry2Trb ()
	do while ! (_sAliasQ) -> (eof ())
		_nTotTit = 0
		_nSldTit = 0
		_aTitOri = {}
		u_log2 ('info', '----------------------------------------------------------------------')
		u_log2 ('info', 'forn.' + (_sAliasQ) -> e2_fornece + '/' + (_sAliasQ) -> e2_loja + ' tit:' + (_sAliasQ) -> e2_prefixo + (_sAliasQ) -> e2_num)
		se2 -> (dbsetorder(6))  // E2_FILIAL, E2_FORNECE, E2_LOJA, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, R_E_C_N_O_, D_E_L_E_T_
		se2 -> (dbseek ((_sAliasQ) -> e2_filial + (_sAliasQ) -> e2_fornece + (_sAliasQ) -> e2_loja + (_sAliasQ) -> e2_prefixo + (_sAliasQ) -> e2_num, .F.))
		do while ! se2 -> (eof ());
			.and. se2 -> e2_filial == (_sAliasQ) -> e2_filial;
			.and. se2 -> e2_fornece == (_sAliasQ) -> e2_fornece;
			.and. se2 -> e2_loja == (_sAliasQ) -> e2_loja;
			.and. se2 -> e2_prefixo == (_sAliasQ) -> e2_prefixo;
			.and. se2 -> e2_num == (_sAliasQ) -> e2_num
			if se2 -> e2_tipo == (_sAliasQ) -> e2_tipo .and. se2 -> e2_emissao == stod ((_sAliasQ) -> e2_emissao)  // Pode ter sido feita alguma fatura e nao quero misturar
				u_log2 ('debug', 'Tit.orig.: ' + se2 ->e2_tipo + ' parc.' + se2 -> e2_parcela + ' sld:' + cvaltochar (se2 -> e2_saldo) + ' vcto:' + dtoc (se2 -> e2_vencrea))
				_nTotTit += se2 -> e2_valor
				_nSldTit += se2 -> e2_saldo
				if se2 -> e2_saldo > 0
					aadd (_aTitOri, {se2 -> E2_PREFIXO, se2 -> E2_NUM, se2 -> E2_PARCELA, se2 -> E2_TIPO, .F.})
				endif
			endif
			se2 -> (dbskip ())
		enddo
		u_log2 ('debug', 'total titulo: ' + cvaltochar (_nTotTit))
		u_log2 ('debug', 'saldo titulo: ' + cvaltochar (_nSldTit))

		// Agora tenho o valor total da nota. Vou distribuir esse valor original dentro dos percentuais corretos
		// para saber o valor liquido que deve ser pago em cada mes.
		_aNewParc = {}
		aadd (_aNewParc, {0                          , 0, 0})
		aadd (_aNewParc, {round (_nTotTit * 0.040, 2), 0, 0})
		aadd (_aNewParc, {round (_nTotTit * 0.114, 2), 0, 0})
		aadd (_aNewParc, {round (_nTotTit * 0.114, 2), 0, 0})
		aadd (_aNewParc, {round (_nTotTit * 0.114, 2), 0, 0})
		aadd (_aNewParc, {round (_nTotTit * 0.114, 2), 0, 0})
		aadd (_aNewParc, {round (_nTotTit * 0.142, 2), 0, 0})
		aadd (_aNewParc, {round (_nTotTit * 0.142, 2), 0, 0})
		// Deixa a diferenca para a primeira parcela.
		_nDistr =0
		for _nParc = 2 to len (_aNewParc)
			_nDistr += _aNewParc [_nParc, 1]
		next
		_aNewParc [1, 1] = _nTotTit - _nDistr  // Este seria o total que deveria ter sido pago ateh junho.
//		u_log2 ('debug', 'Parcelas como era para terem ficado:')
//		u_log2 ('debug', _aNewParc)

		// Agora que tenho os valores como devem ficar, distribuo o saldo do titulo de tras para frente
		// limitando ao valor de cada parcela.
		_nDistr = 0
		for _nParc = len (_aNewParc) to 1 step -1
			_aNewParc [_nParc, 2] = min (_aNewParc [_nParc, 1], _nSldTit - _nDistr)
			_nDistr += _aNewParc [_nParc, 2]
		next
//		u_log2 ('debug', 'Saldo distribuido:')
//		u_log2 ('debug', _aNewParc)

		// Se o saldo do titulo for menor que a distribuicao das parcelas restantes, eh por que ja foi
		// mordido para compensar algum adto.
		if _aNewParc [1, 1] <= 0
			u_log2 ('erro', 'Ainda sem tratamento: Parcelas restantes jah foram parcialmente usadas.')
		else

			// Agora que tenho os valores das novas parcelas, calculo o % de representatividade de cada uma.
			_nDistr = 0
			for _nParc = len (_aNewParc) to 2 step -1
				_aNewParc [_nParc, 3] = round (_aNewParc [_nParc, 2] * 100 / _nSldTit, 2)
				_nDistr += _aNewParc [_nParc, 3]
			next
			// Deixa a diferenca (dos percentuais) para a primeira parcela.
			_aNewParc [1, 3] = 100 - _nDistr
			u_log2 ('debug', 'Percentuais das novas parcelas calculados:')
			u_log2 ('debug', _aNewParc)

			// Ajusta os % no cadastro da condicao de pagamento e confere se fechou 100% (agora ja estou meio apavorado)
			SEC -> (DBSETORDER (1))  // EC_FILIAL, EC_CODIGO, EC_ITEM, R_E_C_N_O_, D_E_L_E_T_
			_ndistr = 0
			for _nParc = 1 to len (_aNewParc)
				if ! sec -> (dbseek (xfilial ("SEC") + '801' + strzero (_nParc, 2), .F.))
					u_help ("ERRO", 'Nao encontrei SEC')
					exit
				else
					reclock ("SEC", .F.)
					sec -> ec_rateio = _aNewParc [_nParc, 3]
					msunlock ()
				endif
				_nDistr += _aNewParc [_nParc, 3]
			next
			if _ndistr != 100
				u_log2 ('erro', 'Distribuicao nao fechou em 100%')
			else

				// Dados para a fatura a ser criada.
				_aFatPag = {}
				Aadd(_aFatPag, "31 ")                                //-- Prefixo
				Aadd(_aFatPag, "FAT")                                //-- Tipo
				Aadd(_aFatPag, (_sAliasQ) -> e2_num)                             //-- Numero da Fatura (se o numero estiver em branco obtem pelo FINA290)
				Aadd(_aFatPag, "120201    ")                         //-- Natureza
				Aadd(_aFatPag, stod ((_sAliasQ) -> e2_emissao))                            //-- Data emissao inicial
				Aadd(_aFatPag, stod ((_sAliasQ) -> e2_emissao))                            //-- Data emissao final
				Aadd(_aFatPag, (_sAliasQ) -> e2_fornece)                            //-- Fornecedor
				Aadd(_aFatPag, (_sAliasQ) -> e2_loja)                               //-- Loja
				Aadd(_aFatPag, (_sAliasQ) -> e2_fornece)                            //-- Fornecedor para geracao
				Aadd(_aFatPag, (_sAliasQ) -> e2_loja)                               //-- Loja do fornecedor para geracao
				Aadd(_aFatPag, '801')                            //-- Condicao de pagto
				Aadd(_aFatPag, 01)                                   //-- Moeda
				Aadd(_aFatPag, aclone(_aTitOri) )                    //-- ARRAY com os titulos da fatura (Prefixo,Numero,Parcela,Tipo,Tï¿½tulo localizado na geracao de fatura (lï¿½gico). Iniciar com falso.)
				Aadd(_aFatPag, 0)                                    //-- Valor de decrescimo
				Aadd(_aFatPag, 0)                                    //-- Valor de acrescimo

				u_log2 ('info', 'Gerando fatura ' + (_sAliasQ) -> e2_num + ' para o fornecedor ' + (_sAliasQ) -> e2_fornece + '/' + (_sAliasQ) -> e2_Loja + ' agrupando os seguintes titulos:')
				u_log2 ('info', _aTitOri)

				_sMsgErro = ''
				dbselectarea("SE2")
				dbsetorder(1)
				set filter to
		//		dbgotop ()
				lMsErroAuto  := .F.
				_sErroAuto := ''
				MsExecAuto( { |x,y| FINA290(x,y)},3,_aFatPag,)
				If lMsErroAuto
					if ! empty (_sErroAuto)
						_sMsgErro += _sErroAuto + '; '
					endif
					if ! empty (NomeAutoLog ())
						_sMsgErro += U_LeErro (memoread (NomeAutoLog ())) + '; '
					endif
					u_help ('Rotina automatica retornou erro: ' + _sMsgErro,, .t.)
				else
					// Ajusta os saldos da conta corrente para os titulos aglutinados na fatura.
					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := ""
					_oSQL:_sQuery += " SELECT R_E_C_N_O_"
					_oSQL:_sQuery +=   " FROM SZI010 SZI"
					_oSQL:_sQuery +=  " WHERE SZI.D_E_L_E_T_ = ''"
					_oSQL:_sQuery +=    " AND SZI.ZI_FILIAL  = '" + xfilial ("SZI") + "'"
					_oSQL:_sQuery +=    " AND SZI.ZI_ASSOC   = '" + (_sAliasQ) -> e2_fornece + "'"
					_oSQL:_sQuery +=    " AND SZI.ZI_LOJASSO = '" + (_sAliasQ) -> e2_loja + "'"
					_oSQL:_sQuery +=    " AND SZI.ZI_SERIE   = '" + (_sAliasQ) -> e2_prefixo + "'"
					_oSQL:_sQuery +=    " AND SZI.ZI_DOC     = '" + (_sAliasQ) -> e2_num + "'"
					//_oSQL:Log ()
					_aDados = _oSQL:Qry2Array ()
					for _nDado = 1 to len (_aDados)
						sZI -> (dbgoto (_aDados [_nDado, 1]))
						_oCtaCorr := ClsCtaCorr ():New (szi -> (recno ()))
						_oCtaCorr:AtuSaldo ()
					next


					// Localiza os titulos gerados pela fatura, atualiza-os e gera conta corrente.
					_oSQL := ClsSQL ():New ()
					_oSQL:_sQuery := ""
					_oSQL:_sQuery += " SELECT R_E_C_N_O_"
					_oSQL:_sQuery +=   " FROM SE2010 SE2"
					_oSQL:_sQuery +=  " WHERE SE2.D_E_L_E_T_ = ''"
					_oSQL:_sQuery +=    " AND SE2.E2_FILIAL  = '" + xfilial ("SE2") + "'"
					_oSQL:_sQuery +=    " AND SE2.E2_EMISSAO = '" + dtos (ddatabase) + "'"
					_oSQL:_sQuery +=    " AND SE2.E2_SALDO   > 0"
					_oSQL:_sQuery +=    " AND SE2.E2_TIPO    = 'FAT'"
					_oSQL:_sQuery +=    " AND SE2.E2_FORNECE = '" + (_sAliasQ) -> e2_fornece + "'"
					_oSQL:_sQuery +=    " AND SE2.E2_LOJA    = '" + (_sAliasQ) -> e2_loja + "'"
					_oSQL:_sQuery +=    " AND SE2.E2_PREFIXO = '31 '"
					_oSQL:_sQuery +=    " AND SE2.E2_NUM     = '" + (_sAliasQ) -> e2_num + "'"
					//_oSQL:Log ()
					_aDados = _oSQL:Qry2Array ()
					for _nDado = 1 to len (_aDados)
						se2 -> (dbgoto (_aDados [_nDado, 1]))
					//	u_log2 ('debug', 'fatura: ' + se2 ->e2_tipo + ' ' + se2 -> e2_parcela + ' sld:' + cvaltochar (se2 -> e2_saldo) + ' ' + dtoc (se2 -> e2_vencrea))

						// altera o historio e deixa posicionado o E2 para criar conta corrente referente a este titulo.
						reclock("SE2", .F.)
						SE2->E2_HIST := 'REPARCELAMENTO COMPRA SAFRA 2020 GRP.C'
						MsUnLock()

						_oCtaCorr := ClsCtaCorr():New ()
						_oCtaCorr:Assoc    = se2 -> e2_fornece
						_oCtaCorr:Loja     = se2 -> e2_loja
						_oCtaCorr:TM       = '13'
						_oCtaCorr:DtMovto  = se2 -> e2_EMISSAO
						_oCtaCorr:Valor    = se2 -> e2_valor
						_oCtaCorr:SaldoAtu = se2 -> e2_saldo
						_oCtaCorr:Usuario  = cUserName
						_oCtaCorr:Histor   = SE2 -> E2_HIST
						_oCtaCorr:MesRef   = strzero(month(_oCtaCorr:DtMovto),2)+strzero(year(_oCtaCorr:DtMovto),4)
						_oCtaCorr:Doc      = se2 -> e2_num
						_oCtaCorr:Serie    = se2 -> e2_prefixo
						_oCtaCorr:Origem   = 'GLPI8138'
						_oCtaCorr:Parcela  = se2 -> e2_parcela
						if _oCtaCorr:PodeIncl ()
							if ! _oCtaCorr:Grava (.F., .F.)
								U_help ("Erro na atualizacao da conta corrente para o associado '" + se2 -> e2_fornece + '/' + se2 -> e2_loja + "'. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg,, .t.)
							else
								if empty (se2 -> e2_vachvex)
									reclock ("SE2", .F.)
									se2 -> e2_vachvex = _oCtaCorr:ChaveExt ()
									msunlock ()
								endif
							endif
						else
							U_help ("Gravacao do SZI nao permitida na atualizacao da conta corrente para o associado '" + se2 -> e2_fornece + '/' + se2 -> e2_loja + "'. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg,, .t.)
						endif
					next
				endif
			endif
		endif
		(_sAliasQ) -> (dbskip ())
		//exit  // teste
	enddo
return
*/
/*
	// Simula integralizacao de cotas sobre a producao do associado
	cPerg := "SZI_ICP"
	U_GravaSX1 (cPerg, "01", '006417')
	U_GravaSX1 (cPerg, "02", '')
	U_GravaSX1 (cPerg, "03", '006418')
	U_GravaSX1 (cPerg, "04", 'zz')
	U_GravaSX1 (cPerg, "05", '2020')
	U_GravaSX1 (cPerg, "06", 2)  // gerar/simular
	U_szi_icp (.t.)
return
*/
/*
	// aKeyValues:= {"USR_CODIGO","USR_NOME","USR_EMAIL","USR_MSBLQL"}
	// Para obter as informaï¿½ï¿½es das empresas que o usuï¿½rio tem acesso, deve-se usar a funï¿½ï¿½o FWUsrEmp
	// FWSFallGrps
	// http://sempreju.com.br/principais-funcoes-para-informacoes-de-usuarios/
	// RETORNA O MESMO QUE PSWRET(), MAS PRA TODOS OS USUARIOS --> u_showarray (allusers ())
	u_log2 ('debug', pswret ())
//	u_showarray (pswret ())
	PswOrder(1)
	if PswSeek ('000653', .T.)
		_aPswRet := PswRet ()
		u_log2 ('debug', _apswret)
	else
		u_log2 ('erro', 'Nao localizei usuario')
	endif

	_aSup := FWSFUsrSup('000653')
	For _i := 1 to Len(_aSup)
		u_log2 ('info', 'Superior: ' + _aSup [_i])
	next

	// Retorna regras / politicas
	_aUsers := FWSFAllRules()
	U_LOG2 ('INFO', _aUsers)

	_aRet := FWGetMnuAccess (__cUserID, 97 )
	u_log2 ('info', _aRet)

	// https://tdn.totvs.com/pages/viewpage.action?pageId=42796368
	// https://tdn.totvs.com/display/tec/GetUserFromSID
	//_aSID = GetUserFromSID ()
	//u_log2 ('info', _aSID)

	// http://microsigadvpl.blogspot.com/2010/09/pegando-senhas-dos-usuarios-do-protheus.html
	
	if "TESTE" $ upper (GetEnvServer())
		cKey1 := cKey2 := cKey3 := cPswDet := ''
		nRetUser := 2
		u_log2 ('info', 'chamando getfields')
		SPF_GETFIELDS('sigapss.spf',nRetUser,@cKey1,@cKey2,@cKey3,@cPswDet)
		oXml:=XmlParser(cPswDet,"_",@cErro,@cWarn)
		u_log2 ('debug', XMLSaveStr(oXml))
	endif

return
*/
	/*
	// Puxa ZZ9 da base quente para base teste, para simular geracao de notas.
	if "TESTE" $ upper (GetEnvServer())
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "update ZZ9010 set D_E_L_E_T_ = '*' where ZZ9_SAFRA = '2020'"
		if _oSQL:Exec ()
			_oSQL:_sQuery := " SELECT * from LKSRV_PROTHEUS.protheus.dbo.ZZ9010 WHERE D_E_L_E_T_ = '' AND ZZ9_SAFRA = '2020'"
			_sAliasQ = _oSQL:Qry2Trb ()
			do while ! (_sAliasQ) -> (eof ())
				if (_sAliasQ) -> (recno ()) % 10 == 0
					u_log2 ('info', 'copiando ZZ9 reg. ' + cvaltochar ((_sAliasQ) -> (recno ())) + ' de ' + cvaltochar ((_sAliasQ) -> (reccount ())))
				endif
				reclock ("ZZ9", .T.)
				for _nCampo = 1 to zz9 -> (fcount ())
					_sCampo = alltrim (zz9 -> (fieldname (_nCampo)))
					_xDado = (_sAliasQ) -> &(_sCampo)
					zz9 -> &(_sCampo) = _xDado
				next
				msunlock ()
				(_sAliasQ) -> (dbskip ())
			enddo
		endif
	endif
return
*/
/* Acho que vai dar 1 trabalhao e nao tenho tempo.
	// Gera planilha com tabelas de precos de uvas em formato amigavel.
	local _aTabFinal := {}
	local _nQualTab := 0
	local _aGrpUva := {}
	local _nGrpUva := 0
	_nQualTab = 1

	// Define quais grupos de uvas devem ser lidos
	if _nQualTab == 1  // Uvas comuns
		
		if _sSafra == '2020'
			_aGrpUva = {'101','111','131','141','151','152'}

			// Cria uma linha na tabela final que vai servir como titulos das colunas.
			aadd (_aTabFinal, {'Grau', 'Conv/bordadura', 'Em conversao', 'Organica', 'Conv/bordadura', 'Em conversao', 'Organica', 'Conv/bordadura', 'Em conversao', 'Organica', 'Conv/bordadura', 'Em conversao', 'Organica', 'Conv/bordadura', 'Em conversao', 'Organica', 'Conv/bordadura', 'Em conversao', 'Organica'}
		endif

	elseif _nQualTab == 2  // Viniferas espaldeira
		if _sSafra == '2020'
			_aGrpUva = {'210','211','213','214'}
		endif

	elseif _nQualTab == 3  // Viniferas latadas
		if _sSafra == '2020'
			_aGrpUva = {'301','302','304','305'}
		endif
	endif

	// Cria linhas com as variedades no inicio da tabela final.
	for _nGrpUva = 1 to len (_aGrpUva)

		// Verifica em qual coluna da tabela final esta variedades devem aparecer
		local _nColTbFin := 0
		_nColTbFin = _nGrpUva * (parei aqui) + 1
		// Monta lista com as variedades do grupo
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT RTRIM (ZX5_14PROD) + '-' + RTRIM (B1_DESC)"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("ZX5") + " ZX5, "
		_oSQL:_sQuery +=             RetSQLName ("ZB1") + " SB1 "
		_oSQL:_sQuery += " WHERE ZX5.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND ZX5_FILIAL     = '" + xfilial ("ZX5") + "'"
		_oSQL:_sQuery +=   " AND ZX5_TABELA     = '14'"
		_oSQL:_sQuery +=   " AND ZX5_14SAFR     = '" + _sSafra + "'"
		_oSQL:_sQuery +=   " AND ZX5.ZX5_14GRUP = '" + _aGrpUva [_nGrpUva] + "'"
		_oSQL:_sQuery +=   " AND SB1.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
		_oSQL:_sQuery +=   " AND SB1.B1_COD     = ZX5.ZX5_14PROD"
		_oSQL:_sQuery += " ORDER BY B1_DESC"
		_oSQL:Log ()
		local _aVaried := {}
		local _nVaried := 0
		_aVaried := aclone (_oSQL:Qry2Array ())
		for _nVaried = 1 to len (_aVaried)

			// Se nao tem linha disponivel para esta variedade na array final, cria uma linha nova.
			_nLinDest = ascan (_aTabFinal, {|_aVal| empty (_aVal [_nGrpUva + 1])})
		next
return
*/
/*
	// Gera precos para as pre-notas de compra de safra.
	Private cPerg   := "VAZZ9P"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2019') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // produto ini
	U_GravaSX1 (cPerg, '07', 'z')    // fim
	U_GravaSX1 (cPerg, '08', 3)      // tipos uvas {"Comuns","Finas","Todas"}
	U_GravaSX1 (cPerg, '09', 2)      // regrava com NF ja gerada {"Sim", "Nao"}
	U_GravaSX1 (cPerg, '10', 1)      // regrava com obs {"Regrava","Nao altera"}
	U_GravaSX1 (cPerg, '11', '')     // Filial inicial
	U_GravaSX1 (cPerg, '12', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '13', 'O')    // parcela ini
	U_GravaSX1 (cPerg, '14', 'O')    // parcela final
	U_GravaSX1 (cPerg, '15', 2)      // regrava se ja tiver preco {"Sim", "Nao"}
	U_VA_ZZ9P (.t.)
return
*/
/*	// Gera adiantamento 2a. parcela safra 2020
	Private cPerg   := "VA_ADSAF"
	U_GravaSX1 (cPerg, '01', '') //012000')
	U_GravaSX1 (cPerg, '02', '')
	U_GravaSX1 (cPerg, '03', 'z') //012800')
	U_GravaSX1 (cPerg, '04', 'z')
	U_GravaSX1 (cPerg, '05', '2020')
	U_GravaSX1 (cPerg, '06', 2)  // Simular / Gerar
	U_GravaSX1 (cPerg, '07', stod ('20200430'))  // Data para pagto
	U_GravaSX1 (cPerg, '08', '041')  // Banco
	U_GravaSX1 (cPerg, '09', '0873')  // Agencia
	U_GravaSX1 (cPerg, '10', '0685668204')  // Conta
	U_GravaSX1 (cPerg, '11', 2)  // Qual parcela vai ser adiantada (primeira, segunda, ...)
	U_GravaSX1 (cPerg, '12', 2)  // Qual preco do ZZ9 deve ser usado
	U_GravaSX1 (cPerg, '13', STOD ('20200328'))  // Ignorar debitos CC antes desta data (em que foi gerado o adto. da parcela anterior)
	u_va_adsaf (.T.)
return
*/
/*
	// Gera precos para as pre-notas de compra de safra.
	Private cPerg   := "VAZZ9P"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2020') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // produto ini
	U_GravaSX1 (cPerg, '07', 'z')    // fim
	U_GravaSX1 (cPerg, '08', 3)      // tipos uvas {"Comuns","Finas","Todas"}
	U_GravaSX1 (cPerg, '09', 2)      // regrava com NF ja gerada {"Sim", "Nao"}
	U_GravaSX1 (cPerg, '10', 1)      // regrava com obs {"Regrava","Nao altera"}
	U_GravaSX1 (cPerg, '11', '')     // Filial inicial
	U_GravaSX1 (cPerg, '12', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '13', '')    // parcela ini
	U_GravaSX1 (cPerg, '14', 'z')    // parcela final
	U_GravaSX1 (cPerg, '15', 1)      // regrava se ja tiver preco {"Sim", "Nao"}
	U_VA_ZZ9P (.t.)
return
*/

/*
	Private cPerg   := "VA_ADSAF"
	U_GravaSX1 (cPerg, '01', '012000')
	U_GravaSX1 (cPerg, '02', '')
	U_GravaSX1 (cPerg, '03', '012800')
	U_GravaSX1 (cPerg, '04', 'z')
	U_GravaSX1 (cPerg, '05', '2020')
	U_GravaSX1 (cPerg, '06', 1)  // Simular / Gerar
	U_GravaSX1 (cPerg, '07', stod ('20200331'))  // Data para pagto
	U_GravaSX1 (cPerg, '08', '041')  // Banco
	U_GravaSX1 (cPerg, '09', '0873')  // Agencia
	U_GravaSX1 (cPerg, '10', '0685668204')  // Conta
	u_va_adsaf (.T.)
return
*/
/*
	// sIMULA EXECUCAO DO RATEIO de estocagem
	_ddfim := '20190131'
	_ddini := substr(_ddfim,1,6) + '01'
	// Cria array com os produtos do tipo VD e seus saldos em estoque na data final do periodo.
	// Somente aqueles que nao tem mao de obra na estrutra (os demais custeiam pelo "AO-, GF- e AP-")
	if _lContinua
		incproc ('Verificacao saldos estoque')
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "WITH C AS ("
		_oSQL:_sQuery += "SELECT B2_COD, B2_LOCAL,"
		_oSQL:_sQuery +=       " dbo.VA_SALDOESTQ (SB2.B2_FILIAL, SB2.B2_COD, SB2.B2_LOCAL, '" + _dDFim + "') AS SALDOESTQ"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB2") + " SB2,"
		_oSQL:_sQuery +=             RetSQLName ("SB1") + " SB1"
		_oSQL:_sQuery += " WHERE SB2.D_E_L_E_T_  = ''"
		_oSQL:_sQuery +=   " AND SB2.B2_FILIAL   = '"  + XFilial("SB2") + "' "
		_oSQL:_sQuery +=   " AND SB2.B2_COD      = B1_COD "
		_oSQL:_sQuery +=   " AND SB1.D_E_L_E_T_  = ''"
		_oSQL:_sQuery +=   " AND SB1.B1_FILIAL   = '"  + XFilial("SB1") + "' "
		_oSQL:_sQuery +=   " AND SB1.B1_TIPO     = 'VD' "
		_oSQL:_sQuery +=   " AND SB1.B1_AGREGCU != '1' "
		_oSQL:_sQuery +=   " AND NOT EXISTS (SELECT *"
		_oSQL:_sQuery +=                     " FROM " + RETSQLNAME ("SG1") + " SG1 "
		_oSQL:_sQuery +=                    " WHERE SG1.D_E_L_E_T_ != '*'"
		_oSQL:_sQuery +=                      " AND SG1.G1_FILIAL   = '" + xfilial ("SG1") + "'"
		_oSQL:_sQuery +=                      " AND SG1.G1_COD      = SB1.B1_COD"
		_oSQL:_sQuery +=                      " AND SG1.G1_INI     <= '" + _dDFim + "'"
		_oSQL:_sQuery +=                      " AND SG1.G1_FIM     >= '" + _dDFim + "'"
		_oSQL:_sQuery +=                      " AND SG1.G1_COMP    LIKE 'MMM%'"
		_oSQL:_sQuery +=                    ")"
		_oSQL:_sQuery += " )"
		_oSQL:_sQuery += " SELECT C.*, SUM (SALDOESTQ) OVER () AS ESTQ_TOT"
		_oSQL:_sQuery +=  " FROM C"
		//_oSQL:_sQuery += " WHERE SALDOESTQ > 0"
		_oSQL:_sQuery += " WHERE SALDOESTQ > 0.01"  // Evita pegar produtos com saldo muito pequeno
		_oSQL:Log ()
		_aEstq = aclone (_oSQL:Qry2Array ())
		if len (_aEstq) == 0
			u_help ("Nao foi encontrado nenhum produto com estoque em " + dtoc (stod (_dDFim)) + " e que precise rateio.")
			_lContinua = .F.
		else
			_nTotEstq = _aEstq [1, 4]
		endif
		u_log ('Estoques:', _aEstq)
	endif

	_aCC = {}
	aadd (_aCC, {'011101', 99584.36,  '300'})
	aadd (_aCC, {'011102', 175876.08, '301'})
	aadd (_aCC, {'011201', 77640.88,  '302'})
	aadd (_aCC, {'011202', 57885.53,  '303'})
	_aDist := {}
	for _nCC = 1 to len (_aCC)
		_nADistr = _aCC [_nCC, 2]
		//u_log ('Valor a distribuir:', _nADistr)
		for _nEstq = 1 to len (_aEstq)
			_nQtd = _aEstq [_nEstq, 3]
		
			// Gera, para cada produto, uma movimentacao de custo proporcional a seu estoque.
			_nCusMvTot = _nQtd * _nADistr / _nTotEstq

			u_log ("union all SELECT '01' AS FILIAL, '20190131' AS EMISSAO, '" + _aCC [_nCC, 3] + "' AS TM, '" + _aEstq [_nEstq, 1] + "' AS ITEM, '" + _aEstq [_nEstq, 2] + "' as LOCAL, " + CVALTOCHAR (_nCusMvTot) + " aS VALOR")
			aadd (_aDist, {_aCC [_nCC, 1], _aCC [_nCC, 2], _aEstq [_nEstq, 1], _aEstq [_nEstq, 2], _aEstq [_nEstq, 3], _nCusMvTot})
		next
	next
	U_AColsXLS (_aDist)
return
*/
/*
	// Recalcula classificacao uvas para 2020 e compara com conteudo gravado no SZF.
	_sLinkSrv = U_LkServer ('NAWEB')
	private _aRusInsp := {}
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT FILIAL, SAFRA, CARGA "
	_oSQL:_sQuery +=  " FROM VA_VCARGAS_SAFRA"
	_oSQL:_sQuery += " WHERE SAFRA = '2020' AND FILIAL = '" + xfilial ("SZE") + "'"
	_oSQL:_sQuery +=   " and STATUS != 'C'"
	_oSQL:_sQuery +=   " and GRAU != ''"
	//_oSQL:_sQuery +=   " and PRODUTO = '9861'"
	//_oSQL:_sQuery +=   " and VARUVA = 'F'"
	//_oSQL:_sQuery +=   " and VARUVA = 'F'"
	//_oSQL:_sQuery +=   " AND CARGA in ('0065','0096','1051','1207')"
	_oSQL:_sQuery += " ORDER BY CARGA"
	_oSQL:Log ()
	_aCargas = _oSQL:Qry2Array ()
//	u_log (_aCargas)
	for _nCarga = 1 to len (_aCargas)
		u_log (replicate ('-', 80))
		szf -> (dbsetorder (1))  // filial + safra + carga + item
		sze -> (dbsetorder (1))
		if sze -> (dbseek (_aCargas [_nCarga, 1] + _aCargas [_nCarga, 2] + _aCargas [_nCarga, 3], .T.))
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += " SELECT SITUACAO,"
			_oSQL:_sQuery +=        " VAR_NAO_PREV_CAD_VIT as VarNaoPrev,"
			_oSQL:_sQuery +=        " ENTREGOU_CADERNO_CPO as EntrCad,"
			_oSQL:_sQuery +=        " BOTRYTIS_PATIO as BOTRYP, "
			_oSQL:_sQuery +=        " BOTRYTIS_TOMBADOR AS BOTRYT, "
			_oSQL:_sQuery +=        " GLOMERELLA_PATIO as GlomeP, "
			_oSQL:_sQuery +=        " GLOMERELLA_TOMBADOR as GlomeT, "
			_oSQL:_sQuery +=        " ASPERGILLUS_PATIO as AsperP, "
			_oSQL:_sQuery +=        " ASPERGILLUS_TOMBADOR as AsperT, "
			_oSQL:_sQuery +=        " PODRIDAO_ACIDA_PATIO as PodriP, "
			_oSQL:_sQuery +=        " PODRIDAO_ACIDA_TOMBADOR as PodriT, "
			_oSQL:_sQuery +=        " ACIDEZ_VOLATIL_PATIO as AcVolP, "
			_oSQL:_sQuery +=        " ACIDEZ_VOLATIL_TOMBADOR as AcVolT, "
			_oSQL:_sQuery +=        " MATERIAIS_ESTRANHOS_PATIO as MEstrP, "
			_oSQL:_sQuery +=        " MATERIAIS_ESTRANHOS_TOMBADOR as MEstrT, "
			_oSQL:_sQuery +=        " MISTURA_VARIEDADES as Mistu"
			_oSQL:_sQuery +=   " FROM " + _sLinkSrv + ".VA_VINSPECOES_SAFRA_" + _aCargas [_nCarga, 2]
			_oSQL:_sQuery +=  " WHERE SAFRA  = '" + sze -> ze_safra  + "'"
			_oSQL:_sQuery +=    " AND FILIAL = '" + sze -> ze_filial + "'"
			_oSQL:_sQuery +=    " AND CARGA  = '" + sze -> ze_carga  + "'"
			_oSQL:Log ()
			_sAliasInsp = _oSQL:Qry2Trb (.F.)

			// Alimenta array de inspecoes. Deve estar previamente criada como 'private' na rotina chamadora.
			_aRusInsp = aclone (afill (array (.InspecoesSafraQtColunas), ''))

			if (_sAliasInsp) -> (eof ())
				u_log ('Sem retorno na consulta de inspecoes. Vou assumir valores padrao.')
				// Se nao encontou inspecao, assume status vazio e nao conforme para facilitar nos testes posteriores.
				_aRusInsp [.InspecoesSafraSituacao]         = '   '
				_aRusInsp [.InspecoesSafraVarNaoPrevCadVit] = 'N'  // N='Nao teve nenhuma variedade nao prevista no cadastro viticola'
				_aRusInsp [.InspecoesSafraEntrCadCpo]       = 'S'  // S='entregou caderno de campo'
				_sInspBotr = ''
				_sInspGlom = ''
				_sInspAspe = ''
				_sInspPodr = ''
				_sInspAcid = ''
				_sInspMEst = ''
			else
				_aRusInsp [.InspecoesSafraSituacao]          = (_sAliasInsp) -> situacao
				_aRusInsp [.InspecoesSafraVarNaoPrevCadVit]  = (_sAliasInsp) -> VarNaoPrev
				_aRusInsp [.InspecoesSafraEntrCadCpo]        = (_sAliasInsp) -> EntrCad
				_aRusInsp [.InspecoesSafraMisturaNoTombador] = (_sAliasInsp) -> Mistu

				// Se tem resultado na inspecao de tombador, melhor. Senao, pega a de patio.
				_sInspBotr = iif (! empty ((_sAliasInsp) -> BotryT), (_sAliasInsp) -> BotryT, (_sAliasInsp) -> BotryP)
				_sInspGlom = iif (! empty ((_sAliasInsp) -> GlomeT), (_sAliasInsp) -> GlomeT, (_sAliasInsp) -> GlomeP)
				_sInspAspe = iif (! empty ((_sAliasInsp) -> AsperT), (_sAliasInsp) -> AsperT, (_sAliasInsp) -> AsperP)
				_sInspPodr = iif (! empty ((_sAliasInsp) -> PodriT), (_sAliasInsp) -> PodriT, (_sAliasInsp) -> PodriP)
				_sInspAcid = iif (! empty ((_sAliasInsp) -> AcVolT), (_sAliasInsp) -> AcVolT, (_sAliasInsp) -> AcVolP)
				_sInspMEst = iif (! empty ((_sAliasInsp) -> MEstrT), (_sAliasInsp) -> MEstrT, (_sAliasInsp) -> MEstrP)
			endif
			(_sAliasInsp) -> (dbclosearea ())
			dbselectarea ("SZE")
			
			u_log ('Inspecoes:')
			u_log (   'Situacao da carga no APP........: ', _aRusInsp [.InspecoesSafraSituacao])
			u_log (   'Varied.nao prevista no cad.vitic: ', _aRusInsp [.InspecoesSafraVarNaoPrevCadVit])
			u_log (   'Entrega cad.campo...............: ', _aRusInsp [.InspecoesSafraEntrCadCpo])
			u_log (   'Mistura variedades no tombador..: ', _aRusInsp [.InspecoesSafraMisturaNoTombador])
			u_log (   'Chave agenda original...........: ', _aRusInsp [.InspecoesSafraAgendaOri])
			u_log (   'Botrytis......:', _sInspBotr)
			u_log (   'Glomerella....:', _sInspGlom)
			u_log (   'Aspergyllus...:', _sInspAspe)
			u_log (   'Podridoes.....:', _sInspPodr)
			u_log (   'Acidez volatil:', _sInspAcid)
			u_log (   'Mat.estranho..:', _sInspMEst)

			sb1 -> (dbsetorder (1))
			szf -> (dbsetorder (1))  // filial + safra + carga + item
			szf -> (dbseek (xfilial ("SZF") + sze -> ze_safra + sze -> ze_carga, .T.))
			do while ! szf -> (eof ()) .and. szf -> zf_filial == xfilial ("SZF") .and. szf -> zf_safra == sze -> ze_safra .and. szf -> zf_carga == sze -> ze_carga
				if ! sb1 -> (dbseek (xfilial ("SB1") + szf -> zf_produto, .F.))
					u_log ('Produto nao cadastrado:', szf -> zf_produto)
				else
					u_log ('Filial:', sze -> ze_filial, 'Safra:', sze -> ze_safra, 'Carga:', sze -> ze_carga, 'Item:', szf -> zf_item, 'Grau:', szf -> zf_grau)
					_aClasUva = aclone (U_ClUva20 (szf -> zf_produto, val (szf -> zf_grau), szf -> zf_conduc, val (_sInspBotr), val (_sInspGlom), val (_sInspAspe), val (_sInspPodr), val (_sInspAcid), _sInspMEst))
					u_log (_aClasUva)
					reclock ("SZF", .F.)
					if szf -> zf_conduc == 'L'
						szf -> zf_clabd_2 = _aClasUva [1]
						if alltrim (_aClasUva [1]) != alltrim (szf -> zf_clasABD)
							u_log ('no ZF_CLASABD consta ', szf -> zf_clasABD, 'zf_obs:', szf -> zf_obs)
						endif
					else
						szf -> zf_prm99_2 = _aClasUva [5]
						if alltrim (_aClasUva [5]) != alltrim (szf -> zf_prm99)
							u_log ('no ZF_CLASSE consta ', szf -> zf_prm99, 'zf_obs:', szf -> zf_obs)
						endif
					endif
					msunlock ()
				endif
				szf -> (dbskip ())
			enddo
		endif
	next
return
*/

/*	_a := {}
	aadd (_a, {'0345', '0082', nil   , nil   , '9901'})
	aadd (_a, {''    , '0328', '0150', '8010', nil})
	aadd (_a, {'0005', nil   , '0151', '8011', 0})
	aadd (_a, {'0348', nil   , ''    , '8012', nil})
	_oLstPrd := ClsAUtil ():New (_a)
	_oLstPrd:ReduzLin ()
	u_log (_oLstPrd:_aArray)
return
*/
/*
	// Gera alguns XML para testar criacao de novas cargas
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT top 100 FILIAL, SAFRA, CARGA "
	_oSQL:_sQuery +=  " FROM VA_VCARGAS_SAFRA"
	_oSQL:_sQuery += " WHERE SAFRA = '2019' AND FILIAL = '" + xfilial ("SZE") + "'"
	_oSQL:_sQuery +=   " and STATUS != 'C' And CONTRANOTA != ''"
	_oSQL:_sQuery +=   " and NOT EXISTS (SELECT * FROM SZE010 WHERE ZE_FILIAL = FILIAL AND ZE_SAFRA = '2020' AND ZE_ASSOC = ASSOCIADO AND ZE_NFPROD = NF_PRODUTOR)"
	_oSQL:_sQuery += " ORDER BY CARGA"
	_oSQL:Log ()
	_aCargas = _oSQL:Qry2Array ()
//	u_log (_aCargas)
	for _nCarga = 1 to len (_aCargas)
		szf -> (dbsetorder (1))  // filial + safra + carga + item
		sze -> (dbsetorder (1))
		if sze -> (dbseek (_aCargas [_nCarga, 1] + _aCargas [_nCarga, 2] + _aCargas [_nCarga, 3], .T.))
			sb1 -> (dbsetorder (1))
			szf -> (dbsetorder (1))  // filial + safra + carga + item
			szf -> (dbseek (xfilial ("SZF") + sze -> ze_safra + sze -> ze_carga, .T.))
			_sXML := "#$XML += '<Acao>IncluiCargaSafra</Acao><Safra>2020</Safra><Balanca>LB</Balanca><Associado>" + sze -> ze_assoc + '</Associado><Loja>' + sze -> ze_lojasso + '</Loja><SerieNfProdutor>' + sze -> ze_snfprod + '</SerieNfProdutor><NumeroNfProdutor>' + sze -> ze_nfprod + '</NumeroNfProdutor><ChaveNFPe></ChaveNFPe><PlacaVeiculo>' + sze -> ze_placa + '</PlacaVeiculo><Tombador>1</Tombador><Obs>Teste WS para inclusao de carga de uva durante a safra</Obs><coletarAmostra>N</coletarAmostra>'
			_sItem = '1'
			do while ! szf -> (eof ()) .and. szf -> zf_filial == xfilial ("SZF") .and. szf -> zf_safra == sze -> ze_safra .and. szf -> zf_carga == sze -> ze_carga
				_sXML += "<cadastroViticola" + _sItem + ">" + szf -> zf_cadviti + "</cadastroViticola" + _sItem + "><Variedade" + _sItem + ">" + szf -> zf_produto + "</Variedade" + _sItem + "><Embalagem" + _sItem + ">G</Embalagem" + _sItem + ">"
				_sItem = soma1 (_sItem)
				szf -> (dbskip ())
			enddo
			u_log (_sXML + "'")
		endif
	next
return
*/
/*
	// teste leitura inspecoes safra
	_sLinkSrv = U_LkServer ('NAWEB')
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT top 50 FILIAL, SAFRA, CARGA "
	_oSQL:_sQuery +=  " FROM VA_VCARGAS_SAFRA"
	_oSQL:_sQuery += " WHERE SAFRA = '2020' AND FILIAL = '01'"
	_oSQL:_sQuery +=   " and STATUS != 'C'"
	_oSQL:Log ()
	_aCargas = _oSQL:Qry2Array ()
	for _nCarga = 1 to len (_aCargas)
		szf -> (dbsetorder (1))  // filial + safra + carga + item
		sze -> (dbsetorder (1))
		if sze -> (dbseek (_aCargas [_nCarga, 1] + _aCargas [_nCarga, 2] + _aCargas [_nCarga, 3], .T.))
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += " SELECT SITUACAO,"
			_oSQL:_sQuery +=        " VAR_NAO_PREV_CAD_VIT as VarNaoPrev,"
			_oSQL:_sQuery +=        " ENTREGOU_CADERNO_CPO as EntrCad,"
			_oSQL:_sQuery +=        " BOTRYTIS_PATIO as BOTRYP, "
			_oSQL:_sQuery +=        " BOTRYTIS_TOMBADOR AS BOTRYT, "
			_oSQL:_sQuery +=        " GLOMERELLA_PATIO as GlomeP, "
			_oSQL:_sQuery +=        " GLOMERELLA_TOMBADOR as GlomeT, "
			_oSQL:_sQuery +=        " ASPERGILLUS_PATIO as AsperP, "
			_oSQL:_sQuery +=        " ASPERGILLUS_TOMBADOR as AsperT, "
			_oSQL:_sQuery +=        " PODRIDAO_ACIDA_PATIO as PodriP, "
			_oSQL:_sQuery +=        " PODRIDAO_ACIDA_TOMBADOR as PodriT, "
			_oSQL:_sQuery +=        " ACIDEZ_VOLATIL_PATIO as AcVolP, "
			_oSQL:_sQuery +=        " ACIDEZ_VOLATIL_TOMBADOR as AcVolT, "
			_oSQL:_sQuery +=        " MATERIAIS_ESTRANHOS_PATIO as MEstrP, "
			_oSQL:_sQuery +=        " MATERIAIS_ESTRANHOS_TOMBADOR as MEstrT, "
			_oSQL:_sQuery +=        " DESUNIFORMIDADE_MATURACAO_PATIO as DesunP, "
			_oSQL:_sQuery +=        " DESUNIFORMIDADE_MATURACAO_TOMBADOR as DesunT, "
			_oSQL:_sQuery +=        " MISTURA_VARIEDADES as Mistu"
			_oSQL:_sQuery +=   " FROM " + _sLinkSrv + ".VA_VINSPECOES_SAFRA"
			_oSQL:_sQuery +=  " WHERE SAFRA  = '" + sze -> ze_safra  + "'"
			_oSQL:_sQuery +=    " AND FILIAL = '" + sze -> ze_filial + "'"
			_oSQL:_sQuery +=    " AND CARGA  = '" + sze -> ze_carga  + "'"
			_oSQL:Log ()
			u_log (_oSQL:Qry2Array ())
		endif
	next
return
*/
/*
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT SA1.R_E_C_N_O_ "
	_oSQL:_sQuery += " FROM " + RetSQLName ("SA1") + " SA1 "
	_oSQL:_sQuery += " WHERE SA1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery += " AND SA1.A1_FILIAL = '" + xfilial ("SA1") + "'"  // Deixar esta opcao para poder ler os campos memo.
	_oSQL:_sQuery += " AND EXISTS (SELECT *"
	_oSQL:_sQuery += "			   FROM " + RetSQLName ("SZN") + " SZN "	
	_oSQL:_sQuery += "			   WHERE SZN.ZN_CODEVEN = 'ALT001'"
	_oSQL:_sQuery += "			   AND SZN.ZN_ALIAS = 'SA1'"
	_oSQL:_sQuery += "			   AND SZN.ZN_DATA >= '20190801'"
	_oSQL:_sQuery += "			   AND SZN.ZN_USUARIO IN ('ADMINISTRADOR', 'robert.koch')"
	_oSQL:_sQuery += "			   AND SZN.ZN_PILHA LIKE '%BATLIMCR%'"
	_oSQL:_sQuery += "			   AND SZN.ZN_CLIENTE = SA1.A1_COD"
	_oSQL:_sQuery += "			   AND SZN.ZN_LOJACLI = SA1.A1_LOJA)
	_oSQL:Log ()
	_aDados = aclone (_oSQL:Qry2Array ())
	For _nLinha := 1 To Len(_aDados)
		sa1 -> (dbgoto (_aDados [_nLinha, 1]))
		U_LOG (SA1 -> A1_COD)
		U_AtuMerc ("SA1", sa1 -> (recno ()))
	next
return
*/
/*
	cPerg := "VASESCO"
	U_GravaSX1 (cPerg, '01', '2019')
	U_GravaSX1 (cPerg, '02', '08')
	U_GravaSX1 (cPerg, '03', 'c:\temp\sescoop_08.txt')
	U_GravaSX1 (cPerg, '04', 257)  // qt func
	U_GravaSX1 (cPerg, '05', 3)  // admitidos
	U_GravaSX1 (cPerg, '06', 4)  // demitidos
	U_GravaSX1 (cPerg, '07', 1)  // 1=gerar planilha;2=gerar arquivo
	U_GravaSX1 (cPerg, '08', '517/518/519')  // Visoes gerenciais a usar
	U_VA_SESCO (.T.)
return
*/
/*
	// limpa SIX duplicado
	use \robert\six_dupl VIA 'DBFCDXADS' exclusive new alias _dup
	pack
	//u_logtrb ('_dup', .t.)
	//index on indice to &(criatrab ({}, .F.))
	_i = 1
	_nTotReg = _dup -> (reccount ())
	do while _i <= _nTotReg
		u_log (_i) //, _i, 'de', _nTotReg)
		_dup -> (dbgoto (_i))
		_aRegOri = {_dup -> indice, _dup -> ordem, _dup -> chave}
		_j = _i + 1
		do while _j <= _nTotReg
			//u_log ('_j', _j)
			_dup -> (dbgoto (_j))
			if _dup -> indice == _aRegOri [1] .and. _dup -> ordem == _aRegOri [2] .and. _dup -> chave == _aRegOri [3]
				//u_log (_j, 'duplicado')
				_dup -> (dbdelete ())
			endif
			_j ++
		enddo
		_i ++
	enddo
return
*/
/*
	cPerg := "VA_GSE2"
	U_GravaSX1 (cPerg, '01', 'c:\temp\km_cedulas.csv')
	U_GravaSX1 (cPerg, '02', stod ('20191008'))
	U_VA_GSE2 (.t.)
return
*/
/*
	// Atualiza tabelas de verbas (ZA4 e ZA5) para casos em que o desconto na baixa do contas a receber nao estava gravando (GLPI 6573)
	//se5 -> (dbgoto (1638881)) ; _wNumVerba = '008797'; _wValor = se5 -> e5_vadcmpv
	//se5 -> (dbgoto (1639278)) ; _wNumVerba = '008799'; _wValor = se5 -> e5_vadcmpv
	//se5 -> (dbgoto (1639280)) ; _wNumVerba = '008791'; _wValor = se5 -> e5_vadcmpv
	//se5 -> (dbgoto (1639801)) ; _wNumVerba = '008803'; _wValor = se5 -> e5_vadcmpv
	//se5 -> (dbgoto (1639925)) ; _wNumVerba = '008804'; _wValor = se5 -> e5_vadcmpv
	//se5 -> (dbgoto (1639951)) ; _wNumVerba = '008806'; _wValor = se5 -> e5_vadcmpv
	//se5 -> (dbgoto (1639953)) ; _wNumVerba = '008805'; _wValor = se5 -> e5_vadcmpv
	//se5 -> (dbgoto (1640285)) ; _wNumVerba = '008700'; _wValor = se5 -> e5_vadcmpv
	//se5 -> (dbgoto (1639929)) ; _wNumVerba = '008807'; _wValor = se5 -> e5_vadarei
	//se5 -> (dbgoto (1640551)) ; _wNumVerba = '008603'; _wValor = se5 -> e5_vaencar
	//se5 -> (dbgoto (1640277)) ; _wNumVerba = '008295'; _wValor = se5 -> e5_vadarei
	u_logtrb ("SE5")
	se1 -> (dbsetorder (2))  // E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
	if ! se1 -> (dbseek (se5 -> e5_filial + se5 -> e5_cliente + se5 -> e5_loja + se5 -> e5_prefixo + se5 -> e5_numero + se5 -> e5_parcela + se5 -> e5_tipo, .F.))
		u_help ('Nao encontrei SE1')
	else
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += " SELECT MAX(ZA5.ZA5_SEQ)"
		_oSQL:_sQuery += "   FROM " + RetSQLName ("ZA5") + " AS ZA5 "
		_oSQL:_sQuery += "   WHERE D_E_L_E_T_   = ''"
		_oSQL:_sQuery += "     AND ZA5.ZA5_NUM  = '" + @(_wnumverba) + "'"
		_oSQL:Log ()
		_aDados := _oSQL:Qry2Array ()
		_wseq := 0
		if len(_aDados) > 0
			_wseq = _aDados[1,1]
		endif
		if _wseq > 0
			u_log ('Parece que jah tem ZA5')
		else
			if _wValor == 0
				u_log ('Nao achei o valor')
			else
				u_log ('gravando')
				// grava tabela ZA5
				RecLock ("ZA5",.T.)
				za5 -> za5_num     = @(_wnumverba)
				za5 -> za5_seq     = _wseq+1
				za5 -> za5_vlr     = @(_wvalor)
				za5 -> za5_prefix  = se1 -> e1_prefixo
				za5 -> za5_doc     = se1 -> e1_num
				za5 -> za5_parc    = se1 -> e1_parcela
				za5 -> za5_tipo    = se1 -> e1_tipo
				za5 -> za5_cli	   = se1 -> e1_cliente
				za5 -> za5_loja    = se1 -> e1_loja
				za5 -> za5_tlib    = fBuscaCpo ('ZA4', 1, xfilial('ZA4') + @(_wnumverba), "ZA4_TLIB")
				za5 -> za5_usu     = alltrim (cUserName)
				za5 -> za5_dta     = ddatabase
				za5 -> za5_filial  = xFilial("ZA5") 
				MsUnLock()
				_wstatus = '2'
				_oSQL:_sQuery := ""
				_oSQL:_sQuery += " SELECT SUM(ZA4.ZA4_VLR) - ISNULL( ( SELECT ROUND(SUM(ZA5_VLR),2)"
				_oSQL:_sQuery += "         			      		       FROM " + RetSQLName ("ZA5")
				_oSQL:_sQuery += "       				  		          WHERE D_E_L_E_T_ = ''"
				_oSQL:_sQuery += "         						        AND ZA5_NUM    = ZA4.ZA4_NUM) ,0) AS VLR_SLD"
				_oSQL:_sQuery += "   FROM " + RetSQLName ("ZA4") + " AS ZA4 "
				_oSQL:_sQuery += "  WHERE D_E_L_E_T_   = ''"
				_oSQL:_sQuery += "    AND ZA4.ZA4_NUM  = '" + @(_wnumverba) + "'"
				_oSQL:_sQuery += "  GROUP BY ZA4.ZA4_NUM "
				_oSQL:Log ()
				_aDados := _oSQL:Qry2Array () //U_Qry2Array(_sQuery)
				_wsaldo := 0
				if len(_aDados) > 0
					_wsaldo = _aDados[1,1]
					if _wsaldo > 0
						_wstatus = '1'
					endif
				endif
				// grava status de utilizacao
				DbSelectArea("ZA4")
				DbSetOrder(1)
				DbSeek(xFilial("ZA4") + @(_wnumverba),.F.)
				RecLock ("ZA4",.F.)
				za4 -> za4_sutl = _wstatus
				MsUnLock()
			endif
		endif
	endif
return
*/
/*
	// Atualiza campo memo migrado de virtual para real
	sa1 -> (dbgotop ())
	do while ! sa1 -> (eof ())
		if empty (sa1 -> a1_vamudou) .and. ! empty (SA1 -> A1_VACMUDO)
			_sContAnt := alltrim (MSMM (SA1 -> A1_VACMUDO))
			if ! empty (_sContAnt)
				u_log (sa1 -> a1_cod, sa1 -> a1_loja, ' memo real:' + alltrim (sa1 -> a1_vamudou) + ' memo antigo: ' + alltrim (_sContAnt))
				reclock ("SA1", .F.)
				sa1 -> a1_vamudou = _sContAnt
				msunlock ()
			endif
		endif
		sa1 -> (dbskip ())
	enddo
return
*/
/*
	// Ajusta cadastro clientes em lote - GLPI ??? - Caiu a ST dos vinhso para RS em 01/08/2019
	sa1 -> (dbsetorder (1))
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT SA1.R_E_C_N_O_, A1_COD"
	_oSQL:_sQuery +=   " FROM " + RetSQLName ("SA1") + " SA1 "
	_oSQL:_sQuery +=  " WHERE SA1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=    " AND SA1.A1_FILIAL = '" + xfilial ("SA1") + "'"
	_oSQL:_sQuery +=    " AND A1_TIPO = 'S' AND A1_EST = 'RS' and A1_VAREGE != '2'"
	_oSQL:_sQuery +=  " ORDER BY A1_COD"
	_oSQL:Log ()
	_aDados = _oSQL:Qry2Array ()
	u_log (_aDados)
	for _i = 1 to len (_aDados)
		sa1 -> (dbgoto (_aDados [_i, 1]))
		u_log ('Verificando cli.', sa1 -> a1_cod, _i / len (_aDados) * 100, '%')

		// Cria variaveis para uso na gravacao do evento de alteracao
		regtomemory ("SA1", .F., .F.)
		m->a1_varege = '2'
		
		// Grava evento de alteracao
		_oEvento := ClsEvent():new ()
		_oEvento:AltCadast ("SA1", m->a1_cod, sa1 -> (recno ()), '', .F.)

		reclock ("SA1", .f.)
		sa1 -> a1_varege = m->a1_varege
		msunlock ()
		U_AtuMerc ("SA1", sa1 -> (recno ()))
		//exit
	next
return
*/
/*
	// Migra memo virtual para real no SZN.
	_NgRAVADO := 0
	_nVazio := 0
	szn -> (dbgotop ())
	do while ! szn -> (eof ())
		if ! empty (szn -> zn_codmemo) .AND. Empty (szn -> zn_txt)
			_sTexto = msmm (szn -> zn_codmemo,,,,3)
			if ! empty (_sTexto)
				reclock ("SZN", .F.)
				szn -> zn_txt = _sTexto
				msunlock ()
				_nGravado ++
			else
				_nVazio ++
			endif
		endif
		szn -> (dbskip ())
		if szn -> (recno ()) % 1000 == 0
			u_log (szn -> (recno ()))
		endif
	enddo
	u_log ('Gravados:', _nGravado)
	u_log ('vazios:', _nVazio)
	u_log ('finalizado')
return
*/
/*
	// Limpa registros duplicados
	sx7 -> (dbsetorder (1))
	sx7 -> (dbgotop ())
	do while ! sx7 -> (eof ())
		_sCampo = sx7 -> x7_campo
		_sSeq = sx7 -> x7_sequenc
		_sCDomin = sx7 -> x7_cdomin
		_sRegra = sx7 -> x7_regra
		_sTipo = sx7 -> x7_tipo
		_sSeek = sx7 -> x7_seek
		_sAlias = sx7 -> x7_alias
		_nOrdem = sx7 -> x7_ordem
		_sChave = sx7 -> x7_chave
		_sCondic = sx7 -> x7_condic
		
		sx7 -> (dbskip ())
		
		if sx7 -> x7_campo == _sCampo .and. sx7 -> x7_sequenc == _sSeq .and. sx7 -> x7_cdomin == _sCDomin .and. sx7 -> x7_regra == _sRegra .and. _sTipo = sx7 -> x7_tipo .and. sx7 -> x7_seek == _sSeek .and. sx7 -> x7_alias == _sAlias ;
			.and. sx7 -> x7_ordem == _nOrdem .and. sx7 -> x7_chave == _sChave .and. sx7 -> x7_condic == _sCondic
			u_log ('encontrei duplicidade para', _sCampo, _sSeq, _sCDomin, _sRegra)
			reclock ("SX7", .f.)
			sx7 -> (dbdelete ())
			msunlock ()
		//else
			//sx7 -> (dbskip ())
		endif
	enddo
	u_log ('finalizado')
return
*/
/*
	// Gera precos para as pre-notas de compra de safra.
	Private cPerg   := "VAZZ9P"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2019') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // produto ini
	U_GravaSX1 (cPerg, '07', 'z')    // fim
	U_GravaSX1 (cPerg, '08', 3)      // tipos uvas {"Comuns","Finas","Todas"}
	U_GravaSX1 (cPerg, '09', 2)      // regrava com NF ja gerada {"Sim", "Nao"}
	U_GravaSX1 (cPerg, '10', 1)      // regrava com obs {"Regrava","Nao altera"}
	U_GravaSX1 (cPerg, '11', '')     // Filial inicial
	U_GravaSX1 (cPerg, '12', 'zz')   // Filial final
	U_GravaSX1 (cPerg, '13', 'O')    // parcela ini
	U_GravaSX1 (cPerg, '14', 'O')    // parcela final
	U_GravaSX1 (cPerg, '15', 2)      // regrava se ja tiver preco {"Sim", "Nao"}
	U_VA_ZZ9P (.t.)
return
*/

/*
	Private cPerg   := "VA_EID"
	U_GravaSX1 (cPerg, '01', '')  // NF entr - forn
	U_GravaSX1 (cPerg, '02', '')  // NF entr - loja
	U_GravaSX1 (cPerg, '03', '')  // NF entr - numeros separados por barras
	U_GravaSX1 (cPerg, '04', '')  // NF entr - serie
	U_GravaSX1 (cPerg, '05', '000009885')  // NF saida - numeros separados por barras
	U_GravaSX1 (cPerg, '06', '10 ')  // NF saida - serie
	U_GravaSX1 (cPerg, '07', 2)  // Exportar registros deletados S/N
	U_VA_EID (.t.)
return
*/

// nao deu resultado
//user function MT242CPO ()
//	u_help (procname ())
//return {"D3_VAMOTIV","D3_VAETIQ"}
/*
	// Reavalia classificacao das uvas viniferas safra 2019
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT DISTINCT FILIAL, SAFRA, CARGA "
	_oSQL:_sQuery +=  " FROM VA_VCARGAS_SAFRA"
	_oSQL:_sQuery += " WHERE SAFRA = '2019' AND FILIAL = '" + xfilial ("SZE") + "'"
	_oSQL:_sQuery +=   " AND VARUVA = 'F' and STATUS != 'C'"
	_oSQL:_sQuery +=   " AND ASSOCIADO = '004927' AND PRODUTO = '9979' and STATUS != 'C'"
	_oSQL:_sQuery += " ORDER BY CARGA"
	_oSQL:Log ()
	_aCargas = _oSQL:Qry2Array ()
//	u_log (_aCargas)
	for _nCarga = 1 to len (_aCargas)
		szf -> (dbsetorder (1))  // filial + safra + carga + item
		sze -> (dbsetorder (1))
		if sze -> (dbseek (_aCargas [_nCarga, 1] + _aCargas [_nCarga, 2] + _aCargas [_nCarga, 3], .T.))
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += " SELECT SITUACAO,"
			_oSQL:_sQuery +=        " VAR_NAO_PREV_CAD_VIT as VarNaoPrev,"
			_oSQL:_sQuery +=        " ENTREGOU_CADERNO_CPO as EntrCad,"
			_oSQL:_sQuery +=        " BOTRYTIS_PATIO as BOTRYP, "
			_oSQL:_sQuery +=        " BOTRYTIS_TOMBADOR AS BOTRYT, "
			_oSQL:_sQuery +=        " GLOMERELLA_PATIO as GlomeP, "
			_oSQL:_sQuery +=        " GLOMERELLA_TOMBADOR as GlomeT, "
			_oSQL:_sQuery +=        " ASPERGILLUS_PATIO as AsperP, "
			_oSQL:_sQuery +=        " ASPERGILLUS_TOMBADOR as AsperT, "
			_oSQL:_sQuery +=        " PODRIDAO_ACIDA_PATIO as PodriP, "
			_oSQL:_sQuery +=        " PODRIDAO_ACIDA_TOMBADOR as PodriT, "
			_oSQL:_sQuery +=        " ACIDEZ_VOLATIL_PATIO as AcVolP, "
			_oSQL:_sQuery +=        " ACIDEZ_VOLATIL_TOMBADOR as AcVolT, "
			_oSQL:_sQuery +=        " MATERIAIS_ESTRANHOS_PATIO as MEstrP, "
			_oSQL:_sQuery +=        " MATERIAIS_ESTRANHOS_TOMBADOR as MEstrT, "
			_oSQL:_sQuery +=        " DESUNIFORMIDADE_MATURACAO_PATIO as DesunP, "
			_oSQL:_sQuery +=        " DESUNIFORMIDADE_MATURACAO_TOMBADOR as DesunT, "
			_oSQL:_sQuery +=        " MISTURA_VARIEDADES as Mistu"
			_oSQL:_sQuery +=   " FROM VA_VINSPECOES_SAFRA"
			_oSQL:_sQuery +=  " WHERE SAFRA  = '" + sze -> ze_safra  + "'"
			_oSQL:_sQuery +=    " AND FILIAL = '" + sze -> ze_filial + "'"
			_oSQL:_sQuery +=    " AND CARGA  = '" + sze -> ze_carga  + "'"
			//_oSQL:Log ()
			_sAliasInsp = _oSQL:Qry2Trb (.F.)

			// Alimenta array de inspecoes. Deve estar previamente criada como 'private' na rotina chamadora.
			_aRusInsp = aclone (afill (array (.InspecoesSafraQtColunas), ''))

			if (_sAliasInsp) -> (eof ())
				// Se nao encontou inspecao, assume status vazio e nao conforme para facilitar nos testes posteriores.
				_aRusInsp [.InspecoesSafraSituacao]         = '   '
				_aRusInsp [.InspecoesSafraVarNaoPrevCadVit] = 'N'  // N='Nao teve nenhuma variedade nao prevista no cadastro viticola'
				_aRusInsp [.InspecoesSafraEntrCadCpo]       = 'S'  // S='entregou caderno de campo'
				_sInspBotr = ''
				_sInspGlom = ''
				_sInspAspe = ''
				_sInspPodr = ''
				_sInspAcid = ''
				_sInspMEst = ''
				_sInspDesu = ''
			else
				_aRusInsp [.InspecoesSafraSituacao]          = (_sAliasInsp) -> situacao
				_aRusInsp [.InspecoesSafraVarNaoPrevCadVit]  = (_sAliasInsp) -> VarNaoPrev
				_aRusInsp [.InspecoesSafraEntrCadCpo]        = (_sAliasInsp) -> EntrCad
				_aRusInsp [.InspecoesSafraMisturaNoTombador] = (_sAliasInsp) -> Mistu

				// Se tem resultado na inspecao de tombador, melhor. Senao, pega a de patio.
				_sInspBotr = iif (! empty ((_sAliasInsp) -> BotryT), (_sAliasInsp) -> BotryT, (_sAliasInsp) -> BotryP)
				_sInspGlom = iif (! empty ((_sAliasInsp) -> GlomeT), (_sAliasInsp) -> GlomeT, (_sAliasInsp) -> GlomeP)
				_sInspAspe = iif (! empty ((_sAliasInsp) -> AsperT), (_sAliasInsp) -> AsperT, (_sAliasInsp) -> AsperP)
				_sInspPodr = iif (! empty ((_sAliasInsp) -> PodriT), (_sAliasInsp) -> PodriT, (_sAliasInsp) -> PodriP)
				_sInspAcid = iif (! empty ((_sAliasInsp) -> AcVolT), (_sAliasInsp) -> AcVolT, (_sAliasInsp) -> AcVolP)
				_sInspMEst = iif (! empty ((_sAliasInsp) -> MEstrT), (_sAliasInsp) -> MEstrT, (_sAliasInsp) -> MEstrP)
				_sInspDesu = iif (! empty ((_sAliasInsp) -> DesunT), (_sAliasInsp) -> DesunT, (_sAliasInsp) -> DesunP)
			endif
			(_sAliasInsp) -> (dbclosearea ())
			dbselectarea ("SZE")
			
			//u_log ('inspecoes:', _aRusInsp)

			sb1 -> (dbsetorder (1))
			szf -> (dbsetorder (1))  // filial + safra + carga + item
			szf -> (dbseek (xfilial ("SZF") + sze -> ze_safra + sze -> ze_carga, .T.))
			do while ! szf -> (eof ()) .and. szf -> zf_filial == xfilial ("SZF") .and. szf -> zf_safra == sze -> ze_safra .and. szf -> zf_carga == sze -> ze_carga
				if ! sb1 -> (dbseek (xfilial ("SB1") + szf -> zf_produto, .F.))
					u_log ('Produto nao cadastrado:', szf -> zf_produto)
				else
					if sb1 -> b1_varuva == 'F' .and. sb1 -> b1_vafcuva == 'F'
						_aClasFina = aclone (U_ClUva19 (szf -> zf_produto, val (szf -> zf_grau), szf -> zf_conduc, val (_sInspBotr), val (_sInspGlom), val (_sInspAspe), val (_sInspPodr), val (_sInspAcid), _sInspMEst, val (_sInspDesu)))

						// Assume as classificoes calculadas somente se encontrou dados de inspecao no NaWeb. Senao, assume valores medios.
						if empty (_sInspBotr) .or. empty (_sInspGlom) .or. empty (_sInspAspe) .or. empty (_sInspPodr) .or. empty (_sInspAcid) .or. empty (_sInspMEst) .or. empty (_sInspDesu)
							u_log ('Nao tenho os dados de inspecoes. Assumindo valores medios.')
							if szf -> zf_prm03 != 'B' .or. szf -> zf_prm04 != 'B' .or. szf -> zf_prm05 != 'B'
								u_log ('Classificacoes deveriam estar padrao B por falta de dados no naweb')
							endif
						endif
						
						// Verifica se ficou diferente do calculado.
						if szf -> zf_prm02 != _aClasFina [1] ;
							.or. szf -> zf_prm03 != _aClasFina [2] ;
							.or. szf -> zf_prm04 != _aClasFina [3] ;
							.or. szf -> zf_prm05 != _aClasFina [4] ;
							.or. (szf -> zf_conduc == 'L' .and. szf -> zf_clasABD != _aClasFina [5]) ;
							.or. (szf -> zf_conduc == 'E' .and. szf -> zf_prm99 != _aClasFina [5])
							_sMsg := '  acucar:[' + szf -> zf_prm02 + ' deveria ser ' + _aClasFina [1] + ']'
							_sMsg += '  sanid.:[' + szf -> zf_prm03 + ' deveria ser ' + _aClasFina [2] + ']'
							_sMsg += '  matur.:[' + szf -> zf_prm04 + ' deveria ser ' + _aClasFina [3] + ']'
							_sMsg += '  mt.estr[' + szf -> zf_prm05 + ' deveria ser ' + _aClasFina [4] + ']'
							_sMsg += '  final: [abd:' + szf -> zf_clasABD + '  prm99:' + szf -> zf_prm99 + ' deveria ser ' + _aClasFina [5] + ']'
							_sMsg += ' ' + DTOC (sze -> ze_data)
							_sMsg += ' ' + alltrim (posicione ("SB1", 1, xfilial ("SB1") + SZF -> zf_produto, "B1_DESC")) 
							_sMsg += ' grau ' + szf -> zf_grau
							_sMsg += ' de ' + alltrim (posicione ("SA2", 1, xfilial ("SA2") + sze -> ze_assoc + sze -> ze_lojasso, "A2_NOME"))
							u_log ('carga', szf -> zf_carga, _sMsg)
						endif
					endif
				endif
				szf -> (dbskip ())
			enddo
		endif
	next
	u_log ('finalizado.')
return
*/
/*	// LISTA CAMPOS OBRIGATORIOS
	sx3 -> (dbsetorder (1))
	sx3 -> (dbseek ('SD1', .t.))
	do while ! sd3 -> (eof ()) .and. sx3 -> x3_arquivo == 'SD1'
		if (x3uso(SX3->X3_USADO) .and. ((SubStr(BIN2STR(SX3->X3_OBRIGAT),1,1) == "x") .or. VerByte(SX3->x3_reserv,7)))
			u_log (sx3 -> x3_campo)
		endif
		sx3 -> (dbskip ())
	enddo
return
*/
/*
	Private cPerg   := "VAGNF2"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2019') // Safra referencia
	U_GravaSX1 (cPerg, '06', '')     // Parcelas sep.barras (bco=todas)
	U_GravaSX1 (cPerg, '07', 'C')    // Grupos
	U_GravaSX1 (cPerg, '08', 3)      // Geracao por DCO: {"Com DCO", "Sem DCO", "Todos"}
	U_GravaSX1 (cPerg, '09', 2)      // fina/comum: {"Comum", "Fina", "Todas"}
	U_GravaSX1 (cPerg, '10', 1)      // tipo NF: {"Normais", "Compl.preco"}
	U_GravaSX1 (cPerg, '11', '801')     // Cond pagto
	u_va_gnf2 (.t.)
return
*/
/*
	// importa planilha com cadastro de DAPs dos associados
	use \robert\dap VIA 'DBFCDXADS' shared new alias _dap
	//u_logtrb ('_dap', .T.)
	_dap -> (dbgotop ())
	do while ! _dap -> (eof ())
		_sCPF = substring (_dap -> cpf, 2, 3) + substring (_dap -> cpf, 6, 3) + substring (_dap -> cpf, 10, 3) + substring (_dap -> cpf, 14, 2)
		u_log (_sCPF)
		sa2 -> (dbsetorder (3))  // A2_FILIAL+A2_CGC
		if sa2 -> (dbseek (xfilial ("SA2") + _sCPF, .F.))
			_oAssoc := ClsAssoc ():New (sa2 -> a2_cod, sa2 -> a2_loja, .F.)
			sa2 -> (dbsetorder (1))
			if sa2 -> (dbseek (xfilial ("SA2") + _oAssoc:CodBase + _oAssoc:LojaBase, .F.))
				if alltrim(sa2 -> A2_VANRDAP) != alltrim (_dap -> dap) .or. sa2 -> A2_VAVLDAP != stod (_dap -> valid) .or. sa2 -> A2_VAENDAP != _dap -> enq
					u_log ('Vou atualizar no CPF', sa2 -> a2_cgc)
					_aAutoSA2 := {}
					aadd (_aAutoSA2, {"A2_COD",     sa2 -> a2_cod, NIL})
					aadd (_aAutoSA2, {"A2_LOJA",    sa2 -> a2_loja, NIL})
					aadd (_aAutoSA2, {"A2_VANRDAP", alltrim (_dap -> dap), NIL})
					aadd (_aAutoSA2, {"A2_VAVLDAP", stod (_dap -> valid), NIL})
					aadd (_aAutoSA2, {"A2_VAENDAP", _dap -> enq, NIL})
					_aAutoSA2 := aclone (U_OrdAuto (_aAutoSA2))
					//u_log (_aAutoSA2)
					lMSErroAuto := .F.
					lMSHelpAuto := .F.
					private _sErroAuto  := ""
					MSExecAuto ({|_x, _y| MATA020 (_x, _y)}, _aAutoSA2, 4)
					if lMSErroAuto
						_sErro := memoread (NomeAutoLog ())
						u_log ('Erro:', _sErro)
					endif
					if ! empty (_sErroAuto)
						u_log (_sErroAuto)
					endif
				else
					u_log ('Jah estava correto')
				endif
			else
				u_help ("Loja base do associado nao encontrada")
			endif
		else
			u_help ('CPF nao encontrado:', _sCPF)
		endif
		_dap -> (dbskip ())
	enddo
	_dap -> (dbclosearea ())
	u_log ('Finalizado')
return
*/
/*
	Private cPerg   := "VA_ECM"
	U_GravaSX1 (cPerg, '01', '02/2018')
	U_GravaSX1 (cPerg, '02', '01/2019')
	U_GravaSX1 (cPerg, '03', '')
	U_GravaSX1 (cPerg, '04', 'z')
	U_GravaSX1 (cPerg, '05', '')
	U_GravaSX1 (cPerg, '06', '1183')
	U_GravaSX1 (cPerg, '07', '')
	U_GravaSX1 (cPerg, '08', 'z')
	U_GravaSX1 (cPerg, '09', 1)
	U_GravaSX1 (cPerg, '10', '')
	U_GravaSX1 (cPerg, '11', 'z')
	U_GravaSX1 (cPerg, '12', '')
	U_GravaSX1 (cPerg, '13', 'z')
	U_GravaSX1 (cPerg, '14', 1)
	U_GravaSX1 (cPerg, '15', 1)
	U_GravaSX1 (cPerg, '16', 1)
	U_VA_ECM (.t.)
return
*/
/*
	Private cPerg   := "VA_COP"
	U_GravaSX1 (cPerg, '01', stod ('20150101'))
	U_GravaSX1 (cPerg, '02', stod ('20150131'))
	U_GravaSX1 (cPerg, '03', 1)
	U_GravaSX1 (cPerg, '04', '2444')
	U_GravaSX1 (cPerg, '05', '2445')
	U_GravaSX1 (cPerg, '06', '')
	U_GravaSX1 (cPerg, '07', '')
	U_GravaSX1 (cPerg, '08', 'z')
	U_GravaSX1 (cPerg, '09', '')
	U_GravaSX1 (cPerg, '10', 'z')
	U_GravaSX1 (cPerg, '11', '')
	U_GravaSX1 (cPerg, '12', 'z')
	U_GravaSX1 (cPerg, '13', '')
	U_VA_COP ()
return
*/
/*
	// Exclui distribuicao de sobras gerada com erro (GLPI 5254)
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := " SELECT R_E_C_N_O_"
	_oSQL:_sQuery += " FROM " + RetSQLName ("SZI") + " SZI"
	_oSQL:_sQuery += " WHERE SZI.D_E_L_E_T_ = ''"
	_oSQL:_sQuery += " AND SZI.ZI_FILIAL = '" + xfilial ("SZI") + "'"
	_oSQL:_sQuery += " AND SZI.ZI_TM = '19'"
	_oSQL:_sQuery += " AND SZI.ZI_SALDO = SZI.ZI_VALOR"
	_oSQL:_sQuery += " AND SZI.ZI_DATA = '20160331'"
	_oSQL:_sQuery += " AND SZI.ZI_PARCELA = '1'"
	_oSQL:_sQuery += " AND SZI.ZI_ASSOC NOT IN ('004348', '003154')"  // isolda longo e neusa ceccato
	_oSQL:_sQuery += " and not exists (SELECT *"
	_oSQL:_sQuery +=                   " FROM " + RetSQLName ("SZI") + " S"
	_oSQL:_sQuery +=                  " WHERE S.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=                    " AND S.ZI_FILIAL = '" + xfilial ("SZI") + "'"
	_oSQL:_sQuery +=                    " AND S.ZI_TM = '09'"
	_oSQL:_sQuery +=                    " AND S.ZI_DATA >= '20180101'"
	_oSQL:_sQuery +=                    " AND S.ZI_ASSOC = SZI.ZI_ASSOC"
	_oSQL:_sQuery +=                    " AND S.ZI_LOJASSO = SZI.ZI_LOJASSO)"
	_oSQL:_sQuery += " and not exists (SELECT *"
	_oSQL:_sQuery +=                   " FROM " + RetSQLName ("SZI") + " S"
	_oSQL:_sQuery +=                  " WHERE S.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=                    " AND S.ZI_FILIAL = '" + xfilial ("SZI") + "'"
	_oSQL:_sQuery +=                    " AND S.ZI_TM IN ('11','27')"
	_oSQL:_sQuery +=                    " AND S.ZI_ASSOC = SZI.ZI_ASSOC"
	_oSQL:_sQuery +=                    " AND S.ZI_LOJASSO = SZI.ZI_LOJASSO)"
	_oSQL:_sQuery += " ORDER BY ZI_DATA, ZI_ASSOC"
	_oSQL:Log ()
	_aDados = aclone (_oSQL:Qry2Array ())
	for _nLinha := 1 to len (_aDados)
		SZI -> (dbgoto (_aDados [_nLinha, 1]))
		u_log (szi -> zi_assoc, szi -> zi_lojasso, szi -> zi_nomasso, szi -> zi_histor)
		_oCtaCorr := ClsCtaCorr ():New (szi -> (recno ()))
		// desabilitei este linha pra evitar compilar por engano... _oCtaCorr:Exclui ()
		u_log (_oCtaCorr:UltMsg)
	next
	u_log ('Processo finalizado')
return
*/

/*	// Gera SE2 para lcto especifico do SZI
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT R_E_C_N_O_"
	_oSQL:_sQuery +=   " FROM " + RetSqlName ("SZI") + " SZI "
	_oSQL:_sQuery +=  " WHERE SZI.D_E_L_E_T_ != '*'"
	_oSQL:_sQuery +=    " AND SZI.ZI_TM = '19'"
	_oSQL:_sQuery +=    " AND SZI.ZI_ASSOC = '003603'"
	_oSQL:_sQuery +=    " AND SZI.ZI_LOJASSO = '02'"
	_oSQL:_sQuery +=    " AND SZI.ZI_SEQ = '000005'"
	_aDados = _oSQL:Qry2Array ()
	for _i = 1 to len (_aDados)
		szi -> (dbgoto (_aDados [_i, 1]))
		_oCtaCorr := ClsCtaCorr ():New (szi -> (recno ()))
		u_logobj (_oCtaCorr)
		dDataBase = stod ('20160331')
		u_log (_oCtaCorr:GeraSE2 (_oCtaCorr:OQueGera (), _oCtaCorr:DtMovto, .F.))
		u_log (_oCtaCorr:UltMsg)
	next
return
*/
/*
	// Simula calculos de precos de uva 2019
	_aVaried = {}
	aadd (_aVaried, {'01', '9925           ', 13, '', ''}) // bordo
	aadd (_aVaried, {'01', '9948           ', 13, '', ''}) // bordo em conversao
	aadd (_aVaried, {'01', '9959           ', 13, '', ''}) // bordo organico
//	aadd (_aVaried, {'01', '9904           ', 13, '', ''}) // niagara branca
//	aadd (_aVaried, {'01', '9901           ', 13, '', ''}) // isabel
//	aadd (_aVaried, {'01', '9923           ', 13, '', ''}) // seibel 2
//	aadd (_aVaried, {'01', '9847           ', 13, '', ''}) // MAGNA
//	aadd (_aVaried, {'01', '9933           ', 13, '', ''}) // lorena
//	aadd (_aVaried, {'01', '9908           ', 13, 'B', 'E'}) // cabernet
//	aadd (_aVaried, {'07', '9908           ', 13, 'B', 'E'}) // cabernet
	aadd (_aVaried, {'09', '9908           ', 13, 'B', 'E'}) // cabernet
	aadd (_aVaried, {'03', '9963           ', 13, 'B', 'E'}) // cabernet
	aadd (_aVaried, {'03', '9902           ', 11.6,'B', 'E'}) // chardonnay
	aadd (_aVaried, {'03', '9954           ', 11.6,'B', 'E'}) // gew.p/espum.
	sb1 -> (dbsetorder (1))
	_aPrecos = {}
	for _nVaried = 1 to len (_aVaried)
		if sb1 -> (dbseek (xfilial ("SB1") + _aVaried [_nVaried, 2], .F.))
			_sFil  = _aVaried [_nVaried, 1]
			_nGrau = _aVaried [_nVaried, 3]
			_sClas = _aVaried [_nVaried, 4]
			_sCond = _aVaried [_nVaried, 5]
			_aRet = U_PrcUva19 (_sFil, sb1 -> b1_cod, _nGrau, _sClas, _sCond)[4]
			for _nRet = 1 to len (_aRet)
				aadd (_aPrecos, {sb1 -> b1_cod, alltrim (sb1 -> b1_desc), 'F' + _sFil, _sClas, _sCond, _aRet [_nRet, 1], _aRet [_nRet, 2], _aRet [_nRet, 3]})
			next
		endif
	next
	u_log (_aPrecos)
//	u_acolsxls (_aPrecos)
return
*/
/*
	// GLPI5163 - Leitura da parcela H do ZZ9 e geracao de lctos na conta corrente de associados como adto.sobras (especifico para o ano de 2018)
	if cFilAnt != '01'
		u_help ('Filial errada')
		return
	endif
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT ZZ9_FORNEC, ZZ9_LOJA,SUM (ZZ9_VUNIT) AS VALOR"
	_oSQL:_sQuery +=  " from " + RETSQLNAME ("ZZ9") + " ZZ9 "
	_oSQL:_sQuery += " where ZZ9.D_E_L_E_T_ != '*'"
	_oSQL:_sQuery +=   " and ZZ9.ZZ9_SAFRA  = '2018'"
	_oSQL:_sQuery +=   " and ZZ9.ZZ9_PARCEL = 'H'"
	_oSQL:_sQuery +=   " and ZZ9.ZZ9_NFCOMP = ''"
	_oSQL:_sQuery += " GROUP BY ZZ9_FORNEC, ZZ9_LOJA"
	_oSQL:_sQuery += " ORDER BY ZZ9_FORNEC, ZZ9_LOJA"
	_oSQL:Log ()
	_sAliasQ = _oSQL:Qry2Trb ()
	procregua ((_sAliasQ) -> (reccount ()))
	(_sAliasQ) -> (dbgotop ())
	do while ! (_sAliasQ) -> (eof ())
		u_log ((_sAliasQ) -> zz9_fornec)
		// Busca uma parcela que ainda nao exista para o associado.
		_sDoc = '201812'
		_sSerie = 'DS'
		_sParcela = '1'
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := ""                                                                                            
		_oSQL:_sQuery += " select IsNull (max (E2_PARCELA), '1'),"
		_oSQL:_sQuery +=        " SUM (CASE E2_PARCELA WHEN '" + _sParcela + "' THEN 1 ELSE 0 END)"  // Contagem de ocorrencias da parcela desejada.
		_oSQL:_sQuery +=   " from " + RetSQLName ("SE2") + " SE2 "
		_oSQL:_sQuery +=  " where SE2.D_E_L_E_T_ != '*'"
		_oSQL:_sQuery +=    " and SE2.E2_FILIAL   = '" + xfilial ("SE2")   + "'"
		_oSQL:_sQuery +=    " and SE2.E2_FORNECE  = '" + (_sAliasQ) -> zz9_fornec + "'"
		_oSQL:_sQuery +=    " and SE2.E2_LOJA     = '" + (_sAliasQ) -> zz9_Loja  + "'"
		_oSQL:_sQuery +=    " and SE2.E2_NUM      = '" + _sDoc   + "'"
		_oSQL:_sQuery +=    " and SE2.E2_PREFIXO  = '" + _sSerie + "'"
		_aRetParc = aclone (_oSQL:Qry2Array ())
		if _aRetParc [1, 2] == 0  // Nao encontrou nenhuma ocorrencia da parcela desejada
			_sParcela = _sParcela
		else
			_sParcela = soma1 (_aRetParc [1, 1])
		endif
		
		_oCtaCorr := ClsCtaCorr():New ()
		_oCtaCorr:Assoc    = (_sAliasQ) -> zz9_fornec
		_oCtaCorr:Loja     = (_sAliasQ) -> zz9_loja
		_oCtaCorr:TM       = '30'
		_oCtaCorr:DtMovto  = date ()
		_oCtaCorr:Valor    = (_sAliasQ) -> valor
		_oCtaCorr:SaldoAtu = (_sAliasQ) -> valor
		_oCtaCorr:Usuario  = cUserName
		_oCtaCorr:Histor   = 'ANTECIPACAO DE SOBRAS EXERC 2018'
		_oCtaCorr:MesRef   = strzero(month(_oCtaCorr:DtMovto),2)+strzero(year(_oCtaCorr:DtMovto),4)
		_oCtaCorr:Doc      = _sDoc
		_oCtaCorr:Serie    = _sSerie
		_oCtaCorr:Origem   = 'GLPI5163'
		_oCtaCorr:Parcela  = _sParcela
		if _oCtaCorr:PodeIncl ()
			if ! _oCtaCorr:Grava (.F., .F.)
				U_help ("Erro na atualizacao da conta corrente. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg)
			else
				_oSQL := ClsSQL ():New ()
				_oSQL:_sQuery += " UPDATE " + RETSQLNAME ("ZZ9")
				_oSQL:_sQuery +=   " SET ZZ9_NFCOMP = '" + _sDoc + "', ZZ9_SERCOM = '" + _sSerie + "'"
				_oSQL:_sQuery += " where D_E_L_E_T_ != '*'"
				_oSQL:_sQuery +=   " and ZZ9_SAFRA  = '2018'"
				_oSQL:_sQuery +=   " and ZZ9_PARCEL = 'H'"
				_oSQL:_sQuery +=   " and ZZ9_FORNEC = '" + (_sAliasQ) -> zz9_fornec + "'"
				_oSQL:_sQuery +=   " and ZZ9_LOJA   = '" + (_sAliasQ) -> zz9_loja + "'"
				_oSQL:Log ()
				_oSQL:Exec ()
			endif
		else
			U_help ("Gravacao do SZI nao permitida na atualizacao da conta corrente. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg)
		endif
		(_sAliasQ) -> (dbskip ())
	enddo
	(_sAliasQ) -> (dbclosearea ())
    dbselectarea ("ZZ9")
    U_HELP ("Processo finalizado")
return
*/
*/
/*	// Compara classificacao viniferas 2018 com criterios de 2019
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT TOP 100 PRODUTO, GRAU, FILIAL, CLAS_FINAL, CLAS_ABD, ACUCAR, SANIDADE, MATURACAO, MAT_ESTRANHO FROM VA_VNOTAS_SAFRA WHERE SAFRA = '2018' AND CLAS_FINAL != '' AND TIPO_NF = 'E'"
	_oSQL:_sQuery += "ORDER BY ASSOCIADO, LOJA_ASSOC, FILIAL, DOC, SERIE, PRODUTO, GRAU"
	_oSQL:Log ()
	_sAliasQ = _oSQL:Qry2Trb ()
	do while ! (_sAliasQ) -> (eof ())
		U_ClUva19 ((_sAliasQ) -> produto, val ((_sAliasQ) -> grau), iif ((_sAliasQ) -> filial == '03', 'E', 'L'), 0, 0, 0, 0, 0, 'ausente', 0)
		u_log ('clas. original:', (_sAliasQ) -> clas_final, 'abd:', (_sAliasQ) -> clas_abd, '     ', (_sAliasQ) -> ACUCAR, (_sAliasQ) -> SANIDADE, (_sAliasQ) -> MATURACAO, (_sAliasQ) -> MAT_ESTRANHO)
		u_log ('')
		u_log ('')
		u_log ('')
		u_log ('')
		(_sAliasQ) -> (dbskip ())
	enddo
return
*/
/*
	// Gera d2_numseq para cupons recurperados
	use \robert\sd2_rk VIA 'DBFCDXADS' shared new
	_sSeq := 'x09A1H'  // PRIMEIRA SEQ DO DIA 23/11
	_oSQL := ClsSQL ():New ()
	do while ! sd2_rk -> (eof ())
		// Encontra sequencial livre na base quente. Vai demorar... mas se demorar demais, ï¿½ por que nao achou...
		do while .T.
			_oSQL:_sQuery := " SELECT (SELECT COUNT (*) FROM LKSRV_PROTHEUS.protheus.dbo.SD1010 WHERE D_E_L_E_T_ = '' AND D1_NUMSEQ = '" + _sSeq + "')"
			_oSQL:_sQuery +=      " + (SELECT COUNT (*) FROM LKSRV_PROTHEUS.protheus.dbo.SD2010 WHERE D_E_L_E_T_ = '' AND D2_NUMSEQ = '" + _sSeq + "')"
			_oSQL:_sQuery +=      " + (SELECT COUNT (*) FROM LKSRV_PROTHEUS.protheus.dbo.SD3010 WHERE D_E_L_E_T_ = '' AND D3_NUMSEQ = '" + _sSeq + "')"
			_oSQL:Log ()
			if _oSQL:RetQry () == 0
				exit
			else
				_sSeq := soma1 (_sSeq)
			endif
		enddo
		reclock ('sd2_rk', .F.)
		sd2_rk -> d2_numseq = _sSeq
		msunlock ()
		_sSeq := soma1 (_sSeq)
		sd2_rk -> (dbskip ())
	enddo
	u_log ('feito')
return
*/
/*
	cPerg = "VAGNF3"
	U_GravaSX1 (cPerg, '01', '')     // Produtor inicial
	U_GravaSX1 (cPerg, '02', '')     // Loja produtor inicial
	U_GravaSX1 (cPerg, '03', 'z')    // Produtor final
	U_GravaSX1 (cPerg, '04', 'z')    // Loja produtor final
	U_GravaSX1 (cPerg, '05', '2018') // Safra referencia
	U_GravaSX1 (cPerg, '06', 'H')    // Parcela
	U_GravaSX1 (cPerg, '07', '')     // DCO inicial
	U_GravaSX1 (cPerg, '08', 'z')    // DCO final
	U_GravaSX1 (cPerg, '09', '')     // Prod ini
	U_GravaSX1 (cPerg, '10', 'z')    // Prod final
	U_GravaSX1 (cPerg, '11', 0)    // Preco 2016
	U_VA_GNF3 (.T.)
return
*/
/* Compara SX6 com outra base de dados
	use \robert\sx6010 shared new alias sx6_medio
	index on x6_var to &(criatrab ({}, .F.))
	sx6_medio -> (dbgotop ())
	do while ! sx6_medio -> (eof ())
		if ! sx6 -> (dbseek (cFilAnt + sx6_medio -> x6_var, .F.))
			sx6 -> (dbseek ('  ' + sx6_medio -> x6_var, .F.))
		endif
		if sx6 -> (found ())
			if sx6_medio -> x6_conteud != sx6 -> x6_conteud
				u_log (sx6_medio -> x6_fil, sx6_medio -> x6_var, alltrim (sx6_medio -> x6_conteud), '------', alltrim (sx6 -> x6_conteud), '------', alltrim (sx6 -> x6_descric) + alltrim (sx6 -> x6_desc1) + alltrim (sx6 -> x6_desc2))
			endif
		else
			u_log (sx6_medio -> x6_var, 'nao encontrado')
		endif
		sx6_medio -> (dbskip ())
	enddo
	sx6_medio -> (dbclosearea ())
*/	
/*
	_aDados := {}
	sx3 -> (dbgotop ())
	do while ! sx3 -> (eof ())
		if sx3 -> x3_context != 'V' .and. sx3 -> x3_arquivo $ 'SA2'
			aadd (_aDados, {sx3 -> x3_campo, sx3 -> x3_tipo, sx3 -> x3_tamanho, sx3 -> x3_decimal, alltrim (sx3 -> x3_titulo), alltrim (sx3 -> x3_descric), sx3 -> x3_picture, strtran (sx3 -> x3_cbox, ';', '/')})
		endif
		sx3 -> (dbskip ())
	enddo
	u_log (_adados)
	u_acolsxls (_aDados)
return
*/
/*
	_sAlmox = '02'
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT *"
	_oSQL:_sQuery += " FROM " + RetSQLName ("SGQ")
	_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery += " AND GQ_FILIAL = '" + xfilial ("SGQ") + "
	_oSQL:_sQuery += " AND GQ_LOCAL  = '" + _sAlmox + "'"

	SGQ -> (dbSetOrder(1))	//FILIAL + TIPOPER + LOCAL + USER
	if SGQ -> (dbSeek (xFilial ("SGQ") + "1" + _sAlmox + _sUser))  // Tipo '1' = 'por usuario'
		u_log ('Tem acesso direto pelo usuario')
		_lRet = .T.
	else
		_aGrpUsr = UsrRetGRP(__cUserID)  // Grupos aos quais o usuario pertence.
		u_log ('grupos do usuario:', _aGrpUsr)
		if len (_aGrpUsr) > 0
			SGQ -> (dbSeek (xFilial ("SGQ") + "1" + _sAlmox, .T.))
			do while ! sgq -> (eof ()) .and. sgq -> gq_filial == xfilial ("SGQ") .and. sgq -> gq_TipoRer == '1' .and. sgq -> gq_local == _sAlmox
				u_log ('Testando gq_grpuser =', sgq -> gq_grpuser)
				if ascan (_aGrpUsr, {|_aVal| alltrim (_aVal [1]) == alltrim (SGQ -> GQ_GRPUSER)}) > 0
					u_log ('Grupo ok')
					_lRet = .T.
					exit
				endif
				SGQ -> (dbSkip ())
			enddo
		endif
	endif
*/
/*
	_aLaudos := {}
	aadd (_aLaudos, {'000002424', 50})
	aadd (_aLaudos, {'000002420', 100})
	//aadd (_aLaudos, {'000002418', 100})
	//aadd (_aLaudos, {'000002419', 100})
	U_ZAFM (_aLaudos, '2203           ', 'op', 'novolote', '03')
return
*/
/*
	// Gera entrada na conta corrente do associado, com base nos titulos gerados no financeiro para as notas de compra de safra.
	_sSafra = '2018'
	private _sOrigSZI  := "VA_GNF2"
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := "SELECT DISTINCT ASSOCIADO, LOJA_ASSOC, DOC, SERIE" 
	_oSQL:_sQuery +=  " FROM VA_VNOTAS_SAFRA V "
	_oSQL:_sQuery += " WHERE FILIAL = '" + cFilAnt + "'"
	_oSQL:_sQuery +=   " AND SAFRA  = '" + _sSafra + "'"
	_oSQL:_sQuery +=   " AND ASSOCIADO = '003008' AND DATA = '20180622'"
	_oSQL:_sQuery +=   " AND TIPO_NF = 'C'"
	_oSQL:_sQuery +=   " AND NOT EXISTS (SELECT * FROM " + RetSQLName ("SZI") + " SZI "
	_oSQL:_sQuery +=                           " WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=                             " AND ZI_FILIAL  = V.FILIAL"
	_oSQL:_sQuery +=                             " AND ZI_ASSOC   = V.ASSOCIADO"
	_oSQL:_sQuery +=                             " AND ZI_LOJASSO = V.LOJA_ASSOC"
	_oSQL:_sQuery +=                             " AND ZI_DOC     = V.DOC"
	_oSQL:_sQuery +=                             " AND ZI_SERIE   = V.SERIE"
	_oSQL:_sQuery +=                             " AND ZI_TM      = '13')"
	_oSQL:_sQuery += " order by ASSOCIADO, DOC"
	_oSQL:Log ()
	_aDados := _oSQL:Qry2Array ()
	u_log (_aDados)
	for _nDado = 1 to len (_aDados)
		_sQuery := ""
		_sQuery += " SELECT E2_FILIAL, E2_FORNECE, E2_LOJA, E2_NOMFOR, E2_EMISSAO, E2_VENCREA, E2_NUM, E2_PREFIXO, E2_TIPO, E2_VALOR, E2_SALDO, E2_HIST, R_E_C_N_O_, E2_LA, E2_PARCELA,"
		_sQuery +=        " ROW_NUMBER () OVER (ORDER BY E2_PARCELA) AS NUM_PARC"
		_sQuery +=   " FROM " + RetSQLName ("SE2")
		_sQuery +=  " WHERE D_E_L_E_T_ = ''"
		_sQuery +=    " AND E2_TIPO    = 'NF'"
		_sQuery +=    " AND E2_FORNECE = '" + _aDados [_nDado, 1] + "'"
		_sQuery +=    " AND E2_LOJA    = '" + _aDados [_nDado, 2] + "'"
		_sQuery +=    " AND E2_NUM     = '" + _aDados [_nDado, 3] + "'"
		_sQuery +=    " AND E2_PREFIXO = '" + _aDados [_nDado, 4] + "'"
		_sQuery +=    " AND E2_VACHVEX = ''"
		_sQuery +=    " AND E2_FILIAL  = '" + xfilial ("SE2") + "'"
		_sQuery +=  " ORDER BY E2_PARCELA"
		u_log (_sQuery)
		_sAliasQ = GetNextAlias ()
		DbUseArea(.t., 'TOPCONN', TcGenQry (,, _sQuery), _sAliasQ, .f., .t.)
		U_TCSetFld (alias ())
		do while ! (_sAliasQ) -> (eof ())
	  		u_log ('Filial:' + (_sAliasQ) -> e2_filial, 'Forn:' + (_sAliasQ) -> e2_fornece + '/' + (_sAliasQ) -> e2_loja + ' ' + (_sAliasQ) -> e2_nomfor, 'Emis:', (_sAliasQ) -> e2_emissao, 'Vcto:', (_sAliasQ) -> e2_vencrea, 'Doc:', (_sAliasQ) -> e2_num+'/'+(_sAliasQ) -> e2_prefixo, 'Tipo:', (_sAliasQ) -> e2_tipo, 'Valor: ' + transform ((_sAliasQ) -> e2_valor, "@E 999,999,999.99"), 'Saldo: ' + transform ((_sAliasQ) -> e2_saldo, "@E 999,999,999.99"), (_sAliasQ) -> e2_hist)
			_oCtaCorr := ClsCtaCorr():New ()
			_oCtaCorr:Assoc    = (_sAliasQ) -> e2_fornece
			_oCtaCorr:Loja     = (_sAliasQ) -> e2_loja
			_oCtaCorr:TM       = '13'
			_oCtaCorr:DtMovto  = (_sAliasQ) -> e2_EMISSAO
			_oCtaCorr:Valor    = (_sAliasQ) -> e2_valor
			_oCtaCorr:SaldoAtu = (_sAliasQ) -> e2_saldo
			_oCtaCorr:Usuario  = cUserName
			_oCtaCorr:Histor   = 'COMPRA SAFRA ' + _sSafra + "(" + cvaltochar ((_sAliasQ) -> Num_Parc) + ")"
			_oCtaCorr:MesRef   = strzero(month(_oCtaCorr:DtMovto),2)+strzero(year(_oCtaCorr:DtMovto),4)
			_oCtaCorr:Doc      = (_sAliasQ) -> e2_num
			_oCtaCorr:Serie    = (_sAliasQ) -> e2_prefixo
			_oCtaCorr:Origem   = _sOrigSZI
			_oCtaCorr:Parcela  = (_sAliasQ) -> e2_parcela
			if _oCtaCorr:PodeIncl ()
				if ! _oCtaCorr:Grava (.F., .F.)
					U_help ("Erro na atualizacao da conta corrente para o associado '" + (_sAliasQ) -> e2_fornece + '/' + (_sAliasQ) -> e2_loja + "'. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg)
					_lContinua = .F.
				else
					se2 -> (dbgoto ((_sAliasQ) -> r_e_c_n_o_))
					if empty (se2 -> e2_vachvex)  // Soh pra garantir...
						reclock ("SE2", .F.)
						se2 -> e2_vachvex = _oCtaCorr:ChaveExt ()
						msunlock ()
					endif
				endif
			else
				U_help ("Gravacao do SZI nao permitida na atualizacao da conta corrente para o associado '" + (_sAliasQ) -> e2_fornece + '/' + (_sAliasQ) -> e2_loja + "'. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg)
				_lContinua = .F.
			endif
			(_sAliasQ) -> (dbskip ())
		enddo
	next
return
*/
/*
	// Gera entrada na conta corrente do associado, ref. notas de devolucao de compra de safra.
	local _aNfDevol := {}
	local _nNfDevol := 0
	aadd (_aNfDevol, {'2018', '01', '000003702', '30 ', '004831', '01', '20160530', ' - ERRO INSCR.EST.', '000002427', '30 '})
	for _nNfDevol = 1 to len (_aNfDevol)
		if _aNfDevol [_nNfDevol, 2] != cFilAnt
			u_log ('Filial errada')
		else
			_sQuery := ""
			_sQuery += " SELECT FILIAL, ASSOCIADO, LOJA_ASSOC, DOC, SERIE, SUM (VALOR_TOTAL) AS TOTAL"
			_sQuery +=   " FROM VA_VNOTAS_SAFRA"
			_sQuery +=  " WHERE TIPO_NF    = 'C'"
			_sQuery +=    " AND SAFRA      = '" + _aNfDevol [_nNfDevol, 1] + "'"
			_sQuery +=    " AND FILIAL     = '" + _aNfDevol [_nNfDevol, 2] + "'"
			_sQuery +=    " AND ASSOCIADO  = '" + _aNfDevol [_nNfDevol, 5] + "'"
			_sQuery +=    " AND LOJA_ASSOC = '" + _aNfDevol [_nNfDevol, 6] + "'"
			_sQuery +=    " AND DOC        = '" + _aNfDevol [_nNfDevol, 9] + "'"
			_sQuery +=    " AND SERIE      = '" + _aNfDevol [_nNfDevol, 10] + "'"
			_sQuery += " GROUP BY FILIAL, ASSOCIADO, LOJA_ASSOC, DOC, SERIE"
			u_log (_sQuery)
			_sAliasQ = GetNextAlias ()
			DbUseArea(.t., 'TOPCONN', TcGenQry (,, _sQuery), _sAliasQ, .f., .t.)
			U_TCSetFld (alias ())
			do while ! (_sAliasQ) -> (eof ())
		  		_oCtaCorr := ClsCtaCorr():New ()
				_oCtaCorr:Assoc    = (_sAliasQ) -> ASSOCIADO
				_oCtaCorr:Loja     = (_sAliasQ) -> LOJA_ASSOC
				_oCtaCorr:TM       = '22'
				_oCtaCorr:DtMovto  = stod (_aNfDevol [_nNfDevol, 7])
				_oCtaCorr:Valor    = (_sAliasQ) -> TOTAL
				_oCtaCorr:SaldoAtu = (_sAliasQ) -> TOTAL
				_oCtaCorr:Usuario  = cUserName
				_oCtaCorr:Histor   = 'DEVOL.COMPRA SAFRA ' + _aNFDevol [_nNFDevol, 1] + _aNFDevol [_nNFDevol, 8]
				_oCtaCorr:MesRef   = strzero(month(_oCtaCorr:DtMovto),2)+strzero(year(_oCtaCorr:DtMovto),4)
				_oCtaCorr:Doc      = _aNfDevol [_nNfDevol, 3]
				_oCtaCorr:Serie    = _aNfDevol [_nNfDevol, 4]
				_oCtaCorr:Origem   = 'DEVOL'
				if _oCtaCorr:PodeIncl ()
					if ! _oCtaCorr:Grava (.F., .F.)
						U_log ("Erro na atualizacao da conta corrente. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg)
					else
						u_log ('SZI gerado.')
					endif
				else
					U_help ("Gravacao do SZI nao permitida. Ultima mensagem do objeto:" + _oCtaCorr:UltMsg)
				endif
				(_sAliasQ) -> (dbskip ())
			enddo
			(_sAliasQ) -> (dbclosearea ())
		endif
	next
return
*/
/*
	// Cobrei multa por mistura de variedades de um pessoal que estava entregando em caixas.
	if cFilAnt != '07'
		u_help ('filial errada')
		return
	endif
	_sPreNF := "000000"
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT * FROM VA_VNOTAS_SAFRA V WHERE SAFRA = '2018' AND V.TIPO_NF = 'C' AND V.FILIAL = '07' AND exists (select * from ZZ9010 ZZ9 where ZZ9.D_E_L_E_T_ = '' AND V.SAFRA = ZZ9.ZZ9_SAFRA AND V.FILIAL = ZZ9_FILIAL"
	_oSQL:_sQuery += " AND V.ASSOCIADO NOT IN ('000248','002083','002387','002486','002513','002514','002517','002522','002633','002639','003019','003559','004367','004399','005331')"
	_oSQL:_sQuery += " AND V.ASSOCIADO = ZZ9_FORNEC AND V.LOJA_ASSOC = ZZ9_LOJA AND V.DOC = ZZ9_NFCOMP AND V.SERIE = ZZ9_SERCOM AND V.PRODUTO = ZZ9_PRODUT AND V.GRAU = ZZ9_GRAU AND V.CLAS_FINAL = ZZ9_CLASSE AND (ZZ9_MISTU1 != ''"
	_oSQL:_sQuery += " OR ZZ9_MISTU2 != '' OR ZZ9_MISTU3 != '') AND ZZ9_MSGNF LIKE '%Usando prc%' AND EXISTS (SELECT * FROM SD1010 SD1 WHERE SD1.D_E_L_E_T_ = '' AND SD1.D1_FILIAL = ZZ9_FILIAL AND SD1.D1_FORNECE = ZZ9_FORNEC AND SD1.D1_LOJA = ZZ9_LOJA AND SD1.D1_DOC = ZZ9_NFENTR AND SD1.D1_SERIE = '30 ' AND SD1.D1_EMISSAO < '20180120'))"
	_oSQL:Log ()
	_sAliasQ = _oSQL:Qry2Trb ()
	u_logtrb (_sAliasQ, .T.)
	(_sAliasQ) -> (dbgotop ())
	do while ! (_sAliasQ) -> (eof ())
		do while ! (_sAliasQ) -> (eof ())
			_nPreco = U_PrecoUva ((_sAliasQ) -> associado, (_sAliasQ) -> loja_assoc, (_sAliasQ) -> Produto, (_sAliasQ) -> grau, (_sAliasQ) -> Safra, (_sAliasQ) -> clas_final, (_sAliasQ) -> clas_abd, 'C', (_sAliasQ) -> filial)
			if _nPreco > (_sAliasQ) -> valor_unit
				reclock ("ZZ9", .T.)
				zz9 -> zz9_filial = xfilial ("ZZ9")
				zz9 -> zz9_pre_nf = _sPreNF
				zz9 -> zz9_safra  = '2018'
				zz9 -> zz9_parcel = 'F'
				zz9 -> zz9_fornec = (_sAliasQ) -> associado
				zz9 -> zz9_loja   = (_sAliasQ) -> loja_assoc
				zz9 -> zz9_TipoNF = "C"
				zz9 -> zz9_produt = (_sAliasQ) -> produto
				zz9 -> zz9_grau   = (_sAliasQ) -> grau
				zz9 -> zz9_classe = (_sAliasQ) -> clas_final
				zz9 -> zz9_clabd  = (_sAliasQ) -> clas_abd
				zz9 -> zz9_quant  = 0
				zz9 -> zz9_vunit  = (_sAliasQ) -> peso_liq * _nPreco - (_sAliasQ) -> valor_total
				zz9 -> zz9_obs    = 'Uva em caixa, nao havia mistura'
				zz9 -> zz9_msgNF  = 'Vl.orig.considerado como mistura'
				zz9 -> zz9_nfori  = (_sAliasQ) -> doc
				zz9 -> zz9_serior = (_sAliasQ) -> serie
				zz9 -> zz9_itemor = (_sAliasQ) -> item_nota
				msunlock ()
				_sPreNF = soma1 (soma1 (soma1 (soma1 (soma1 (_sPreNF)))))
			endif
			(_sAliasQ) -> (dbskip ())
		enddo
	enddo
return
*/


/*

static function _AtuSZI ()
	local _nRegSZI  := 0
	local _oCtaCorr := NIL
	local _oSQL     := NIL
	local _nValFat  := 0

	// Estou posicionado num dos titulos que fazem parte da fatura: verifica se existe lcto correspondente na conta corrente de associados.
	if se2 -> e2_tipo != 'FAT'  // Soh quero rodar para os titulos que participaram da fatura.
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT SZI.R_E_C_N_O_"
		_oSQL:_sQuery +=  " FROM " + RETSQLNAME ("SZI") + " SZI "
		_oSQL:_sQuery += " WHERE SZI.D_E_L_E_T_ != '*'"
		_oSQL:_sQuery +=   " AND SZI.ZI_FILIAL   = '" + xfilial ("SZI") + "'"
		_oSQL:_sQuery +=   " AND SZI.ZI_ASSOC    = '" + se2 -> e2_fornece + "'"
		_oSQL:_sQuery +=   " AND SZI.ZI_LOJASSO  = '" + se2 -> e2_loja + "'"
		_oSQL:_sQuery +=   " AND SZI.ZI_DOC      = '" + se2 -> e2_num + "'"
		_oSQL:_sQuery +=   " AND SZI.ZI_SERIE    = '" + se2 -> e2_prefixo + "'"
		_oSQL:_sQuery +=   " AND SZI.ZI_PARCELA  = '" + se2 -> e2_parcela + "'"
		_oSQL:Log ()
		_nRegSZI = _oSQL:RetQry (1, .F.)
		if _nRegSZI != 0
			szi -> (dbgoto (_nRegSZI))
			
			// Verifica se existe movimento de geracao de fatura
			_oSQL := ClsSQL():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += "SELECT TOP 1 E5_VALOR"  // Soh deve ter um, mas por via das duvidas, buscarei o mais recente.
			_oSQL:_sQuery +=  " FROM " + RETSQLNAME ("SE5") + " SE5 "
			_oSQL:_sQuery += " WHERE SE5.D_E_L_E_T_ != ''"  // SE5 jah vai estar deletado.
			_oSQL:_sQuery +=   " AND SE5.E5_FILIAL   = '" + xfilial ("SE5") + "'"
			_oSQL:_sQuery +=   " AND SE5.E5_CLIFOR   = '" + szi -> zi_assoc + "'"
			_oSQL:_sQuery +=   " AND SE5.E5_LOJA     = '" + szi -> zi_lojasso + "'"
			_oSQL:_sQuery +=   " AND SE5.E5_NUMERO   = '" + szi -> zi_doc + "'"
			_oSQL:_sQuery +=   " AND SE5.E5_PREFIXO  = '" + szi -> zi_serie + "'"
			_oSQL:_sQuery +=   " AND SE5.E5_PARCELA  = '" + szi -> zi_parcela + "'"
			_oSQL:_sQuery +=   " AND SE5.E5_MOTBX    = 'FAT'"
			_oSQL:_sQuery +=   " AND dbo.VA_SE5_ESTORNO (SE5.R_E_C_N_O_) = 0"
			_oSQL:_sQuery += " ORDER BY R_E_C_N_O_ DESC"
			_oSQL:Log ()
			_nValFat = _oSQL:RetQry (1, .F.)
			U_LOG ('_NvALfAT = ', _nValFat)
			if _nValFat > 0
				u_log ('Aumentando saldo SZI de ', szi -> zi_saldo, ' para', szi -> zi_saldo + _nValFat)
				reclock ("SZI", .F.)
				szi -> zi_saldo += _nValFat
				msunlock ()
			endif
		endif
	else
		if se2 -> e2_tipo == 'FAT' .and. se2 -> (deleted ())  // Excluiu a fatura
			_oSQL := ClsSQL():New ()
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += "SELECT SZI.R_E_C_N_O_"
			_oSQL:_sQuery +=  " FROM " + RETSQLNAME ("SZI") + " SZI "
			_oSQL:_sQuery += " WHERE SZI.D_E_L_E_T_ != '*'"
			_oSQL:_sQuery +=   " AND SZI.ZI_FILIAL   = '" + xfilial ("SZI") + "'"
			_oSQL:_sQuery +=   " AND SZI.ZI_ASSOC    = '" + se2 -> e2_fornece + "'"
			_oSQL:_sQuery +=   " AND SZI.ZI_LOJASSO  = '" + se2 -> e2_loja + "'"
			_oSQL:_sQuery +=   " AND SZI.ZI_DOC      = '" + se2 -> e2_num + "'"
			_oSQL:_sQuery +=   " AND SZI.ZI_SERIE    = '" + se2 -> e2_prefixo + "'"
			_oSQL:_sQuery +=   " AND SZI.ZI_PARCELA  = '" + se2 -> e2_parcela + "'"
			_oSQL:Log ()
			_nRegSZI = _oSQL:RetQry (1, .F.)
			if _nRegSZI != 0
				szi -> (dbgoto (_nRegSZI))
				u_log ('Excluindo fatura ' + szi -> zi_doc + ' do SZI')
				reclock ("SZI", .F.)
				szi -> (dbdelete ())
				msunlock ()
			endif
		endif
	endif
return
*/

/*
	// Recalcula na conta corrente os saldos das faturas de pagamento da safra 2018
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := " SELECT SZI.R_E_C_N_O_"
	_oSQL:_sQuery += " FROM " + RetSQLName ("SZI") + " SZI "
	_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery += " AND ZI_FILIAL  = '" + xfilial ("SZI") + "'"
	_oSQL:_sQuery += " AND ZI_TM      = '13'"
	_oSQL:_sQuery += " AND ZI_DATA   >= '20180320'"
	_oSQL:_sQuery += " AND ZI_DOC     like '2018%'"
	_oSQL:_sQuery += " AND ZI_SALDO   > 0"
	_oSQL:Log ()
	_aDados = aclone (_oSQL:Qry2Array ())
	For _nLinha := 1 To Len(_aDados)
		szi -> (dbgoto (_aDados [_nLinha, 1]))
		_oCtaCorr := ClsCtaCorr ():New (szi -> (recno ()))
		_oCtaCorr:AtuSaldo ()
		u_log (_oCtaCorr:UltMsg)
	next
return
*/
/*
	// Varre grupos familiares (atual cadastro viticola) e cria um talhao para cada variedade encontrada.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := " SELECT DISTINCT CAD_VITICOLA, PRODUTO, DESCRICAO, SIST_CONDUCAO"
	_oSQL:_sQuery += " FROM VA_VASSOC_CAD_VITIC V"
	_oSQL:_sQuery += " WHERE SAFRA >= '2016'"
	_oSQL:_sQuery += " and EXISTS (SELECT *"
	_oSQL:_sQuery +=    " FROM ZA8010"
	_oSQL:_sQuery +=    " WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=    " AND ZA8_COD = V.CAD_VITICOLA)"
	_oSQL:_sQuery += " and NOT EXISTS (SELECT *"
	_oSQL:_sQuery +=    " FROM SZ9010"
	_oSQL:_sQuery +=    " WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=    " AND Z9_IDZA8 = V.CAD_VITICOLA"
	_oSQL:_sQuery +=    " AND Z9_IDSB1 = V.PRODUTO)"
	_oSQL:_sQuery += " ORDER BY CAD_VITICOLA, PRODUTO"
	_oSQL:Log ()
	_sAliasQ = _oSQL:Qry2Trb ()
	do while ! (_sAliasQ) -> (eof ())
		_sSeq = '001'
		_sCadVit = (_sAliasQ) -> cad_viticola
		do while ! (_sAliasQ) -> (eof ()) .and. (_sAliasQ) -> cad_viticola == _sCadVit
			reclock ('SZ9', .T.)
			sz9 -> z9_filial  = xfilial ("SZ9")
			sz9 -> z9_idZA8   = _sCadVit
			sz9 -> z9_seq     = _sSeq
			sz9 -> z9_idSB1   = (_sAliasQ) -> produto
			sz9 -> z9_descri  = (_sAliasQ) -> descricao
			sz9 -> z9_cultura = '0000000001'  // Uva
			sz9 -> z9_sustent = (_sAliasQ) -> sist_conducao
			sz9 -> z9_status  = 'A'  // Ativo
			msunlock ()
			_sSeq = soma1 (_sSeq)
			(_sAliasQ) -> (dbskip ())
		enddo
	enddo
RETURN
*/
/*
	// Gera tabelas de grupos familiares e propriedades de associados com base no atual cadastro de patriarcas.
	_oSQL := ClsSQL ():New ()
	// Jah teve manutencao manual --> _oSQL:_sQuery := "DELETE ZAN010"  // NUCLEOS FAMILIARES ASSOCIADOS
	// Jah teve manutencao manual --> _oSQL:Exec ()
	_oSQL:_sQuery := "DELETE ZA8010"  // PROPRIEDADES RURAIS ASSOCIADOS
	_oSQL:Exec ()
	_oSQL:_sQuery := "DELETE SZ9010"  // Talhoes das propriedades rurais
	_oSQL:Exec ()
	// Jah teve manutencao manual --> _oSQL:_sQuery := "DELETE ZAK010"  // ASSOCIADO X NUCLEO FAMILIAR
	// Jah teve manutencao manual --> _oSQL:Exec ()
	_oSQL:_sQuery := "DELETE ZAL010"  // NUCLEO FAMILIAR X PROPRIEDADES RURAIS
	_oSQL:Exec ()
	
	// Cria uma propriedade para cada cadastro viticola movimentado nas duas ultimas safras.
	_oSQL:_sQuery := " SELECT DISTINCT Z2_CADVITI, Z2_CODMUN"
	_oSQL:_sQuery += " FROM SZ2010 SZ2, VA_VNOTAS_SAFRA"
	_oSQL:_sQuery += " WHERE SZ2.D_E_L_E_T_ = '' and Z2_FILIAL = '  ' AND Z2_CADVITI = CAD_VITIC AND SAFRA >= '2016' AND TIPO_NF = 'E'"
	_oSQL:Log ()
	_aCadVit := aclone (_oSQL:Qry2Array ())
	u_log ('gerando SZ8')
	for _nCadVit = 1 to len (_aCadVit)
	
		// Cria propriedade
		reclock ('ZA8', .T.)
		za8 -> za8_filial = xfilial ("ZA8")
		za8 -> za8_cod    = _aCadVit [_nCadVit, 1]    // cada cad.vit. eh uma propriedade rural.    // soma1 (U_RetSQL ("SELECT MAX (ZA8_COD) FROM ZA8010 WHERE D_E_L_E_T_ = ''"))
		za8 -> za8_codmun = _aCadVit [_nCadVit, 2]
		za8 -> za8_descri = 'PROPRIEDADE ' + _aCadVit [_nCadVit, 1]
		za8 -> za8_status = 'A'  // Ativa
		msunlock ()
		//u_log ('za8 criado:', za8 -> za8_cod)

		// Cria um talhao inicial para a propriedade (o mapeamento nao vai ficar pronto para esta safra)
		reclock ('SZ9', .T.)
		sz9 -> z9_filial  = xfilial ("SZ9")
		sz9 -> z9_idZA8   = za8 -> za8_cod
		sz9 -> z9_seq     = '001'
		sz9 -> z9_descri  = 'TALHAO UNICO'
		sz9 -> z9_cultura = '0000000001'  // Uva
		sz9 -> z9_sustent = 'L'  // a grande maioria eh latada.
		sz9 -> z9_status  = 'A'  // Ativo
		msunlock ()
	next

	// Varre propriedades (cad.vitic) e busca patriarcas ligados a esse cad.vitic. A partir deles, busca a distancia ate as filiais.
	u_log ('ajustando KM do SZ8')
	za8 -> (dbgotop ())
	do while ! za8 -> (eof ())
		_oSQL:_sQuery := " SELECT distinct Z8_KMF01, Z8_KMF03, Z8_KMF07"
		_oSQL:_sQuery += " FROM SZ8010 SZ8, ZZB010 ZZB
		_oSQL:_sQuery += " WHERE SZ8.D_E_L_E_T_ = ''"
		_oSQL:_sQuery += " AND ZZB.D_E_L_E_T_ = ''"
		_oSQL:_sQuery += " AND Z8_FILIAL  = '" + xfilial ("SZ8") + "'"
		_oSQL:_sQuery += " AND Z8_SAFRA   = '2018'"
		_oSQL:_sQuery += " AND Z8_CODPAT  = ZZB_CODPAT"
		_oSQL:_sQuery += " AND Z8_LOJAPAT = ZZB_LOJPAT"
		_oSQL:_sQuery += " AND ZZB_CADVIT = '" + za8 -> za8_cod + "'"
		_oSQL:_sQuery += " AND (Z8_KMF01 > 0 OR Z8_KMF03 > 0 OR Z8_KMF07 > 0)"
		//_oSQL:Log ()
		_aDist := aclone (_oSQL:Qry2Array ())
//		u_log (_aDist)
		if len (_aDist) == 1  // Se encontrar mais de um, deixa em branco
			reclock ('ZA8', .F.)
			za8 -> za8_kmf01  = _aDist [1, 1]
			za8 -> za8_kmf03  = _aDist [1, 2]
			za8 -> za8_kmf07  = _aDist [1, 3]
			msunlock ()
			//u_log ('za8 com km atualizado:', za8 -> za8_cod)
		endif
		za8 -> (dbskip ())
	enddo

	// Cria grupos familiares a partir do cadastro de patriarcas
	u_log ('gerando ZAN')
	_oSQL:_sQuery := " SELECT *" //distinct Z8_CODPAT, Z8_LOJAPAT"
	_oSQL:_sQuery += " FROM " + RetSQLName ("SZ8") + " SZ8 "
	_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery += " AND Z8_FILIAL  = '" + xfilial ("SZ8") + "'"
	_oSQL:_sQuery += " AND Z8_SAFRA   = '2018'"
//	_oSQL:_sQuery += " AND NOT EXISTS (SELECT * FROM SZ8010 OUTRO WHERE OUTRO.D_E_L_E_T_ = '' AND OUTRO.Z8_SAFRA = SZ8.Z8_SAFRA AND OUTRO.Z8_CODREL = SZ8.Z8_CODREL AND OUTRO.Z8_LOJAREL = SZ8.Z8_LOJAREL AND OUTRO.Z8_CODPAT + OUTRO.Z8_LOJAPAT != SZ8.Z8_CODPAT + SZ8.Z8_LOJAPAT)"
	_oSQL:_sQuery += " AND NOT EXISTS (SELECT * FROM SZ8010 OUTROPAT WHERE OUTROPAT.D_E_L_E_T_ = '' AND OUTROPAT.Z8_SAFRA = SZ8.Z8_SAFRA AND OUTROPAT.Z8_CODPAT = SZ8.Z8_CODPAT AND OUTROPAT.Z8_LOJAPAT > SZ8.Z8_LOJAPAT)"
//	_oSQL:_sQuery += " AND NOT EXISTS (SELECT * FROM SZ8010 OUTRO WHERE OUTRO.D_E_L_E_T_ = '' AND OUTRO.Z8_SAFRA = SZ8.Z8_SAFRA AND OUTRO.Z8_CODREL = SZ8.Z8_CODREL AND OUTRO.Z8_LOJAREL = SZ8.Z8_LOJAREL AND OUTRO.Z8_CODPAT != SZ8.Z8_CODPAT)"
	_oSQL:_sQuery += " ORDER BY Z8_CODPAT, Z8_LOJAPAT, Z8_CODREL, Z8_LOJAREL"
	_oSQL:Log ()
	_sz8 = _oSQL:Qry2Trb ()
	(_sz8) -> (dbgotop ())
	do while ! (_sz8) -> (eof ())
		_sPatr = (_sz8) -> z8_codpat + (_sz8) -> z8_lojapat
		u_log (_sPatr)

		// Cria grupo familiar
		sa2 -> (dbsetorder (1))
		if ! sa2 -> (dbseek (xfilial ("SA2") + (_sz8) -> z8_codpat + (_sz8) -> z8_lojapat, .F.))
			u_log ('cadastro patriarca nao encontrado')
		else
//			_sCodZAN = (_sz8) -> z8_codpat  // patriarca aqui pra ter a origem.  --> soma1 (U_RetSQL ("SELECT MAX (ZAN_COD) FROM ZAN010 WHERE D_E_L_E_T_ = ''"))
//			reclock ('ZAN', .T.)
//			zan -> zan_filial = xfilial ("ZAN")
//			zan -> zan_cod    = _sCodZAN
//			zan -> zan_descri = 'GRUPO DE ' + alltrim ((_sz8) -> z8_nomepat)
//			zan -> zan_ativo  = 'S'
//			zan -> zan_avisad = sa2 -> a2_vacavis
//			zan -> zan_ljavis = sa2 -> a2_valavis
//			zan -> zan_nucleo = sa2 -> a2_vanucl
//			zan -> zan_subnuc = sa2 -> a2_vasubnu
//			msunlock ()
//	
//			// Relaciona associados com o grupo familiar
//			do while ! (_sz8) -> (eof ()) .and. (_sz8) -> z8_codpat + (_sz8) -> z8_lojapat == _sPatr
//				if (_sz8) -> z8_codrel + (_sz8) -> z8_lojarel == (_sz8) -> z8_codpat + (_sz8) -> z8_lojapat .OR. U_EhAssoc ((_sz8) -> z8_codrel, (_sz8) -> z8_lojarel, date ())
//					reclock ('ZAK', .T.)
//					zak -> zak_filial = xfilial ("ZAK")
//					zak -> zak_assoc  = (_sz8) -> z8_codrel
//					zak -> zak_loja   = (_sz8) -> z8_lojarel
//					// nao tem mais o mesmo conteudo --> zak -> zak_tipore = (_sz8) -> z8_tiporel
//					zak -> zak_idzan  = _sCodZAN
//					msunlock ()
//				endif
//				(_sz8) -> (dbskip ())
//			enddo
	
			// Associa o grupo familiar com as propriedades rurais que ele explora.
			_oSQL:_sQuery := " SELECT DISTINCT ZZB.ZZB_CADVIT"
			_oSQL:_sQuery += " FROM ZZB010 ZZB"
			_oSQL:_sQuery += " WHERE ZZB.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZZB.D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=   " AND ZZB_CODPAT     = '" + _sCodZAN + "'"
			//NAO TEM LOJA _oSQL:_sQuery +=   " AND ZZB_LOJPAT     = '" + (_sz8) -> z8_lojapat + "'"
//			_oSQL:Log ()
			_aCadVit := aclone (_oSQL:Qry2Array ())
			if len (_aCadVit) == 0
				u_log ('sem cad vit para', _sCodZAN)
			endif
			za8 -> (dbsetorder (1))  // ZA8_FILIAL+ZA8_COD
			zal -> (dbsetorder (1))  // ZAL_FILIAL+ZAL_IDZAN+ZAL_IDZA8
			for _nCadVit = 1 to len (_aCadVit)
				if ! zal -> (dbseek (xfilial ("ZAL") + _sCodZAN + _aCadVit [_nCadVit, 1], .F.))
					if za8 -> (dbseek (xfilial ("ZA8") + _aCadVit [_nCadVit, 1], .F.))
						reclock ('ZAL', .T.)
						zal -> zal_filial = xfilial ("ZAL")
						zal -> zal_IdZAN  = _sCodZAN
						zal -> zal_IdZA8  = _aCadVit [_nCadVit, 1]
						msunlock ()
					endif
				endif
			next
		endif

	enddo
	(_sz8) -> (dbclosearea ())
	U_LOG ('PRONTO')
return
*/
/*
user function FINA290 ()
	local _aAreaAnt := U_ML_SRArea ()
	local _oSQL     := NIL
	U_LOGiNI ()
	u_help (procname ())
	u_logtrb ("SE2")

	// Deleta lcto correspondente na conta corrente de associados.
	if se2 -> (deleted ())  // Excluiu a fatura
		_oSQL := ClsSQL():New ()
		_oSQL:_sQuery := ""
		_oSQL:_sQuery += "SELECT SZI.R_E_C_N_O_"
		_oSQL:_sQuery +=  " FROM " + RETSQLNAME ("SZI") + " SZI "
		_oSQL:_sQuery += " WHERE SZI.D_E_L_E_T_ != '*'"
		_oSQL:_sQuery +=   " AND SZI.ZI_FILIAL   = '" + xfilial ("SZI") + "'"
		_oSQL:_sQuery +=   " AND SZI.ZI_ASSOC    = '" + se2 -> e2_fornece + "'"
		_oSQL:_sQuery +=   " AND SZI.ZI_LOJASSO  = '" + se2 -> e2_loja + "'"
		_oSQL:_sQuery +=   " AND SZI.ZI_DOC      = '" + se2 -> e2_num + "'"
		_oSQL:_sQuery +=   " AND SZI.ZI_SERIE    = '" + se2 -> e2_prefixo + "'"
		_oSQL:_sQuery +=   " AND SZI.ZI_PARCELA  = '" + se2 -> e2_parcela + "'"
		_oSQL:Log ()
		_nRegSZI = _oSQL:RetQry (1, .F.)
		if _nRegSZI != 0
			szi -> (dbgoto (_nRegSZI))
			reclock ("SZI", .F.)
			szi -> (dbdelete ())
			msunlock ()
		endif
	endif

	U_ML_SRArea (_aAreaAnt)
	u_logFim ()
return
*/


/*
	// Envia atualizacoes para o Mercanet
	//_oSQL := ClsSQL ():New ()
	//_oSQL:_sQuery := ""
   	//_oSQL:_sQuery += " SELECT R_E_C_N_O_ "
	//_oSQL:_sQuery += " FROM " + RetSQLName ("SB1")
	//_oSQL:_sQuery += " WHERE D_E_L_E_T_ = ''"
	//_oSQL:_sQuery += " AND B1_FILIAL = '" + xfilial ("SB1") + "'"  // Deixar esta opcao para poder ler os campos memo.
	//_oSQL:_sQuery += " AND B1_COD IN ('0345', '0150')"
	//_oSQL:Log ()
	//_aDados = aclone (_oSQL:Qry2Array ())
	//For _nLinha := 1 To Len(_aDados)
	//	sb1 -> (dbgoto (_aDados [_nLinha, 1]))
	//	U_AtuMerc ("SB1", sb1 -> (recno ()))
	//next
	//da0 -> (dbgotop ())
	//do while ! da0 -> (eof ())
	//	U_AtuMerc ("DA0", da0 -> (recno ()))
	//	da0 -> (dbskip ())
	//enddo
	//sf2 -> (dbsetorder (18)) // F2_FILIAL+DTOS(F2_EMISSAO)
	//sf2 -> (dbseek (xfilial ("SF2") + "20170712", .T.))
	//do while ! sf2 -> (eof ()) .and. sf2 -> f2_filial == xfilial ("SF2") .and. dtos (sf2 -> f2_emissao) <= "20170712"
	//	u_log (sf2 -> f2_doc, sf2 -> f2_emissao)
	//	U_AtuMerc ("SF2", sf2 -> (recno ()))
	//	sf2 -> (dbskip ())
	//enddo
return
*/
/*
	// importa cadastro de tanques
	sbe -> (dbsetorder (1)) // BE_FILIAL+BE_LOCAL+BE_LOCALIZ
	sn1 -> (dbsetorder (2)) // N1_FILIAL+N1_CHAPA
	use \robert\tanques2 shared new alias tanques
    Index on strzero (val (tanques -> filial), 2) + strzero (tanques -> tanque, 6) to &(criatrab ({}, .F.))
	u_logtrb ('tanques', .F.)
	tanques -> (dbgotop ())
	u_log (TamSX3 ("BE_LOCALIZ"))
	do while ! tanques -> (eof ())
		if strzero (val (tanques -> filial), 2) == cFilAnt
			if tanques -> tanque == 0 .or. tanques -> filial != cFilAnt
				tanques -> (dbskip ())
				loop
			endif
			//u_logtrb ('tanques', .F.)

			_sEndereco = U_TamFixo ("T" + cFilAnt + strzero (tanques -> tanque, 4), TamSX3 ("BE_LOCALIZ")[1], ' ')
			//u_log ('>>' + _sEndereco + '<<')

			// 1=Carbono;2=Concreto;3=Fibra vidro;4=Inox 304;5=Inox 316;6=Madeira alta densid;7=Madeira baixa densid
			_sMaterial = ''
			_sDescMat = ''
			if 'CARBONO' $ upper (tanques -> material)
				_sMaterial = '1'
				_sDescMat = 'CARBONO'
			elseif 'CONCRETO' $ upper (tanques -> material)
				_sMaterial = '2'
				_sDescMat = 'CONCRETO'
			elseif 'FIBRA' $ upper (tanques -> material)
				_sMaterial = '3'
				_sDescMat = 'FIBRA'
			elseif 'INOX' $ upper (tanques -> material) .and. '304' $ upper (tanques -> complmat)
				_sMaterial = '4'
				_sDescMat = 'INOX'
			elseif 'INOX' $ upper (tanques -> material) .and. '316' $ upper (tanques -> complmat)
				_sMaterial = '5'
				_sDescMat = 'INOX'
			elseif 'MADEIRA' $ upper (tanques -> material) .and. 'ALTA' $ upper (tanques -> complmat)
				_sMaterial = '6'
				_sDescMat = 'MADEIRA'
			elseif 'MADEIRA' $ upper (tanques -> material) .and. 'BAIXA' $ upper (tanques -> complmat)
				_sMaterial = '7'
				_sDescMat = 'MADEIRA'
			endif

			if sn1 -> (dbseek (xfilial ("SN1") + strzero (tanques -> patrim, 6), .F.)) 
				_sBem = sn1 -> n1_chapa
			else
				_sBem = ''
			endif
			
			_sRefrig = ''  // 1=Nao tem;2=Nao isolado;3=Isolado;4=Cintas ext.isolado;5=Cintas ext.nao isolado;6=Placas internas
			if 'CINTAS EXTERNAS - Nï¿½O ISOLADO' $ upper (tanques -> refrig)
				_sRefrig = '5'
			elseif 'CINTAS EXTERNAS - ISOLADO' $ upper (tanques -> refrig)
				_sRefrig = '4'
			elseif 'PLACAS INTERNAS' $ upper (tanques -> refrig)
				_sRefrig = '6'
			elseif 'Nï¿½O TEM' $ upper (tanques -> refrig)
				_sRefrig = '1'
			elseif 'NAO ISOLADO' $ upper (tanques -> refrig)
				_sRefrig = '2'
			elseif 'ISOLADO' $ upper (tanques -> refrig)
				_sRefrig = '3'
			endif

			_sRevInt = ''
			if 'Nï¿½O TEM' $ upper (tanques -> revint) .or. 'SEM REVESTIMENTO' $ upper (tanques -> revint) .or. empty (tanques -> revint)
				_sRevInt = '1'
			elseif 'EPOXI' $ upper (tanques -> revint)
				_sRevInt = '2'
			elseif 'FIBRA' $ upper (tanques -> revint)
				_sRevInt = '3'
			endif

			_sApoio = ''
			if 'Pï¿½S' $ upper (tanques -> apoio)
				_sApoio = '1'
			elseif 'MURETAS' $ upper (tanques -> apoio)
				_sApoio = '2'
			elseif 'BASE TOTAL' $ upper (tanques -> apoio)
				_sApoio = '3'
			endif
			
			_sUso = ''
			_sLocal = '03'
			if "UTILIDADES" $ upper (tanques -> uso)
				_sUso = '4'
			elseif "PROCESSAMENTO" $ upper (tanques -> uso)
				_sUso = '3'
			elseif "ESTOCAGEM" $ upper (tanques -> uso)
				_sUso = '1'
			elseif "FORMUL" $ upper (tanques -> uso)
				_sUso = '2'
				if cFilAnt == '01'
					_sLocal = '07'
				endif
			endif
			
			_sSituacao = ''
			if "EM INSTAL" $ upper (tanques -> uso)
				_sSituacao = '2'
			elseif "DESATIVADO" $ upper (tanques -> uso)
				_sSituacao = '3'
			elseif "INVESTIM" $ upper (tanques -> uso)
				_sSituacao = '4'
			ELSEif "INSTALADO" $ upper (tanques -> uso)
				_sSituacao = '1'
			endif

			if ! sbe -> (dbseek (xfilial ("SBE") + _sLocal + _sEndereco, .F.))
				_aAutoSBE := {}
				aadd (_aAutoSBE, {"BE_LOCAL",   _sLocal, NIL})
				aadd (_aAutoSBE, {"BE_LOCALIZ", _sEndereco, NIL})
				aadd (_aAutoSBE, {"BE_DESCRIC", 'TANQUE ' + strzero (tanques -> tanque, 4) + ' (' + _sDescMat + ' ' + alltrim (transform (tanques -> volnom, '@E 9999999')) + ' L)', NIL})
				aadd (_aAutoSBE, {"BE_VATANQ",  'S', NIL})
				aadd (_aAutoSBE, {"BE_VAMATL",  _sMaterial, NIL})
				aadd (_aAutoSBE, {"BE_VAREFRI", _sRefrig, NIL})
				aadd (_aAutoSBE, {"BE_VABEM",   _sBem, NIL})
				aadd (_aAutoSBE, {"BE_VAOBS",   NoAcento (alltrim (tanques -> obs)), NIL})
				aadd (_aAutoSBE, {"BE_VADIAM",  tanques -> diam, NIL})
				aadd (_aAutoSBE, {"BE_ALTURLC", tanques -> altura, NIL})
				aadd (_aAutoSBE, {"BE_CAPACID", tanques -> volnom, NIL})
				aadd (_aAutoSBE, {"BE_VAMATL",  _sMaterial, NIL})
				aadd (_aAutoSBE, {"BE_VAREFRI", _sRefrig, NIL})
				aadd (_aAutoSBE, {"BE_VAAPOIO", _sApoio,  NIL})
				aadd (_aAutoSBE, {"BE_VAREVIN", _sRevInt, NIL})
				aadd (_aAutoSBE, {"BE_VAUSO",   _sUso, NIL})
				aadd (_aAutoSBE, {"BE_VAVFINO", left (tanques -> vinfino, 1), NIL})
				aadd (_aAutoSBE, {"BE_VAVCOMU", left (tanques -> vincomum, 1), NIL})
				aadd (_aAutoSBE, {"BE_VAGASEI", left (tanques -> gaseif, 1), NIL})
				aadd (_aAutoSBE, {"BE_VAMOSTO", left (tanques -> mostosulf, 1), NIL})
				aadd (_aAutoSBE, {"BE_VASUCOI", left (tanques -> sucoint, 1), NIL})
				aadd (_aAutoSBE, {"BE_VASUCOA", left (tanques -> sucoassep, 1), NIL})
				aadd (_aAutoSBE, {"BE_VANECTA", left (tanques -> nectar, 1), NIL})
				aadd (_aAutoSBE, {"BE_VASITUA", _sSituacao, NIL})
				_aAutoSBE := aclone (U_OrdAuto (_aAutoSBE))
				u_log (_aAutoSBE)
				lMSErroAuto := .F.
				lMSHelpAuto := .F.
				private _sErroAuto  := ""
				MSExecAuto ({|_x, _y| MATA015 (_x, _y)}, _aAutoSBE, 3)
				if lMSErroAuto
					_sErro := memoread (NomeAutoLog ())
					u_log ('Erro:', _sErro)
				endif
				if ! empty (_sErroAuto)
					u_log (_sErroAuto)
				endif
			else
				u_log ('Endereco ' + _sEndereco + ' jah cadastrado')
			endif
		endif
		tanques -> (dbskip ())
	enddo
return
*/
/*
	// Testes com XML.
	local _sXML      := ""
	local _oXml      := NIL
	local _sError    := ''
	local _sWarning  := ''
	
	_sXML := '<?xml version="1.0" encoding="UTF-8"?>'
	_sXML += '<Param>'
	_sXML += '<Produto>0005           </Produto>'
	_sXML += '<Quant>10.5</Quant>'
	_sXML += '<Produto>0150           </Produto>'
	_sXML += '<Quant>7</Quant>'
	_sXML += '</Param>'
	
	// Cria o Objeto XML.
   	_oXML := XmlParser (_sXML, "_", @_sError, @_sWarning)
	If !Empty (_sError) .or. !Empty (_sWarning)
		u_help (_sError + ' ' + _sWarning)
	else
		u_log (_oXML)
	endif

	// oXml := XmlParserFile( cFile, "_", @cError, @cWarning )
return
*/

/*
	sb1 -> (dbsetorder (1))
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := " SELECT DISTINCT D2_COD FROM SD2010 WHERE D2_EMISSAO >= '20160701'"
	_oSQL:_sQuery += " AND EXISTS (SELECT * FROM SB5010 WHERE D_E_L_E_T_ = '' AND B5_COD = D2_COD AND B5_VASISDE = 'S')"
	_oSQL:_sQuery += " UNION ALL"
	_oSQL:_sQuery += " SELECT DISTINCT D1_COD FROM SD1010 WHERE D1_DTDIGIT >= '20160701'"
	_oSQL:_sQuery += " AND EXISTS (SELECT * FROM SB5010 WHERE D_E_L_E_T_ = '' AND B5_COD = D1_COD AND B5_VASISDE = 'S')"
	_aRetSQL := aclone (_oSQL:Qry2Array ())
	for _nRetSQL = 1 to len (_aRetSQL)
		if sb1 -> (dbseek (xfilial ("SB1") + _aRetSQL [_nRetSQL, 1], .F.))
			_oSisDec := ClsSisd ():New (sb1 -> b1_cod, 'SB5', cFilAnt)
			_oSisDec:ValProd ()
			for _nErro = 1 to len (_oSisDec:Erros)
				u_log ("ERRO  '" + sb1 -> b1_cod + '-' + sb1 -> b1_desc + "': " + _oSisDec:Erros [_nErro])
			next
		endif
	next
return
*/

/*
	// Recupera cupons que constam na impressora fiscal e nao no sistema.
	_aCupons := {}
	// Nao apagar estas linhas, pois jah me ajudaram a identificar cupons reincluidos...
	//               Fil   Orc.loja  NF/doc       Serie  Emissao            Produt              Qt   VlUni  AliqICM  ItemSD2 ItemSL2 Portador
//	aadd (_aCupons, {'13', '021199', '022472   ', '003', stod ('20160721'), '8155           ',  2,  39.00,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '020852', '022106   ', '003', stod ('20160711'), '8239           ',  6,  49.50,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '021019', '022282   ', '003', stod ('20160716'), '8231           ',  2,   2.50,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '021019', '022282   ', '003', stod ('20160716'), '8095           ',  1,  14.80,    18,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'10', '012516', '014119   ', 'CL4', stod ('20160701'), '8247           ',  2,   4.60,    18,    '01',   '01',   'CX3'})
//	aadd (_aCupons, {'10', '012822', '014449   ', 'CL4', stod ('20160721'), '8164           ',  1,  19.50,    18,    '01',   '01',   'CX3'})
//	aadd (_aCupons, {'10', '012822', '014449   ', 'CL4', stod ('20160721'), '8000           ',  1,   2.00,    18,    '02',   '02',   'CX3'})

//	aadd (_aCupons, {'13', '019733', '020930   ', '003', stod ('20160616'), '8148           ',  1,  14.50,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '019733', '020930   ', '003', stod ('20160616'), '8028           ',  1,  17.50,    18,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '019733', '020930   ', '003', stod ('20160616'), '8212           ',  2,  14.00,    18,    '03',   '03',   'CY3'})
//	aadd (_aCupons, {'13', '019733', '020930   ', '003', stod ('20160616'), '8124           ',  1,  14.05,    18,    '04',   '04',   'CY3'})
//	aadd (_aCupons, {'13', '019733', '020930   ', '003', stod ('20160616'), '8247           ',  2,   8.50,    18,    '05',   '05',   'CY3'})
//	aadd (_aCupons, {'13', '019733', '020930   ', '003', stod ('20160616'), '8192           ',  4,  22.55,    18,    '06',   '06',   'CY3'})
//	aadd (_aCupons, {'13', '019804', '021004   ', '003', stod ('20160617'), '8168           ',  1,  17.90,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '019874', '021077   ', '003', stod ('20160618'), '8104           ',  2,  24.70,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '019874', '021077   ', '003', stod ('20160618'), '8104           ',  2,  24.70,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '020102', '021317   ', '003', stod ('20160623'), '8163           ',  4,  15.15,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '020102', '021317   ', '003', stod ('20160623'), '8093           ',  2,  15.15,    18,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '017157', '018218   ', '003', stod ('20160408'), '8155           ',  1,  17.70,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '017536', '018611   ', '003', stod ('20160422'), '8146           ',  2,   7.50,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'10', '011305', '012809   ', 'CL4', stod ('20160317'), '8192           ',  1,  14.90,    18,    '01',   '01',   'CX3'})
//	aadd (_aCupons, {'13', '015908', '016866   ', '003', stod ('20160222'), '8179           ', 15,   4.50,    18,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '015908', '016866   ', '003', stod ('20160222'), '8077           ',  1,   5.00,    18,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'10', '010503', '011934   ', 'CL4', stod ('20151222'), '8066           ',  6,  16.75,    17,    '01',   '01',   'CX3'})
//	aadd (_aCupons, {'10', '010503', '011934   ', 'CL4', stod ('20151222'), '8147           ', 12,   3.95,    17,    '02',   '02',   'CX3'})
//	aadd (_aCupons, {'13', '013674', '014455   ', '003', stod ('20151211'), '8092           ',  1,  14.70,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '013674', '014455   ', '003', stod ('20151211'), '8154           ',  1,  12.50,    17,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '012582', '013286   ', '003', stod ('20151105'), '8063           ',  1,  21.40,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '011685', '012313   ', '003', stod ('20151002'), '8092           ',  1,  14.70,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '012122', '012783   ', '003', stod ('20151017'), '8222           ',  2,  22.70,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '012122', '012783   ', '003', stod ('20151017'), '8175           ',  6,  10.45,    17,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '011589', '012210   ', '003', stod ('20150929'), '8125           ',  1,  11.80,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '011589', '012210   ', '003', stod ('20150929'), '8127           ',  1,  11.80,    17,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '011589', '012210   ', '003', stod ('20150929'), '8126           ',  1,  11.80,    17,    '03',   '03',   'CY3'})
//	aadd (_aCupons, {'13', '011589', '012210   ', '003', stod ('20150929'), '8123           ',  1,  11.80,    17,    '04',   '04',   'CY3'})
//	aadd (_aCupons, {'13', '011589', '012210   ', '003', stod ('20150929'), '8154           ',  6,  11.80,    17,    '05',   '05',   'CY3'})
//	aadd (_aCupons, {'13', '011589', '012210   ', '003', stod ('20150929'), '8148           ',  3,  11.80,    17,    '06',   '06',   'CY3'})
//	aadd (_aCupons, {'13', '011590', '012211   ', '003', stod ('20150929'), '8222           ',  1,  23.00,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '011590', '012211   ', '003', stod ('20150929'), '8192           ',  1,  20.30,    17,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '011590', '012211   ', '003', stod ('20150929'), '8235           ', 24,   1.1875,  17,    '03',   '03',   'CY3'})
//	aadd (_aCupons, {'13', '011591', '012212   ', '003', stod ('20150929'), '8233           ',  3,   3.00,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '011591', '012212   ', '003', stod ('20150929'), '8231           ',  2,   3.00,    17,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '011591', '012212   ', '003', stod ('20150929'), '8232           ',  2,   3.00,    17,    '03',   '03',   'CY3'})
//	aadd (_aCupons, {'13', '011591', '012212   ', '003', stod ('20150929'), '8134           ',  2,   6.90,    17,    '04',   '04',   'CY3'})
//	aadd (_aCupons, {'13', '011591', '012212   ', '003', stod ('20150929'), '8135           ',  1,   6.90,    17,    '05',   '05',   'CY3'})
//	aadd (_aCupons, {'13', '011591', '012212   ', '003', stod ('20150929'), '8163           ',  1,  14.70,    17,    '06',   '06',   'CY3'})
//	aadd (_aCupons, {'13', '011591', '012212   ', '003', stod ('20150929'), '8096           ',  1,  12.75,    17,    '07',   '07',   'CY3'})
//	aadd (_aCupons, {'13', '011591', '012212   ', '003', stod ('20150929'), '8178           ',  3,   4.70,    17,    '08',   '08',   'CY3'})
//	aadd (_aCupons, {'13', '011591', '012212   ', '003', stod ('20150929'), '8179           ',  3,   4.70,    17,    '09',   '09',   'CY3'})
//	aadd (_aCupons, {'13', '011592', '012213   ', '003', stod ('20150929'), '8092           ',  3,  10.70,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '011592', '012213   ', '003', stod ('20150929'), '8093           ',  1,  10.70,    17,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '011593', '012214   ', '003', stod ('20150929'), '8123           ', 10,   6.95,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '011593', '012214   ', '003', stod ('20150929'), '8127           ',  2,   6.95,    17,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '011593', '012214   ', '003', stod ('20150929'), '8148           ',  1,  12.50,    17,    '03',   '03',   'CY3'})
//	aadd (_aCupons, {'13', '011593', '012214   ', '003', stod ('20150929'), '8154           ',  1,  12.50,    17,    '04',   '04',   'CY3'})
//	aadd (_aCupons, {'13', '011593', '012214   ', '003', stod ('20150929'), '8122           ',  1,   4.70,    17,    '05',   '05',   'CY3'})
//	aadd (_aCupons, {'13', '011594', '012215   ', '003', stod ('20150929'), '8194           ',  1,    8.5,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '011594', '012215   ', '003', stod ('20150929'), '8167           ',  1,   15.0,    17,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '011595', '012216   ', '003', stod ('20150929'), '8102           ',  1,   25.9,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '011596', '012217   ', '003', stod ('20150929'), '8106           ',  2,   13.4,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '011596', '012217   ', '003', stod ('20150929'), '8233           ',  2,    2.5,    17,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'10', '009481', '010850   ', 'CL4', stod ('20150929'), '8178           ',  1,    2.4,    17,    '01',   '01',   'CX3'})
//	aadd (_aCupons, {'10', '009481', '010850   ', 'CL4', stod ('20150929'), '8244           ',  1,   1.25,    17,    '02',   '02',   'CX3'})
//	aadd (_aCupons, {'10', '009481', '010850   ', 'CL4', stod ('20150929'), '8000           ',  1,  19.85,    17,    '03',   '03',   'CX3'})
//	aadd (_aCupons, {'10', '009481', '010850   ', 'CL4', stod ('20150929'), '8000           ',  1,    6.5,    17,    '04',   '04',   'CX3'})
//	aadd (_aCupons, {'10', '009482', '010851   ', 'CL4', stod ('20150929'), '8157           ',  2,   30.0,    17,    '01',   '01',   'CX3'})
//	aadd (_aCupons, {'13', '008839', '009271   ', '003', stod ('20150702'), '8092           ',  2,   12.7,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '008839', '009271   ', '003', stod ('20150702'), '8163           ',  1,   12.7,    17,    '02',   '02',   'CY3'})
//	aadd (_aCupons, {'13', '008839', '009271   ', '003', stod ('20150702'), '8145           ',  1,   10.4,    17,    '03',   '03',   'CY3'})
//	aadd (_aCupons, {'13', '008839', '009271   ', '003', stod ('20150702'), '8092           ',  1,    9.5,    17,    '04',   '04',   'CY3'})
//	aadd (_aCupons, {'13', '006908', '007243   ', '003', stod ('20150505'), '8104           ',  1,   14.2,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '006595', '006912   ', '003', stod ('20150428'), '8157           ',  1,   15.5,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'13', '004592', '004775   ', 'CL3', stod ('20150213'), '8066           ',  3,   19.0,    17,    '01',   '01',   'CY3'})
//	aadd (_aCupons, {'10', '007808', '008997   ', 'CL4', stod ('20150219'), '8213           ',  1,   12.0,    17,    '01',   '01'})
//	aadd (_aCupons, {'10', '007808', '008997   ', 'CL4', stod ('20150219'), '2144           ',  2,   16.0,    17,    '02',   '02'})
//	aadd (_aCupons, {'10', '007808', '008997   ', 'CL4', stod ('20150219'), '8155           ',  1,   30.9,    17,    '03',   '03'})
//	aadd (_aCupons, {'10', '007808', '008997   ', 'CL4', stod ('20150219'), '8093           ',  1,   13.7,    17,    '04',   '04'})
//	aadd (_aCupons, {'10', '007808', '008997   ', 'CL4', stod ('20150219'), '8222           ',  1,   27.5,    17,    '05',   '05'})
//	aadd (_aCupons, {'10', '007808', '008997   ', 'CL4', stod ('20150219'), '8066           ',  1,   11.7,    17,    '06',   '06'})
//	aadd (_aCupons, {'10', '007808', '008997   ', 'CL4', stod ('20150219'), '8000           ',  1,    2.0,    17,    '07',   '07'})
//	aadd (_aCupons, {'10', '007808', '008997   ', 'CL4', stod ('20150219'), '8192           ',  1,   19.0,    17,    '08',   '08'})

//aadd (_aCupons, {'08', '000256', '000249   ', '001', stod ('20160816'),	'8192           '           	,3	, 19.5,	20,	'01',	'01',	'C03'})
//aadd (_aCupons, {'08', '000256', '000249   ', '001', stod ('20160816'),	'8156           '           	,1	, 19.5,	20,	'02',	'02',	'C03'})
//aadd (_aCupons, {'08', '000256', '000249   ', '001', stod ('20160816'),	'8145           '           	,1	, 13.2,	20,	'03',	'03',	'C03'})
//aadd (_aCupons, {'08', '000256', '000249   ', '001', stod ('20160816'),	'8168           '           	,5	, 11.5,	20,	'04',	'04',	'C03'})
//aadd (_aCupons, {'08', '000256', '000249   ', '001', stod ('20160816'),	'8170           '           	,3	, 11.5,	20,	'05',	'05',	'C03'})
//aadd (_aCupons, {'08', '000256', '000249   ', '001', stod ('20160816'),	'8169           '           	,1	, 11.5,	20,	'06',	'06',	'C03'})

//aadd (_aCupons, {'08', '000257', '000250   ', '001', stod ('20160816'),	'8066           '           	,12	, 18.4,	20,	'01',	'01',	'C03'})
//aadd (_aCupons, {'08', '000257', '000250   ', '001', stod ('20160816'),	'8156           '           	,1	, 19.5,	20,	'02',	'02',	'C03'})
//aadd (_aCupons, {'08', '000257', '000250   ', '001', stod ('20160816'),	'8143           '           	,1	, 13.2,	20,	'03',	'03',	'C03'})
//aadd (_aCupons, {'08', '000257', '000250   ', '001', stod ('20160816'),	'8249           '           	,1	, 5.3,	20,	'04',	'04',	'C03'})
//aadd (_aCupons, {'08', '000257', '000250   ', '001', stod ('20160816'),	'8250           '           	,1	, 5.3,	20,	'05',	'05',	'C03'})
//aadd (_aCupons, {'08', '000257', '000250   ', '001', stod ('20160816'),	'8253           '           	,3	, 1.4,	20,	'06',	'06',	'C03'})
//aadd (_aCupons, {'08', '000257', '000250   ', '001', stod ('20160816'),	'8252           '           	,2	, 1.4,	20,	'07',	'07',	'C03'})

//aadd (_aCupons, {'08', '000250', '000243   ', '001', stod ('20160810'),	'8156           '           	,2 	, 19.5,	17,	'01',	'01',	'C03'})
//aadd (_aCupons, {'08', '000250', '000243   ', '001', stod ('20160810'),	'8250           '           	,2 	,  5.3,	17,	'02',	'02',	'C03'})
//aadd (_aCupons, {'08', '000250', '000243   ', '001', stod ('20160810'),	'8251           '           	,1 	,  5.3,	17,	'03',	'03',	'C03'})
//aadd (_aCupons, {'08', '000250', '000243   ', '001', stod ('20160810'),	'8249           '           	,1 	,  5.3,	17,	'04',	'04',	'C03'})
//aadd (_aCupons, {'08', '000250', '000243   ', '001', stod ('20160810'),	'8243           '           	,1 	,  5.3,	17,	'05',	'05',	'C03'})
//aadd (_aCupons, {'08', '000250', '000243   ', '001', stod ('20160810'),	'8231           '           	,4 	,  2.7,	17,	'06',	'06',	'C03'})

//aadd (_aCupons, {'08', '000252', '000245   ', '001', stod ('20160810'),	'8066           '           	,2 	, 18.4,	17,	'01',	'01',	'C03'})
//aadd (_aCupons, {'08', '000252', '000245   ', '001', stod ('20160810'),	'8251           '           	,1 	,  5.3,	17,	'02',	'02',	'C03'})
//aadd (_aCupons, {'08', '000252', '000245   ', '001', stod ('20160810'),	'8249           '           	,1 	,  5.3,	17,	'03',	'03',	'C03'})
//aadd (_aCupons, {'08', '000252', '000245   ', '001', stod ('20160810'),	'8231           '           	,12	,  2.7,	17,	'04',	'04',	'C03'})

//	_CriaCupom (_aCupons)
return
*/

//Get-ChildItem *.pr* | Select-String -pattern "wait" | Select-String -NotMatch "CursorWait"

/*
//	U_LOG (PutSX1Help ("teste1", {"Teste de pergunta"}, {'teste2'}, {'teste3'}, .T.))
	PutSX1 ('ROBERT', '01', 'teste', 'teste', 'teste', 'mv_ch1', 'C', 6, 0, 0, 'G', '', 'SA1', '', '', 'mv_par01',; 
	'', '', '', '000001',; 
	'', '', '',; 
	'', '', '',; 
	'', '', '',; 
	'', '', '',; 
	{'linha1', 'linha2'}, {}, {}, '')
*/
/* testes para criar help de pergunta cfe chamado da Totvs
Local aHelpP := {}
Local aHelpE := {}
Local aHelpS := {}
Local aAreaSX1 := SX1->(GetArea())

dbSelectArea("SX1")
dbSetOrder(1)
cPerg := "tstputsx1 "

if dbSeek(cPerg + '01')
Reclock("SX1", .F.)
SX1->(dbDelete())
MsUnlock()
endif

// mv_par01 - Data de?
Aadd( aHelpP, "Teste 01 " )
Aadd( aHelpP, "processamento. " )
Aadd( aHelpP, " " )
Aadd( aHelpE, "Teste 01 " )
Aadd( aHelpE, "processamento. " )
Aadd( aHelpE, " " )
Aadd( aHelpS, "Teste 01 " )
Aadd( aHelpS, "processamento. " )
Aadd( aHelpS, " " )
PutSX1(cPerg,"01","Data de?","Data de?","Data de?","MV_CH1","D",8,0,0,"G"," "," "," "," ","mv_par01"," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," ",aHelpP,aHelpE,aHelpS)

Return	
*/



/*
	// Ajusta OPs safra 2016
	_aOP := {}
	aadd (_aOP, {'08724501002', 142790})
	aadd (_aOP, {'08724601001', 64100})
	aadd (_aOP, {'08731801001', 66150})
	aadd (_aOP, {'08733601001', 41200})
	aadd (_aOP, {'08734601003', 30100})
	aadd (_aOP, {'08737901001', 29400})
	aadd (_aOP, {'08738201001', 22000})
	aadd (_aOP, {'08742201001', 2200})
	aadd (_aOP, {'08742301001', 44100})
	aadd (_aOP, {'08742401001', 44100})
	aadd (_aOP, {'08747001001', 33150})
	aadd (_aOP, {'08747301001', 55250})
	aadd (_aOP, {'08747501001', 24300})
	aadd (_aOP, {'08753101001', 44200})
	aadd (_aOP, {'08753501001', 13250})
	aadd (_aOP, {'08753701001', 46550})
	aadd (_aOP, {'08754001001', 33360})
	aadd (_aOP, {'08756701001', 55250})
	aadd (_aOP, {'08757601001', 66300})
	aadd (_aOP, {'08761401001', 66300})
	aadd (_aOP, {'08763401001', 32300})
	aadd (_aOP, {'08763501001', 33150})
	aadd (_aOP, {'08763801001', 33600})
	aadd (_aOP, {'08766901001', 86600})
	aadd (_aOP, {'08768201001', 25600})
	aadd (_aOP, {'08770601001', 142800})
	aadd (_aOP, {'08770901001', 32700})
	aadd (_aOP, {'08774601001', 14900})
                              
	aadd (_aOP, {'08725001001', 71000})
	aadd (_aOP, {'08753801001', 9390})
	aadd (_aOP, {'08754101001', 5790})
	aadd (_aOP, {'08771001001', 28594})
	aadd (_aOP, {'08770801001', 28616})
                              
	aadd (_aOP, {'08720201001', 176800})
	aadd (_aOP, {'08722101001', 37200})
	aadd (_aOP, {'08722801001', 37200})
	aadd (_aOP, {'08724701001', 69800})
	aadd (_aOP, {'08727601001', 65100})
	aadd (_aOP, {'08729001001', 49700})
	aadd (_aOP, {'08730401001', 59800})
	aadd (_aOP, {'08730601001', 30250})
	aadd (_aOP, {'08733401001', 32600})
	aadd (_aOP, {'08736001001', 66300})
	aadd (_aOP, {'08736901001', 74400})
	aadd (_aOP, {'08736901001', 74400})
	aadd (_aOP, {'08738301001', 37200})
	aadd (_aOP, {'08739001001', 35400})
	aadd (_aOP, {'08739401001', 20950})
	aadd (_aOP, {'08739501001', 69600})
	aadd (_aOP, {'08739601001', 71800})
	aadd (_aOP, {'08740601001', 23300})
	aadd (_aOP, {'08741101001', 81800})
	aadd (_aOP, {'08741201001', 37200})
	aadd (_aOP, {'08741301001', 81800})
	aadd (_aOP, {'08743001001', 66850})
	aadd (_aOP, {'08743701001', 939100})
	aadd (_aOP, {'08743801001', 34900})
	aadd (_aOP, {'08744601001', 53000})
	aadd (_aOP, {'08745001001', 34900})
	aadd (_aOP, {'08745101001', 35400})
	aadd (_aOP, {'08746101001', 46500})
	aadd (_aOP, {'08747101001', 35400})
	aadd (_aOP, {'08747601001', 60500})
	aadd (_aOP, {'08747701001', 36900})
	aadd (_aOP, {'08747701001', 36900})
	aadd (_aOP, {'08748701001', 66300})
	aadd (_aOP, {'08748801001', 82900})
	aadd (_aOP, {'08750001001', 39500})
	aadd (_aOP, {'08750201001', 49700})
	aadd (_aOP, {'08750301001', 16300})
	aadd (_aOP, {'08750701001', 54100})
	aadd (_aOP, {'08752101001', 77300})
	aadd (_aOP, {'08752201001', 82500})
	aadd (_aOP, {'08762001001', 66300})
	aadd (_aOP, {'08762101001', 66300})
	aadd (_aOP, {'08762201001', 38700})
	aadd (_aOP, {'08762301001', 65200})
	aadd (_aOP, {'08762401001', 165200})
	aadd (_aOP, {'08762501001', 457200})

	for _nOP = 1 to len (_aOP)
		u_logIni (_aOP [_nOP, 1])
		sc2 -> (dbsetorder (1))
		if ! sc2 -> (dbseek ('01' + _aOP [_nOP, 1], .F.))
			u_log ('OP nao cadastrada')
		else
			_sWhere := " where D_E_L_E_T_ = ''"
			_sWhere +=   " and D3_FILIAL  = '" + sc2 -> c2_filial + "'"
			_sWhere +=   " and D3_OP      = '" + _aOP [_nOP, 1] + "'"
			_sWhere +=   " and D3_CF      = 'PR0'"
			_sWhere +=   " and D3_QUANT   = " + cvaltochar (sc2 -> c2_quje)
			_oSQL := ClsSQL ():New ()
			_oSQL:_sQuery = "select count (*) FROM SD3010 " + _sWhere
			if _oSQL:RetQry () != 1
				u_log ('Nao encontrei apontamento (ou encontrei mais de 1)')
			else
				_oSQL:_sQuery := "update SD3010 set D3_QUANT = " + cvaltochar (_aOP [_nOP, 2]) + _sWhere
				_oSQL:Log ()
				if _oSQL:Exec ()
					//u_log (sc2 -> c2_quje * 100 / _aOP [_nOP, 2])
					reclock ("SC2", .F.)
					sc2 -> c2_quje = _aOP [_nOP, 2]
					msunlock ()
				endif
			endif
		endif
		u_logFim (_aOP [_nOP, 1])
	next
return
*/
/*
Beleza Robert, 
tentei tambï¿½m com a SoftLock, mas me parece que ele bloqueava o registro tambï¿½m.
Consegui fazer com a funï¿½ï¿½o RLOCK( RECNO ).. essa ele retorna falso se nï¿½o conseguir bloquear.
Valeu!
Att.
Germano Possamai Neto
*/

/*
// --------------------------------------------------------------------------
static function _CriaCupom (_aCupons)
	LOCAL _nCupom := 0
	local _sCliente := ""
	local _sLoja := ""
	local _nValBrut := 0
	local _aImpCD2 := {}
	local _nImpCD2 := 0

	u_logIni ()
	u_log (_aCupons)
	
	begin transaction
	for _nCupom = 1 to len (_aCupons)
		if ascan (_aCupons, {|_aVal| _aVal [9] != _aCupons [_nCupom, 9]}) > 0
			u_help ("Mais de uma aliquota de ICMS. Sem tratamento.")
			return  // Cai fora sem usar loop para evitar o 'end transaction'.
		endif
	next
	for _nCupom = 1 to len (_aCupons)
		if ascan (_aCupons, {|_aVal| _aVal [3] != _aCupons [_nCupom, 3]}) > 0
			u_help ("Mais de um cupom. Sem tratamento.")
			return  // Cai fora sem usar loop para evitar o 'end transaction'.
		endif
	next
	_sCliente := '000000'
	_sLoja := '01'
	_nValBrut = 0
	for _nCupom = 1 to len (_aCupons)
		_nValBrut += _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8]
	next
	u_log ('ValBrut:', _nValBrut)

	for _nCupom = 1 to len (_aCupons)
		if cFilAnt != _aCupons [_nCupom, 1]
			u_help ("Filial errada")
			return  // Cai fora sem usar loop para evitar o 'end transaction'.
		endif
		u_logIni (_aCupons [_nCupom, 3] + ' ' + _aCupons [_nCupom, 6])
		sl1 -> (dbsetorder (1))  // L1_FILIAL+L1_NUM
		if ! sl1 -> (dbseek (xfilial ("SL1") + _aCupons [_nCupom, 2], .F.))
			u_help ("falta criar sl1")
			return  // Cai fora sem usar loop para evitar o 'end transaction'.
		else
			U_LOG ('Alterando SL1')
			reclock ("SL1", .F.)
			sl1 -> (dbrecall ())
			sl1 -> l1_doc     = _aCupons [_nCupom, 3]
			sl1 -> l1_serie   = _aCupons [_nCupom, 4]
			sl1 -> l1_emisnf  = _aCupons [_nCupom, 5]
			sl1 -> l1_dinheir = sl1 -> l1_valmerc
			sl1 -> l1_entrada = sl1 -> l1_valmerc
			sl1 -> l1_valicm  = sl1 -> l1_valbrut * _aCupons [_nCupom, 9] / 100
			sl1 -> l1_numcfis = _aCupons [_nCupom, 3]
			sl1 -> l1_pdv     = '001'
			sl1 -> l1_tipo    = 'V'
			sl1 -> l1_operado = _aCupons [_nCupom, 12]
			sl1 -> l1_situa   = 'OK'
			sl1 -> l1_storc   = ''
			msunlock ()
			
			sl2 -> (dbsetorder (1))  // L2_FILIAL+L2_NUM+L2_ITEM+L2_PRODUTO
			if ! sl2 -> (dbseek (xfilial ("SL2") + _aCupons [_nCupom, 2] + _aCupons [_nCupom, 11] + _aCupons [_nCupom, 6], .F.))
				u_help ("falta criar sl2 item '" + _aCupons [_nCupom, 11] + "'")
				return  // Cai fora sem usar loop para evitar o 'end transaction'.
			else
				U_LOG ('Alterando SL2')
				if sl2 -> l2_quant != _aCupons [_nCupom, 7]
					u_help ("quant.divergente SL2")
					return  // Cai fora sem usar loop para evitar o 'end transaction'.
				endif
				reclock ("SL2", .F.)
				sl2 -> (dbrecall ())
				sl2 -> l2_vendido = 'S'
				sl2 -> l2_doc     = _aCupons [_nCupom, 3]
				sl2 -> l2_serie   = _aCupons [_nCupom, 4]
				sl2 -> l2_valicm  = sl2 -> l2_baseicm * _aCupons [_nCupom, 9] / 100
				//sl2 -> l2_sittrib = 'T' + _nAliquota_ICMS_verificar_aqui
				sl2 -> l2_pdv     = '001'
				msunlock ()
			endif
			
			sf2 -> (dbsetorder (1))  // F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_FORMUL+F2_TIPO
			if ! sf2 -> (dbseek (xfilial ("SF2") + _aCupons [_nCupom, 3] + _aCupons [_nCupom, 4] + _sCliente + _sLoja, .F.))
				u_log ("Criando SF2")
				reclock ("SF2", .T.)
			else
				u_log ('Alterando SF2')
				reclock ("SF2", .F.)
			endif
			sf2 -> f2_filial  = xfilial ("SF2")
			sf2 -> f2_doc     = _aCupons [_nCupom, 3]
			sf2 -> f2_serie   = _aCupons [_nCupom, 4]
			sf2 -> f2_cliente = _sCliente
			sf2 -> f2_loja    = _sLoja
			sf2 -> f2_cond    = '097'
			sf2 -> f2_dupl    = _aCupons [_nCupom, 3]
			sf2 -> f2_emissao = _aCupons [_nCupom, 5]
			sf2 -> f2_est     = GetMv ("MV_ESTADO")
			sf2 -> f2_tipocli = 'F'
			sf2 -> f2_valbrut = _nValBrut
			sf2 -> f2_baseicm = _nValBrut
			sf2 -> f2_valicm  = _nValBrut * _aCupons [1, 9] / 100
			sf2 -> f2_valmerc = _nValBrut
			sf2 -> f2_tipo    = 'N'
			sf2 -> f2_vend1   = '060'
			sf2 -> f2_dtlanc  = ctod ('')  // Para poder 
			sf2 -> f2_valfat  = _nValBrut
			sf2 -> f2_especie = 'NFCE'
			sf2 -> f2_pdv     = '001'
			sf2 -> f2_ecf     = 'S'
			sf2 -> f2_prefixo = _aCupons [_nCupom, 4]
			sf2 -> f2_basimp5 = _nValBrut
			sf2 -> f2_basimp6 = _nValBrut
			sf2 -> f2_valimp5 = _nValBrut * 7.6 / 100
			sf2 -> f2_valimp6 = _nValBrut * 1.65 / 100
			sf2 -> f2_reciss  = '2'
			msunlock ()
			
			sd2 -> (dbsetorder (3))  // D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM
			if ! sd2 -> (dbseek (xfilial ("SD2") + _aCupons [_nCupom, 3] + _aCupons [_nCupom, 4] + _sCliente + _sLoja + _aCupons [_nCupom, 6] + _aCupons [_nCupom, 10], .F.))
				u_log ("Criando SD2")
				reclock ("SD2", .T.)
			else
				u_log ('Alterando SD2')
				reclock ("SD2", .F.)
			endif
			sb1 -> (dbsetorder (1))
			if ! sb1 -> (dbseek (xfilial ("SB1") + _aCupons [_nCupom, 6], .F.))
				u_help ("SB1 nao encontrado.")
				return  // Cai fora sem usar loop para evitar o 'end transaction'.
			endif
			sd2 -> d2_filial  = xfilial ("SD2")
			sd2 -> d2_cod     = _aCupons [_nCupom, 6]
			sd2 -> d2_quant   = _aCupons [_nCupom, 7]
			sd2 -> d2_prcven  = _aCupons [_nCupom, 8]
			sd2 -> d2_total   = _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8]
			sd2 -> d2_valicm  = _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8] * _aCupons [_nCupom, 9] / 100
			sd2 -> d2_tes     = '526'
			sd2 -> d2_um      = sb1 -> b1_um
			sd2 -> d2_cf      = '5101'
			sd2 -> d2_picm    = _aCupons [_nCupom, 9]
			sd2 -> d2_peso    = _aCupons [_nCupom, 7] * sb1 -> b1_peso
			sd2 -> d2_conta   = '101030101011        '
			sd2 -> d2_cliente = _sCliente
			sd2 -> d2_loja    = _sLoja
			sd2 -> d2_itempv  = strzero (_nCupom, tamsx3 ("D2_ITEMPV")[1])
			sd2 -> d2_doc     = _aCupons [_nCupom, 3]
			sd2 -> d2_emissao = _aCupons [_nCupom, 5]
			sd2 -> d2_local   = sb1 -> b1_locpad
			sd2 -> d2_tp      = sb1 -> b1_tipo
			sd2 -> d2_grupo   = sb1 -> b1_grupo
			sd2 -> d2_serie   = _aCupons [_nCupom, 4]
			sd2 -> d2_est     = GetMv ("MV_ESTADO")
			sd2 -> d2_prunit  = _aCupons [_nCupom, 8]
			sd2 -> d2_tipo    = 'N'
			sd2 -> d2_origlan = 'LO'
			sd2 -> d2_baseicm = _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8]
			sd2 -> d2_item    = _aCupons [_nCupom, 10]  //strzero (_nCupom, tamsx3 ("D2_ITEM")[1])
			sd2 -> d2_comis1  = 1.3
			sd2 -> d2_pdv     = '0001'
			sd2 -> d2_clasfis = '000'
			sd2 -> d2_basimp5 = _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8]
			sd2 -> d2_basimp6 = _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8]
			sd2 -> d2_valimp5 = _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8] * 7.6 / 100
			sd2 -> d2_valimp6 = _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8] * 1.65 / 100
			sd2 -> d2_alqimp5 = 7.6
			sd2 -> d2_alqimp6 = 1.65
			sd2 -> d2_valbrut = _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8]
			sd2 -> d2_sittrib = 'T' + strzero (_aCupons [1, 9] * 100, 2)  //'T1700'
			msunlock ()

			_aImpCD2 := {}
			aadd (_aImpCD2, {'CF2   ', '01', '',   7.60})
			aadd (_aImpCD2, {'ICM   ', '00', '3', _aCupons [1, 9]})
			aadd (_aImpCD2, {'PS2   ', '01', '',   1.65})
			cd2 -> (dbsetorder (1))  // CD2_FILIAL+CD2_TPMOV+CD2_SERIE+CD2_DOC+CD2_CODCLI+CD2_LOJCLI+CD2_ITEM+CD2_CODPRO+CD2_IMP
			for _nImpCD2 = 1 to len (_aImpCD2)
				if ! cd2 -> (dbseek (xfilial ("CD2") + 'S' + _aCupons [_nCupom, 4] + _aCupons [_nCupom, 3] + _sCliente + _sLoja + _aCupons [_nCupom, 10] + '  ' + _aCupons [_nCupom, 6] + _aImpCD2 [_nImpCD2, 1], .F.))
					u_log ("Criando CD2 para ", _aImpCD2 [_nImpCD2, 1])
					reclock ("CD2", .T.)
				else
					u_log ("Alterando CD2 para ", _aImpCD2 [_nImpCD2, 1])
					reclock ("CD2", .F.)
				endif
				sb1 -> (dbsetorder (1))
				if ! sb1 -> (dbseek (xfilial ("SB1") + _aCupons [_nCupom, 6], .F.))
					u_help ("SB1 nao encontrado.")
					return  // Cai fora sem usar loop para evitar o 'end transaction'.
				endif
				cd2 -> cd2_filial  = xfilial ("CD2")
				cd2 -> cd2_tpmov   = 'S'
				cd2 -> cd2_doc     = _aCupons [_nCupom, 3]
				cd2 -> cd2_serie   = _aCupons [_nCupom, 4]
				cd2 -> cd2_codcli  = _sCliente
				cd2 -> cd2_lojcli  = _sLoja
				cd2 -> cd2_item    = _aCupons [_nCupom, 10] //strzero (_nCupom, tamsx3 ("CD2_ITEM")[1])
				cd2 -> cd2_codpro  = _aCupons [_nCupom, 6]
				cd2 -> cd2_imp     = _aImpCD2 [_nImpCD2, 1]
				cd2 -> cd2_origem  = '0'
				cd2 -> cd2_cst     = _aImpCD2 [_nImpCD2, 2]
				cd2 -> cd2_modbc   = _aImpCD2 [_nImpCD2, 3]
				cd2 -> cd2_bc      = _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8]
				cd2 -> cd2_aliq    = _aImpCD2 [_nImpCD2, 4]
				cd2 -> cd2_vltrib  = _aCupons [_nCupom, 7] * _aCupons [_nCupom, 8] * _aImpCD2 [_nImpCD2, 4]
				cd2 -> cd2_qtrib   = _aCupons [_nCupom, 7]
				msunlock ()
			next

			_sParcela := space (tamsx3 ("E1_PARCELA")[1])
			_sTipo := 'R$ '
			se1 -> (dbsetorder (1))  // E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
			if ! se1 -> (dbseek (xfilial ("SE1") + _aCupons [_nCupom, 4] + _aCupons [_nCupom, 3], .T.))
				u_log ("Criando SE1")
				reclock ("SE1", .T.)
			else
				u_log ("Alterando SE1")
				reclock ("SE1", .F.)
			endif
			se1 -> e1_filial  = xfilial ("SE1")
			se1 -> e1_prefixo = _aCupons [_nCupom, 4]
			se1 -> e1_num     = _aCupons [_nCupom, 3]
			se1 -> e1_parcela = _sParcela
			se1 -> e1_tipo    = _sTipo
			se1 -> e1_cliente = _sCliente
			se1 -> e1_naturez = 'DINHEIRO'
			se1 -> e1_portado = _aCupons [_nCupom, 12]
			se1 -> e1_agedep  = '.'
			se1 -> e1_conta   = '.'
			se1 -> e1_loja    = _sLoja
			se1 -> e1_nomcli  = 'CONSUMIDOR FINAL'
			se1 -> e1_emissao = _aCupons [_nCupom, 5]
			se1 -> e1_vencto  = _aCupons [_nCupom, 5]
			se1 -> e1_vencrea = _aCupons [_nCupom, 5]
			se1 -> e1_valor   = _nValBrut
			se1 -> e1_vlcruz  = _nValBrut
			se1 -> e1_baixa   = _aCupons [_nCupom, 5]
			se1 -> e1_emis1   = _aCupons [_nCupom, 5]
			se1 -> e1_hist    = 'VENDA EM DINHEIRO'
			se1 -> e1_movimen = _aCupons [_nCupom, 5]
			se1 -> e1_situaca = '0'
			se1 -> e1_vend1   = '060'
			se1 -> e1_comis1  = 1.3
			se1 -> e1_valliq  = _nValBrut
			se1 -> e1_vencori = _aCupons [_nCupom, 5]
			se1 -> e1_moeda   = 1
			se1 -> e1_bascom1 = _nValBrut
			se1 -> e1_valcom1 = _nValBrut * 1.3 / 100
			se1 -> e1_numnota = _aCupons [_nCupom, 3]
			se1 -> e1_serie   = _aCupons [_nCupom, 4]
			se1 -> e1_status  = 'B'
			se1 -> e1_origem  = 'LOJA701'
			se1 -> e1_fluxo   = 'S'
			se1 -> e1_filorig = xfilial ("SE1")
			se1 -> e1_multnat = '2'
			se1 -> e1_nummov  = '01'
			se1 -> e1_relato  = '2'
			msunlock ()

			_sSeqSE5 := strzero (1, tamsx3 ("E5_SEQ")[1])  // space (tamsx3 ("E5_SEQ")[1])
			se5 -> (dbsetorder (7))  // E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
			if ! se5 -> (dbseek (xfilial ("SE5") + _aCupons [_nCupom, 4] + _aCupons [_nCupom, 3] + _sParcela + _sTipo + _sCliente + _sLoja + _sSeqSE5, .F.))
				u_log ('Criando SE5')
				reclock ("SE5", .T.)
			else
				u_log ('Alterando SE5')
				reclock ("SE5", .F.)
			endif
			se5 -> e5_filial  = xfilial ("SE5")
			se5 -> e5_data    = _aCupons [_nCupom, 5]
			se5 -> e5_tipo    = _sTipo
			se5 -> e5_valor   = _nValBrut
			se5 -> e5_naturez = 'DINHEIRO'
			se5 -> e5_banco   = _aCupons [_nCupom, 12]
			se5 -> e5_agencia = '.'
			se5 -> e5_conta   = '.'
			se5 -> e5_recpag  = 'R'
			se5 -> e5_histor  = 'BAIXA REF VENDA EM DINHEIRO'
			se5 -> e5_tipodoc = 'LJ'
			se5 -> e5_prefixo = _aCupons [_nCupom, 4]
			se5 -> e5_numero  = _aCupons [_nCupom, 3]
			se5 -> e5_parcela = _sParcela
			se5 -> e5_clifor  = _sCliente
			se5 -> e5_loja    = _sLoja
			se5 -> e5_dtdigit = _aCupons [_nCupom, 5]
			se5 -> e5_motbx   = 'NOR'
			se5 -> e5_dtdispo = _aCupons [_nCupom, 5]
			se5 -> e5_filorig = xfilial ("SE5")
			se5 -> e5_cliente = _sCliente
			se5 -> e5_nummov  = '01'
			se5 -> e5_seq     = _sSeqSE5
			msunlock ()
		endif
		u_logFim (_aCupons [_nCupom, 3] + ' ' + _aCupons [_nCupom, 6])
	next
	end transaction
	
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery = "SELECT SUM (F2_VALBRUT) OVER () AS VL_ACUM, * FROM " + RetSQLName ("SF2") + " WHERE D_E_L_E_T_ = '' and F2_FILIAL  = '" + _aCupons [1, 1] + "' AND F2_DOC    = '" + _aCupons [1, 3] + "' AND F2_SERIE   = '" + _aCupons [1, 4] + "'"
	u_log (_oSQL:Qry2Array (.T., .T.)) 
	_oSQL:_sQuery = "SELECT SUM (E1_VALOR)   OVER () AS VL_ACUM, * FROM " + RetSQLName ("SE1") + " WHERE D_E_L_E_T_ = '' and E1_FILIAL  = '" + _aCupons [1, 1] + "' AND E1_NUM    = '" + _aCupons [1, 3] + "' AND E1_PREFIXO = '" + _aCupons [1, 4] + "'"
	u_log (_oSQL:Qry2Array (.T., .T.)) 
	_oSQL:_sQuery = "SELECT SUM (E5_VALOR)   OVER () AS VL_ACUM, * FROM " + RetSQLName ("SE5") + " WHERE D_E_L_E_T_ = '' and E5_FILIAL  = '" + _aCupons [1, 1] + "' AND E5_NUMERO = '" + _aCupons [1, 3] + "' AND E5_PREFIXO = '" + _aCupons [1, 4] + "'"
	u_log (_oSQL:Qry2Array (.T., .T.)) 
	_oSQL:_sQuery = "SELECT SUM (D2_VALBRUT) OVER () AS VL_ACUM, * FROM " + RetSQLName ("SD2") + " WHERE D_E_L_E_T_ = '' and D2_FILIAL  = '" + _aCupons [1, 1] + "' AND D2_DOC    = '" + _aCupons [1, 3] + "' AND D2_SERIE   = '" + _aCupons [1, 4] + "'"
	u_log (_oSQL:Qry2Array (.T., .T.)) 
	_oSQL:_sQuery = "SELECT SUM (CD2_BC)     OVER () AS VL_ACUM, * FROM " + RetSQLName ("CD2") + " WHERE D_E_L_E_T_ = '' and CD2_FILIAL = '" + _aCupons [1, 1] + "' AND CD2_DOC   = '" + _aCupons [1, 3] + "' AND CD2_SERIE  = '" + _aCupons [1, 4] + "' AND CD2_IMP = 'ICM'"
	u_log (_oSQL:Qry2Array (.T., .T.))
	U_LOGfIM () 
return
*/
/*
	// Comparacao do SX3 com SXG
	procregua (9999999)
	sx3 -> (dbsetorder (1))
	sx3 -> (dbgotop ())
	do while ! sx3 -> (eof ())
		if ! empty (sx3 -> x3_grpsxg)
			incproc (sx3 -> x3_grpsxg)
			if ! sxg -> (dbseek (sx3 -> x3_grpsxg, .F.))
				u_log ('nao encontrei', sx3 -> x3_grpsxg, 'no SXG')
			else
				if sx3 -> x3_tamanho != sxg -> xg_size
					if ! sx2 -> (dbseek (sx3 -> x3_arquivo, .F.))
						u_log (sx3 -> x3_arquivo, 'nao existe no sx2.')
					else
						if U_RetSQL ("select count (*) from sysobjects where name = '" + RetSQLName (sx3 -> x3_arquivo) + "' and type = 'U'") == 0
							u_log (RetSQLName (sx3 -> x3_arquivo), 'nao existe. Vou alterar SX3.')
							reclock ("SX3", .F.)
							sx3 -> x3_tamanho = sxg -> xg_size
							msunlock ()
						else
							if U_RetSQL ("select count (*) from " + RetSQLName (sx3 -> x3_arquivo)) == 0
								u_log (RetSQLName (sx3 -> x3_arquivo), 'vazio. Vou dar drop.')
								_oSQL := ClsSQL():New()
								_oSQL:_sQuery = 'drop table ' + RetSQLName (sx3 -> x3_arquivo)
								if msgyesno (_oSQL:_sQuery)
									_oSQL:Exec ()
									reclock ("SX3", .F.)
									sx3 -> x3_tamanho = sxg -> xg_size
									msunlock ()
								endif
							else
								u_log ('alterar tamanho do', sx3 -> x3_campo, 'de', sx3 -> x3_tamanho, 'para', sxg -> xg_size, 'grupo xsg:', sx3 -> x3_grpsxg)
							endif
						endif
					endif
				endif
			endif
		endif
		sx3 -> (dbskip ())
	enddo

	// Comparacao da estrutura do arquivo com SX3
	_aComandos = {}
	sx2 -> (dbsetorder (1))
	sx3 -> (dbsetorder (2))
	sx2 -> (dbgotop ())
	//sx2 -> (dbseek ('S', .T.))
	do while ! sx2 -> (eof ())
		u_log ('Verificando ' + sx2 -> x2_arquivo)
		if U_RetSQL ("select count (*) from sysobjects where name = '" + sx2 -> x2_arquivo + "' and type = 'U'") > 0
			_aEstrut := aclone ((sx2 -> x2_chave) -> (dbstruct ()))
//			u_log (_aEstrut)
			for _nCampo = 1 to len (_aEstrut)
//				u_log (_nCampo, '>>' + left (_aEstrut [_nCampo, 1] + '          ', 10) + "<<")
				if ! sx3 -> (dbseek (left (_aEstrut [_nCampo, 1] + '          ', 10), .F.))
					u_log ('Campo', _aEstrut [_nCampo, 1], 'nao encontrado no SX3.')
				else
					//u_log ('_nCampo antes de testar campo memo:', _nCampo)
					if sx3 -> x3_tipo != 'M' .and. _aEstrut [_nCampo, 2] != 'M'  // Campos memo sao complicados...
						//u_log ('_nCampo antes de testar tipo, tamanho e decimais:', _nCampo)
						if sx3 -> x3_tipo != _aEstrut [_nCampo, 2] .or. sx3 -> x3_tamanho != _aEstrut [_nCampo, 3] .or. sx3 -> x3_decimal != _aEstrut [_nCampo, 4]
							//u_log ('_nCampo antes da contagem do SX2:', _nCampo)
							if U_RetSQL ("select count (*) from " + sx2 -> x2_arquivo) == 0
								u_log (sx2 -> x2_arquivo, 'vazio. Vou dar drop.')
								aadd (_aComandos, {'drop table ' + sx2 -> x2_arquivo, sx2 -> x2_nome})
								exit // Nao preciso mais verificar este arquivo.
							else
								//u_log ('_nCampo antes da msg:', _nCampo)
								u_log ('Campo', _aEstrut [_nCampo, 1], ': sx3:', sx3 -> x3_tipo, sx3 -> x3_tamanho, sx3 -> x3_decimal, '  no arquivo:', _aEstrut [_nCampo, 2], _aEstrut [_nCampo, 3], _aEstrut [_nCampo, 4], 'x2_arquivo:', sx2 -> x2_arquivo)
								//u_log ('_nCampo depois da msg:', _nCampo)
							endif
						endif
					endif
				endif
			next
		endif
		sx2 -> (dbskip ())
	enddo
	// Grava em log os comandos a executar no SQL
	u_log (_aComandos)
return
*/

/*
	// Ajusta transferencias internas que ficaram com D3_NUMSEQ repetido.
	_dDataIni := stod ('20150112')
	_dDataFim := stod ('20151231')
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " SELECT D3_NUMSEQ "
	_oSQL:_sQuery +=   " FROM " + RetSQLName ("SD3")
	_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=    " AND D3_FILIAL = '" + xfilial ("SD3") + "'"
	_oSQL:_sQuery +=    " AND D3_EMISSAO BETWEEN '" + dtos (_dDataIni) + "' AND '" + dtos (_dDataFim) + "'"
	_oSQL:_sQuery +=    " AND D3_EMISSAO > '" + DTOS (getmv ("MV_ULMES")) + "'"  // Soh pra nao mexer em mes fechado...
	_oSQL:_sQuery +=    " AND D3_CF IN ('RE4', 'DE4')"
	_oSQL:_sQuery +=  " GROUP BY D3_NUMSEQ"
	_oSQL:_sQuery += " HAVING COUNT (*) > 2"
	_oSQL:_sQuery +=  " ORDER BY D3_NUMSEQ"
	u_log (_oSQL:_sQuery)
	_aRetSQL := aclone (_oSQL:Qry2Array ())
	u_log (_aRetSQL)
	for _nRetSQL = 1 to len (_aRetSQL)
		u_log (_nRetSQL, 'de', len (_aRetSQL))
		do while .t.
			_nRegRE = 0
			_nRegDE = 0
			_oSQL:_sQuery := ""
			_oSQL:_sQuery += " SELECT top 1 R_E_C_N_O_, D3_COD, D3_EMISSAO, D3_QUANT "
			_oSQL:_sQuery +=   " FROM " + RetSQLName ("SD3")
			_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
			_oSQL:_sQuery +=    " AND D3_FILIAL = '" + xfilial ("SD3") + "'"
			_oSQL:_sQuery +=    " AND D3_NUMSEQ  = '" + _aRetSQL [_nRetSQL, 1] + "'"
			_oSQL:_sQuery +=    " AND D3_CF      = 'RE4'"
			u_log (_oSQL:_sQuery)
			//_nRegRE = _oSQL:RetQry ()
			_aRE = _oSQL:Qry2Array ()
			if len (_aRE) == 1
				_nRegRE = _aRE [1, 1]
				_oSQL:_sQuery := ""
				_oSQL:_sQuery += " SELECT top 1 R_E_C_N_O_ "
				_oSQL:_sQuery +=   " FROM " + RetSQLName ("SD3")
				_oSQL:_sQuery +=  " WHERE D_E_L_E_T_ = ''"
				_oSQL:_sQuery +=    " AND D3_FILIAL = '" + xfilial ("SD3") + "'"
				_oSQL:_sQuery +=    " AND D3_NUMSEQ  = '" + _aRetSQL [_nRetSQL, 1] + "'"
				_oSQL:_sQuery +=    " AND D3_COD     = '" + _aRE [1, 2] + "'"
				_oSQL:_sQuery +=    " AND D3_EMISSAO = '" + dtos (_aRE [1, 3]) + "'"
				_oSQL:_sQuery +=    " AND D3_QUANT   = '" + cvaltochar (_aRE [1, 4]) + "'"
				_oSQL:_sQuery +=    " AND D3_CF      = 'DE4'"
				u_log (_oSQL:_sQuery)
				_nRegDE = _oSQL:RetQry ()
			endif
			if _nRegDE == 0 .or. _nRegRe == 0  // Se nao achou mais nenhum par, cai fora.
				exit
			endif
			_sNumSeq = ProxNum ()
			u_log ('vou gravar:', _sNumSeq)
			sd3 -> (dbgoto (_nRegDE))
			u_logtrb ('SD3')
			reclock ("SD3", .F.)
			sd3 -> d3_numseq = _sNumSeq
			msunlock ()
			sd3 -> (dbgoto (_nRegRE))
			u_logtrb ('SD3')
			reclock ("SD3", .F.)
			sd3 -> d3_numseq = _sNumSeq
			msunlock ()
		enddo
	next
return
*/
/*
	// Gera codigo EAN para os produtos que estao em branco.
	sb1 -> (dbsetorder (2))  // B1_FILIAL+B1_TIPO+B1_COD
	sb1 -> (dbgotop ())
	do while ! sb1 -> (eof ())
		IF left (sb1 -> b1_vaeanun, 7) != '0000000' ;
			.and. SUBSTR (sb1 -> b1_vaeanun, 9, 4) != left (sb1 -> b1_cod, 4) ;
			.and. left (sb1 -> b1_vaeanun, 3) != '789' ;
			.and. ! empty (left (sb1 -> b1_cod, 1)) ;
			.and. ! isalpha (left (sb1 -> b1_cod, 1)) ;
			.and. ! sb1 -> b1_tipo $ 'PA/MO/BN/GF/MC/'

			U_LOG (sb1 -> b1_tipo, sb1 -> B1_COD, sb1 -> B1_vaeanun, sb1 -> b1_desc)
			reclock ("SB1", .F.)
			if ISALPHA (right (alltrim (sb1 -> b1_cod), 1))
				sb1 -> b1_vaeanun = U_ML_DVEAN ('00000009' + left (sb1->B1_cod, 4), .T.)
			else
				sb1 -> b1_vaeanun = U_ML_DVEAN ('00000000' + alltrim (sb1->B1_cod), .T.)
			endif
			msunlock ()
		endif
		sb1 -> (dbskip ())
	enddo
return
*/
/*
	local cURL       := PadR(GetNewPar("MV_SPEDURL","http://localhost:8080/sped"),250)
	local _sEntidade := "000001"
	local _sXML      := ""
	local _sRet      := ""
	local cError     := ""
	local cWarning   := ""
	oWS:= WSNFeSBRA():New()
	oWS:cUSERTOKEN        := "TOTVS"
	oWS:cID_ENT           := _sEntidade
	oWS:oWSNFEID          := NFESBRA_NFES2():New()
	oWS:oWSNFEID:oWSNotas := NFESBRA_ARRAYOFNFESID2():New()
	aadd(oWS:oWSNFEID:oWSNotas:oWSNFESID2,NFESBRA_NFESID2():New())
	Atail(oWS:oWSNFEID:oWSNotas:oWSNFESID2):cID := "10 " + "000056066"
	oWS:nDIASPARAEXCLUSAO := 0
	oWS:_URL := AllTrim(cURL)+"/NFeSBRA.apw"
	If oWS:RETORNANOTAS()
		u_log ('retornanotas')
		// Precisa ler toda a array por que o mesmo numero de nota pode retornar
		// em producao/homologacao, ou em modo normal/contingencia
		For nX := 1 To Len(oWs:oWsRetornaNotasResult:OWSNOTAS:OWSNFES3)
			u_log (nX)
			if valtype (oWs:oWsRetornaNotasResult:OWSNOTAS:OWSNFES3[nX]:oWSNFE) == "O"
				u_log ('protoc.:', oWs:oWsRetornaNotasResult:OWSNOTAS:OWSNFES3[nX]:oWSNFE:CPROTOCOLO)
				_sXml = oWs:oWsRetornaNotasResult:OWSNOTAS:OWSNFES3[nX]:oWSNFE:CXML
				u_log (_sXML)
				if at ("<tpAmb>1</tpAmb>", _sXml) > 0  // Ambiente: 1=producao, 2=homologacao
					
					// Cria objeto XML com dados da NF-e
					oXml := XmlParser(_sXML, "_", @cError, @cWarning )
					u_log (substr (oXml:_NFE:_INFNFE:_ID:TEXT, 4, 44))
				endif
			endif
		next
	endif
return
*/
