// Programa:  VA_ACR
// Autor:     Robert Koch
// Data:      30/09/2023
// Descricao: Analise custo reposicao (GLPI 14309)

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Consulta
// #Descricao         #Objetivo listar itens de venda abrindo su custo de reposicao.
// #PalavasChave      #custo_reposicao #custo_standard #estrutura
// #TabelasPrincipais #SB1 #SG1
// #Modulos           #EST

#include "protheus.ch"

#XTranslate .EstrHistNivel      => 1
#XTranslate .EstrHistTipoComp   => 2
#XTranslate .EstrHistCodComp    => 3
#XTranslate .EstrHistDescri     => 4
#XTranslate .EstrHistQuantAcum  => 5
#XTranslate .EstrHistRevAtu     => 6
#XTranslate .EstrHistCustDUnit  => 7
#XTranslate .EstrHistCustDAcum  => 8
#XTranslate .EstrHistEhUva      => 9
#XTranslate .EstrHistQtColunas  => 9

// --------------------------------------------------------------------------
user function VA_ACR (_lAuto)
	Local cCadastro := "Analise custo reposicao"
	Local aSays     := {}
	Local aButtons  := {}
	Local nOpca     := 0
	Local lPerg     := .F.
	private cPerg   := 'VA_ACR'

	_validperg ()
	pergunte (cPerg, .f.)
	if _lAuto != NIL .and. _lAuto
		Processa( { |lEnd| _Gera() } )
	else
		AADD(aSays,cCadastro)
		AADD(aSays,"")
		AADD(aSays,"")
		AADD(aButtons, { 5, .T.,{|| lPerg := Pergunte(cPerg,.T. ) } } )
		AADD(aButtons, { 1, .T.,{|| nOpca := If(( lPerg .Or. Pergunte(cPerg,.T.)) .And. _TudoOk() , 1, 2 ), If( nOpca == 1, FechaBatch(), Nil ) }})
//		AADD(aButtons, { 15,.T.,{|| U_VA_SZNC ('EVENTO', 'CT2001')}})
		AADD(aButtons, { 2, .T.,{|| FechaBatch() }} )
		FormBatch( cCadastro, aSays, aButtons)
		If nOpca == 1
			Processa( { |lEnd| _Gera() } )
		Endif
	endif
return


// --------------------------------------------------------------------------
// 'Tudo OK' do FormBatch.
Static Function _TudoOk ()
	local _lRet := .T.
return _lRet


// --------------------------------------------------------------------------
static function _Gera ()
	local _lContinua := .T.
	local _oSQL      := NIL
	local _aHeader   := {}
	local _aCols     := {}
	local _n         := 1
	local _aEstrAux  := {}
	local _aEstrHist := {}
	local _nEstrAux  := 0
	local _nFilho    := 0
	local _sFiltComp := ''
	private _aEstruts := {}  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oDlg1    := NIL  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oGetD1   := NIL  // Deixar private para ser vista pelas funcoes auxiliares.

	// Cria aHeader em formato compativel com a query para mostrar posteriormente em tela.
	_aHeader = {}
	//              Titulo                  Campo        Masc               Tam Dec Valid Usado Tipo F3     Context CBox Relacao Alteravel
	aadd (_aHeader, {"Produto",             "PRODUTO",   "",                15, 0,  "",   "",   "C", "SB1", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Descricao",           "DESCRICAO", "",                60, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Rev.Atual",           "REVATU",    "",                 3, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo ME",            "CUSTOME",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo VD",            "CUSTOVD",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo MO",            "CUSTOVO",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo BN",            "CUSTOBN",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo Outros",        "CUSTOOUTR", "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})

	// Alimentacao inicial do aCols com os itens a serem analisados.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += "SELECT B1_COD, B1_DESC, B1_REVATU"
	_oSQL:_sQuery +=      ", 0 AS CUSTO_ME"    // 4
	_oSQL:_sQuery +=      ", 0 AS CUSTO_VD"    // 5
	_oSQL:_sQuery +=      ", 0 AS CUSTO_MO"    // 6
	_oSQL:_sQuery +=      ", 0 AS CUSTO_BN"    // 7
	_oSQL:_sQuery +=      ", 0 AS CUSTO_OUTR"  // 8
	_oSQL:_sQuery +=      ", '' AS DELETADO"
	_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB1") + " SB1"
	_oSQL:_sQuery += " WHERE SB1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=   " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
	_oSQL:_sQuery +=   " AND SB1.B1_COD     BETWEEN '" + mv_par01 + "' AND '" + mv_par02 + "'"
	_oSQL:_sQuery +=   " AND SB1.B1_TIPO    IN ('PA')"
	_oSQL:_sQuery +=   " AND SB1.B1_MSBLQL != '1'"
	_oSQL:_sQuery += " ORDER BY B1_COD"
	_oSQL:Log ('[' + procname () + ']')
	_aCols := aclone (_oSQL:Qry2Array (.f., .f.))
	if len (_aCols) == 0
		u_help ("Nenhum item selecionado para analise.",, .t.)
	endif

	// Alimenta custos e outros dados adicionais no aCols.
	procregua (len (_aCols))

	// Monta expressao para filtrar componentes
	_sFiltComp = ".T."
	if mv_par03 == 1  // Nao considerar uvas
		_sFiltComp += ".and.sb1->b1_grupo!='0400'"
	endif
	if ! empty (mv_par04)
		_sFiltComp += ".and.!sb1->b1_tipo$'" + alltrim (mv_par04) + "'"
	endif
	U_Log2 ('debug', '[' + procname () + ']Filtro para leitura das estruturas: ' + _sFiltComp)

	sb1 -> (dbsetorder (1))
	for _n = 1 to len (_aCols)
		incproc ('Lendo estrutura do ' + _aCols [_n, 1])

		U_Log2 ('debug', '[' + procname () + ']' + _aCols [_n, 1])
		// Preenche a ultima coluna com .F. para indicar 'linha nao deletada'.
		_aCols [_n, len (_aCols [_n])] = .F.

		_aEstrAux = aclone (U_ML_Comp2 (_aCols [_n, 1], 1, _sFiltComp, dDataBase, .f., .f., .f., .f., .f., '', .f., .t., .t., .f., _aCols [_n, 3]))

		// Nao preciso de todas as colunas da array gerada pela funcao de
		// leitura de estrutura, entao vou substituir por coisas que preciso.
		for _nEstrAux = 1 to len (_aEstrAux)
			if ! sb1 -> (dbseek (xfilial ("SB1") + _aEstrAux [_nEstrAux, 2], .F.))
				u_help ("Nao localizado cadastro do item '" + _aEstrAux [_nEstrAux, 2] + "'",, .t.)
				_lContinua = .F.
			else
				_aEstrAux [_nEstrAux, 5] = sb1 -> b1_tipo
				_aEstrAux [_nEstrAux, 6] = sb1 -> b1_desc
				_aEstrAux [_nEstrAux, 8] = sb1 -> b1_custd
				_aEstrAux [_nEstrAux, 9] = (sb1 -> b1_grupo == '0400')
			endif
		next
		U_Log2 ('debug', '[' + procname () + ']_aEstrAux com dados do SB1')
		U_Log2 ('debug', _aEstrAux)

		// Prepara uma 'estrutura para historico' filtrando itens que nao interessam,
		// acrescentando acumulados, etc. Tambem jah grava uma copia dessa estrutura
		// numa array em memoria, para o caso do usuario querer consultar depois.
		_aEstrHist = {}
		_nEstrAux = 1
		do while _nEstrAux <= len (_aEstrAux)

			aadd (_aEstrHist, array (.EstrHistQtColunas))
			_aEstrHist [len (_aEstrHist), .EstrHistNivel]     = _aEstrAux [_nEstrAux, 1]
			_aEstrHist [len (_aEstrHist), .EstrHistCodComp]   = _aEstrAux [_nEstrAux, 2]
			_aEstrHist [len (_aEstrHist), .EstrHistQuantAcum] = _aEstrAux [_nEstrAux, 4]
			_aEstrHist [len (_aEstrHist), .EstrHistRevAtu]    = _aEstrAux [_nEstrAux, 12]
			_aEstrHist [len (_aEstrHist), .EstrHistTipoComp]  = _aEstrAux [_nEstrAux, 5]
			_aEstrHist [len (_aEstrHist), .EstrHistCustDUnit] = _aEstrAux [_nEstrAux, 8]
			_aEstrHist [len (_aEstrHist), .EstrHistDescri]    = alltrim (_aEstrAux [_nEstrAux, 6])
			_aEstrHist [len (_aEstrHist), .EstrHistEhUva]     = _aEstrAux [_nEstrAux, 9]

	// Passado para depois de acumular os subniveis
	//		// Como o primeiro item eh o proprio pai, nao quero somar seu custo.
	//		if _nEstrAux > 1
	//			do case
	//			case _aEstrAux [_nEstrAux, 5] == 'ME'
	//				_aCols [_n, 4] += sb1 -> b1_custd * _aEstrAux [_nEstrAux, 4]
	//			case _aEstrAux [_nEstrAux, 5] == 'VD'
	//				_aCols [_n, 5] += sb1 -> b1_custd * _aEstrAux [_nEstrAux, 4]
	//			case _aEstrAux [_nEstrAux, 5] == 'MO'
	//				_aCols [_n, 6] += sb1 -> b1_custd * _aEstrAux [_nEstrAux, 4]
	//			case _aEstrAux [_nEstrAux, 5] == 'BN'
	//				_aCols [_n, 7] += sb1 -> b1_custd * _aEstrAux [_nEstrAux, 4]
	//			otherwise
	//				_aCols [_n, 8] += sb1 -> b1_custd * _aEstrAux [_nEstrAux, 4]
	//			endcase
	//		endif

			// Ateh nova definicao, queremos ler o custo
			// somente do nivel mais alto do VD, desconsiderando os
			// subniveis para composicao do custo do produto acabado.
			// Isso por que temos casos de VD dentro de VD.
			if mv_par05 == 1
				if _aEstrAux [_nEstrAux, 5] == 'VD'
					_nFilho = _nEstrAux
					do while _nFilho <= len (_aEstrAux) .and. _aEstrAux [_nFilho + 1, 1] > _aEstrAux [_nEstrAux, 1]
						U_Log2 ('debug', '[' + procname () + ']Desconsiderando comp. ' + _aEstrAux [_nFilho+1, 2] + ' (nivel ' + cvaltochar (_aEstrAux [_nFilho+1, 1]) + ' por ser descendente de um VD.')
						_nFilho ++
					enddo
					_nEstrAux = _nFilho
				endif
			endif

			_nEstrAux ++
		enddo

		// Acumula o custo de reposicao dos niveis superiores somando o custo de seus filhos.
		_aEstrHist [1, .EstrHistCustDAcum] = _AcumNiv (@_aEstrHist, 1)
	// ainda nao pronto	_AcumCust (@_aEstrHist, 1)

		// Abre os custos do item atual conforme os tipos de seus componentes.
		for _nEstrAux = 2 to len (_aEstrAux)  // Como o primeiro item eh o proprio pai, nao quero somar seu custo.
			do case
			case _aEstrAux [_nEstrAux, 5] == 'ME'
				_aCols [_n, 4] += sb1 -> b1_custd * _aEstrAux [_nEstrAux, 4]
			case _aEstrAux [_nEstrAux, 5] == 'VD'
				_aCols [_n, 5] += sb1 -> b1_custd * _aEstrAux [_nEstrAux, 4]
			case _aEstrAux [_nEstrAux, 5] == 'MO'
				_aCols [_n, 6] += sb1 -> b1_custd * _aEstrAux [_nEstrAux, 4]
			case _aEstrAux [_nEstrAux, 5] == 'BN'
				_aCols [_n, 7] += sb1 -> b1_custd * _aEstrAux [_nEstrAux, 4]
			otherwise
				_aCols [_n, 8] += sb1 -> b1_custd * _aEstrAux [_nEstrAux, 4]
			endcase
		next

		// Guardo a estrutura pronta numa array geral, pois imagino que o
		// usuario vai consultar mais de uma vez e, jah que gastei tempo
		// na leitura inicial, por que nao aproveitar?
		aadd (_aEstruts, {_aCols [_n, 1], aclone (_aEstrHist)})
	next

	U_Log2 ('debug', '[' + procname () + ']_aEstruts:')
	U_Log2 ('debug', _aEstruts)
	u_LogACols (_aHeader, _aCols)
	// durante testes, rodo via script e nao tenho interface com o usuario.
	if type ("oMainWnd") != "O"
		_VisEstru (mv_par01)
	endif

	if _lContinua
		_aSize := MsAdvSize()
		define MSDialog _oDlg1 from _aSize [1], _aSize [1] to _aSize [6], _aSize [5] of oMainWnd pixel title "Analise custo reposicao"

		_oGetD1 := MsNewGetDados ():New (31, ;                       // Limite superior
									5, ;                             // Limite esquerdo 
									_oDlg1:nClientHeight / 2 - 1, ;  // Limite inferior
									_oDlg1:nClientWidth / 2 - 10, ;  // Limite direito
									2, ;                             // [ nStyle ]
									"AllwaysTrue ()", ;              // [ uLinhaOk ]
									"AllwaysTrue ()", ;              // [ uTudoOk ]
									NIL, ;                           // [cIniCpos]
									NIL,;                            // [ aAlter ]
									NIL,;                            // [ nFreeze ]
									NIL,;                            // [ nMax ]
									NIL,;                            // [ cFieldOk ]
									NIL,;                            // [ uSuperDel ]
									NIL,;                            // [ uDelOk ]
									_oDlg1,;                         // [ oWnd ]
									_aHeader,;                       // [ ParHeader ]
									_aCols)                          // [ aParCols ]

		_oGetD1:oBrowse:bLDblClick := {|| _DblClick ()}
		_oGetD1:oBrowse:bRClicked := {|_o, _x, _y| _RClick (_o, _x, _y)}

		// Define botoes para a barra de ferramentas
		_bBotaoOK  = {|| _oDlg1:End ()}
		_bBotaoCan = {|| _oDlg1:End ()}
		_aBotAdic  = {}

		aadd (_aBotAdic, {"", {|| aHeader := aclone (_oGetD1:aHeader), aCols := aclone (_oGetD1:aCols), U_aColsXLS ()}, "Exp.planilha"})
		
		// durante testes, rodo via script e nao tenho interface com o usuario.
		if type ("oMainWnd") == "O"
			activate dialog _oDlg1 on init (EnchoiceBar (_oDlg1, _bBotaoOK, _bBotaoCan,, _aBotAdic))
		endif
	endif
return


// --------------------------------------------------------------------------
// Funcao executada pelo duplo clique do mouse.
static function _DblClick ()
//	local _sCampo := aHeader [_oGetD1:oBrowse:nColPos, 2]
return


// --------------------------------------------------------------------------
// Funcao executada pelo clique do botao direito do mouse.
static function _RClick (_o, _x, _y)
	local _oMenu     := NIL
	Local _oMenuItem := {}
	local _sProduto  := GDFieldGet ("PRODUTO", _oGetD1:nAt, .f., _oGetD1:aHeader, _oGetD1:aCols)
 
	MENU _oMenu POPUP 
	aAdd( _oMenuItem, MenuAddItem ("Visualizar estrutura"    ,,, .T.,,,, _oMenu, {|| processa ({||_VisEstru (_sProduto, .f.)}) },,,,,{|| .T.}) ) 
//	aAdd( _oMenuItem, MenuAddItem ("Vis.estrut.c/ult.compras",,, .T.,,,, _oMenu, {|| _VisEstru (_sProduto, .t.) },,,,,{|| .T.}) ) 
	ENDMENU

	_oMenu:Activate (_x + 15, _y + 205)
return


// --------------------------------------------------------------------------
// Visualiza estrutura que foi considerada para o produto selecionado.
static function _VisEstru (_sProduto, _lUltComp)
	local _nPosEstr    := 0
	local _nCompon     := 0
	local _oSQL        := NIL
	local _aHeader     := {}
	local _aCols       := {}
	local _n           := 1
	local _bBotaoOK    := {}
	local _bBotaoCan   := {}
	local _aBotAdic    := {}
	private _oDlgEstr  := NIL  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oGetDEstr := NIL  // Deixar private para ser vista pelas funcoes auxiliares.

	// Joga uma ossinho pro usuario roer
	procregua (10)
	incproc ()

	_nPosEstr = ascan (_aEstruts, {|_aVal| _aVal [1] == _sProduto})
	if _nPosEstr == 0
		u_help ("Estrutura nao encontrada!",, .t.)
	else
		// Extrai, da array de estruturas que jah tenho em memoria, a estrutura
		// do item solicitado.
		_aAux = aclone (_aEstruts [_nPosEstr, 2])
		
		_aHeader = {}
		//              Titulo            Campo       Masc                 Tam Dec Valid Usado Tipo F3  Context CBox Relacao Alteravel
		aadd (_aHeader, {"Indice",        "INDICE",   "",                   10, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Nivel",         "NIVEL",    "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Tipo",          "TIPO",     "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Componente",    "COMP",     "",                   15, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Descricao",     "DESCR",    "",                   60, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Quant(acum)",   "QUANT",    "@E 999,999.9999999", 14, 7,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Custo acum",    "CUSTACUM", "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Cus.rep.atual", "CUSREP",   "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp",      "ULTCOMP1", "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp-1",    "ULTCOMP2", "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp-2",    "ULTCOMP3", "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Rev.atual",     "REVATU",   "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})

		_aCols = {}
		for _nCompon = 1 to len (_aAux)
			aadd (_aCols, aclone (U_LinVazia (_aHeader)))
			_n = len (_aCols)

			// Monta um codigo 'com pontos' para ajudar a identificar a hereditariedade dos componentes.
			GDFieldPut ("INDICE",   alltrim (_sProduto) + '.' + strzero (_nCompon, 2), _n, _aHeader, _aCols)
			GDFieldPut ("NIVEL",    _aAux [_nCompon, .EstrHistNivel], _n, _aHeader, _aCols)
			GDFieldPut ("TIPO",     _aAux [_nCompon, .EstrHistTipoComp], _n, _aHeader, _aCols)
			GDFieldPut ("COMP",     _aAux [_nCompon, .EstrHistCodComp], _n, _aHeader, _aCols)
			GDFieldPut ("DESCR",    iif (_nCompon == 1, '', space (_aAux [_nCompon, .EstrHistNivel] * 5) + '+---') + _aAux [_nCompon, .EstrHistDescri], _n, _aHeader, _aCols)
			GDFieldPut ("QUANT",    _aAux [_nCompon, .EstrHistQuantAcum], _n, _aHeader, _aCols)
			GDFieldPut ("CUSREP",   _aAux [_nCompon, .EstrHistCustDUnit], _n, _aHeader, _aCols)
			GDFieldPut ("CUSTACUM", _aAux [_nCompon, .EstrHistCustDUnit] * _aAux [_nCompon, .EstrHistQuantAcum], _n, _aHeader, _aCols)
			GDFieldPut ("REVATU",   _aAux [_nCompon, .EstrHistRevAtu], _n, _aHeader, _aCols)

			// Busca ultimas compras do componente.
			_aUltCom = {}
			// O primeiro (pai) nao precisa. Os demais, somente se nao tiverem filhos.
			if _nCompon == 1
				// O 'pai' da estrutura nao tem necessidade de ler ultimas compras.
			elseif _aAux [_nCompon, .EstrHistEhUva]
				// Ateh o momento, nao preciso ler ultimas compras da uva por
				// que nao ha intencao de usar aqui. De qualquer forma, se for
				// para buscar ultima compra, acho melhor calcular preco medio
				// com base na VA_VPRECOS_EFETIVOS_SAFRA.
			elseif _nCompon < len (_aAux) .and. _aAux [_nCompon + 1, .EstrHistNivel] > _aAux [_nCompon, .EstrHistNivel]
				// Estou num componente que tem filhos. Nao preciso ler ultimas compras.
			else
				_oSQL := ClsSQL():New ()
				_oSQL:_sQuery := "SELECT CUSREPUNI"
				_oSQL:_sQuery += " FROM VA_ULTCOMP ('', 'zz', '" + _aAux [_nCompon, .EstrHistCodComp] + "', 3)"
				_oSQL:Log ('[' + procname () + '][' + _aAux [_nCompon, .EstrHistCodComp] + ']')
				_aUltCom := aclone (_oSQL:Qry2Array (.F., .F.))
			endif

			// Acrescenta custo calculado nas ultimas compras do componente.
			// (pode nao haver tantas ultimas compras quanto solicitado).
			GDFieldPut ("ULTCOMP1", iif (len (_aUltCom) >= 1, _aUltCom [1, 1], 0), _n, _aHeader, _aCols)
			GDFieldPut ("ULTCOMP2", iif (len (_aUltCom) >= 2, _aUltCom [2, 1], 0), _n, _aHeader, _aCols)
			GDFieldPut ("ULTCOMP3", iif (len (_aUltCom) >= 3, _aUltCom [3, 1], 0), _n, _aHeader, _aCols)
		next

		u_LogACols (_aHeader, _aCols)

		_aSize := MsAdvSize()
		define MSDialog _oDlgEstr from _aSize [1] + 50, _aSize [1] + 50 to _aSize [6] - 50, _aSize [5] - 50 of oMainWnd pixel title "Estrutura do " + _sProduto

		_oGetDEstr := MsNewGetDados ():New (31, ;                       // Limite superior
									5, ;                             // Limite esquerdo 
									_oDlgEstr:nClientHeight / 2 - 1, ;  // Limite inferior
									_oDlgEstr:nClientWidth / 2 - 10, ;  // Limite direito
									2, ;                             // [ nStyle ]
									"AllwaysTrue ()", ;              // [ uLinhaOk ]
									"AllwaysTrue ()", ;              // [ uTudoOk ]
									NIL, ;                           // [cIniCpos]
									NIL,;                            // [ aAlter ]
									NIL,;                            // [ nFreeze ]
									NIL,;                            // [ nMax ]
									NIL,;                            // [ cFieldOk ]
									NIL,;                            // [ uSuperDel ]
									NIL,;                            // [ uDelOk ]
									_oDlgEstr,;                         // [ oWnd ]
									_aHeader,;                       // [ ParHeader ]
									_aCols)                          // [ aParCols ]

	//	_oGetDEstr:oBrowse:bLDblClick := {|| _DblClick ()}
	//	_oGetDEstr:oBrowse:bRClicked := {|_o, _x, _y| _RClick (_o, _x, _y)}

		// Define botoes para a barra de ferramentas
		_bBotaoOK  = {|| _oDlgEstr:End ()}
		_bBotaoCan = {|| _oDlgEstr:End ()}
		_aBotAdic  = {}
		aadd (_aBotAdic, {"", {|| aHeader := aclone (_oGetDEstr:aHeader), aCols := aclone (_oGetDEstr:aCols), U_aColsXLS ()}, "Exp.planilha"})
		
		// durante testes, rodo via script e nao tenho interface com o usuario.
		if type ("oMainWnd") == "O"
			activate dialog _oDlgEstr on init (EnchoiceBar (_oDlgEstr, _bBotaoOK, _bBotaoCan,, _aBotAdic))
		endif
	endif

/*
	local _nPosEstr := 0
	local _aLinha   := {}
	local _aEstrVis := {}
	local _aCols    := {}
	local _aAux     := {}
	local _nCompon  := 0
	local _oSQL     := NIL
	local _aUltCom  := {}

	// Joga uma ossinho pro usuario roer
	procregua (10)
	incproc ()

	_nPosEstr = ascan (_aEstruts, {|_aVal| _aVal [1] == _sProduto})
	if _nPosEstr == 0
		u_help ("Estrutura nao encontrada!",, .t.)
	else
		// Extrai, da array de estruturas que jah tenho em memoria, a estrutura
		// do item solicitado.
		_aAux = aclone (_aEstruts [_nPosEstr, 2])
		
		_aCols = {}
		aadd (_aCols, { 1, 'Indice',        30, ''})
		aadd (_aCols, { 2, 'Nivel',         25, ''})
		aadd (_aCols, { 3, 'Tipo',          25, ''})
		aadd (_aCols, { 4, 'Componente',    45, ''})
		aadd (_aCols, { 5, 'Descricao',    150, ''})
		aadd (_aCols, { 6, 'Quant(acum)',   50, '@E 999,999.9999999'})
		aadd (_aCols, { 7, 'Custo acum',    50, '@E 999,999.9999'})
		aadd (_aCols, { 8, 'Cus.rep.atual', 50, '@E 999,999.9999'})
		aadd (_aCols, { 9, 'Ult.comp',      50, '@E 999,999.9999'})
		aadd (_aCols, {10, 'Ult.comp-1',    50, '@E 999,999.9999'})
		aadd (_aCols, {11, 'Ult.comp-2',    50, '@E 999,999.9999'})
		aadd (_aCols, {12, 'Rev.atual',     25, ''})
		_aEstrVis = {}
		for _nCompon = 1 to len (_aAux)

			_aLinha = {}

			// Monta um codigo 'com pontos' para ajudar a identificar a hereditariedade dos componentes.
			aadd (_aLinha, alltrim (_sProduto) + '.' + strzero (_nCompon, 2))

			aadd (_aLinha, _aAux [_nCompon, .EstrHistNivel])
			aadd (_aLinha, _aAux [_nCompon, .EstrHistTipoComp])
			aadd (_aLinha, _aAux [_nCompon, .EstrHistCodComp])
			aadd (_aLinha, iif (_nCompon == 1, '', space (_aAux [_nCompon, .EstrHistNivel] * 5) + '+---') + _aAux [_nCompon, .EstrHistDescri])
			aadd (_aLinha, _aAux [_nCompon, .EstrHistQuantAcum])
			aadd (_aLinha, _aAux [_nCompon, .EstrHistCustDUnit])
			aadd (_aLinha, _aAux [_nCompon, .EstrHistCustDUnit] * _aAux [_nCompon, .EstrHistQuantAcum])

			// Busca ultimas compras do componente.
			_aUltCom = {}
			// O primeiro (pai) nao precisa. Os demais, somente se nao tiverem filhos.
			if _nCompon == 1
				// O 'pai' da estrutura nao tem necessidade de ler ultimas compras.
			elseif _nCompon < len (_aAux) .and. _aAux [_nCompon + 1, .EstrHistNivel] > _aAux [_nCompon, .EstrHistNivel]
				// Estou num componente que tem filhos. Nao preciso ler ultimas compras.
			else
				_oSQL := ClsSQL():New ()
				_oSQL:_sQuery := "SELECT CUSREPUNI"
				_oSQL:_sQuery += " FROM VA_ULTCOMP ('', 'zz', '" + _aAux [_nCompon, .EstrHistCodComp] + "', 3)"
				_oSQL:Log ('[' + procname () + '][' + _aAux [_nCompon, .EstrHistCodComp] + ']')
				_aUltCom := aclone (_oSQL:Qry2Array (.F., .F.))
			endif

			// Acrescenta custo calculado nas ultimas compras do componente.
			// (pode nao haver tantas ultimas compras quanto solicitado).
			aadd (_aLinha, iif (len (_aUltCom) >= 1, _aUltCom [1, 1], 0))
			aadd (_aLinha, iif (len (_aUltCom) >= 2, _aUltCom [2, 1], 0))
			aadd (_aLinha, iif (len (_aUltCom) >= 3, _aUltCom [3, 1], 0))

			aadd (_aLinha, _aAux [_nCompon, .EstrHistRevAtu])
//			U_Log2 ('debug', '[' + procname () + ']_aLinha:')
//			U_Log2 ('debug', _aLinha)
			// Prepara array para visualizacao
			aadd (_aEstrVis, _aLinha)

		next
//		U_Log2 ('debug', '[' + procname () + ']_aCols:')
//		U_Log2 ('debug', _aCols)
		U_F3Array (_aEstrVis, 'Estrutura do ' + _sProduto, _aCols, nil, nil, '', '', .t., 'C', 'Erro na leitura da estrutura')
	endif
*/
return


// --------------------------------------------------------------------------
// Acumula custos por niveis - versao 1
static function _AcumNiv (_aEst, _nLinha)
	U_Log2 ('debug', '[' + procname () + ']Recebi chamada para linha ' + cvaltochar (_nLinha))

	if _nLinha >= len (_aEst)
		U_Log2 ('debug', '[' + procname () + ']Retornando por que terminou a array.')
		return _aEst [_nLinha, .EstrHistCustDAcum]
	endif

	do while _nLinha < len (_aEst)
		if _aEst [_nLinha + 1, .EstrHistNivel] > _aEst [_nLinha, .EstrHistNivel]
			_aEst [_nLinha + 1, .EstrHistCustDAcum] = _AcumNiv (@_aEst, _nLinha + 1)
		endif
		_nLinha ++
		U_Log2 ('debug', '[' + procname () + ']Incrementei _nLinha para ' + cvaltochar (_nLinha))
	enddo
return

/*
// --------------------------------------------------------------------------
// Acumula custos por niveis - versao 2
static function _AcumCust (_aEst, _nLinha)
	U_Log2 ('debug', '[' + procname () + ']Recebi chamada para linha ' + cvaltochar (_nLinha))
	if _nLinha >= len (_aEst)
		U_Log2 ('debug', '[' + procname () + ']Retornando por que terminou a array.')
		return
	endif
	do while _nLinha < len (_aEst)
		if _aEst [_nLinha + 1, .EstrHistNivel] > _aEst [_nLinha, .EstrHistNivel]
			_aEst [_nLinha + 1, .EstrHistCustDAcum] = _AcumNiv (@_aEst, _nLinha + 1)

return
*/

// --------------------------------------------------------------------------
// Cria Perguntas no SX1
static function _ValidPerg ()
	local _aRegsPerg := {}
	local _aDefaults := {}

	//                     PERGUNT                           TIPO TAM DEC VALID F3      Opcoes          Help
	aadd (_aRegsPerg, {01, "Produto inicial               ", "C", 15, 0,  "",   "SB1 ", {},             ""})
	aadd (_aRegsPerg, {02, "Produto final                 ", "C", 15, 0,  "",   "SB1 ", {},             ""})
	aadd (_aRegsPerg, {03, "Ignorar uva na estrutura      ", "N",  1, 0,  "",   "    ", {"Sim", "Nao"}, ""})
	aadd (_aRegsPerg, {04, "Tipos compon.ignorar(ex:MP/PS)", "C", 60, 0,  "",   "    ", {},             ""})
	aadd (_aRegsPerg, {05, "Ignorar subniveis dos VD      ", "N",  1, 0,  "",   "    ", {"Sim", "Nao"}, ""})
	U_ValPerg (cPerg, _aRegsPerg, {}, _aDefaults)
return

/*
na consulta da estrutura:
- numeracao com pontos pra identificar os niveis
- mostrar data da ultima atualização do standard e tb ultimas compras (com fornecedor)
- quantidade faltam decimais
- no caso de uvas, diferenciar compra X complemento de safra (por que o volume de mosto já terminou)
*/
