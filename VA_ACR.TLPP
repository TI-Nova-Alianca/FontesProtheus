// Programa:  VA_ACR
// Autor:     Robert Koch
// Data:      30/09/2023
// Descricao: Analise custo reposicao (GLPI 14309)

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Consulta
// #Descricao         #Objetivo listar itens de venda abrindo su custo de reposicao.
// #PalavasChave      #custo_reposicao #custo_standard #estrutura
// #TabelasPrincipais #SB1 #SG1
// #Modulos           #EST

// Historico de alteracoes:
// 13/11/2023 - Robert - Filtrar estruturas pelo campo g1_vacpcus (GLPI 14489)
// 21/11/2023 - Robert - Para a tela inicial, nao acumula mais os subnives por que acabava duplicando
//                     - Criados parametros de filtro por linha comercial
// 22/11/2023 - Robert - Acrescentada coluna com custo medio
// 24/11/2023 - Robert - Ao atualizar o campo B1_CUSTD, nao atualizava o campo B1_DATREF
// 29/11/2023 - Robert - Verifica se falta informar B1_REVATU (GLPI 14559)
//                     - Mostrar B1_CODLIN e B1_UM (1a. e 2a. telas respectivamente) - GLPI 14559
// 03/12/2023 - Robert - Opcao de cuatear pelo medio em vez do standard
//                     - Opcao de selecionar os PAs com base em determinado componente.
// 13/12/2203 - Robert - Opcao de exportar todas as estruturas numa unica planilha.
//

#include "protheus.ch"

#XTranslate .EstrHistNivel        => 1
#XTranslate .EstrHistTipoComp     => 2
#XTranslate .EstrHistCodComp      => 3
#XTranslate .EstrHistDescri       => 4
#XTranslate .EstrHistQuantAcum    => 5
#XTranslate .EstrHistRevAtu       => 6
#XTranslate .EstrHistCustoUnit    => 7
#XTranslate .EstrHistCustoAcum    => 8
#XTranslate .EstrHistEhUva        => 9
#XTranslate .EstrHistMaiorNivelVD => 10
#XTranslate .EstrHistDtCustD      => 11
#XTranslate .EstrHistSomaNoCusto  => 12
#XTranslate .EstrHistUnidMedida   => 13
#XTranslate .EstrHistQtColunas    => 13

// --------------------------------------------------------------------------
user function VA_ACR (_lAutomat)
	Local cCadastro := "Analise custo reposicao"
	Local aSays     := {}
	Local aButtons  := {}
	Local nOpca     := 0
	Local lPerg     := .F.
	private cPerg   := 'VA_ACR'
	private _lAuto  := iif (_lAutomat == NIL, .F., _lAutomat)

	_validperg ()
	pergunte (cPerg, .f.)
	if _lAuto
		if _TudoOK ()
			Processa( { |lEnd| _Gera () } )
		endif
	else
		AADD(aSays,cCadastro)
		AADD(aSays,"")
		AADD(aSays,"")
		AADD(aButtons, { 5, .T.,{|| lPerg := Pergunte(cPerg,.T. ) } } )
		AADD(aButtons, { 1, .T.,{|| nOpca := If(( lPerg .Or. Pergunte(cPerg,.T.)) .And. _TudoOk() , 1, 2 ), If( nOpca == 1, FechaBatch(), Nil ) }})
//		AADD(aButtons, { 15,.T.,{|| U_VA_SZNC ('EVENTO', 'CT2001')}})
		AADD(aButtons, { 2, .T.,{|| (nOpca := 2, FechaBatch()) }} )
		do while .T.
			FormBatch( cCadastro, aSays, aButtons)
	//		U_Log2 ('debug', '[' + procname () + ']nOpca=' + cvaltochar (nOpca))
			if nOpca == 1
				Processa( { |lEnd| _Gera () } )
			else
				exit
			Endif
		enddo
	endif
return


// --------------------------------------------------------------------------
// 'Tudo OK' do FormBatch.
Static Function _TudoOk ()
	local _lRet := .T.
return _lRet


// --------------------------------------------------------------------------
static function _Gera ()
	local _oSQL       := NIL
	local _sAliasQ    := ''
	local _nRecCount  := 0
	local _aHeader    := {}
	local _aCols      := {}
	local _n          := 1
	local _aEstrHist  := {}
	local _nCustoME   := 0
	local _nCustoVD   := 0
	local _nCustoMO   := 0
	local _nCustoBN   := 0
	local _nCustoPS   := 0
	local _nCustoOUT  := 0
	local _nCustoTOT  := 0
	local _oVerif     := NIL
	local _nColProd   := 0
	local _lTemAviso  := .F.
	private _aEstruts := {}  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oDlg1    := NIL  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oGetD1   := NIL  // Deixar private para ser vista pelas funcoes auxiliares.

	U_LogSX1 (cPerg)

	// Cria lista de produtos que deveriam ter o campo B1_REVATU informado
	_oVerif := ClsVerif():New (1)
	_oVerif:Executa ()
//	U_Log2 ('debug', '[' + procname () + ']Resultado da verificacao:')
//	U_Log2 ('debug', _oVerif:Result)
	if len (_oVerif:Result) >= 1
		_nColProd = ascan (_oVerif:Result [1], 'PRODUTO')
		if _nColProd == 0
			u_help ("Coluna indicando o codigo do produto nao localizada na verificaco 1. Nao vai ser possivel validar produtos sem revisao padrao no cadastro.",, .t.)
		endif
	endif

	// Cria aHeader para a tela inicial.
	_aHeader = {}
	//              Titulo                  Campo         Masc               Tam Dec Valid Usado Tipo F3     Context CBox Relacao Alteravel
	aadd (_aHeader, {"Produto",             "PRODUTO",    "",                15, 0,  "",   "",   "C", "SB1", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Descricao",           "DESCRICAO",  "",                60, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Un.med",              "UN_MED",     "",                 2, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Linha coml.",         "LINCOM",     "",                25, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Litragem",            "LITRAGEM",   "@E 999.9",         5, 1,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Cus.medio",           "CUSMEDUNIT", "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Cus.rep.atu.",        "CUSTD",      "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Cus.calculado",       "CUSTACUM",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo ME",            "CUSTOME",    "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.ME %",           "PPARTME",    "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo VD",            "CUSTOVD",    "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.VD %",           "PPARTVD",    "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo MO",            "CUSTOMO",    "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.MO %",           "PPARTMO",    "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo BN",            "CUSTOBN",    "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.BN %",           "PPARTBN",    "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo PS",            "CUSTOPS",    "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.PS %",           "PPARTPS",    "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo Outros",        "CUSTOOUT",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.Out %",          "PPARTOUT",   "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Rev.estrut",          "REVATU",     "",                 3, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Avisos",              "AVISOS",     "",               250, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})

	// Busca produtos cuja estrutura vai ser analisada.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " WITH PRODUTOS AS"
	_oSQL:_sQuery += " ("
	_oSQL:_sQuery +=    " SELECT B1_COD, B1_DESC, B1_REVATU, B1_CUSTD, B1_UM, B1_CODLIN, ZX5_39.ZX5_39DESC, B1_LITROS"
	_oSQL:_sQuery +=      " FROM " + RetSQLName ("SB1") + " SB1"
	_oSQL:_sQuery +=         " LEFT JOIN " + RetSQLName ("ZX5") + " ZX5_39"
	_oSQL:_sQuery +=              " ON (ZX5_39.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=             " AND ZX5_39.ZX5_FILIAL  = '" + xfilial ("SB1") + "'"
	_oSQL:_sQuery +=             " AND ZX5_39.ZX5_TABELA  = '39'"
	_oSQL:_sQuery +=             " AND ZX5_39.ZX5_39COD   = SB1.B1_CODLIN)
	_oSQL:_sQuery +=     " WHERE SB1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=       " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
	if ! empty (mv_par09)
		// Quero somente os produtos que utilizam este componente
		_oSQL:_sQuery += " AND SB1.B1_COD IN (" + _QuemUsa2 (mv_par09) + ")"
	else
		_oSQL:_sQuery += " AND SB1.B1_COD     BETWEEN '" + mv_par01 + "' AND '" + mv_par02 + "'"
		_oSQL:_sQuery += " AND SB1.B1_CODLIN  BETWEEN '" + mv_par05 + "' AND '" + mv_par06 + "'"
		_oSQL:_sQuery += " AND SB1.B1_TIPO    IN " + FormatIn (alltrim (mv_par03), '/')
		if mv_par07 == 1
			_oSQL:_sQuery +=   " AND SB1.B1_MRP     = 'S'"
		endif
	endif
	_oSQL:_sQuery +=       " AND SB1.B1_MSBLQL != '1'"
	_oSQL:_sQuery += " )"
	_oSQL:_sQuery += " , ULTIMOS_SB9 AS"
	_oSQL:_sQuery += " ("
	_oSQL:_sQuery +=    " SELECT B9_COD, MAX (B9_DATA) B9_DATA"
	_oSQL:_sQuery +=      " FROM " + RetSQLName ("SB9") + " ULT"
	_oSQL:_sQuery +=     " WHERE ULT.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=       " AND ULT.B9_FILIAL  = '01'"  // Atualmente focamos na matriz por que eh onde temos o envase.
	_oSQL:_sQuery +=       " AND ULT.B9_QINI    > 0"
	_oSQL:_sQuery +=       " AND ULT.B9_VINI1   > 0"
	_oSQL:_sQuery +=       " AND EXISTS (SELECT *"
	_oSQL:_sQuery +=                     " FROM PRODUTOS"
	_oSQL:_sQuery +=                    " WHERE B1_COD = ULT.B9_COD"
	_oSQL:_sQuery +=                   ")"
	_oSQL:_sQuery +=     " GROUP BY ULT.B9_COD"
	_oSQL:_sQuery += " )"
	_oSQL:_sQuery += " SELECT PRODUTOS.*"
	_oSQL:_sQuery +=      " , ISNULL ((SELECT SUM (B9_VINI1) / SUM (B9_QINI)"
	_oSQL:_sQuery +=      " FROM " + RetSQLName ("SB9") + " SB9"
	_oSQL:_sQuery +=     " WHERE SB9.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=       " AND SB9.B9_FILIAL  = '01'"  // Atualmente focamos na matriz por que eh onde temos o envase.
	_oSQL:_sQuery +=       " AND SB9.B9_COD     = PRODUTOS.B1_COD"
	_oSQL:_sQuery +=       " AND SB9.B9_QINI    > 0"
	_oSQL:_sQuery +=       " AND SB9.B9_VINI1   > 0"
	_oSQL:_sQuery +=       " AND SB9.B9_DATA    = ULTIMOS_SB9.B9_DATA"
	_oSQL:_sQuery +=      "), 0) AS CUSMED"
	_oSQL:_sQuery +=  " FROM PRODUTOS, ULTIMOS_SB9"
	_oSQL:_sQuery += " WHERE B9_COD = B1_COD"
	_oSQL:_sQuery += " ORDER BY B1_COD"
	_oSQL:Log ('[' + procname () + ']')
	_sAliasQ = _oSQL:Qry2Trb (.f.)
	count to _nRecCount
	procregua (_nRecCount)
	(_sAliasQ) -> (dbgotop ())
	do while ! (_sAliasQ) -> (eof ())
		incproc ('Lendo estrutura do ' + (_sAliasQ) -> b1_cod)

		_nCustoTot = 0
		_nCustoME  = 0
		_nCustoVD  = 0
		_nCustoMO  = 0
		_nCustoBN  = 0
		_nCustoPS  = 0
		_nCustoOUT = 0

		_LeDados ((_sAliasQ) -> b1_cod, (_sAliasQ) -> b1_revatu, @_aEstrHist, @_nCustoME, @_nCustoVD, @_nCustoMO, @_nCustoBN, @_nCustoPS, @_nCustoOUT)

		if len (_aEstrHist) == 0
			U_Log2 ('aviso', '[' + procname () + ']Item sem estrutura: ' + (_sAliasQ) -> b1_cod)
		else

			// Passa para _aCols os dados da array lida
			aadd (_aCols, aclone (U_LinVazia (_aHeader)))
			_n = len (_aCols)
			_nCustoTot = _nCustoME +  _nCustoVD + _nCustoMO + _nCustoBN + _nCustoPS + _nCustoOUT
			GDFieldPut ("PRODUTO",    (_sAliasQ) -> b1_cod,            _n, _aHeader, _aCols)
			GDFieldPut ("DESCRICAO",  alltrim ((_sAliasQ) -> b1_desc), _n, _aHeader, _aCols)
			GDFieldPut ("LINCOM",     alltrim ((_sAliasQ) -> b1_codlin) + '-' + (_sAliasQ) -> zx5_39desc, _n, _aHeader, _aCols)
			GDFieldPut ("LITRAGEM",   (_sAliasQ) -> b1_litros,         _n, _aHeader, _aCols)
			GDFieldPut ("REVATU",     (_sAliasQ) -> b1_revatu,         _n, _aHeader, _aCols)
			GDFieldPut ("UN_MED",     (_sAliasQ) -> b1_um,             _n, _aHeader, _aCols)
			GDFieldPut ("CUSTD",      (_sAliasQ) -> b1_custd,          _n, _aHeader, _aCols)
			GDFieldPut ("CUSMEDUNIT", (_sAliasQ) -> CusMed,            _n, _aHeader, _aCols)
			GDFieldPut ("CUSTACUM",   _nCustoTot,                      _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOME",    _nCustoME,                       _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOVD",    _nCustoVD,                       _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOMO",    _nCustoMO,                       _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOBN",    _nCustoBN,                       _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOPS",    _nCustoPS,                       _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOOUT" ,  _nCustoOUT,                      _n, _aHeader, _aCols)
			GDFieldPut ("PPARTME",    _nCustoME*100/_nCustoTot,        _n, _aHeader, _aCols)
			GDFieldPut ("PPARTVD",    _nCustoVD*100/_nCustoTot,        _n, _aHeader, _aCols)
			GDFieldPut ("PPARTMO",    _nCustoMO*100/_nCustoTot,        _n, _aHeader, _aCols)
			GDFieldPut ("PPARTBN",    _nCustoBN*100/_nCustoTot,        _n, _aHeader, _aCols)
			GDFieldPut ("PPARTPS",    _nCustoPS*100/_nCustoTot,        _n, _aHeader, _aCols)
			GDFieldPut ("PPARTOUT",   _nCustoOut*100/_nCustoTot,       _n, _aHeader, _aCols)

			if _nColProd > 0 .and. ascan (_oVerif:Result, {|_aVal| _aVal [_nColProd] == (_sAliasQ) -> b1_cod}) > 0
				GDFieldPut ("AVISOS", "Falta revisao padrao no campo B1_REVATU. (Verif.Alianca numero 1)", _n, _aHeader, _aCols)
				_lTemAviso = .t.
			endif

			// Guardo a estrutura pronta numa array geral, pois imagino que o
			// usuario vai consultar mais de uma vez e, jah que gastei tempo
			// na leitura inicial, por que nao aproveitar?
			aadd (_aEstruts, {_aCols [_n, 1], aclone (_aEstrHist)})

		endif

		(_sAliasQ) -> (dbskip ())
	enddo
	(_sAliasQ) -> (dbclosearea ())
	dbselectarea ("SB1")

	if len (_aCols) == 0
		u_help ("Nenhum item selecionado para analise.",, .t.)
	else

	//	// Abre em planilha para ajudar durante desenvolvimento do programa
	//	if _lAuto
	//		U_acolsXLS (_aCols, .t., _aHeader)
	//	endif
	
		// durante testes, rodo via script e nao tenho interface com o usuario.
		if type ("oMainWnd") != "O"
		//	_SimEstru (mv_par01, .f.)
			_SimEstru ('', .t.)
		endif

		if _lTemAviso
			u_help ("ATENCAO: Verifique a coluna de avisos, pois encontrei alguma inconsistencia nos dados.",, .t.)
		endif

		_aSize := MsAdvSize()
		define MSDialog _oDlg1 from _aSize [1], _aSize [1] to _aSize [6], _aSize [5] of oMainWnd pixel title "Analise custo " + iif (mv_par08 == 1, "reposicao", iif (mv_par08 == 2, "medio", ""))

		_oGetD1 := MsNewGetDados ():New (31, ;                       // Limite superior
									5, ;                             // Limite esquerdo 
									_oDlg1:nClientHeight / 2 - 20, ;  // Limite inferior
									_oDlg1:nClientWidth / 2 - 10, ;  // Limite direito
									2, ;                             // [ nStyle ]
									"AllwaysTrue ()", ;              // [ uLinhaOk ]
									"AllwaysTrue ()", ;              // [ uTudoOk ]
									NIL, ;                           // [cIniCpos]
									NIL,;                            // [ aAlter ]
									NIL,;                            // [ nFreeze ]
									NIL,;                            // [ nMax ]
									NIL,;                            // [ cFieldOk ]
									NIL,;                            // [ uSuperDel ]
									NIL,;                            // [ uDelOk ]
									_oDlg1,;                         // [ oWnd ]
									_aHeader,;                       // [ ParHeader ]
									_aCols)                          // [ aParCols ]

		_oGetD1:oBrowse:bLDblClick := {|| allwaystrue ()}
		_oGetD1:oBrowse:bRClicked := {|_o, _x, _y| _RClick1 (_o, _x, _y)}

		// Define botoes para a barra de ferramentas
		_bBotaoOK  = {|| _oDlg1:End ()}
		_bBotaoCan = {|| _oDlg1:End ()}
		_aBotAdic  = {}

		aadd (_aBotAdic, {"", {|| aHeader := aclone (_oGetD1:aHeader), aCols := aclone (_oGetD1:aCols), U_aColsXLS ()}, "Exp.planilha"})
		aadd (_aBotAdic, {"", {|| processa ({||_SimEstru ('', .t.)})}, "Exportar todas as estruturas"})
		
		// durante testes, rodo via script e nao tenho interface com o usuario.
		if type ("oMainWnd") == "O"
			activate dialog _oDlg1 on init (EnchoiceBar (_oDlg1, _bBotaoOK, _bBotaoCan,, _aBotAdic))
		endif
	endif
return


// --------------------------------------------------------------------------
// Leitura e preparacao de dados para a tela principal.
static function _LeDados (_sProduto, _sRevisao, _aEstrHist, _nCustoME, _nCustoVD, _nCustoMO, _nCustoBN, _nCustoPS, _nCustoOUT)
	local _sFiltComp  := ''
	local _aEstrAux   := {}
	local _nComp      := 0
	local _nFilho     := 0
	local _aRetCusMed := {}

	// Monta expressao para filtrar componentes
	_sFiltComp = ".T."
	_sFiltComp += ".and.sg1->g1_vacpcus='S'"

	sb1 -> (dbsetorder (1))

	_aEstrAux = U_ML_Comp2 (_sProduto, 1, _sFiltComp, dDataBase, .f., .f., .f., .f., .f., '', .f., .t., .t., .f., _sRevisao)

	// Nao preciso de todas as colunas da array gerada pela funcao de
	// leitura de estrutura, entao vou substituir por coisas que preciso.
	for _nComp = 1 to len (_aEstrAux)
		if ! sb1 -> (dbseek (xfilial ("SB1") + _aEstrAux [_nComp, 2], .F.))
			u_help ("Nao localizado cadastro do item '" + _aEstrAux [_nComp, 2] + "'",, .t.)
			_lContinua = .F.
		else
			_aEstrAux [_nComp, 5]  = sb1 -> b1_tipo
			_aEstrAux [_nComp, 6]  = sb1 -> b1_desc
			if mv_par08 == 1
				_aEstrAux [_nComp, 8]  = sb1 -> b1_custd
				_aEstrAux [_nComp, 10] = sb1 -> b1_datref
			elseif mv_par08 == 2
				_aRetCusMed = _RetCusMed (sb1 -> b1_cod)
			//	U_Log2 ('debug', '[' + procname () + ']retorno de _retcusmed:')
			//	U_Log2 ('debug', _aRetCusMed)
				_aEstrAux [_nComp, 8]  = _aRetCusMed [1]
				_aEstrAux [_nComp, 10] = _aRetCusMed [2]
			endif
			_aEstrAux [_nComp, 9]  = (sb1 -> b1_grupo == '0400')
			_aEstrAux [_nComp, 11] = sb1 -> b1_um
		endif
	next

	// Prepara uma 'estrutura para historico' filtrando itens que nao interessam,
	// acrescentando acumulados, etc.
	_aEstrHist = {}
	_nComp = 1
	do while _nComp <= len (_aEstrAux)
		aadd (_aEstrHist, array (.EstrHistQtColunas))
		_aEstrHist [len (_aEstrHist), .EstrHistNivel]        = _aEstrAux [_nComp, 1]
		_aEstrHist [len (_aEstrHist), .EstrHistCodComp]      = _aEstrAux [_nComp, 2]
		_aEstrHist [len (_aEstrHist), .EstrHistQuantAcum]    = _aEstrAux [_nComp, 4]
		_aEstrHist [len (_aEstrHist), .EstrHistUnidMedida]   = _aEstrAux [_nComp, 11]
		_aEstrHist [len (_aEstrHist), .EstrHistRevAtu]       = _aEstrAux [_nComp, 12]
		_aEstrHist [len (_aEstrHist), .EstrHistTipoComp]     = _aEstrAux [_nComp, 5]
		_aEstrHist [len (_aEstrHist), .EstrHistCustoUnit]    = _aEstrAux [_nComp, 8]
		_aEstrHist [len (_aEstrHist), .EstrHistDtCustD]      = _aEstrAux [_nComp, 10]
		_aEstrHist [len (_aEstrHist), .EstrHistDescri]       = alltrim (_aEstrAux [_nComp, 6])
		_aEstrHist [len (_aEstrHist), .EstrHistEhUva]        = _aEstrAux [_nComp, 9]
		_aEstrHist [len (_aEstrHist), .EstrHistMaiorNivelVD] = .F.  // Vai ser revisado mais adante
		_aEstrHist [len (_aEstrHist), .EstrHistSomaNoCusto]  = 'S'  // Ateh segunda ordem, todos os componentes devem ser considerados.
		_nComp ++
	enddo

	// Identifica os VDs que tem o maior nivel, para que no grid principal,
	// na coluna 'custo VD', seja somado somente o seu custo e nao dos
	// filhos, pois eh comum termos itens VD dentro de outros VD. Nesses
	// casos, eu estaria somando mais que uma vez.
	// Sim, sim, eu sei... o certo mesmo seria um 'custo em partes' aqui!
	_nComp = 2  // Posso estar analisando um VD como 'pai'
	do while _nComp <= len (_aEstrHist)
		if _aEstrHist [_nComp, .EstrHistTipoComp] == 'VD'
			_aEstrHist [_nComp, .EstrHistMaiorNivelVD] = .T.
			_nFilho = _nComp
			do while _nFilho < len (_aEstrHist) .and. _aEstrHist [_nFilho+1, .EstrHistNivel] > _aEstrHist [_nComp, .EstrHistNivel]
				_aEstrHist [_nFilho+1, .EstrHistMaiorNivelVD] = .F.

				// Usuario pode optar por considerar o VD como se fosse um item comprado.
				// Isso por que ainda temos dificuldade em abrir o custo dos itens tipo VD.
				if mv_par04 == 2
					_aEstrHist [_nFilho+1, .EstrHistSomaNoCusto] = 'N'
				endif

				_nFilho ++
			enddo
			_nComp = _nFilho
		endif
		_nComp ++
	enddo

	// Acumula o custo de reposicao dos niveis 'pais' somando o custo de seus filhos.
	_AtuCust (@_aEstrHist, 1)
//	U_Log2 ('debug', '[' + procname () + ']Custos acumulados:')
//	U_Log2 ('debug', _aEstrHist)

	// Abre os custos do item atual conforme os tipos de seus componentes.
	for _nComp = 2 to len (_aEstrHist)  // Como o primeiro item eh o proprio pai, nao quero somar seu custo.
		
		// Quero apenas os filhos diretos do produto final.
		if _aEstrHist [_nComp, 1] == 1
			do case
			case _aEstrHist [_nComp, .EstrHistTipoComp] == 'ME'
				_nCustoME += _aEstrHist [_nComp, .EstrHistCustoAcum]
			case _aEstrHist [_nComp, .EstrHistTipoComp] == 'VD'
				if _aEstrHist [_nComp, .EstrHistMaiorNivelVD]  // Somente o maior nivel
					_nCustoVD += _aEstrHist [_nComp, .EstrHistCustoAcum]
				endif
			case _aEstrHist [_nComp, .EstrHistTipoComp] == 'MO'
				_nCustoMO += _aEstrHist [_nComp, .EstrHistCustoAcum]
			case _aEstrHist [_nComp, .EstrHistTipoComp] == 'BN'
				_nCustoBN += _aEstrHist [_nComp, .EstrHistCustoAcum]
			case _aEstrHist [_nComp, .EstrHistTipoComp] == 'PS'
				_nCustoPS += _aEstrHist [_nComp, .EstrHistCustoAcum]
			otherwise
				_nCustoOUT += _aEstrHist [_nComp, .EstrHistCustoAcum]
			endcase
		endif
	next
return


// --------------------------------------------------------------------------
// Acumula custos por niveis - versao 3 afff
static function _AtuCust (_aEst, _nLinha, _nInteracao)
	local _nCusFilhos := 0
	local _nLinAux    := 0
	local _lTemSubNiv := .F.
	local _lSomouSub  := .F.
	_nInteracao := iif (_nInteracao == NIL, 1, _nInteracao+1)
	_sPrefLog := 'int' + strzero (_nInteracao, 2)

	// Se tem filhos, preciso atualizar antes o custo dos filhos
	_nLinAux = _nLinha + 1
	_nCusFilhos = 0
	do while _nLinAux <= len (_aEst) .and. _aEst [_nLinAux, .EstrHistNivel] > _aEst [_nLinha, .EstrHistNivel]
		_lTemSubNiv = .T.
		
		// Processar somente os filhos, e nao os netos.
		if _aEst [_nLinAux, .EstrHistNivel] == _aEst [_nLinha, .EstrHistNivel] + 1
			_AtuCust (@_aEst, _nLinAux, _nInteracao)
			
			// Agora que tenho o custo deste filho atualizado, posso soma-lo ao custo do nivel atual.
			if _aEst [_nLinAux, .EstrHistSomaNoCusto] == 'S'
				_nCusFilhos += _aEst [_nLinAux, .EstrHistCustoAcum]
				_lSomouSub = .T.
			else
	//			U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, .EstrHistNivel] * 2) + 'o filho ' + alltrim (_aEst [_nLinAux, .EstrHistCodComp]) + ' nao deve ser somado ao custo.')
			endif
	//		U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, .EstrHistNivel] * 2) + 'Acumulei para o ' + alltrim (_aEst [_nLinha, .EstrHistCodComp]) + ' o custo de ' + cvaltochar (_aEst [_nLinAux, .EstrHistCustoAcum])+ ' do filho ' + alltrim (_aEst [_nLinAux, .EstrHistCodComp]) + '. _nCusFilhos = ' + cvaltochar (_nCusFilhos))
		else
	//		U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, .EstrHistNivel] * 2) + 'Nao eh filho direto.')
		endif
		_nLinAux ++
	enddo
	
	// Se nao tem filhos, fica com seu propro custo.
	if _lSomouSub // _lTemSubNiv
		_aEst [_nLinha, .EstrHistCustoAcum] = _nCusFilhos
	//	U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinha, .EstrHistNivel] * 2) + 'Gravado ' + cvaltochar (_aEst [_nLinha, .EstrHistCustoAcum]) + ' na linha ' + cvaltochar (_nLinha) + ' (cod. ' + _aEst [_nLinha, .EstrHistCodComp] + ')')
	else
		_aEst [_nLinha, .EstrHistCustoAcum] = _aEst [_nLinha, .EstrHistQuantAcum] * _aEst [_nLinha, .EstrHistCustoUnit]
	endif
return


// --------------------------------------------------------------------------
// Retorna lista de produtos que usam o componente.
static function _QuemUsa (_sCompon as character, _aLista as array)
	local _aAreaAnt := U_ML_SRArea ()
//	U_Log2 ('debug', '[' + procname () + ']Verificando componente ' + _sCompon)
	sb1 -> (dbsetorder (1))
	sg1 -> (dbsetorder (2))  // G1_FILIAL, G1_COMP, G1_COD, R_E_C_N_O_, D_E_L_E_T_
	sg1 -> (dbseek (xfilial ("SG1") + _sCompon, .T.))
	do while ! sg1 -> (eof ()) .and. sg1 -> g1_filial == xfilial ("SG1") .and. sg1 -> g1_comp == _sCompon
//		U_Log2 ('debug', '[' + procname () + ']loop 1 com g1_cod = ' + sg1 -> g1_cod)
		if sg1 -> g1_ini <= dDataBase .and. sg1 -> g1_fim >= dDataBase .and. sg1 -> g1_fantasm != '1'
//			U_Log2 ('debug', '[' + procname () + ']loop 2 com g1_cod = ' + sg1 -> g1_cod)
			if sb1 -> (dbseek (xfilial ("SB1") + sg1 -> g1_cod, .f.))
//				U_Log2 ('debug', '[' + procname () + ']loop 3 com g1_cod = ' + sg1 -> g1_cod)
				if sg1 -> g1_revini <= sb1 -> b1_revatu .and. sg1 -> g1_revfim >= sb1 -> b1_revatu
//					U_Log2 ('debug', '[' + procname () + ']loop 4 com g1_cod = ' + sg1 -> g1_cod)
					_nTamAnt = len (_aLista)
					_QuemUsa (sg1 -> g1_cod, @_aLista)
					if len (_aLista) == _nTamAnt  // Nao achou mais nada
						aadd (_aLista, sg1 -> g1_cod)
					endif
				endif
			endif
		endif
		sg1 -> (dbskip ())
	enddo
	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Retorna lista de produtos que usam o componente em formato string.
static function _QuemUsa2 (_sCompon as character)
	local _sRet := ''
	local _nIdxQuemUsa := 0
	local _aQuemUsa := {}

	_QuemUsa (_sCompon, @_aQuemUsa)

	for _nIdxQuemUsa = 1 to len (_aQuemUsa)
		if ! alltrim (_aQuemUsa [_nIdxQuemUsa]) $ _sRet
			_sRet += "'" + alltrim (_aQuemUsa [_nIdxQuemUsa]) + "',"
		endif
	next

	// Remove a provavel virgula do final
	if right (_sRet, 1) == ','
		_sRet = left (_sRet, len (_sRet) - 1)
	endif
return _sRet


// --------------------------------------------------------------------------
// Retorna o custo medio do produto. Montei uma funcao separada para clareza
// nos programas e, tambem, pretendo usar uma variavel static para guardar os
// custos, pois eh muito provavel que varias estruturas usem os mesmos itens.
// Assim, evito releituras desnecessarias.
static function _RetCusMed (_sProduto as character)
	local _aRet       := {}
	local _oSQL       := NIL
	local _aRetQry    := {}
	local _nIdxCusMed := 0
	static _aCusMed   := {}

	_nIdxCusMed = ascan (_aCusMed, {|_aVal| _aVal [1] == _sProduto})
	if _nIdxCusMed == 0
		_oSQL := ClsSQL ():New ()
		_oSQL:_sQuery := "SELECT ISNULL ((SELECT SUM (B9_VINI1) / SUM (B9_QINI) ), 0) AS CUSMED"
		_oSQL:_sQuery +=      ", MAX (B9_DATA)"
		_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB9") + " SB9"
		_oSQL:_sQuery += " WHERE SB9.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=   " AND SB9.B9_FILIAL  = '01'"  // Atualmente focamos na matriz por que eh onde temos o envase.
		_oSQL:_sQuery +=   " AND SB9.B9_COD     = '" + _sProduto + "'"
		_oSQL:_sQuery +=   " AND SB9.B9_QINI    > 0"
		_oSQL:_sQuery +=   " AND SB9.B9_VINI1   > 0"
		_oSQL:_sQuery +=   " AND SB9.B9_DATA    = (SELECT MAX (B9_DATA)"
		_oSQL:_sQuery +=                           " FROM " + RetSQLName ("SB9") + " ULT"
		_oSQL:_sQuery +=                          " WHERE ULT.D_E_L_E_T_ = ''"
		_oSQL:_sQuery +=                            " AND ULT.B9_FILIAL  = '01'"  // Atualmente focamos na matriz por que eh onde temos o envase.
		_oSQL:_sQuery +=                            " AND ULT.B9_QINI    > 0"
		_oSQL:_sQuery +=                            " AND ULT.B9_VINI1   > 0"
		_oSQL:_sQuery +=                            " AND ULT.B9_COD     = '" + _sProduto + "'"
		_oSQL:_sQuery +=                         ")"
	//	_oSQL:Log ('[' + procname () + ']')
		_aRetQry = aclone (_oSQL:Qry2Array (.f., .f.))
		aadd (_aCusMed, {_sProduto, _aRetQry [1, 1], stod (_aRetQry [1, 2])})
		_nIdxCusMed = len (_aCusMed)
	endif
	_aRet = {_aCusMed [_nIdxCusMed, 2], _aCusMed [_nIdxCusMed, 3]}
return _aRet


// --------------------------------------------------------------------------
// Funcao executada pelo clique do botao direito do mouse (no browse 1)
static function _RClick1 (_o, _x, _y) //, _sMomento)
	local _oMenu1   := NIL
	Local _oMenuIt1 := {}
	local _sProduto := ''
 
	MENU _oMenu1 POPUP
		_sProduto = GDFieldGet ("PRODUTO", _oGetD1:nAt, .f., _oGetD1:aHeader, _oGetD1:aCols)
	//	U_Log2 ('debug', '[' + procname () + ']_sProduto = ' + _sProduto)
		aAdd (_oMenuIt1, MenuAddItem ("Simulacoes estrutura"          ,,, .T.,,,, _oMenu1, {|| processa ({||_SimEstru (_sProduto, .f.)}) },,,,,{|| .T.}))
	ENDMENU
	_oMenu1:Activate (_x + 15, _y + 205)
return


// --------------------------------------------------------------------------
// Altera custo de reposicao do componente, no cadastro.
static function _AltCustD (_nLinha, _aHeader, _aCols)
	local _sProduto  := ''
	local _sDescr    := ''
	local _nNovoCust := 0
	local _aAreaAnt  := U_ML_SRArea ()
	static _sMasc    := X3Picture ("B1_CUSTD")

	if mv_par08 != 1
		u_help ("Opcao disponivel somente quando o custo em analise for o custo de reposicao (Standard).",, .t.)
	else
		_sProduto = GDFieldGet ("COMP",  _nLinha, .F., _aHeader, _aCols)
		_sDescr   = GDFieldGet ("DESCR", _nLinha, .F., _aHeader, _aCols)
	//	U_Log2 ('debug', '[' + procname () + ']_sProduto = ' + _sProduto)
		_nNovoCust = GDFieldGet ("CUSUNIT", _nLinha, .F., _aHeader, _aCols)
	//	U_Log2 ('debug', '[' + procname () + ']_nNovoCust = ' + cvaltochar (_nNovoCust))
		do while .T.
			_nNovoCust = u_Get ('Informe novo custo de reposicao para o item ' + alltrim (_sProduto) + ' ' + _sDescr, 'N', 12, _sMasc, '', _nNovoCust, .F., '.t.')
			if _nNovoCust == NIL
				u_help ("Alteracao de cadastro cancelada.",, .T.)
				exit
			endif
			if _nNovoCust < 0
				u_help ("Custo de reposicao nao pode ser negativo.",, .t.)
			else
				sb1 -> (dbsetorder (1))
				if ! sb1 -> (dbseek (xfilial ("SB1") + _sProduto, .F.))
					u_help ("Produto nao localizado no cadastro!",, .t.)
				else
					if sb1 -> b1_custd != _nNovoCust
						// Cria variaveis para uso na gravacao do evento de alteracao
						regtomemory ("SB1", .F., .F.)
						m->b1_custd = _nNovoCust
						m->b1_datref = date ()

						// Grava evento de alteracao
						_oEvento := ClsEvent():new ()
						_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), funname () + ' Alter.manual custo repos.', .F.)
						reclock ("SB1", .f.)
						sb1 -> b1_custd = m->b1_custd
						sb1 -> B1_datref = m->b1_datref
						msunlock ()
						GDFieldPut ("CUSUNIT", _nNovoCust, _nLinha, _aHeader, _aCols)

						// Atualiza browse na tela
						_oGetDEstr:oBrowse:Refresh()
						_oGetDEstr:Show ()
				//		U_Log2 ('debug', '[' + procname () + ']_aCols depois de alterar o CUSUNIT')
				//		U_Log2 ('debug', _aCols)

						// Avisa o sistema Mercanet de que houve alteracao no cadastro deste item.
						U_AtuMerc ("SB1", sb1 -> (recno ()))

					endif
				endif

				// Vou recalcular o custo de toda a estrutura.
				// Se ficar lento, avaliarei posteriormente a ideia de racalcular apenas o 'trecho que interessa'
				_RecCust (_aHeader, _aCols)
				exit
			endif
		enddo
		U_ML_SRArea (_aAreaAnt)
	endif
return


// --------------------------------------------------------------------------
// Visualiza estrutura que foi considerada para o produto selecionado.
static function _SimEstru (_sProduto as character, _lExpTodas as logical)
	local _nPosIni     := 0
	local _nPosFim     := 0
	local _nPosEstr    := 0
	local _nCompon     := 0
	local _oSQL        := NIL
	local _aHeader     := {}
	local _aCols       := {}
	local _n           := 1
	local _bBotaoOK    := {}
	local _bBotaoCan   := {}
	local _aBotAdic    := {}
	local _lContinua   := .T.
	local _aTodasEst   := {}
	local _aAux        := {}
	local _aAux2       := {}
	local _nCol        := 0
	private _oDlgEstr  := NIL  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oGetDEstr := NIL  // Deixar private para ser vista pelas funcoes auxiliares.

	// Joga uma ossinho pro usuario roer
	procregua (len (_aEstruts))

	if _lContinua
		if _lExpTodas  // Preciso exportar todas as estruturas
			_nPosIni = 1
			_nPosFim = len (_aEstruts)
		else
			_nPosIni = ascan (_aEstruts, {|_aVal| _aVal [1] == _sProduto})
			_nPosFim = _nPosIni
			if _nPosIni == 0
				u_help ("Estrutura nao encontrada!",, .t.)
				_lContinua = .F.
			endif
		endif
	endif

	if _lContinua
		//              Titulo             Campo         Masc                 Tam Dec Valid Usado Tipo F3  Context CBox Relacao Alteravel
		aadd (_aHeader, {"Indice",         "INDICE",     "",                   18, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Nivel",          "NIVEL",      "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Tipo",           "TIPO",       "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Componente",     "COMP",       "",                   15, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Descricao",      "DESCR",      "",                   60, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Quant(acum)",    "QUANT",      "@E 999,999.9999999", 14, 7,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Un.med",         "UN_MED",     "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Cus.calculado",  "CUSTACUM",   "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		if mv_par08 == 1
			aadd (_aHeader, {"Cus.unit.(std)",   "CUSUNIT",   "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
			aadd (_aHeader, {"Dt.cus.std",     "DTCUSUNIT",   "@D",                  8, 0,  "",   "",  "D", "", "V",    "",  "",     '.F.'})
		elseif mv_par08 == 2
			aadd (_aHeader, {"Cus.unit.(medio)", "CUSUNIT",   "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
			aadd (_aHeader, {"Dt.cus.medio",     "DTCUSUNIT", "@D",                  8, 0,  "",   "",  "D", "", "V",    "",  "",     '.F.'})
		endif
		aadd (_aHeader, {"Soma no custo",  "CONSNOCUST", "",                    1, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp",       "VULTCOMP1",  "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Dt.Ult.comp",    "DULTCOMP1",  "@D",                  8, 0,  "",   "",  "D", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Forn.Ult.comp",  "FULTCOMP1",  "",                   60, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp-1",     "VULTCOMP2",  "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp-2",     "VULTCOMP3",  "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Rev.estrut",     "REVATU",     "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
	endif

	if _lContinua
		for _nPosEstr = _nPosIni to _nPosFim
	//		U_Log2 ('debug', '[' + procname () + ']Lendo _nPosEstr = ' + cvaltochar (_nPosEstr))
			_sProduto = _aEstruts [_nPosEstr, 1]
			incproc (_sProduto)

			// Extrai, da array de estruturas que jah tenho em memoria, a estrutura
			// do item solicitado.
			_aAux = aclone (_aEstruts [_nPosEstr, 2])
			
			_aCols = {}
			for _nCompon = 1 to len (_aAux)
				aadd (_aCols, aclone (U_LinVazia (_aHeader)))
				_n = len (_aCols)

				// Monta um codigo 'com pontos' para ajudar a identificar a hereditariedade dos componentes.
				GDFieldPut ("INDICE",     alltrim (_sProduto) + '.' + strzero (_nCompon, 2), _n, _aHeader, _aCols)
				GDFieldPut ("NIVEL",      _aAux [_nCompon, .EstrHistNivel],       _n, _aHeader, _aCols)
				GDFieldPut ("TIPO",       _aAux [_nCompon, .EstrHistTipoComp],    _n, _aHeader, _aCols)
				GDFieldPut ("COMP",       _aAux [_nCompon, .EstrHistCodComp],     _n, _aHeader, _aCols)
				GDFieldPut ("DESCR",      iif (_nCompon == 1, '', space (_aAux [_nCompon, .EstrHistNivel] * 5) + '+---') + _aAux [_nCompon, .EstrHistDescri], _n, _aHeader, _aCols)
				GDFieldPut ("QUANT",      _aAux [_nCompon, .EstrHistQuantAcum],   _n, _aHeader, _aCols)
				GDFieldPut ("UN_MED",     _aAux [_nCompon, .EstrHistUnidMedida],  _n, _aHeader, _aCols)
				GDFieldPut ("CUSUNIT",    _aAux [_nCompon, .EstrHistCustoUnit],   _n, _aHeader, _aCols)
				GDFieldPut ("DTCUSUNIT",  _aAux [_nCompon, .EstrHistDtCustD],     _n, _aHeader, _aCols)
				GDFieldPut ("CUSTACUM",   _aAux [_nCompon, .EstrHistCustoAcum],   _n, _aHeader, _aCols)
				GDFieldPut ("REVATU",     _aAux [_nCompon, .EstrHistRevAtu],      _n, _aHeader, _aCols)
				GDFieldPut ("CONSNOCUST", _aAux [_nCompon, .EstrHistSomaNoCusto], _n, _aHeader, _aCols)

				// Busca ultimas compras do componente.
				_aUltCom = {}
				// O primeiro (pai) nao precisa. Os demais, somente se nao tiverem filhos.
				if _nCompon == 1
					// O 'pai' da estrutura nao tem necessidade de ler ultimas compras.
				elseif _aAux [_nCompon, .EstrHistEhUva]
					// Ateh o momento, nao preciso ler ultimas compras da uva por
					// que nao ha intencao de usar aqui. De qualquer forma, se for
					// para buscar ultima compra, acho melhor calcular preco medio
					// com base na VA_VPRECOS_EFETIVOS_SAFRA.
				elseif _nCompon < len (_aAux) .and. _aAux [_nCompon + 1, .EstrHistNivel] > _aAux [_nCompon, .EstrHistNivel]
					// Estou num componente que tem filhos. Nao preciso ler ultimas compras.
				else
					_oSQL := ClsSQL():New ()
					_oSQL:_sQuery := "SELECT CUSREPUNI, D1_DTDIGIT, D1_FORNECE, D1_LOJA"
					_oSQL:_sQuery += " FROM VA_ULTCOMP ('', 'zz', '" + _aAux [_nCompon, .EstrHistCodComp] + "', 3)"
				//	_oSQL:Log ('[' + procname () + '][' + _aAux [_nCompon, .EstrHistCodComp] + ']')
					_aUltCom := aclone (_oSQL:Qry2Array (.F., .F.))
				endif

				// Acrescenta custo calculado nas ultimas compras do componente.
				// (pode nao haver tantas ultimas compras quanto solicitado).
				GDFieldPut ("VULTCOMP1", iif (len (_aUltCom) >= 1, _aUltCom [1, 1], 0), _n, _aHeader, _aCols)
				GDFieldPut ("DULTCOMP1", iif (len (_aUltCom) >= 1, stod (_aUltCom [1, 2]), ctod ('')), _n, _aHeader, _aCols)
				GDFieldPut ("FULTCOMP1", iif (len (_aUltCom) >= 1, alltrim (fBuscaCpo ("SA2", 1, xfilial ("SA2") + _aUltCom [1, 3] + _aUltCom [1, 4], "A2_NOME")), ''), _n, _aHeader, _aCols)
				GDFieldPut ("VULTCOMP2", iif (len (_aUltCom) >= 2, _aUltCom [2, 1], 0), _n, _aHeader, _aCols)
				GDFieldPut ("VULTCOMP3", iif (len (_aUltCom) >= 3, _aUltCom [3, 1], 0), _n, _aHeader, _aCols)
			next

			// u_LogACols (_aHeader, _aCols)

			// Abre em planilha para ajudar durante desenvolvimento do programa
			//if _lAuto
			//	U_acolsXLS (_aCols, .t., _aHeader)
			//endif

			// Se preciso apenas exportar as estruturas, basta adicionar o
			// aCols a uma array que vai ser exportada no final do processo.
			if _lExpTodas
		//		U_Log2 ('debug', _aCols)
				for _n = 1 to len (_aCols)
					_aAux2 = {}
					aadd (_aAux2, _sProduto)
					for _nCol = 1 to len (_aCols [1])
						aadd (_aAux2, _aCols [_n, _nCol])
					next
					aadd (_aTodasEst, aclone (_aAux2))
				next
		//		U_Log2 ('debug', _aTodasEst)
			else
				_aSize := MsAdvSize()
				define MSDialog _oDlgEstr from _aSize [1] + 25, _aSize [1] + 25 to _aSize [6] - 25, _aSize [5] - 25 of oMainWnd pixel title "Estrutura do " + _sProduto

				_oGetDEstr := MsNewGetDados ():New (31, ;                        // Limite superior
											5, ;                                 // Limite esquerdo 
											_oDlgEstr:nClientHeight / 2 - 20, ;  // Limite inferior
											_oDlgEstr:nClientWidth / 2 - 10, ;   // Limite direito
											2, ;                                 // [ nStyle ] 2=visualiza, 4=altera, ...
											"AllwaysTrue ()", ;                  // [ uLinhaOk ]
											"AllwaysTrue ()", ;                  // [ uTudoOk ]
											NIL, ;                               // [cIniCpos]
											NIL,;                                // [ aAlter ]
											NIL,;                                // [ nFreeze ]
											NIL,;                                // [ nMax ]
											NIL,;                                // [ cFieldOk ]
											NIL,;                                // [ uSuperDel ]
											NIL,;                                // [ uDelOk ]
											_oDlgEstr,;                          // [ oWnd ]
											_aHeader,;                           // [ ParHeader ]
											_aCols)                              // [ aParCols ]

				_oGetDEstr:oBrowse:bLDblClick := {|| allwaystrue ()}
				_oGetDEstr:oBrowse:bRClicked := {|| allwaystrue ()} // {|_o, _x, _y| _RClick1 (_o, _x, _y)}

				// Define botoes para a barra de ferramentas
				_bBotaoOK  = {|| _oDlgEstr:End ()}
				_bBotaoCan = {|| _oDlgEstr:End ()}
				_aBotAdic  = {}
				aadd (_aBotAdic, {"", {|| aHeader := aclone (_oGetDEstr:aHeader), aCols := aclone (_oGetDEstr:aCols), U_aColsXLS ()}, "Exp.planilha"})
				aadd (_aBotAdic, {"", {|| _RecCust (_oGetDEstr:aHeader, @_oGetDEstr:aCols)}, "Recalcular custo"})
				aadd (_aBotAdic, {"", {|| _AltCustD (_oGetDEstr:nAt, _oGetDEstr:aHeader, @_oGetDEstr:aCols)}, "Alterar cus.repos.cadastro"})
				
				// durante testes, rodo via script e nao tenho interface com o usuario.
				if type ("oMainWnd") == "O"
					activate dialog _oDlgEstr on init (EnchoiceBar (_oDlgEstr, _bBotaoOK, _bBotaoCan,, _aBotAdic))
				endif

				// Replica na array de estruturas as possiveis alteracoes que o usuario tenha feito
				for _nCompon = 1 to len (_aCols)
					_aAux [_nCompon, .EstrHistCustoUnit] = GDFieldGet ("CUSUNIT", _nCompon, .F., _oGetDEstr:aHeader, _oGetDEstr:aCols)
				next
				_aEstruts [_nPosEstr, 2] = aclone (_aAux)
			endif
		next

		if _lExpTodas
			// Insere uma 'coluna' no inicio do aHeader. Eh para o produto final, que nao existe em tela.
			aadd (_aHeader, NIL)
			ains (_aHeader, 1)
			//              Titulo       Campo       Masc Tam Dec Valid Usado Tipo F3  Context CBox Relacao Alteravel
			_aHeader [1] = {"PROD_PAI", "Prod_pai", "",   15, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'}
		//	U_Log2 ('debug', _aHeader)

			U_aColsXLS (_aTodasEst, .t., _aHeader)
		endif
	endif
return


// --------------------------------------------------------------------------
// Recalcula o custo de uma estrutura que estah sendo visualizada em tela.
static function _RecCust (_aHeader, _aCols)
	local _aEstrTela := {}
	local _n         := 0
	local _lContinua := .T.

	CursorWait ()
	
	// Nao deixo deletar itens pais por que, ao acumular os custos, somente
	// considero as quantidades das 'folhas' da arvore.
	for _n = 1 to len (_aCols)
		if _n < len (_aCols) .and. GDDeleted (_n, _aHeader, _aCols) .and. GDFieldGet ("NIVEL", _n, .f., _aHeader, _aCols) < GDFieldGet ("NIVEL", _n+1, .f., _aHeader, _aCols)
			u_help ("Para recalculo de custos, somente podem ser deletadas linhas de itens 'filhos'.",, .t.)
			_lContinua = .F.
			exit
		endif
	next

	if _lContinua
		for _n = 1 to len (_aCols)
			aadd (_aEstrTela, array (.EstrHistQtColunas))
			_aEstrTela [len (_aEstrTela), .EstrHistNivel]     = GDFieldGet ("NIVEL",    _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistTipoComp]  = GDFieldGet ("TIPO",     _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistCodComp]   = GDFieldGet ("COMP",     _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistDescri]    = GDFieldGet ("DESCR",    _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistRevAtu]    = GDFieldGet ("REVATU",   _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistCustoUnit] = GDFieldGet ("CUSUNIT",   _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistCustoAcum] = GDFieldGet ("CUSTACUM", _n, .f., _aHeader, _aCols)
			if GDDeleted (_n, _aHeader, _aCols)
				_aEstrTela [len (_aEstrTela), .EstrHistQuantAcum] = 0
			else
				_aEstrTela [len (_aEstrTela), .EstrHistQuantAcum] = GDFieldGet ("QUANT",    _n, .f., _aHeader, _aCols)
			endif
		next

		_AtuCust (@_aEstrTela, 1)

		// Atualiza os custos no aCols
		for _n = 1 to len (_aEstrTela)
			GDFieldPut ("CUSTACUM", _aEstrTela [_n, .EstrHistCustoAcum], _n, _aHeader, _aCols)
		next
		// Atualiza browse na tela
		_oGetDEstr:oBrowse:Refresh()
		_oGetDEstr:Show ()
	endif
	CursorArrow ()
return


// --------------------------------------------------------------------------
// Cria Perguntas no SX1
static function _ValidPerg ()
	local _aRegsPerg := {}
	local _aDefaults := {}

	//                     PERGUNT                           TIPO TAM DEC VALID F3       Opcoes                         Help
	aadd (_aRegsPerg, {01, "Produto inicial a analisar    ", "C", 15, 0,  "",   "SB1 ",  {},                            ""})
	aadd (_aRegsPerg, {02, "Produto final a analisar      ", "C", 15, 0,  "",   "SB1 ",  {},                            ""})
	aadd (_aRegsPerg, {03, "Tipos produtos a analisar     ", "C", 60, 0,  "",   "    ",  {},                            ""})
	aadd (_aRegsPerg, {04, "Considerar subniveis dos VD   ", "N",  1, 0,  "",   "    ",  {"Sim", "Nao"},                ""})
	aadd (_aRegsPerg, {05, "Linha comercial inicial       ", "C",  2, 0,  "",   "ZX539", {},                            ""})
	aadd (_aRegsPerg, {06, "Linha comercial final         ", "C",  2, 0,  "",   "ZX539", {},                            ""})
	aadd (_aRegsPerg, {07, "Itens que entram no MRP       ", "N",  1, 0,  "",   "    ",  {"So MRP", "Todos"},           ""})
	aadd (_aRegsPerg, {08, "Qual custo analisar           ", "N",  1, 0,  "",   "    ",  {"Standard(repos.)", "Medio"}, ""})
	aadd (_aRegsPerg, {09, "Somente produtos que usam...  ", "C", 15, 0,  "",   "    ",  {},                            ""})
	U_ValPerg (cPerg, _aRegsPerg, {}, _aDefaults)
return

/*
melhorias:
- % de participacao de cada nivel na tela da estrutura
- va_ccr do item 4439 nao bateu (NF 238340 do fornecedor 000851)
*/
