// Programa:  VA_ACR
// Autor:     Robert Koch
// Data:      30/09/2023
// Descricao: Analise custo reposicao (GLPI 14309)

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Consulta
// #Descricao         #Objetivo listar itens de venda abrindo su custo de reposicao.
// #PalavasChave      #custo_reposicao #custo_standard #estrutura
// #TabelasPrincipais #SB1 #SG1
// #Modulos           #EST

#include "protheus.ch"

#XTranslate .EstrHistNivel        => 1
#XTranslate .EstrHistTipoComp     => 2
#XTranslate .EstrHistCodComp      => 3
#XTranslate .EstrHistDescri       => 4
#XTranslate .EstrHistQuantAcum    => 5
#XTranslate .EstrHistRevAtu       => 6
#XTranslate .EstrHistCustDUnit    => 7
#XTranslate .EstrHistCustDAcum    => 8
#XTranslate .EstrHistEhUva        => 9
#XTranslate .EstrHistMaiorNivelVD => 10
#XTranslate .EstrHistDtCustD      => 11
#XTranslate .EstrHistQtColunas    => 11

// --------------------------------------------------------------------------
user function VA_ACR (_lAuto)
	Local cCadastro := "Analise custo reposicao"
	Local aSays     := {}
	Local aButtons  := {}
	Local nOpca     := 0
	Local lPerg     := .F.
	private cPerg   := 'VA_ACR'

	_validperg ()
	pergunte (cPerg, .f.)
	if _lAuto != NIL .and. _lAuto
		Processa( { |lEnd| _Gera() } )
	else
		AADD(aSays,cCadastro)
		AADD(aSays,"")
		AADD(aSays,"")
		AADD(aButtons, { 5, .T.,{|| lPerg := Pergunte(cPerg,.T. ) } } )
		AADD(aButtons, { 1, .T.,{|| nOpca := If(( lPerg .Or. Pergunte(cPerg,.T.)) .And. _TudoOk() , 1, 2 ), If( nOpca == 1, FechaBatch(), Nil ) }})
//		AADD(aButtons, { 15,.T.,{|| U_VA_SZNC ('EVENTO', 'CT2001')}})
		AADD(aButtons, { 2, .T.,{|| (nOpca := 2, FechaBatch()) }} )
		do while .T.
			FormBatch( cCadastro, aSays, aButtons)
			U_Log2 ('debug', '[' + procname () + ']nOpca=' + cvaltochar (nOpca))
			if nOpca == 1
				Processa( { |lEnd| _Gera() } )
			else
				exit
			Endif
		enddo
	endif
return


// --------------------------------------------------------------------------
// 'Tudo OK' do FormBatch.
Static Function _TudoOk ()
	local _lRet := .T.
return _lRet


// --------------------------------------------------------------------------
static function _Gera ()
	local _oSQL       := NIL
	local _sAliasQ    := ''
	local _nRecCount  := 0
	local _aHeader    := {}
	local _aCols      := {}
	local _n          := 1
	local _aEstrHist  := {}
	local _nCustoME   := 0
	local _nCustoVD   := 0
	local _nCustoMO   := 0
	local _nCustoBN   := 0
	local _nCustoOUT  := 0
	private _aEstruts := {}  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oDlg1    := NIL  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oGetD1   := NIL  // Deixar private para ser vista pelas funcoes auxiliares.

	U_LogSX1 (cPerg)

	// Cria aHeader para a tela inicial.
	_aHeader = {}
	//              Titulo                  Campo        Masc               Tam Dec Valid Usado Tipo F3     Context CBox Relacao Alteravel
	aadd (_aHeader, {"Produto",             "PRODUTO",   "",                15, 0,  "",   "",   "C", "SB1", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Descricao",           "DESCRICAO", "",                60, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Cus.rep.atu.",        "CUSTD",     "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"C.rep.calculado",     "CUSTACUM",  "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo ME",            "CUSTOME",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo VD",            "CUSTOVD",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo MO",            "CUSTOMO",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo BN",            "CUSTOBN",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo Outros",        "CUSTOOUT",  "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Rev.estrut",          "REVATU",    "",                 3, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})

	// Busca produtos cuja estrutura vai ser analisada.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += "SELECT B1_COD, B1_DESC, B1_REVATU, B1_CUSTD"
	_oSQL:_sQuery +=  " FROM " + RetSQLName ("SB1") + " SB1"
	_oSQL:_sQuery += " WHERE SB1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=   " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
	_oSQL:_sQuery +=   " AND SB1.B1_COD     BETWEEN '" + mv_par01 + "' AND '" + mv_par02 + "'"
	_oSQL:_sQuery +=   " AND SB1.B1_TIPO    IN " + FormatIn (alltrim (mv_par03), '/')
	_oSQL:_sQuery +=   " AND SB1.B1_MSBLQL != '1'"
	_oSQL:_sQuery += " ORDER BY B1_COD"
	_oSQL:Log ('[' + procname () + ']')
	_sAliasQ = _oSQL:Qry2Trb (.f.)
	count to _nRecCount
	procregua (_nRecCount)
	(_sAliasQ) -> (dbgotop ())
	do while ! (_sAliasQ) -> (eof ())
		incproc ('Lendo estrutura do ' + (_sAliasQ) -> b1_cod)
		_LeDados ((_sAliasQ) -> b1_cod, (_sAliasQ) -> b1_revatu, @_aEstrHist, @_nCustoME, @_nCustoVD, @_nCustoMO, @_nCustoBN, @_nCustoOUT)

		if len (_aEstrHist) == 0
			U_Log2 ('aviso', '[' + procname () + ']Item sem estrutura: ' + (_sAliasQ) -> b1_cod)
		else

			// Passa para _aCols os dados da array lida
			aadd (_aCols, aclone (U_LinVazia (_aHeader)))
			_n = len (_aCols)
			GDFieldPut ("PRODUTO",   (_sAliasQ) -> b1_cod,    _n, _aHeader, _aCols)
			GDFieldPut ("DESCRICAO", (_sAliasQ) -> b1_desc,   _n, _aHeader, _aCols)
			GDFieldPut ("REVATU",    (_sAliasQ) -> b1_revatu, _n, _aHeader, _aCols)
			GDFieldPut ("CUSTD",     (_sAliasQ) -> b1_custd,  _n, _aHeader, _aCols)
			GDFieldPut ("CUSTACUM",  (_nCustoME + _nCustoVD + _nCustoMO + _nCustoBN + _nCustoOUT),  _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOME",   _nCustoME,               _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOVD",   _nCustoVD,               _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOMO",   _nCustoMO,               _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOBN",   _nCustoBN,               _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOOUT" , _nCustoOUT,              _n, _aHeader, _aCols)

			// Guardo a estrutura pronta numa array geral, pois imagino que o
			// usuario vai consultar mais de uma vez e, jah que gastei tempo
			// na leitura inicial, por que nao aproveitar?
			aadd (_aEstruts, {_aCols [_n, 1], aclone (_aEstrHist)})

		endif

		(_sAliasQ) -> (dbskip ())
	enddo
	(_sAliasQ) -> (dbclosearea ())
	dbselectarea ("SB1")

	if len (_aCols) == 0
		u_help ("Nenhum item selecionado para analise.",, .t.)
	else

		u_LogACols (_aHeader, _aCols)
	
		// durante testes, rodo via script e nao tenho interface com o usuario.
		if type ("oMainWnd") != "O"
			_SimEstru (mv_par01)
		endif

		_aSize := MsAdvSize()
		define MSDialog _oDlg1 from _aSize [1], _aSize [1] to _aSize [6], _aSize [5] of oMainWnd pixel title "Analise custo reposicao"

		_oGetD1 := MsNewGetDados ():New (31, ;                       // Limite superior
									5, ;                             // Limite esquerdo 
									_oDlg1:nClientHeight / 2 - 20, ;  // Limite inferior
									_oDlg1:nClientWidth / 2 - 10, ;  // Limite direito
									2, ;                             // [ nStyle ]
									"AllwaysTrue ()", ;              // [ uLinhaOk ]
									"AllwaysTrue ()", ;              // [ uTudoOk ]
									NIL, ;                           // [cIniCpos]
									NIL,;                            // [ aAlter ]
									NIL,;                            // [ nFreeze ]
									NIL,;                            // [ nMax ]
									NIL,;                            // [ cFieldOk ]
									NIL,;                            // [ uSuperDel ]
									NIL,;                            // [ uDelOk ]
									_oDlg1,;                         // [ oWnd ]
									_aHeader,;                       // [ ParHeader ]
									_aCols)                          // [ aParCols ]

		_oGetD1:oBrowse:bLDblClick := {|| allwaystrue ()}
		_oGetD1:oBrowse:bRClicked := {|_o, _x, _y| _RClick1 (_o, _x, _y)}

		// Define botoes para a barra de ferramentas
		_bBotaoOK  = {|| _oDlg1:End ()}
		_bBotaoCan = {|| _oDlg1:End ()}
		_aBotAdic  = {}

		aadd (_aBotAdic, {"", {|| aHeader := aclone (_oGetD1:aHeader), aCols := aclone (_oGetD1:aCols), U_aColsXLS ()}, "Exp.planilha"})
		
		// durante testes, rodo via script e nao tenho interface com o usuario.
		if type ("oMainWnd") == "O"
			activate dialog _oDlg1 on init (EnchoiceBar (_oDlg1, _bBotaoOK, _bBotaoCan,, _aBotAdic))
		endif
	endif
return


// --------------------------------------------------------------------------
// Leitura e preparacao de dados para a tela principal.
static function _LeDados (_sProduto, _sRevisao, _aEstrHist, _nCustoME, _nCustoVD, _nCustoMO, _nCustoBN, _nCustoOUT)
	local _sFiltComp := ''
	local _aEstrAux  := {}

	local _nComp  := 0
	local _nFilho    := 0

	// Monta expressao para filtrar componentes
	_sFiltComp = ".T."
	if mv_par05 == 2  // Nao considerar uvas
		_sFiltComp += ".and.sb1->b1_grupo!='0400'"
	endif
	if ! empty (mv_par04)
		_sFiltComp += ".and.!sb1->b1_tipo$'" + alltrim (mv_par04) + "'"
	endif
	U_Log2 ('debug', '[' + procname () + ']Filtro para leitura das estruturas: ' + _sFiltComp)

	sb1 -> (dbsetorder (1))

	_aEstrAux = U_ML_Comp2 (_sProduto, 1, _sFiltComp, dDataBase, .f., .f., .f., .f., .f., '', .f., .t., .t., .f., _sRevisao)

	// Nao preciso de todas as colunas da array gerada pela funcao de
	// leitura de estrutura, entao vou substituir por coisas que preciso.
	for _nComp = 1 to len (_aEstrAux)
		if ! sb1 -> (dbseek (xfilial ("SB1") + _aEstrAux [_nComp, 2], .F.))
			u_help ("Nao localizado cadastro do item '" + _aEstrAux [_nComp, 2] + "'",, .t.)
			_lContinua = .F.
		else
			_aEstrAux [_nComp, 5]  = sb1 -> b1_tipo
			_aEstrAux [_nComp, 6]  = sb1 -> b1_desc
			_aEstrAux [_nComp, 8]  = sb1 -> b1_custd
			_aEstrAux [_nComp, 9]  = (sb1 -> b1_grupo == '0400')
			_aEstrAux [_nComp, 10] = sb1 -> b1_datref
		endif
	next

	// Prepara uma 'estrutura para historico' filtrando itens que nao interessam,
	// acrescentando acumulados, etc.
	_aEstrHist = {}
	_nComp = 1
	do while _nComp <= len (_aEstrAux)
		aadd (_aEstrHist, array (.EstrHistQtColunas))
		_aEstrHist [len (_aEstrHist), .EstrHistNivel]        = _aEstrAux [_nComp, 1]
		_aEstrHist [len (_aEstrHist), .EstrHistCodComp]      = _aEstrAux [_nComp, 2]
		_aEstrHist [len (_aEstrHist), .EstrHistQuantAcum]    = _aEstrAux [_nComp, 4]
		_aEstrHist [len (_aEstrHist), .EstrHistRevAtu]       = _aEstrAux [_nComp, 12]
		_aEstrHist [len (_aEstrHist), .EstrHistTipoComp]     = _aEstrAux [_nComp, 5]
		_aEstrHist [len (_aEstrHist), .EstrHistCustDUnit]    = _aEstrAux [_nComp, 8]
		_aEstrHist [len (_aEstrHist), .EstrHistDtCustD]      = _aEstrAux [_nComp, 10]
		_aEstrHist [len (_aEstrHist), .EstrHistDescri]       = alltrim (_aEstrAux [_nComp, 6])
		_aEstrHist [len (_aEstrHist), .EstrHistEhUva]        = _aEstrAux [_nComp, 9]
		_aEstrHist [len (_aEstrHist), .EstrHistMaiorNivelVD] = .F.  // Vai ser revisado mais adante

		// Eventualmente queremos considerar o VD como se fosse uma 'MP comprada'
		if mv_par06 == 2
			if _aEstrAux [_nComp, 5] == 'VD'
				_nFilho = _nComp
				do while _nFilho <= len (_aEstrAux) .and. _aEstrAux [_nFilho + 1, 1] > _aEstrAux [_nComp, 1]
					U_Log2 ('debug', '[' + procname () + ']Desconsiderando comp. ' + _aEstrAux [_nFilho+1, 2] + ' (nivel ' + cvaltochar (_aEstrAux [_nFilho+1, 1]) + ' por ser descendente de um VD.')
					_nFilho ++
				enddo
				_nComp = _nFilho
			endif
		endif
		_nComp ++
	enddo

	// Identifica os VDs que tem o maior nivel, para que no grid principal,
	// na coluna 'custo VD', seja somado somente o seu custo e nao dos
	// filhos, pois eh comum termos itens VD dentro de outros VD. Nesses
	// casos, eu estaria somando mais que uma vez.
	// Tah, tah, eu sei... o certo mesmo seria um 'custo em partes' aqui!
	_nComp = 2  // Posso estar analisando um VD como 'pai'
	do while _nComp <= len (_aEstrHist)
		U_Log2 ('debug', '[' + procname () + ']Procurando maior VD na linha ' + cvaltochar (_nComp))
		if _aEstrHist [_nComp, .EstrHistTipoComp] == 'VD'
			U_Log2 ('debug', '[' + procname () + ']eh VD')
			_aEstrHist [_nComp, .EstrHistMaiorNivelVD] = .T.
			_nFilho = _nComp
			do while _nFilho <= len (_aEstrHist) .and. _aEstrHist [_nFilho+1, .EstrHistNivel] > _aEstrHist [_nComp, .EstrHistNivel]
				U_Log2 ('debug', '[' + procname () + ']Achei filho na linha ' + cvaltochar (_nFilho+1))
				_aEstrHist [_nFilho+1, .EstrHistMaiorNivelVD] = .F.
				_nFilho ++
			enddo
			_nComp = _nFilho
		endif
		_nComp ++
	enddo
	U_Log2 ('debug', '[' + procname () + ']Maior nivel de VD identificado:')
	U_Log2 ('debug', _aEstrHist)

	// Acumula o custo de reposicao dos niveis 'pais' somando o custo de seus filhos.
	_AtuCust (@_aEstrHist, 1, .EstrHistNivel, .EstrHistQuantAcum, .EstrHistCustDUnit, .EstrHistCustDAcum)
	U_Log2 ('debug', '[' + procname () + ']Custos acumulados:')
	U_Log2 ('debug', _aEstrHist)

	// Abre os custos do item atual conforme os tipos de seus componentes.
	for _nComp = 2 to len (_aEstrHist)  // Como o primeiro item eh o proprio pai, nao quero somar seu custo.
		do case
		case _aEstrHist [_nComp, .EstrHistTipoComp] == 'ME'
			_nCustoME += _aEstrHist [_nComp, .EstrHistCustDAcum]
		case _aEstrHist [_nComp, .EstrHistTipoComp] == 'VD'
			if _aEstrHist [_nComp, .EstrHistMaiorNivelVD]
				_nCustoVD += _aEstrHist [_nComp, .EstrHistCustDAcum]
			endif
		case _aEstrHist [_nComp, .EstrHistTipoComp] == 'MO'
			_nCustoMO += _aEstrHist [_nComp, .EstrHistCustDAcum]
		case _aEstrHist [_nComp, .EstrHistTipoComp] == 'BN'
			_nCustoBN += _aEstrHist [_nComp, .EstrHistCustDAcum]
		otherwise
			_nCustoOUT += _aEstrHist [_nComp, .EstrHistCustDAcum]
		endcase
	next
return


// --------------------------------------------------------------------------
// Acumula custos por niveis - versao 3 afff
static function _AtuCust (_aEst, _nLinha, _nColNiv, _nColQt, _nColCusUn, _nColAcum, _nInteracao)
	local _nCusFilhos := 0
	local _nLinAux    := 0
	local _lTemSubNiv := .F.
	_nInteracao := iif (_nInteracao == NIL, 1, _nInteracao+1)
	_sPrefLog := 'int' + strzero (_nInteracao, 2)

	// Se tem filhos, preciso atualizar antes o custo dos filhos
	_nLinAux = _nLinha + 1
	_nCusFilhos = 0
	do while _nLinAux <= len (_aEst) .and. _aEst [_nLinAux, _nColNiv] > _aEst [_nLinha, _nColNiv]
		_lTemSubNiv = .T.
		U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, _nColNiv] * 2) + '_nLinha = ' + cvaltochar (_nLinha) + '  _nLinAux = ' + cvaltochar (_nLinAux) + ' dentro do loop da int. ' + strzero (_nInteracao, 2))
		
		// Processar somente os filhos, e nao os netos.
		if _aEst [_nLinAux, _nColNiv] == _aEst [_nLinha, _nColNiv] + 1
			U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, _nColNiv] * 2) + 'Vou fazer chamada para o filho da linha ' + cvaltochar (_nLinAux) + ' nivel ' + cvaltochar (_aEst [_nLinAux, _nColNiv]) + ' ' + _aEst [_nLinAux, .EstrHistCodComp])
			_AtuCust (@_aEst, _nLinAux, _nColNiv, _nColQt, _nColCusUn, _nColAcum, _nInteracao)
			
			// Agora que tenho o custo deste filho atualizado, posso soma-lo ao custo do nivel atual.
			_nCusFilhos += _aEst [_nLinAux, _nColAcum]
			U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, _nColNiv] * 2) + 'Acumulei para o ' + alltrim (_aEst [_nLinha, .EstrHistCodComp]) + ' o custo de ' + cvaltochar (_aEst [_nLinAux, _nColAcum])+ ' do filho ' + alltrim (_aEst [_nLinAux, .EstrHistCodComp]) + '. _nCusFilhos = ' + cvaltochar (_nCusFilhos))
		else
			U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, _nColNiv] * 2) + 'Nao eh filho direto.')
		endif
		_nLinAux ++
	enddo
	
	// Se nao tem filhos, fica com seu propro custo.
	if _lTemSubNiv
		_aEst [_nLinha, _nColAcum] = _nCusFilhos
		U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinha, _nColNiv] * 2) + 'Gravado ' + cvaltochar (_aEst [_nLinha, _nColAcum]) + ' na linha ' + cvaltochar (_nLinha) + ' (cod. ' + _aEst [_nLinha, .EstrHistCodComp] + ')')
	else
		_aEst [_nLinha, _nColAcum] = _aEst [_nLinha, _nColqT] * _aEst [_nLinha, _nColCusUn]
	endif
return


// --------------------------------------------------------------------------
// Funcao executada pelo clique do botao direito do mouse (no browse 1)
static function _RClick1 (_o, _x, _y) //, _sMomento)
	local _oMenu1   := NIL
	Local _oMenuIt1 := {}
	local _sProduto := ''
 
	MENU _oMenu1 POPUP
//	if _sMomento == '1'
		_sProduto = GDFieldGet ("PRODUTO", _oGetD1:nAt, .f., _oGetD1:aHeader, _oGetD1:aCols)
		U_Log2 ('debug', '[' + procname () + ']_sProduto = ' + _sProduto)
		aAdd (_oMenuIt1, MenuAddItem ("Simulacoes estrutura"          ,,, .T.,,,, _oMenu1, {|| processa ({||_SimEstru (_sProduto, .f.)}) },,,,,{|| .T.}))
//	elseif _sMomento == '2'
//		_sProduto = GDFieldGet ("COMP", _oGetDEstr:nAt, .f., _oGetDEstr:aHeader, _oGetDEstr:aCols)
//		U_Log2 ('debug', '[' + procname () + ']_sProduto = ' + _sProduto)
//		aAdd (_oMenuIt1, MenuAddItem ("Alterar cust.repos.no cadastro",,, .T.,,,, _oMenu1, {|| _AltCustD (_sProduto)},,,,,{|| .T.}))
//	endif
	ENDMENU

//	if _sMomento == '1'
		_oMenu1:Activate (_x + 15, _y + 205)
//	elseif _sMomento == '2'
//		_oMenu1:Activate (_x + 25, _y + 225)
//	endif
return


// --------------------------------------------------------------------------
// Altera custo de reposicao do componente, no cadastro.
static function _AltCustD (_nLinha, _aHeader, _aCols)
	local _sProduto  := ''
	local _sDescr    := ''
	local _nNovoCust := 0
	local _aAreaAnt := U_ML_SRArea ()
	static _sMasc    := X3Picture ("B1_CUSTD")

	_sProduto = GDFieldGet ("COMP",  _nLinha, .F., _aHeader, _aCols)
	_sDescr   = GDFieldGet ("DESCR", _nLinha, .F., _aHeader, _aCols)
	U_Log2 ('debug', '[' + procname () + ']_sProduto = ' + _sProduto)
	_nNovoCust = GDFieldGet ("CUSREP", _nLinha, .F., _aHeader, _aCols)
	U_Log2 ('debug', '[' + procname () + ']_nNovoCust = ' + cvaltochar (_nNovoCust))
	do while .T.
		_nNovoCust = u_Get ('Informe novo custo de reposicao para o item ' + alltrim (_sProduto) + ' ' + _sDescr, 'N', 12, _sMasc, '', _nNovoCust, .F., '.t.')
		if _nNovoCust == NIL
			u_help ("Alteracao de cadastro cancelada.",, .T.)
			exit
		endif
		if _nNovoCust < 0
			u_help ("Custo de reposicao nao pode ser negativo.",, .t.)
		else
			u_help ('Agora eu atualizaria o cadastro')
			sb1 -> (dbsetorder (1))
			if ! sb1 -> (dbseek (xfilial ("SB1") + _sProduto, .F.))
				u_help ("Produto nao localizado no cadastro!",, .t.)
			else
				if sb1 -> b1_custd != _nNovoCust
					// Cria variaveis para uso na gravacao do evento de alteracao
					regtomemory ("SB1", .F., .F.)
					m->b1_custd = _nNovoCust

					// Grava evento de alteracao
					_oEvento := ClsEvent():new ()
					_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), funname () + ' Alter.manual custo repos.', .F.)
					reclock ("SB1", .f.)
					sb1 -> b1_custd = m->b1_custd
					msunlock ()
					GDFieldPut ("CUSREP", _nNovoCust, _nLinha, _aHeader, _aCols)

					// Atualiza browse na tela
					_oGetDEstr:oBrowse:Refresh()
					_oGetDEstr:Show ()
					U_Log2 ('debug', '[' + procname () + ']_aCols depois de alterar o CUSREP')
					U_Log2 ('debug', _aCols)

					// Avisa o sistema Mercanet de que houve alteracao no cadastro deste item.
					U_AtuMerc ("SB1", sb1 -> (recno ()))

				endif
			endif

			// Vou recalcular o custo de toda a estrutura.
			// Se ficar lento, avaliarei posteriormente a ideia de racalcular apenas o 'trecho que interessa'
			_RecCust (_aHeader, _aCols)
			exit
		endif
	enddo
	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Visualiza estrutura que foi considerada para o produto selecionado.
static function _SimEstru (_sProduto, _lUltComp)
	local _nPosEstr    := 0
	local _nCompon     := 0
	local _oSQL        := NIL
	local _aHeader     := {}
	local _aCols       := {}
	local _n           := 1
	local _bBotaoOK    := {}
	local _bBotaoCan   := {}
	local _aBotAdic    := {}
	private _oDlgEstr  := NIL  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oGetDEstr := NIL  // Deixar private para ser vista pelas funcoes auxiliares.

	// Joga uma ossinho pro usuario roer
	procregua (10)
	incproc ()

	_nPosEstr = ascan (_aEstruts, {|_aVal| _aVal [1] == _sProduto})
	if _nPosEstr == 0
		u_help ("Estrutura nao encontrada!",, .t.)
	else
		// Extrai, da array de estruturas que jah tenho em memoria, a estrutura
		// do item solicitado.
		_aAux = aclone (_aEstruts [_nPosEstr, 2])
		
		_aHeader = {}
		//              Titulo             Campo        Masc                 Tam Dec Valid Usado Tipo F3  Context CBox Relacao Alteravel
		aadd (_aHeader, {"Indice",         "INDICE",    "",                   10, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Nivel",          "NIVEL",     "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Tipo",           "TIPO",      "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Componente",     "COMP",      "",                   15, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Descricao",      "DESCR",     "",                   60, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Quant(acum)",    "QUANT",     "@E 999,999.9999999", 14, 7,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Cus.calculado",  "CUSTACUM",  "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Cus.cadastro",   "CUSREP",    "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Dt.cus.std",     "DTCUSREP",  "@D",                  8, 0,  "",   "",  "D", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp",       "VULTCOMP1", "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Dt.Ult.comp",    "DULTCOMP1", "@D",                  8, 0,  "",   "",  "D", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Forn.Ult.comp",  "FULTCOMP1", "",                   60, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp-1",     "VULTCOMP2", "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp-2",     "VULTCOMP3", "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Rev.estrut",     "REVATU",    "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})

		_aCols = {}
		for _nCompon = 1 to len (_aAux)
			aadd (_aCols, aclone (U_LinVazia (_aHeader)))
			_n = len (_aCols)

			// Monta um codigo 'com pontos' para ajudar a identificar a hereditariedade dos componentes.
			GDFieldPut ("INDICE",   alltrim (_sProduto) + '.' + strzero (_nCompon, 2), _n, _aHeader, _aCols)
			GDFieldPut ("NIVEL",    _aAux [_nCompon, .EstrHistNivel],     _n, _aHeader, _aCols)
			GDFieldPut ("TIPO",     _aAux [_nCompon, .EstrHistTipoComp],  _n, _aHeader, _aCols)
			GDFieldPut ("COMP",     _aAux [_nCompon, .EstrHistCodComp],   _n, _aHeader, _aCols)
			GDFieldPut ("DESCR",    iif (_nCompon == 1, '', space (_aAux [_nCompon, .EstrHistNivel] * 5) + '+---') + _aAux [_nCompon, .EstrHistDescri], _n, _aHeader, _aCols)
			GDFieldPut ("QUANT",    _aAux [_nCompon, .EstrHistQuantAcum], _n, _aHeader, _aCols)
			GDFieldPut ("CUSREP",   _aAux [_nCompon, .EstrHistCustDUnit], _n, _aHeader, _aCols)
			GDFieldPut ("DTCUSREP", _aAux [_nCompon, .EstrHistDtCustD],   _n, _aHeader, _aCols)
			GDFieldPut ("CUSTACUM", _aAux [_nCompon, .EstrHistCustDAcum], _n, _aHeader, _aCols)
			GDFieldPut ("REVATU",   _aAux [_nCompon, .EstrHistRevAtu],    _n, _aHeader, _aCols)

			// Busca ultimas compras do componente.
			_aUltCom = {}
			// O primeiro (pai) nao precisa. Os demais, somente se nao tiverem filhos.
			if _nCompon == 1
				// O 'pai' da estrutura nao tem necessidade de ler ultimas compras.
			elseif _aAux [_nCompon, .EstrHistEhUva]
				// Ateh o momento, nao preciso ler ultimas compras da uva por
				// que nao ha intencao de usar aqui. De qualquer forma, se for
				// para buscar ultima compra, acho melhor calcular preco medio
				// com base na VA_VPRECOS_EFETIVOS_SAFRA.
			elseif _nCompon < len (_aAux) .and. _aAux [_nCompon + 1, .EstrHistNivel] > _aAux [_nCompon, .EstrHistNivel]
				// Estou num componente que tem filhos. Nao preciso ler ultimas compras.
			else
				_oSQL := ClsSQL():New ()
				_oSQL:_sQuery := "SELECT CUSREPUNI, D1_DTDIGIT, D1_FORNECE, D1_LOJA"
				_oSQL:_sQuery += " FROM VA_ULTCOMP ('', 'zz', '" + _aAux [_nCompon, .EstrHistCodComp] + "', 3)"
			//	_oSQL:Log ('[' + procname () + '][' + _aAux [_nCompon, .EstrHistCodComp] + ']')
				_aUltCom := aclone (_oSQL:Qry2Array (.F., .F.))
			endif

			// Acrescenta custo calculado nas ultimas compras do componente.
			// (pode nao haver tantas ultimas compras quanto solicitado).
			GDFieldPut ("VULTCOMP1", iif (len (_aUltCom) >= 1, _aUltCom [1, 1], 0), _n, _aHeader, _aCols)
			GDFieldPut ("DULTCOMP1", iif (len (_aUltCom) >= 1, stod (_aUltCom [1, 2]), ctod ('')), _n, _aHeader, _aCols)
			GDFieldPut ("FULTCOMP1", iif (len (_aUltCom) >= 1, alltrim (fBuscaCpo ("SA2", 1, xfilial ("SA2") + _aUltCom [1, 3] + _aUltCom [1, 4], "A2_NOME")), ''), _n, _aHeader, _aCols)
			GDFieldPut ("VULTCOMP2", iif (len (_aUltCom) >= 2, _aUltCom [2, 1], 0), _n, _aHeader, _aCols)
			GDFieldPut ("VULTCOMP3", iif (len (_aUltCom) >= 3, _aUltCom [3, 1], 0), _n, _aHeader, _aCols)
			
		next

		u_LogACols (_aHeader, _aCols)

		_aSize := MsAdvSize()
		define MSDialog _oDlgEstr from _aSize [1] + 25, _aSize [1] + 25 to _aSize [6] - 25, _aSize [5] - 25 of oMainWnd pixel title "Estrutura do " + _sProduto

		_oGetDEstr := MsNewGetDados ():New (31, ;                        // Limite superior
									5, ;                                 // Limite esquerdo 
									_oDlgEstr:nClientHeight / 2 - 20, ;  // Limite inferior
									_oDlgEstr:nClientWidth / 2 - 10, ;   // Limite direito
									4, ;                                 // [ nStyle ]
									"AllwaysTrue ()", ;                  // [ uLinhaOk ]
									"AllwaysTrue ()", ;                  // [ uTudoOk ]
									NIL, ;                               // [cIniCpos]
									NIL,;                                // [ aAlter ]
									NIL,;                                // [ nFreeze ]
									NIL,;                                // [ nMax ]
									NIL,;                                // [ cFieldOk ]
									NIL,;                                // [ uSuperDel ]
									NIL,;                                // [ uDelOk ]
									_oDlgEstr,;                          // [ oWnd ]
									_aHeader,;                           // [ ParHeader ]
									_aCols)                              // [ aParCols ]

		_oGetDEstr:oBrowse:bLDblClick := {|| allwaystrue ()}
		_oGetDEstr:oBrowse:bRClicked := {|| allwaystrue ()} // {|_o, _x, _y| _RClick1 (_o, _x, _y)}

		// Define botoes para a barra de ferramentas
		_bBotaoOK  = {|| _oDlgEstr:End ()}
		_bBotaoCan = {|| _oDlgEstr:End ()}
		_aBotAdic  = {}
		aadd (_aBotAdic, {"", {|| aHeader := aclone (_oGetDEstr:aHeader), aCols := aclone (_oGetDEstr:aCols), U_aColsXLS ()}, "Exp.planilha"})
		aadd (_aBotAdic, {"", {|| _RecCust (_oGetDEstr:aHeader, @_oGetDEstr:aCols)}, "Recalcular custo"})
		aadd (_aBotAdic, {"", {|| _AltCustD (_oGetDEstr:nAt, _oGetDEstr:aHeader, @_oGetDEstr:aCols)}, "Alterar cus.repos.cadastro"})
		
		// durante testes, rodo via script e nao tenho interface com o usuario.
		if type ("oMainWnd") == "O"
			activate dialog _oDlgEstr on init (EnchoiceBar (_oDlgEstr, _bBotaoOK, _bBotaoCan,, _aBotAdic))
		endif

		// Replica na array de estruturas as possiveis alteracoes que o usuario tenha feito
		U_Log2 ('debug', '[' + procname () + ']_aAux antes')
		U_Log2 ('debug', _aAux)
		for _nCompon = 1 to len (_aCols)
			_aAux [_nCompon, .EstrHistCustDUnit] = GDFieldGet ("CUSREP", _nCompon, .F., _aHeader, _aCols)
		next
		U_Log2 ('debug', '[' + procname () + ']_aAux depois')
		U_Log2 ('debug', _aAux)
	endif
return


// --------------------------------------------------------------------------
// Recalcula o custo de uma estrutura que estah sendo visualizada em tela.
static function _RecCust (_aHeader, _aCols)
	local _aEstrTela := {}
	local _n         := 0
	local _lContinua := .T.

	CursorWait ()
	
	// Nao deixo deletar itens pais por que, ao acumular os custos, somente
	// considero as quantidades das 'folhas' da arvore.
	for _n = 1 to len (_aCols)
		if _n < len (_aCols) .and. GDDeleted (_n, _aHeader, _aCols) .and. GDFieldGet ("NIVEL", _n, .f., _aHeader, _aCols) < GDFieldGet ("NIVEL", _n+1, .f., _aHeader, _aCols)
			u_help ("Para recalculo de custos, somente podem ser deletadas linhas de itens 'filhos'.",, .t.)
			_lContinua = .F.
			exit
		endif
	next

	if _lContinua
		for _n = 1 to len (_aCols)
			aadd (_aEstrTela, array (.EstrHistQtColunas))
			_aEstrTela [len (_aEstrTela), .EstrHistNivel]     = GDFieldGet ("NIVEL",    _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistTipoComp]  = GDFieldGet ("TIPO",     _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistCodComp]   = GDFieldGet ("COMP",     _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistDescri]    = GDFieldGet ("DESCR",    _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistRevAtu]    = GDFieldGet ("REVATU",   _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistCustDUnit] = GDFieldGet ("CUSREP",   _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistCustDAcum] = GDFieldGet ("CUSTACUM", _n, .f., _aHeader, _aCols)
			if GDDeleted (_n, _aHeader, _aCols)
				_aEstrTela [len (_aEstrTela), .EstrHistQuantAcum] = 0
			else
				_aEstrTela [len (_aEstrTela), .EstrHistQuantAcum] = GDFieldGet ("QUANT",    _n, .f., _aHeader, _aCols)
			endif
		next

		U_Log2 ('debug', '[' + procname () + ']Estrutura para recalc.custo cfe tela:')
		U_Log2 ('debug', _aEstrTela)
		_AtuCust (@_aEstrTela, 1, .EstrHistNivel, .EstrHistQuantAcum, .EstrHistCustDUnit, .EstrHistCustDAcum)

		// Atualiza os custos no aCols
		for _n = 1 to len (_aEstrTela)
			GDFieldPut ("CUSTACUM", _aEstrTela [_n, .EstrHistCustDAcum], _n, _aHeader, _aCols)
		next
		// Atualiza browse na tela
		_oGetDEstr:oBrowse:Refresh()
		_oGetDEstr:Show ()
	endif
	CursorArrow ()
return


// --------------------------------------------------------------------------
// Cria Perguntas no SX1
static function _ValidPerg ()
	local _aRegsPerg := {}
	local _aDefaults := {}

	//                     PERGUNT                           TIPO TAM DEC VALID F3      Opcoes          Help
	aadd (_aRegsPerg, {01, "Produto inicial               ", "C", 15, 0,  "",   "SB1 ", {},             ""})
	aadd (_aRegsPerg, {02, "Produto final                 ", "C", 15, 0,  "",   "SB1 ", {},             ""})
	aadd (_aRegsPerg, {03, "Tipos produtos a analisar     ", "C", 60, 0,  "",   "    ", {},             ""})
	aadd (_aRegsPerg, {04, "Tipos compon.ignorar(ex:MP/PS)", "C", 60, 0,  "",   "    ", {},             ""})
	aadd (_aRegsPerg, {05, "Mostrar uvas na estrutura     ", "N",  1, 0,  "",   "    ", {"Sim", "Nao"}, ""})
	aadd (_aRegsPerg, {06, "Abrir subniveis dos VD        ", "N",  1, 0,  "",   "    ", {"Sim", "Nao"}, ""})
	U_ValPerg (cPerg, _aRegsPerg, {}, _aDefaults)
return

/*
melhorias:
- mostrar data da ultima atualização do standard e tb ultimas compras (com fornecedor)
- b1_custd a dir. da descricao na tela principal
- custo total (acumulado) a dir. da descricao na tela principal
- coluna com data somente da ultima compra

- no caso de uvas, diferenciar compra X complemento de safra (por que o volume de mosto já terminou)
- tela 1 se somar as colunas, nao bate com a abertura da estrutura
- % de participacao de cada tipo na tela principal
- % de participacao de cada nivel na tela da estrutura
- atalho na segunda tela pra alterar o custo std no cadastro do componente (recalcular depois)
- va_ccr do item 4439 nao bateu (NF 238340 do fornecedor 000851)
*/
