// Programa:  VA_ACR
// Autor:     Robert Koch
// Data:      30/09/2023
// Descricao: Analise custo reposicao (GLPI 14309)

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Consulta
// #Descricao         #Objetivo listar itens de venda abrindo su custo de reposicao.
// #PalavasChave      #custo_reposicao #custo_standard #estrutura
// #TabelasPrincipais #SB1 #SG1
// #Modulos           #EST

// Historico de alteracoes:
// 13/11/2023 - Robert - Filtrar estruturas pelo campo g1_vacpcus (GLPI 14489)
// 21/11/2023 - Robert - Para a tela inicial, nao acumula mais os subnives por que acabava duplicando
//                     - Criados parametros de filtro por linha comercial
// 22/11/2023 - Robert - Acrescentada coluna com custo medio
// 24/11/2023 - Robert - Ao atualizar o campo B1_CUSTD, nao atualizava o campo B1_DATREF
// 29/11/2023 - Robert - Verifica se falta informar B1_REVATU (GLPI 14559)
//                     - Mostrar B1_CODLIN e B1_UM (1a. e 2a. telas respectivamente) - GLPI 14559
//

#include "protheus.ch"

#XTranslate .EstrHistNivel        => 1
#XTranslate .EstrHistTipoComp     => 2
#XTranslate .EstrHistCodComp      => 3
#XTranslate .EstrHistDescri       => 4
#XTranslate .EstrHistQuantAcum    => 5
#XTranslate .EstrHistRevAtu       => 6
#XTranslate .EstrHistCustDUnit    => 7
#XTranslate .EstrHistCustDAcum    => 8
#XTranslate .EstrHistEhUva        => 9
#XTranslate .EstrHistMaiorNivelVD => 10
#XTranslate .EstrHistDtCustD      => 11
#XTranslate .EstrHistSomaNoCusto  => 12
#XTranslate .EstrHistUnidMedida   => 13
#XTranslate .EstrHistQtColunas    => 13

// --------------------------------------------------------------------------
user function VA_ACR (_lAutomat)
	Local cCadastro := "Analise custo reposicao"
	Local aSays     := {}
	Local aButtons  := {}
	Local nOpca     := 0
	Local lPerg     := .F.
	private cPerg   := 'VA_ACR'
	private _lAuto  := iif (_lAutomat == NIL, .F., _lAutomat)

	_validperg ()
	pergunte (cPerg, .f.)
	if _lAuto
		Processa( { |lEnd| _Gera () } )
	else
		AADD(aSays,cCadastro)
		AADD(aSays,"")
		AADD(aSays,"")
		AADD(aButtons, { 5, .T.,{|| lPerg := Pergunte(cPerg,.T. ) } } )
		AADD(aButtons, { 1, .T.,{|| nOpca := If(( lPerg .Or. Pergunte(cPerg,.T.)) .And. _TudoOk() , 1, 2 ), If( nOpca == 1, FechaBatch(), Nil ) }})
//		AADD(aButtons, { 15,.T.,{|| U_VA_SZNC ('EVENTO', 'CT2001')}})
		AADD(aButtons, { 2, .T.,{|| (nOpca := 2, FechaBatch()) }} )
		do while .T.
			FormBatch( cCadastro, aSays, aButtons)
			U_Log2 ('debug', '[' + procname () + ']nOpca=' + cvaltochar (nOpca))
			if nOpca == 1
				Processa( { |lEnd| _Gera () } )
			else
				exit
			Endif
		enddo
	endif
return


// --------------------------------------------------------------------------
// 'Tudo OK' do FormBatch.
Static Function _TudoOk ()
	local _lRet := .T.
return _lRet


// --------------------------------------------------------------------------
static function _Gera ()
	local _oSQL       := NIL
	local _sAliasQ    := ''
	local _nRecCount  := 0
	local _aHeader    := {}
	local _aCols      := {}
	local _n          := 1
	local _aEstrHist  := {}
	local _nCustoME   := 0
	local _nCustoVD   := 0
	local _nCustoMO   := 0
	local _nCustoBN   := 0
	local _nCustoPS   := 0
	local _nCustoOUT  := 0
	local _nCustoTOT  := 0
	local _oVerif     := NIL
	local _nColProd   := 0
	local _lTemAviso  := .F.
	private _aEstruts := {}  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oDlg1    := NIL  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oGetD1   := NIL  // Deixar private para ser vista pelas funcoes auxiliares.

	U_LogSX1 (cPerg)

	// Cria lista de produtos que deveriam ter o campo B1_REVATU informado
	_oVerif := ClsVerif():New (1)
	_oVerif:Executa ()
//	U_Log2 ('debug', '[' + procname () + ']Resultado da verificacao:')
//	U_Log2 ('debug', _oVerif:Result)
	if len (_oVerif:Result) >= 1
		_nColProd = ascan (_oVerif:Result [1], 'PRODUTO')
		if _nColProd == 0
			u_help ("Coluna indicando o codigo do produto nao localizada na verificaco 1. Nao vai ser possivel validar produtos sem revisao padrao no cadastro.",, .t.)
		endif
	endif

	// Cria aHeader para a tela inicial.
	_aHeader = {}
	//              Titulo                  Campo         Masc               Tam Dec Valid Usado Tipo F3     Context CBox Relacao Alteravel
	aadd (_aHeader, {"Produto",             "PRODUTO",    "",                15, 0,  "",   "",   "C", "SB1", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Descricao",           "DESCRICAO",  "",                60, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Un.med",              "UN_MED",     "",                 2, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Cus.medio",           "CUSMEDUNIT", "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Cus.rep.atu.",        "CUSTD",      "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"C.rep.calculado",     "CUSTACUM",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo ME",            "CUSTOME",    "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.ME %",           "PPARTME",    "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo VD",            "CUSTOVD",    "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.VD %",           "PPARTVD",    "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo MO",            "CUSTOMO",    "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.MO %",           "PPARTMO",    "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo BN",            "CUSTOBN",    "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.BN %",           "PPARTBN",    "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo PS",            "CUSTOPS",    "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.PS %",           "PPARTPS",    "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Custo Outros",        "CUSTOOUT",   "@E 999,999.9999", 11, 4,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Part.Out %",          "PPARTOUT",   "@E 999.99",        6, 2,  "",   "",   "N", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Rev.estrut",          "REVATU",     "",                 3, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Linha coml.",         "LINCOM",     "",                25, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})
	aadd (_aHeader, {"Avisos",              "AVISOS",     "",               250, 0,  "",   "",   "C", "   ", "V",    "",  "",     '.F.'})

	// Busca produtos cuja estrutura vai ser analisada.
	_oSQL := ClsSQL ():New ()
	_oSQL:_sQuery := ""
	_oSQL:_sQuery += " WITH PRODUTOS AS"
	_oSQL:_sQuery += " ("
	_oSQL:_sQuery +=    " SELECT B1_COD, B1_DESC, B1_REVATU, B1_CUSTD, B1_UM, B1_CODLIN, ZX5_39.ZX5_39DESC"
	_oSQL:_sQuery +=      " FROM " + RetSQLName ("SB1") + " SB1"
	_oSQL:_sQuery +=         " LEFT JOIN " + RetSQLName ("ZX5") + " ZX5_39"
	_oSQL:_sQuery +=              " ON (ZX5_39.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=             " AND ZX5_39.ZX5_FILIAL  = '" + xfilial ("SB1") + "'"
	_oSQL:_sQuery +=             " AND ZX5_39.ZX5_TABELA  = '39'"
	_oSQL:_sQuery +=             " AND ZX5_39.ZX5_39COD   = SB1.B1_CODLIN)
	_oSQL:_sQuery +=     " WHERE SB1.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=       " AND SB1.B1_FILIAL  = '" + xfilial ("SB1") + "'"
	_oSQL:_sQuery +=       " AND SB1.B1_COD     BETWEEN '" + mv_par01 + "' AND '" + mv_par02 + "'"
	_oSQL:_sQuery +=       " AND SB1.B1_CODLIN  BETWEEN '" + mv_par05 + "' AND '" + mv_par06 + "'"
	_oSQL:_sQuery +=       " AND SB1.B1_TIPO    IN " + FormatIn (alltrim (mv_par03), '/')
	_oSQL:_sQuery +=       " AND SB1.B1_MSBLQL != '1'"
	if mv_par07 == 1
		_oSQL:_sQuery +=   " AND SB1.B1_MRP     = 'S'"
	endif
	_oSQL:_sQuery += " )"
	_oSQL:_sQuery += " , ULTIMOS_SB9 AS"
	_oSQL:_sQuery += " ("
	_oSQL:_sQuery +=    " SELECT B9_COD, MAX (B9_DATA) B9_DATA"
	_oSQL:_sQuery +=      " FROM " + RetSQLName ("SB9") + " ULT"
	_oSQL:_sQuery +=     " WHERE ULT.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=       " AND ULT.B9_FILIAL  = '01'"  // Atualmente focamos na matriz por que eh onde temos o envase.
	_oSQL:_sQuery +=       " AND ULT.B9_QINI    > 0"
	_oSQL:_sQuery +=       " AND ULT.B9_VINI1   > 0"
	_oSQL:_sQuery +=       " AND EXISTS (SELECT *"
	_oSQL:_sQuery +=                     " FROM PRODUTOS"
	_oSQL:_sQuery +=                    " WHERE B1_COD = ULT.B9_COD"
	_oSQL:_sQuery +=                   ")"
	_oSQL:_sQuery +=     " GROUP BY ULT.B9_COD"
	_oSQL:_sQuery += " )"
	_oSQL:_sQuery += " SELECT PRODUTOS.*"
	_oSQL:_sQuery +=      " , ISNULL ((SELECT SUM (B9_VINI1) / SUM (B9_QINI)"
	_oSQL:_sQuery +=      " FROM " + RetSQLName ("SB9") + " SB9"
	_oSQL:_sQuery +=     " WHERE SB9.D_E_L_E_T_ = ''"
	_oSQL:_sQuery +=       " AND SB9.B9_FILIAL  = '01'"  // Atualmente focamos na matriz por que eh onde temos o envase.
	_oSQL:_sQuery +=       " AND SB9.B9_COD     = PRODUTOS.B1_COD"
	_oSQL:_sQuery +=       " AND SB9.B9_QINI    > 0"
	_oSQL:_sQuery +=       " AND SB9.B9_VINI1   > 0"
	_oSQL:_sQuery +=       " AND SB9.B9_DATA    = ULTIMOS_SB9.B9_DATA"
	_oSQL:_sQuery +=      "), 0) AS CUSMED"
	_oSQL:_sQuery +=  " FROM PRODUTOS, ULTIMOS_SB9"
	_oSQL:_sQuery += " WHERE B9_COD = B1_COD"
	_oSQL:_sQuery += " ORDER BY B1_COD"
	_oSQL:Log ('[' + procname () + ']')
	_sAliasQ = _oSQL:Qry2Trb (.f.)
	count to _nRecCount
	procregua (_nRecCount)
	(_sAliasQ) -> (dbgotop ())
	do while ! (_sAliasQ) -> (eof ())
		incproc ('Lendo estrutura do ' + (_sAliasQ) -> b1_cod)

		_nCustoTot = 0
		_nCustoME  = 0
		_nCustoVD  = 0
		_nCustoMO  = 0
		_nCustoBN  = 0
		_nCustoPS  = 0
		_nCustoOUT = 0

		_LeDados ((_sAliasQ) -> b1_cod, (_sAliasQ) -> b1_revatu, @_aEstrHist, @_nCustoME, @_nCustoVD, @_nCustoMO, @_nCustoBN, @_nCustoPS, @_nCustoOUT)

		if len (_aEstrHist) == 0
			U_Log2 ('aviso', '[' + procname () + ']Item sem estrutura: ' + (_sAliasQ) -> b1_cod)
		else

			// Passa para _aCols os dados da array lida
			aadd (_aCols, aclone (U_LinVazia (_aHeader)))
			_n = len (_aCols)
			_nCustoTot = _nCustoME +  _nCustoVD + _nCustoMO + _nCustoBN + _nCustoPS + _nCustoOUT
			GDFieldPut ("PRODUTO",    (_sAliasQ) -> b1_cod,      _n, _aHeader, _aCols)
			GDFieldPut ("DESCRICAO",  (_sAliasQ) -> b1_desc,     _n, _aHeader, _aCols)
			GDFieldPut ("LINCOM",     alltrim ((_sAliasQ) -> b1_codlin) + '-' + (_sAliasQ) -> zx5_39desc, _n, _aHeader, _aCols)
			GDFieldPut ("REVATU",     (_sAliasQ) -> b1_revatu,   _n, _aHeader, _aCols)
			GDFieldPut ("UN_MED",     (_sAliasQ) -> b1_um,       _n, _aHeader, _aCols)
			GDFieldPut ("CUSTD",      (_sAliasQ) -> b1_custd,    _n, _aHeader, _aCols)
			GDFieldPut ("CUSMEDUNIT", (_sAliasQ) -> CusMed,      _n, _aHeader, _aCols)
			GDFieldPut ("CUSTACUM",   _nCustoTot,                _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOME",    _nCustoME,                 _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOVD",    _nCustoVD,                 _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOMO",    _nCustoMO,                 _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOBN",    _nCustoBN,                 _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOPS",    _nCustoPS,                 _n, _aHeader, _aCols)
			GDFieldPut ("CUSTOOUT" ,  _nCustoOUT,                _n, _aHeader, _aCols)
			GDFieldPut ("PPARTME",    _nCustoME*100/_nCustoTot,  _n, _aHeader, _aCols)
			GDFieldPut ("PPARTVD",    _nCustoVD*100/_nCustoTot,  _n, _aHeader, _aCols)
			GDFieldPut ("PPARTMO",    _nCustoMO*100/_nCustoTot,  _n, _aHeader, _aCols)
			GDFieldPut ("PPARTBN",    _nCustoBN*100/_nCustoTot,  _n, _aHeader, _aCols)
			GDFieldPut ("PPARTPS",    _nCustoPS*100/_nCustoTot,  _n, _aHeader, _aCols)
			GDFieldPut ("PPARTOUT",   _nCustoOut*100/_nCustoTot, _n, _aHeader, _aCols)

			if _nColProd > 0 .and. ascan (_oVerif:Result, {|_aVal| _aVal [_nColProd] == (_sAliasQ) -> b1_cod}) > 0
				GDFieldPut ("AVISOS", "Falta revisao padrao no campo B1_REVATU. (Verif.Alianca numero 1)", _n, _aHeader, _aCols)
				_lTemAviso = .t.
			endif

			// Guardo a estrutura pronta numa array geral, pois imagino que o
			// usuario vai consultar mais de uma vez e, jah que gastei tempo
			// na leitura inicial, por que nao aproveitar?
			aadd (_aEstruts, {_aCols [_n, 1], aclone (_aEstrHist)})

		endif

		(_sAliasQ) -> (dbskip ())
	enddo
	(_sAliasQ) -> (dbclosearea ())
	dbselectarea ("SB1")

	if len (_aCols) == 0
		u_help ("Nenhum item selecionado para analise.",, .t.)
	else

	//	u_LogACols (_aHeader, _aCols)
		
		// Abre em planilha para ajudar durante desenvolvimento do programa
		if _lAuto
			U_acolsXLS (_aCols, .t., _aHeader)
		endif
	
		// durante testes, rodo via script e nao tenho interface com o usuario.
		if type ("oMainWnd") != "O"
			_SimEstru (mv_par01)
		endif

		if _lTemAviso
			u_help ("ATENCAO: Verifique a coluna de avisos, pois encontrei alguma inconsistencia nos dados.",, .t.)
		endif

		_aSize := MsAdvSize()
		define MSDialog _oDlg1 from _aSize [1], _aSize [1] to _aSize [6], _aSize [5] of oMainWnd pixel title "Analise custo reposicao"

		_oGetD1 := MsNewGetDados ():New (31, ;                       // Limite superior
									5, ;                             // Limite esquerdo 
									_oDlg1:nClientHeight / 2 - 20, ;  // Limite inferior
									_oDlg1:nClientWidth / 2 - 10, ;  // Limite direito
									2, ;                             // [ nStyle ]
									"AllwaysTrue ()", ;              // [ uLinhaOk ]
									"AllwaysTrue ()", ;              // [ uTudoOk ]
									NIL, ;                           // [cIniCpos]
									NIL,;                            // [ aAlter ]
									NIL,;                            // [ nFreeze ]
									NIL,;                            // [ nMax ]
									NIL,;                            // [ cFieldOk ]
									NIL,;                            // [ uSuperDel ]
									NIL,;                            // [ uDelOk ]
									_oDlg1,;                         // [ oWnd ]
									_aHeader,;                       // [ ParHeader ]
									_aCols)                          // [ aParCols ]

		_oGetD1:oBrowse:bLDblClick := {|| allwaystrue ()}
		_oGetD1:oBrowse:bRClicked := {|_o, _x, _y| _RClick1 (_o, _x, _y)}

		// Define botoes para a barra de ferramentas
		_bBotaoOK  = {|| _oDlg1:End ()}
		_bBotaoCan = {|| _oDlg1:End ()}
		_aBotAdic  = {}

		aadd (_aBotAdic, {"", {|| aHeader := aclone (_oGetD1:aHeader), aCols := aclone (_oGetD1:aCols), U_aColsXLS ()}, "Exp.planilha"})
		if 'ROBERT.KOCH' $ alltrim (upper (cUserName))
			aadd (_aBotAdic, {"", {|| u_showarray (_aEstruts)}, "Ver _aEstruts"})
		endif
		
		// durante testes, rodo via script e nao tenho interface com o usuario.
		if type ("oMainWnd") == "O"
			activate dialog _oDlg1 on init (EnchoiceBar (_oDlg1, _bBotaoOK, _bBotaoCan,, _aBotAdic))
		endif
	endif
return


// --------------------------------------------------------------------------
// Leitura e preparacao de dados para a tela principal.
static function _LeDados (_sProduto, _sRevisao, _aEstrHist, _nCustoME, _nCustoVD, _nCustoMO, _nCustoBN, _nCustoPS, _nCustoOUT)
	local _sFiltComp := ''
	local _aEstrAux  := {}

	local _nComp  := 0
	local _nFilho    := 0

	// Monta expressao para filtrar componentes
	_sFiltComp = ".T."
	_sFiltComp += ".and.sg1->g1_vacpcus='S'"
///	U_Log2 ('debug', '[' + procname () + ']Filtro para leitura das estruturas: ' + _sFiltComp)

	sb1 -> (dbsetorder (1))

	_aEstrAux = U_ML_Comp2 (_sProduto, 1, _sFiltComp, dDataBase, .f., .f., .f., .f., .f., '', .f., .t., .t., .f., _sRevisao)

	// Nao preciso de todas as colunas da array gerada pela funcao de
	// leitura de estrutura, entao vou substituir por coisas que preciso.
	for _nComp = 1 to len (_aEstrAux)
		if ! sb1 -> (dbseek (xfilial ("SB1") + _aEstrAux [_nComp, 2], .F.))
			u_help ("Nao localizado cadastro do item '" + _aEstrAux [_nComp, 2] + "'",, .t.)
			_lContinua = .F.
		else
			_aEstrAux [_nComp, 5]  = sb1 -> b1_tipo
			_aEstrAux [_nComp, 6]  = sb1 -> b1_desc
			_aEstrAux [_nComp, 8]  = sb1 -> b1_custd
			_aEstrAux [_nComp, 9]  = (sb1 -> b1_grupo == '0400')
			_aEstrAux [_nComp, 10] = sb1 -> b1_datref
			_aEstrAux [_nComp, 11] = sb1 -> b1_um
		endif
	next

	// Prepara uma 'estrutura para historico' filtrando itens que nao interessam,
	// acrescentando acumulados, etc.
	_aEstrHist = {}
	_nComp = 1
	do while _nComp <= len (_aEstrAux)
		aadd (_aEstrHist, array (.EstrHistQtColunas))
		_aEstrHist [len (_aEstrHist), .EstrHistNivel]        = _aEstrAux [_nComp, 1]
		_aEstrHist [len (_aEstrHist), .EstrHistCodComp]      = _aEstrAux [_nComp, 2]
		_aEstrHist [len (_aEstrHist), .EstrHistQuantAcum]    = _aEstrAux [_nComp, 4]
		_aEstrHist [len (_aEstrHist), .EstrHistUnidMedida]   = _aEstrAux [_nComp, 11]
		_aEstrHist [len (_aEstrHist), .EstrHistRevAtu]       = _aEstrAux [_nComp, 12]
		_aEstrHist [len (_aEstrHist), .EstrHistTipoComp]     = _aEstrAux [_nComp, 5]
		_aEstrHist [len (_aEstrHist), .EstrHistCustDUnit]    = _aEstrAux [_nComp, 8]
		_aEstrHist [len (_aEstrHist), .EstrHistDtCustD]      = _aEstrAux [_nComp, 10]
		_aEstrHist [len (_aEstrHist), .EstrHistDescri]       = alltrim (_aEstrAux [_nComp, 6])
		_aEstrHist [len (_aEstrHist), .EstrHistEhUva]        = _aEstrAux [_nComp, 9]
		_aEstrHist [len (_aEstrHist), .EstrHistMaiorNivelVD] = .F.  // Vai ser revisado mais adante
		_aEstrHist [len (_aEstrHist), .EstrHistSomaNoCusto]  = 'S'  // Ateh segunda ordem, todos os componentes devem ser considerados.
		_nComp ++
	enddo

	// Identifica os VDs que tem o maior nivel, para que no grid principal,
	// na coluna 'custo VD', seja somado somente o seu custo e nao dos
	// filhos, pois eh comum termos itens VD dentro de outros VD. Nesses
	// casos, eu estaria somando mais que uma vez.
	// Sim, sim, eu sei... o certo mesmo seria um 'custo em partes' aqui!
//	U_Log2 ('debug', '[' + procname () + ']Vou procurar o maior nivel de VD neste estrut:')
//	U_Log2 ('debug', _aEstrHist)
	_nComp = 2  // Posso estar analisando um VD como 'pai'
	do while _nComp <= len (_aEstrHist)
//		U_Log2 ('debug', '[' + procname () + ']Procurando maior VD na linha ' + cvaltochar (_nComp))
		if _aEstrHist [_nComp, .EstrHistTipoComp] == 'VD'
//			U_Log2 ('debug', '[' + procname () + ']eh VD')
			_aEstrHist [_nComp, .EstrHistMaiorNivelVD] = .T.
			_nFilho = _nComp
			do while _nFilho < len (_aEstrHist) .and. _aEstrHist [_nFilho+1, .EstrHistNivel] > _aEstrHist [_nComp, .EstrHistNivel]
//				U_Log2 ('debug', '[' + procname () + ']Achei filho na linha ' + cvaltochar (_nFilho+1))
				_aEstrHist [_nFilho+1, .EstrHistMaiorNivelVD] = .F.

				// Usuario pode optar por considerar o VD como se fosse um item comprado.
				// Isso por que ainda temos dificuldade em abrir o custo dos itens tipo VD.
				if mv_par04 == 2
					_aEstrHist [_nFilho+1, .EstrHistSomaNoCusto] = 'N'
				endif

				_nFilho ++
			enddo
			_nComp = _nFilho
		endif
		_nComp ++
	enddo
//	U_Log2 ('debug', '[' + procname () + ']Maior nivel de VD identificado:')
//	U_Log2 ('debug', _aEstrHist)

	// Acumula o custo de reposicao dos niveis 'pais' somando o custo de seus filhos.
	_AtuCust (@_aEstrHist, 1)
//	U_Log2 ('debug', '[' + procname () + ']Custos acumulados:')
//	U_Log2 ('debug', _aEstrHist)

	// Abre os custos do item atual conforme os tipos de seus componentes.
	for _nComp = 2 to len (_aEstrHist)  // Como o primeiro item eh o proprio pai, nao quero somar seu custo.
		
		// Quero apenas os filhos diretos do produto final.
		if _aEstrHist [_nComp, 1] == 1
			do case
			case _aEstrHist [_nComp, .EstrHistTipoComp] == 'ME'
				_nCustoME += _aEstrHist [_nComp, .EstrHistCustDAcum]
			case _aEstrHist [_nComp, .EstrHistTipoComp] == 'VD'
				if _aEstrHist [_nComp, .EstrHistMaiorNivelVD]  // Somente o maior nivel
					_nCustoVD += _aEstrHist [_nComp, .EstrHistCustDAcum]
				endif
			case _aEstrHist [_nComp, .EstrHistTipoComp] == 'MO'
				_nCustoMO += _aEstrHist [_nComp, .EstrHistCustDAcum]
			case _aEstrHist [_nComp, .EstrHistTipoComp] == 'BN'
				_nCustoBN += _aEstrHist [_nComp, .EstrHistCustDAcum]
			case _aEstrHist [_nComp, .EstrHistTipoComp] == 'PS'
				_nCustoPS += _aEstrHist [_nComp, .EstrHistCustDAcum]
			otherwise
				_nCustoOUT += _aEstrHist [_nComp, .EstrHistCustDAcum]
			endcase
		endif
	next
return


// --------------------------------------------------------------------------
// Acumula custos por niveis - versao 3 afff
static function _AtuCust (_aEst, _nLinha, _nInteracao)
	local _nCusFilhos := 0
	local _nLinAux    := 0
	local _lTemSubNiv := .F.
	local _lSomouSub  := .F.
	_nInteracao := iif (_nInteracao == NIL, 1, _nInteracao+1)
	_sPrefLog := 'int' + strzero (_nInteracao, 2)

	// Se tem filhos, preciso atualizar antes o custo dos filhos
	_nLinAux = _nLinha + 1
	_nCusFilhos = 0
	do while _nLinAux <= len (_aEst) .and. _aEst [_nLinAux, .EstrHistNivel] > _aEst [_nLinha, .EstrHistNivel]
		_lTemSubNiv = .T.
	//	U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, .EstrHistNivel] * 2) + '_nLinha = ' + cvaltochar (_nLinha) + '  _nLinAux = ' + cvaltochar (_nLinAux) + ' dentro do loop da int. ' + strzero (_nInteracao, 2))
		
		// Processar somente os filhos, e nao os netos.
		if _aEst [_nLinAux, .EstrHistNivel] == _aEst [_nLinha, .EstrHistNivel] + 1
	//		U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, .EstrHistNivel] * 2) + 'Vou fazer chamada para o filho da linha ' + cvaltochar (_nLinAux) + ' nivel ' + cvaltochar (_aEst [_nLinAux, .EstrHistNivel]) + ' ' + _aEst [_nLinAux, .EstrHistCodComp])
			_AtuCust (@_aEst, _nLinAux, _nInteracao)
			
			// Agora que tenho o custo deste filho atualizado, posso soma-lo ao custo do nivel atual.
			if _aEst [_nLinAux, .EstrHistSomaNoCusto] == 'S'
				_nCusFilhos += _aEst [_nLinAux, .EstrHistCustDAcum]
				_lSomouSub = .T.
			else
	//			U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, .EstrHistNivel] * 2) + 'o filho ' + alltrim (_aEst [_nLinAux, .EstrHistCodComp]) + ' nao deve ser somado ao custo.')
			endif
	//		U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, .EstrHistNivel] * 2) + 'Acumulei para o ' + alltrim (_aEst [_nLinha, .EstrHistCodComp]) + ' o custo de ' + cvaltochar (_aEst [_nLinAux, .EstrHistCustDAcum])+ ' do filho ' + alltrim (_aEst [_nLinAux, .EstrHistCodComp]) + '. _nCusFilhos = ' + cvaltochar (_nCusFilhos))
		else
	//		U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinAux, .EstrHistNivel] * 2) + 'Nao eh filho direto.')
		endif
		_nLinAux ++
	enddo
	
	// Se nao tem filhos, fica com seu propro custo.
	if _lSomouSub // _lTemSubNiv
		_aEst [_nLinha, .EstrHistCustDAcum] = _nCusFilhos
	//	U_Log2 ('debug', '[' + procname () + ']' + space (_aEst [_nLinha, .EstrHistNivel] * 2) + 'Gravado ' + cvaltochar (_aEst [_nLinha, .EstrHistCustDAcum]) + ' na linha ' + cvaltochar (_nLinha) + ' (cod. ' + _aEst [_nLinha, .EstrHistCodComp] + ')')
	else
		_aEst [_nLinha, .EstrHistCustDAcum] = _aEst [_nLinha, .EstrHistQuantAcum] * _aEst [_nLinha, .EstrHistCustDUnit]
	endif
return


// --------------------------------------------------------------------------
// Funcao executada pelo clique do botao direito do mouse (no browse 1)
static function _RClick1 (_o, _x, _y) //, _sMomento)
	local _oMenu1   := NIL
	Local _oMenuIt1 := {}
	local _sProduto := ''
 
	MENU _oMenu1 POPUP
//	if _sMomento == '1'
		_sProduto = GDFieldGet ("PRODUTO", _oGetD1:nAt, .f., _oGetD1:aHeader, _oGetD1:aCols)
		U_Log2 ('debug', '[' + procname () + ']_sProduto = ' + _sProduto)
		aAdd (_oMenuIt1, MenuAddItem ("Simulacoes estrutura"          ,,, .T.,,,, _oMenu1, {|| processa ({||_SimEstru (_sProduto, .f.)}) },,,,,{|| .T.}))
//	elseif _sMomento == '2'
//		_sProduto = GDFieldGet ("COMP", _oGetDEstr:nAt, .f., _oGetDEstr:aHeader, _oGetDEstr:aCols)
//		U_Log2 ('debug', '[' + procname () + ']_sProduto = ' + _sProduto)
//		aAdd (_oMenuIt1, MenuAddItem ("Alterar cust.repos.no cadastro",,, .T.,,,, _oMenu1, {|| _AltCustD (_sProduto)},,,,,{|| .T.}))
//	endif
	ENDMENU

//	if _sMomento == '1'
		_oMenu1:Activate (_x + 15, _y + 205)
//	elseif _sMomento == '2'
//		_oMenu1:Activate (_x + 25, _y + 225)
//	endif
return


// --------------------------------------------------------------------------
// Altera custo de reposicao do componente, no cadastro.
static function _AltCustD (_nLinha, _aHeader, _aCols)
	local _sProduto  := ''
	local _sDescr    := ''
	local _nNovoCust := 0
	local _aAreaAnt := U_ML_SRArea ()
	static _sMasc    := X3Picture ("B1_CUSTD")

	_sProduto = GDFieldGet ("COMP",  _nLinha, .F., _aHeader, _aCols)
	_sDescr   = GDFieldGet ("DESCR", _nLinha, .F., _aHeader, _aCols)
	U_Log2 ('debug', '[' + procname () + ']_sProduto = ' + _sProduto)
	_nNovoCust = GDFieldGet ("CUSREP", _nLinha, .F., _aHeader, _aCols)
	U_Log2 ('debug', '[' + procname () + ']_nNovoCust = ' + cvaltochar (_nNovoCust))
	do while .T.
		_nNovoCust = u_Get ('Informe novo custo de reposicao para o item ' + alltrim (_sProduto) + ' ' + _sDescr, 'N', 12, _sMasc, '', _nNovoCust, .F., '.t.')
		if _nNovoCust == NIL
			u_help ("Alteracao de cadastro cancelada.",, .T.)
			exit
		endif
		if _nNovoCust < 0
			u_help ("Custo de reposicao nao pode ser negativo.",, .t.)
		else
			sb1 -> (dbsetorder (1))
			if ! sb1 -> (dbseek (xfilial ("SB1") + _sProduto, .F.))
				u_help ("Produto nao localizado no cadastro!",, .t.)
			else
				if sb1 -> b1_custd != _nNovoCust
					// Cria variaveis para uso na gravacao do evento de alteracao
					regtomemory ("SB1", .F., .F.)
					m->b1_custd = _nNovoCust
					m->b1_datref = date ()

					// Grava evento de alteracao
					_oEvento := ClsEvent():new ()
					_oEvento:AltCadast ("SB1", m->b1_cod, sb1 -> (recno ()), funname () + ' Alter.manual custo repos.', .F.)
					reclock ("SB1", .f.)
					sb1 -> b1_custd = m->b1_custd
					sb1 -> B1_datref = m->b1_datref
					msunlock ()
					GDFieldPut ("CUSREP", _nNovoCust, _nLinha, _aHeader, _aCols)

					// Atualiza browse na tela
					_oGetDEstr:oBrowse:Refresh()
					_oGetDEstr:Show ()
					U_Log2 ('debug', '[' + procname () + ']_aCols depois de alterar o CUSREP')
					U_Log2 ('debug', _aCols)

					// Avisa o sistema Mercanet de que houve alteracao no cadastro deste item.
					U_AtuMerc ("SB1", sb1 -> (recno ()))

				endif
			endif

			// Vou recalcular o custo de toda a estrutura.
			// Se ficar lento, avaliarei posteriormente a ideia de racalcular apenas o 'trecho que interessa'
			_RecCust (_aHeader, _aCols)
			exit
		endif
	enddo
	U_ML_SRArea (_aAreaAnt)
return


// --------------------------------------------------------------------------
// Visualiza estrutura que foi considerada para o produto selecionado.
static function _SimEstru (_sProduto, _lUltComp)
	local _nPosEstr    := 0
	local _nCompon     := 0
	local _oSQL        := NIL
	local _aHeader     := {}
	local _aCols       := {}
	local _n           := 1
	local _bBotaoOK    := {}
	local _bBotaoCan   := {}
	local _aBotAdic    := {}
	private _oDlgEstr  := NIL  // Deixar private para ser vista pelas funcoes auxiliares.
	private _oGetDEstr := NIL  // Deixar private para ser vista pelas funcoes auxiliares.

	// Joga uma ossinho pro usuario roer
	procregua (10)
	incproc ()

	_nPosEstr = ascan (_aEstruts, {|_aVal| _aVal [1] == _sProduto})
	if _nPosEstr == 0
		u_help ("Estrutura nao encontrada!",, .t.)
	else
		// Extrai, da array de estruturas que jah tenho em memoria, a estrutura
		// do item solicitado.
		_aAux = aclone (_aEstruts [_nPosEstr, 2])
		
		_aHeader = {}
		//              Titulo             Campo         Masc                 Tam Dec Valid Usado Tipo F3  Context CBox Relacao Alteravel
		aadd (_aHeader, {"Indice",         "INDICE",     "",                   10, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Nivel",          "NIVEL",      "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Tipo",           "TIPO",       "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Componente",     "COMP",       "",                   15, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Descricao",      "DESCR",      "",                   60, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Quant(acum)",    "QUANT",      "@E 999,999.9999999", 14, 7,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Un.med",         "UN_MED",     "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Cus.calculado",  "CUSTACUM",   "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Cus.cadastro",   "CUSREP",     "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Soma no custo",  "CONSNOCUST", "",                    1, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Dt.cus.std",     "DTCUSREP",   "@D",                  8, 0,  "",   "",  "D", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp",       "VULTCOMP1",  "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Dt.Ult.comp",    "DULTCOMP1",  "@D",                  8, 0,  "",   "",  "D", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Forn.Ult.comp",  "FULTCOMP1",  "",                   60, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp-1",     "VULTCOMP2",  "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Ult.comp-2",     "VULTCOMP3",  "@E 999,999.9999",    11, 4,  "",   "",  "N", "", "V",    "",  "",     '.F.'})
		aadd (_aHeader, {"Rev.estrut",     "REVATU",     "",                    2, 0,  "",   "",  "C", "", "V",    "",  "",     '.F.'})

		_aCols = {}
		for _nCompon = 1 to len (_aAux)
			aadd (_aCols, aclone (U_LinVazia (_aHeader)))
			_n = len (_aCols)

			// Monta um codigo 'com pontos' para ajudar a identificar a hereditariedade dos componentes.
			GDFieldPut ("INDICE",     alltrim (_sProduto) + '.' + strzero (_nCompon, 2), _n, _aHeader, _aCols)
			GDFieldPut ("NIVEL",      _aAux [_nCompon, .EstrHistNivel],       _n, _aHeader, _aCols)
			GDFieldPut ("TIPO",       _aAux [_nCompon, .EstrHistTipoComp],    _n, _aHeader, _aCols)
			GDFieldPut ("COMP",       _aAux [_nCompon, .EstrHistCodComp],     _n, _aHeader, _aCols)
			GDFieldPut ("DESCR",      iif (_nCompon == 1, '', space (_aAux [_nCompon, .EstrHistNivel] * 5) + '+---') + _aAux [_nCompon, .EstrHistDescri], _n, _aHeader, _aCols)
			GDFieldPut ("QUANT",      _aAux [_nCompon, .EstrHistQuantAcum],   _n, _aHeader, _aCols)
			GDFieldPut ("UN_MED",     _aAux [_nCompon, .EstrHistUnidMedida],  _n, _aHeader, _aCols)
			GDFieldPut ("CUSREP",     _aAux [_nCompon, .EstrHistCustDUnit],   _n, _aHeader, _aCols)
			GDFieldPut ("DTCUSREP",   _aAux [_nCompon, .EstrHistDtCustD],     _n, _aHeader, _aCols)
			GDFieldPut ("CUSTACUM",   _aAux [_nCompon, .EstrHistCustDAcum],   _n, _aHeader, _aCols)
			GDFieldPut ("REVATU",     _aAux [_nCompon, .EstrHistRevAtu],      _n, _aHeader, _aCols)
			GDFieldPut ("CONSNOCUST", _aAux [_nCompon, .EstrHistSomaNoCusto], _n, _aHeader, _aCols)

			// Busca ultimas compras do componente.
			_aUltCom = {}
			// O primeiro (pai) nao precisa. Os demais, somente se nao tiverem filhos.
			if _nCompon == 1
				// O 'pai' da estrutura nao tem necessidade de ler ultimas compras.
			elseif _aAux [_nCompon, .EstrHistEhUva]
				// Ateh o momento, nao preciso ler ultimas compras da uva por
				// que nao ha intencao de usar aqui. De qualquer forma, se for
				// para buscar ultima compra, acho melhor calcular preco medio
				// com base na VA_VPRECOS_EFETIVOS_SAFRA.
			elseif _nCompon < len (_aAux) .and. _aAux [_nCompon + 1, .EstrHistNivel] > _aAux [_nCompon, .EstrHistNivel]
				// Estou num componente que tem filhos. Nao preciso ler ultimas compras.
			else
				_oSQL := ClsSQL():New ()
				_oSQL:_sQuery := "SELECT CUSREPUNI, D1_DTDIGIT, D1_FORNECE, D1_LOJA"
				_oSQL:_sQuery += " FROM VA_ULTCOMP ('', 'zz', '" + _aAux [_nCompon, .EstrHistCodComp] + "', 3)"
			//	_oSQL:Log ('[' + procname () + '][' + _aAux [_nCompon, .EstrHistCodComp] + ']')
				_aUltCom := aclone (_oSQL:Qry2Array (.F., .F.))
			endif

			// Acrescenta custo calculado nas ultimas compras do componente.
			// (pode nao haver tantas ultimas compras quanto solicitado).
			GDFieldPut ("VULTCOMP1", iif (len (_aUltCom) >= 1, _aUltCom [1, 1], 0), _n, _aHeader, _aCols)
			GDFieldPut ("DULTCOMP1", iif (len (_aUltCom) >= 1, stod (_aUltCom [1, 2]), ctod ('')), _n, _aHeader, _aCols)
			GDFieldPut ("FULTCOMP1", iif (len (_aUltCom) >= 1, alltrim (fBuscaCpo ("SA2", 1, xfilial ("SA2") + _aUltCom [1, 3] + _aUltCom [1, 4], "A2_NOME")), ''), _n, _aHeader, _aCols)
			GDFieldPut ("VULTCOMP2", iif (len (_aUltCom) >= 2, _aUltCom [2, 1], 0), _n, _aHeader, _aCols)
			GDFieldPut ("VULTCOMP3", iif (len (_aUltCom) >= 3, _aUltCom [3, 1], 0), _n, _aHeader, _aCols)
			
		next

		u_LogACols (_aHeader, _aCols)

		// Abre em planilha para ajudar durante desenvolvimento do programa
		if _lAuto
			U_acolsXLS (_aCols, .t., _aHeader)
		endif

		_aSize := MsAdvSize()
		define MSDialog _oDlgEstr from _aSize [1] + 25, _aSize [1] + 25 to _aSize [6] - 25, _aSize [5] - 25 of oMainWnd pixel title "Estrutura do " + _sProduto

		_oGetDEstr := MsNewGetDados ():New (31, ;                        // Limite superior
									5, ;                                 // Limite esquerdo 
									_oDlgEstr:nClientHeight / 2 - 20, ;  // Limite inferior
									_oDlgEstr:nClientWidth / 2 - 10, ;   // Limite direito
									2, ;                                 // [ nStyle ] 2=visualiza, 4=altera, ...
									"AllwaysTrue ()", ;                  // [ uLinhaOk ]
									"AllwaysTrue ()", ;                  // [ uTudoOk ]
									NIL, ;                               // [cIniCpos]
									NIL,;                                // [ aAlter ]
									NIL,;                                // [ nFreeze ]
									NIL,;                                // [ nMax ]
									NIL,;                                // [ cFieldOk ]
									NIL,;                                // [ uSuperDel ]
									NIL,;                                // [ uDelOk ]
									_oDlgEstr,;                          // [ oWnd ]
									_aHeader,;                           // [ ParHeader ]
									_aCols)                              // [ aParCols ]

		_oGetDEstr:oBrowse:bLDblClick := {|| allwaystrue ()}
		_oGetDEstr:oBrowse:bRClicked := {|| allwaystrue ()} // {|_o, _x, _y| _RClick1 (_o, _x, _y)}

		// Define botoes para a barra de ferramentas
		_bBotaoOK  = {|| _oDlgEstr:End ()}
		_bBotaoCan = {|| _oDlgEstr:End ()}
		_aBotAdic  = {}
		aadd (_aBotAdic, {"", {|| aHeader := aclone (_oGetDEstr:aHeader), aCols := aclone (_oGetDEstr:aCols), U_aColsXLS ()}, "Exp.planilha"})
		aadd (_aBotAdic, {"", {|| _RecCust (_oGetDEstr:aHeader, @_oGetDEstr:aCols)}, "Recalcular custo"})
		aadd (_aBotAdic, {"", {|| _AltCustD (_oGetDEstr:nAt, _oGetDEstr:aHeader, @_oGetDEstr:aCols)}, "Alterar cus.repos.cadastro"})
		
		// durante testes, rodo via script e nao tenho interface com o usuario.
		if type ("oMainWnd") == "O"
			activate dialog _oDlgEstr on init (EnchoiceBar (_oDlgEstr, _bBotaoOK, _bBotaoCan,, _aBotAdic))
		endif

		// Replica na array de estruturas as possiveis alteracoes que o usuario tenha feito
	//	U_Log2 ('debug', '[' + procname () + ']_aAux antes')
	//	U_Log2 ('debug', _aAux)
		for _nCompon = 1 to len (_aCols)
			_aAux [_nCompon, .EstrHistCustDUnit] = GDFieldGet ("CUSREP", _nCompon, .F., _oGetDEstr:aHeader, _oGetDEstr:aCols)
		next
	//	U_Log2 ('debug', '[' + procname () + ']_aAux depois')
	//	U_Log2 ('debug', _aAux)
		_aEstruts [_nPosEstr, 2] = aclone (_aAux)
	endif
return


// --------------------------------------------------------------------------
// Recalcula o custo de uma estrutura que estah sendo visualizada em tela.
static function _RecCust (_aHeader, _aCols)
	local _aEstrTela := {}
	local _n         := 0
	local _lContinua := .T.

	CursorWait ()
	
	// Nao deixo deletar itens pais por que, ao acumular os custos, somente
	// considero as quantidades das 'folhas' da arvore.
	for _n = 1 to len (_aCols)
		if _n < len (_aCols) .and. GDDeleted (_n, _aHeader, _aCols) .and. GDFieldGet ("NIVEL", _n, .f., _aHeader, _aCols) < GDFieldGet ("NIVEL", _n+1, .f., _aHeader, _aCols)
			u_help ("Para recalculo de custos, somente podem ser deletadas linhas de itens 'filhos'.",, .t.)
			_lContinua = .F.
			exit
		endif
	next

	if _lContinua
		for _n = 1 to len (_aCols)
			aadd (_aEstrTela, array (.EstrHistQtColunas))
			_aEstrTela [len (_aEstrTela), .EstrHistNivel]     = GDFieldGet ("NIVEL",    _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistTipoComp]  = GDFieldGet ("TIPO",     _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistCodComp]   = GDFieldGet ("COMP",     _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistDescri]    = GDFieldGet ("DESCR",    _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistRevAtu]    = GDFieldGet ("REVATU",   _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistCustDUnit] = GDFieldGet ("CUSREP",   _n, .f., _aHeader, _aCols)
			_aEstrTela [len (_aEstrTela), .EstrHistCustDAcum] = GDFieldGet ("CUSTACUM", _n, .f., _aHeader, _aCols)
			if GDDeleted (_n, _aHeader, _aCols)
				_aEstrTela [len (_aEstrTela), .EstrHistQuantAcum] = 0
			else
				_aEstrTela [len (_aEstrTela), .EstrHistQuantAcum] = GDFieldGet ("QUANT",    _n, .f., _aHeader, _aCols)
			endif
		next

	//	U_Log2 ('debug', '[' + procname () + ']Estrutura para recalc.custo cfe tela:')
	//	U_Log2 ('debug', _aEstrTela)
		_AtuCust (@_aEstrTela, 1)

		// Atualiza os custos no aCols
		for _n = 1 to len (_aEstrTela)
			GDFieldPut ("CUSTACUM", _aEstrTela [_n, .EstrHistCustDAcum], _n, _aHeader, _aCols)
		next
		// Atualiza browse na tela
		_oGetDEstr:oBrowse:Refresh()
		_oGetDEstr:Show ()
	endif
	CursorArrow ()
return


// --------------------------------------------------------------------------
// Cria Perguntas no SX1
static function _ValidPerg ()
	local _aRegsPerg := {}
	local _aDefaults := {}

	//                     PERGUNT                           TIPO TAM DEC VALID F3       Opcoes               Help
	aadd (_aRegsPerg, {01, "Produto inicial a analisar    ", "C", 15, 0,  "",   "SB1 ",  {},                  ""})
	aadd (_aRegsPerg, {02, "Produto final a analisar      ", "C", 15, 0,  "",   "SB1 ",  {},                  ""})
	aadd (_aRegsPerg, {03, "Tipos produtos a analisar     ", "C", 60, 0,  "",   "    ",  {},                  ""})
	aadd (_aRegsPerg, {04, "Considerar subniveis dos VD   ", "N",  1, 0,  "",   "    ",  {"Sim", "Nao"},      ""})
	aadd (_aRegsPerg, {05, "Linha comercial inicial       ", "C",  2, 0,  "",   "ZX539", {},                  ""})
	aadd (_aRegsPerg, {06, "Linha comercial final         ", "C",  2, 0,  "",   "ZX539", {},                  ""})
	aadd (_aRegsPerg, {07, "Itens que entram no MRP       ", "N",  1, 0,  "",   "    ",  {"So MRP", "Todos"}, ""})
	U_ValPerg (cPerg, _aRegsPerg, {}, _aDefaults)
return

/*
melhorias:
- % de participacao de cada nivel na tela da estrutura
- va_ccr do item 4439 nao bateu (NF 238340 do fornecedor 000851)
*/
