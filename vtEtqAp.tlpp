// Programa:  vtEtqAp
// Autor:     Robert Koch
// Data:      26/08/2022
// Descricao: Apontamento de etiquetas de producao via telnet (GLPI 11994)

// Tags para automatizar catalogo de customizacoes:
// #TipoDePrograma    #Processamento
// #Descricao         #Apontamento de etiquetas de producao via telnet
// #PalavasChave      #telnet #terminal #coletor #apontamento_producao #apontamento_etiqueta
// #TabelasPrincipais #ZA1 #SD3 #SC2
// #Modulos           #PCP #EST

// Historico de alteracoes:
// 02/09/2022 - Robert - Chamadas de vtAlert() substituidas por u_help().
//

#include "protheus.ch"

// --------------------------------------------------------------------------
user function vtEtqAp ()
	local _lContinua   := .T.
	private _sBarEtiq  := ''
	private _sBarProd  := ''
	private _sProdEtq  := ''
	private _dDatProd  := ctod ('')
	private _oEtiq     := NIL
	private _sTnoProd  := ' '
	private _nAltTela  := 10
	private _nLargTela := 39

	do while _lContinua
		
		// Limpa variaveis para ler nova etiqueta.
		_sBarEtiq = space (10)
		_sBarProd = space (17)  // Maior que o necessario por que tem casos de licitacoes de SP que exigem uns caracteres de controle no inicio das barras.
		_sProdEtq = space (15)
		// Nao limpar entre as etiquetas --> _dDatProd = ctod ('')
		_oEtiq    = NIL
		// Nao limpar entre as etiquetas --> _sTnoProd   = space (1)

		vtSetSize (_nAltTela, _nLargTela)
		terCls()

		if _lContinua
			terSay(0, 0, "Apontar etiqueta:")
			U_Log2 ('debug', '[' + procname () + ']Antes de ler etiq')
			VTSetGet (@_sBarEtiq, "_sBarEtiq", 0, 19, {||_ValEtiq ()})
			vtRead ()
			_lContinua = (vtLastkey() != 27)
			terCBuffer ()
		endif
		if _lContinua
			U_Log2 ('debug', '[' + procname () + ']Antes de ler barras produto')
			terSay (1, 0, "Cod.barras produto:")
			VTSetGet (@_sBarProd, "_sBarProd", 1, 19, {||_ValCBProd ()})
			vtRead ()
			_lContinua = (vtLastkey() != 27)
			terCBuffer ()
		endif
		if _lContinua
			terSay (4, 0, "Dt.producao:")
			VTSetGet (@_dDatProd, "_dDatProd", 4, 13, {||_ValDtProd ()})
			vtRead ()
			_lContinua = (vtLastkey() != 27)
			terCBuffer ()
		endif
		if _lContinua
			terSay (4, 25, "Turno:")
			VTSetGet (@_sTnoProd, "_sTnoProd", 4, 31, {||_ValTurno ()})
			vtRead ()
			_lContinua = (vtLastkey() != 27)
			terCBuffer ()
		endif
		if _lContinua
			U_Log2 ('info', '[' + procname () + ']Campos lidos. Vou gerar apontamento')
			terSay (6, 0, "Aguarde... gerando apontamento")
			if _oEtiq:ApontaOP (_dDatProd, _sTnoProd)
				u_help ("Etiq." + _oEtiq:Codigo + " apontada com sucesso!")
			else
				u_help ("ERRO no apontamento.",, .t.)
			endif
		endif
	enddo
return

// --------------------------------------------------------------------------
static function _ValEtiq ()
	local _lRet := .T.
	U_Log2 ('debug', '[' + procname () + ']' + _sBarEtiq)
	
	// Farei algumas validacoes rapidinhas direto pelo ZA1 antes de instanciar uma etiqueta, para melhoria de performance.
	za1 -> (dbsetorder (1))  // ZA1_FILIAL+ZA1_CODIGO+ZA1_DATA+ZA1_OP
	if _lRet
		if ! za1 -> (dbseek (xfilial ("ZA1") + _sBarEtiq, .F.))
			U_Log2 ('debug', '[' + procname () + ']etiq.invalida')
			vtBeep (2)
			u_help ("Etiqueta nao cadastrada.",, .t.)
			_sProdEtq = ''
			_lRet = .F.
		else
			_sProdEtq = za1 -> za1_prod
		endif
	endif
	if _lRet
		_oEtiq := ClsEtiq ():New (_sBarEtiq)
		_lRet = _oEtiq:PodeApont(_oEtiq:Quantidade, 0)  // Sempre seria um apontamento 
	endif
return _lRet

// --------------------------------------------------------------------------
static function _ValCBProd ()
	local _lRet      := .T.
	local _sDescProd := ''

	U_Log2 ('debug', '[' + procname () + ']barras lidas: >>' + _sBarProd + '<<')
	sb1 -> (dbsetorder (5))  // B1_FILIAL, B1_CODBAR, R_E_C_N_O_, D_E_L_E_T_
	if ! sb1 -> (dbseek (xfilial ("SB1") + _sBarProd, .F.))
		u_help ("Nenhum produto cadastrado com esse codigo de barras",, .t.)
		_lRet = .F.
	else
		if sb1 -> b1_cod != _sProdEtq
			u_help ("Produto nao pertence a esta etiqueta",, .t.)
			_lRet = .F.
		else
			_sDescProd = alltrim (sb1 -> b1_cod) + ' - ' + alltrim (sb1 -> b1_desc)
			terSay (2, 0, substr (_sDescProd, 1, _nLargTela))
			terSay (3, 0, substr (_sDescProd, _nLargTela + 1, _nLargTela))
	
			// Nao vou permitir mais de um produto com mesmo codigo de barras
			sb1 -> (dbskip ())
			if sb1 -> b1_codbar == _sBarProd
				u_help ("Encontrado mais de um produto com o mesmo codigo de barras.")
				_lRet = .F.
			endif
		endif
	endif
	U_Log2 ('info', 'Finalizando ' + procname ())
return _lRet

// --------------------------------------------------------------------------
static function _ValDtProd ()
	local _lRet := .T.
	U_Log2 ('debug', '[' + procname () + ']' + dtoc (_dDatProd))
	if _lRet .and. _dDatProd > date ()
		u_help ("Nao pode ser informada data futura",, .t.)
		_lRet = .F.
	endif
	if _lRet .and. _dDatProd < date () - 5  // Aqui pode ter ajustes...
		u_help ("Nao pode ser informada data muito antiga",, .t.)
		_lRet = .F.
	endif
return _lRet

// --------------------------------------------------------------------------
static function _ValTurno ()
	local _lRet := .T.
	U_Log2 ('debug', '[' + procname () + ']' + _sTnoProd)
	if _lRet .and. ! _sTnoProd $ '12'
		u_help ("Turno deve ser 1 ou 2",, .t.)
		_lRet = .F.
	endif
return _lRet
